var rr = Object.defineProperty;
var sr = (O, S, t) => S in O ? rr(O, S, { enumerable: !0, configurable: !0, writable: !0, value: t }) : O[S] = t;
var ee = (O, S, t) => (sr(O, typeof S != "symbol" ? S + "" : S, t), t), je = (O, S, t) => {
  if (!S.has(O))
    throw TypeError("Cannot " + t);
};
var e = (O, S, t) => (je(O, S, "read from private field"), t ? t.call(O) : S.get(O)), W = (O, S, t) => {
  if (S.has(O))
    throw TypeError("Cannot add the same private member more than once");
  S instanceof WeakSet ? S.add(O) : S.set(O, t);
}, rt = (O, S, t, n) => (je(O, S, "write to private field"), n ? n.call(O, t) : S.set(O, t), t);
var ue = (O, S, t, n) => ({
  set _(h) {
    rt(O, S, h, t);
  },
  get _() {
    return e(O, S, n);
  }
}), J = (O, S, t) => (je(O, S, "access private method"), t);
import { shallowRef, watchEffect, toValue, onBeforeUnmount, defineComponent, ref, toRef, computed, watch, openBlock, createElementBlock, Fragment, renderList, renderSlot, createElementVNode, normalizeStyle, createCommentVNode } from "vue";
import { PasswordResponses } from "pdfjs-dist";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getAugmentedNamespace(O) {
  if (O.__esModule)
    return O;
  var S = O.default;
  if (typeof S == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(S, arguments, this.constructor) : S.apply(this, arguments);
    };
    t.prototype = S.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(O).forEach(function(n) {
    var h = Object.getOwnPropertyDescriptor(O, n);
    Object.defineProperty(t, n, h.get ? h : {
      enumerable: !0,
      get: function() {
        return O[n];
      }
    });
  }), t;
}
function commonjsRequire(O) {
  throw new Error('Could not dynamically require "' + O + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" })), require$$6 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var path2dPolyfill_esm = {}, hasRequiredPath2dPolyfill_esm;
function requirePath2dPolyfill_esm() {
  if (hasRequiredPath2dPolyfill_esm)
    return path2dPolyfill_esm;
  hasRequiredPath2dPolyfill_esm = 1;
  function O(s, o, l) {
    if (l || arguments.length === 2)
      for (var u = 0, v = o.length, p; u < v; u++)
        (p || !(u in o)) && (p || (p = Array.prototype.slice.call(o, 0, u)), p[u] = o[u]);
    return s.concat(p || Array.prototype.slice.call(o));
  }
  var S = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  }, t = /([astvzqmhlc])([^astvzqmhlc]*)/gi, n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
  function h(s) {
    var o = s.match(n);
    return o ? o.map(Number) : [];
  }
  function T(s) {
    var o = [], l = String(s).trim();
    return l[0] !== "M" && l[0] !== "m" || l.replace(t, function(u, v, p) {
      var C = h(p), r = v.toLowerCase(), i = v;
      if (r === "m" && C.length > 2 && (o.push(O([i], C.splice(0, 2), !0)), r = "l", i = i === "m" ? "l" : "L"), C.length < S[r])
        return "";
      for (o.push(O([i], C.splice(0, S[r]), !0)); C.length >= S[r] && C.length && S[r]; )
        o.push(O([i], C.splice(0, S[r]), !0));
      return "";
    }), o;
  }
  function P(s, o) {
    var l = s.x * Math.cos(o) - s.y * Math.sin(o), u = s.y * Math.cos(o) + s.x * Math.sin(o);
    s.x = l, s.y = u;
  }
  function f(s, o, l) {
    s.x += o, s.y += l;
  }
  function y(s, o) {
    s.x *= o, s.y *= o;
  }
  var c = (
    /** @class */
    function() {
      function s(o) {
        var l;
        this.commands = [], o && o instanceof s ? (l = this.commands).push.apply(l, o.commands) : o && (this.commands = T(o));
      }
      return s.prototype.addPath = function(o) {
        var l;
        o && o instanceof s && (l = this.commands).push.apply(l, o.commands);
      }, s.prototype.moveTo = function(o, l) {
        this.commands.push(["M", o, l]);
      }, s.prototype.lineTo = function(o, l) {
        this.commands.push(["L", o, l]);
      }, s.prototype.arc = function(o, l, u, v, p, C) {
        this.commands.push(["AC", o, l, u, v, p, !!C]);
      }, s.prototype.arcTo = function(o, l, u, v, p) {
        this.commands.push(["AT", o, l, u, v, p]);
      }, s.prototype.ellipse = function(o, l, u, v, p, C, r, i) {
        this.commands.push(["E", o, l, u, v, p, C, r, !!i]);
      }, s.prototype.closePath = function() {
        this.commands.push(["Z"]);
      }, s.prototype.bezierCurveTo = function(o, l, u, v, p, C) {
        this.commands.push(["C", o, l, u, v, p, C]);
      }, s.prototype.quadraticCurveTo = function(o, l, u, v) {
        this.commands.push(["Q", o, l, u, v]);
      }, s.prototype.rect = function(o, l, u, v) {
        this.commands.push(["R", o, l, u, v]);
      }, s.prototype.roundRect = function(o, l, u, v, p) {
        typeof p > "u" ? this.commands.push(["RR", o, l, u, v, 0]) : this.commands.push(["RR", o, l, u, v, p]);
      }, s;
    }()
  );
  function a(s, o) {
    var l = 0, u = 0, v, p, C, r, i, w, x, b, F, L, G, nt, D, X, q, j, z, it, Q, Et, Ct, H = null, m = null, k = null, d = null, R = null, M = null;
    s.beginPath();
    for (var B = 0; B < o.length; ++B) {
      it = o[B][0], it !== "S" && it !== "s" && it !== "C" && it !== "c" && (H = null, m = null), it !== "T" && it !== "t" && it !== "Q" && it !== "q" && (k = null, d = null);
      var _ = void 0;
      switch (it) {
        case "m":
        case "M":
          _ = o[B], it === "m" ? (l += _[1], u += _[2]) : (l = _[1], u = _[2]), (it === "M" || !R) && (R = { x: l, y: u }), s.moveTo(l, u);
          break;
        case "l":
          _ = o[B], l += _[1], u += _[2], s.lineTo(l, u);
          break;
        case "L":
          _ = o[B], l = _[1], u = _[2], s.lineTo(l, u);
          break;
        case "H":
          _ = o[B], l = _[1], s.lineTo(l, u);
          break;
        case "h":
          _ = o[B], l += _[1], s.lineTo(l, u);
          break;
        case "V":
          _ = o[B], u = _[1], s.lineTo(l, u);
          break;
        case "v":
          _ = o[B], u += _[1], s.lineTo(l, u);
          break;
        case "a":
        case "A":
          if (_ = o[B], M === null)
            throw new Error("This should never happen");
          it === "a" ? (l += _[6], u += _[7]) : (l = _[6], u = _[7]), X = _[1], q = _[2], x = _[3] * Math.PI / 180, C = !!_[4], r = !!_[5], i = { x: l, y: u }, w = {
            x: (M.x - i.x) / 2,
            y: (M.y - i.y) / 2
          }, P(w, -x), b = w.x * w.x / (X * X) + w.y * w.y / (q * q), b > 1 && (b = Math.sqrt(b), X *= b, q *= b), Q = {
            x: X * w.y / q,
            y: -(q * w.x) / X
          }, F = X * X * q * q, L = X * X * w.y * w.y + q * q * w.x * w.x, r !== C ? y(Q, Math.sqrt((F - L) / L) || 0) : y(Q, -Math.sqrt((F - L) / L) || 0), p = Math.atan2((w.y - Q.y) / q, (w.x - Q.x) / X), v = Math.atan2(-(w.y + Q.y) / q, -(w.x + Q.x) / X), P(Q, x), f(Q, (i.x + M.x) / 2, (i.y + M.y) / 2), s.save(), s.translate(Q.x, Q.y), s.rotate(x), s.scale(X, q), s.arc(0, 0, 1, p, v, !r), s.restore();
          break;
        case "C":
          _ = o[B], H = _[3], m = _[4], l = _[5], u = _[6], s.bezierCurveTo(_[1], _[2], H, m, l, u);
          break;
        case "c":
          _ = o[B], s.bezierCurveTo(_[1] + l, _[2] + u, _[3] + l, _[4] + u, _[5] + l, _[6] + u), H = _[3] + l, m = _[4] + u, l += _[5], u += _[6];
          break;
        case "S":
          _ = o[B], (H === null || m === null) && (H = l, m = u), s.bezierCurveTo(2 * l - H, 2 * u - m, _[1], _[2], _[3], _[4]), H = _[1], m = _[2], l = _[3], u = _[4];
          break;
        case "s":
          _ = o[B], (H === null || m === null) && (H = l, m = u), s.bezierCurveTo(2 * l - H, 2 * u - m, _[1] + l, _[2] + u, _[3] + l, _[4] + u), H = _[1] + l, m = _[2] + u, l += _[3], u += _[4];
          break;
        case "Q":
          _ = o[B], k = _[1], d = _[2], l = _[3], u = _[4], s.quadraticCurveTo(k, d, l, u);
          break;
        case "q":
          _ = o[B], k = _[1] + l, d = _[2] + u, l += _[3], u += _[4], s.quadraticCurveTo(k, d, l, u);
          break;
        case "T":
          _ = o[B], (k === null || d === null) && (k = l, d = u), k = 2 * l - k, d = 2 * u - d, l = _[1], u = _[2], s.quadraticCurveTo(k, d, l, u);
          break;
        case "t":
          _ = o[B], (k === null || d === null) && (k = l, d = u), k = 2 * l - k, d = 2 * u - d, l += _[1], u += _[2], s.quadraticCurveTo(k, d, l, u);
          break;
        case "z":
        case "Z":
          R && (l = R.x, u = R.y), R = null, s.closePath();
          break;
        case "AC":
          _ = o[B], l = _[1], u = _[2], D = _[3], p = _[4], v = _[5], Et = _[6], s.arc(l, u, D, p, v, Et);
          break;
        case "AT":
          _ = o[B], G = _[1], nt = _[2], l = _[3], u = _[4], D = _[5], s.arcTo(G, nt, l, u, D);
          break;
        case "E":
          _ = o[B], l = _[1], u = _[2], X = _[3], q = _[4], x = _[5], p = _[6], v = _[7], Et = _[8], s.save(), s.translate(l, u), s.rotate(x), s.scale(X, q), s.arc(0, 0, 1, p, v, Et), s.restore();
          break;
        case "R":
          _ = o[B], l = _[1], u = _[2], j = _[3], z = _[4], R = { x: l, y: u }, s.rect(l, u, j, z);
          break;
        case "RR":
          _ = o[B], l = _[1], u = _[2], j = _[3], z = _[4], Ct = _[5], R = { x: l, y: u }, s.roundRect(l, u, j, z, Ct);
          break;
      }
      M ? (M.x = l, M.y = u) : M = { x: l, y: u };
    }
  }
  function I(s) {
    if (!(!s || !s.CanvasRenderingContext2D || s.Path2D)) {
      var o = s.CanvasRenderingContext2D, l = o.prototype.fill, u = o.prototype.stroke, v = o.prototype.isPointInPath;
      o.prototype.fill = function() {
        for (var C = [], r = 0; r < arguments.length; r++)
          C[r] = arguments[r];
        if (C[0] instanceof c) {
          var i = C[0], w = C[1] || "nonzero";
          a(this, i.commands), l.apply(this, [w]);
        } else {
          var w = C[0] || "nonzero";
          return l.apply(this, [w]);
        }
      }, o.prototype.stroke = function(C) {
        C && a(this, C.commands), u.apply(this);
      }, o.prototype.isPointInPath = function() {
        for (var C = [], r = 0; r < arguments.length; r++)
          C[r] = arguments[r];
        if (C[0] instanceof c) {
          var i = C[0], w = C[1], x = C[2], b = C[3] || "nonzero";
          return a(this, i.commands), v.apply(this, [w, x, b]);
        } else
          return v.apply(this, C);
      }, s.Path2D = c;
    }
  }
  function A(s, o, l, u, v) {
    var p = this;
    if (v === void 0 && (v = 0), typeof v == "number" && (v = [v]), Array.isArray(v)) {
      if (v.length === 0 || v.length > 4)
        throw new RangeError("Failed to execute 'roundRect' on '".concat(this.constructor.name, "': ").concat(v.length, " radii provided. Between one and four radii are necessary."));
      v.forEach(function(b) {
        if (b < 0)
          throw new RangeError("Failed to execute 'roundRect' on '".concat(p.constructor.name, "': Radius value ").concat(b, " is negative."));
      });
    } else
      return;
    if (v.length === 1 && v[0] === 0)
      return this.rect(s, o, l, u);
    var C = Math.min(l, u) / 2, r, i, w, x = r = i = w = Math.min(C, v[0]);
    v.length === 2 && (r = w = Math.min(C, v[1])), v.length === 3 && (r = w = Math.min(C, v[1]), i = Math.min(C, v[2])), v.length === 4 && (r = Math.min(C, v[1]), i = Math.min(C, v[2]), w = Math.min(C, v[3])), this.moveTo(s, o + u - w), this.arcTo(s, o, s + x, o, x), this.arcTo(s + l, o, s + l, o + r, r), this.arcTo(s + l, o + u, s + l - i, o + u, i), this.arcTo(s, o + u, s, o + u - w, w), this.moveTo(s, o);
  }
  function g(s) {
    if (!(!s || !s.CanvasRenderingContext2D)) {
      var o = s.CanvasRenderingContext2D, l = s.Path2D;
      o && !o.prototype.roundRect && (o.prototype.roundRect = A), l && !l.prototype.roundRect && (l.prototype.roundRect = A);
    }
  }
  return I(window), g(window), path2dPolyfill_esm;
}
(function(module, exports) {
  (function(S, t) {
    module.exports = S.pdfjsLib = t();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (O, S, t) => {
          var Yt;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.VerbosityLevel = S.Util = S.UnknownErrorException = S.UnexpectedResponseException = S.TextRenderingMode = S.RenderingIntentFlag = S.PromiseCapability = S.PermissionFlag = S.PasswordResponses = S.PasswordException = S.PageActionEventType = S.OPS = S.MissingPDFException = S.MAX_IMAGE_SIZE_TO_CACHE = S.LINE_FACTOR = S.LINE_DESCENT_FACTOR = S.InvalidPDFException = S.ImageKind = S.IDENTITY_MATRIX = S.FormatError = S.FeatureTest = S.FONT_IDENTITY_MATRIX = S.DocumentActionEventType = S.CMapCompressionType = S.BaseException = S.BASELINE_FACTOR = S.AnnotationType = S.AnnotationReplyType = S.AnnotationPrefix = S.AnnotationMode = S.AnnotationFlag = S.AnnotationFieldFlag = S.AnnotationEditorType = S.AnnotationEditorPrefix = S.AnnotationEditorParamsType = S.AnnotationBorderStyleType = S.AnnotationActionEventType = S.AbortException = void 0, S.assert = Q, S.bytesToString = pt, S.createValidAbsoluteUrl = Ct, S.getModificationDate = Ut, S.getUuid = Xt, S.getVerbosityLevel = q, S.info = j, S.isArrayBuffer = wt, S.isArrayEqual = Lt, S.isNodeJS = void 0, S.normalizeUnicode = Jt, S.objectFromMap = yt, S.objectSize = lt, S.setVerbosityLevel = X, S.shadow = H, S.string32 = Tt, S.stringToBytes = dt, S.stringToPDFString = ct, S.stringToUTF8String = ot, S.unreachable = it, S.utf8StringToString = vt, S.warn = z, t(2), t(84), t(86), t(87), t(89), t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123);
          const n = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          S.isNodeJS = n;
          const h = [1, 0, 0, 1, 0, 0];
          S.IDENTITY_MATRIX = h;
          const T = [1e-3, 0, 0, 1e-3, 0, 0];
          S.FONT_IDENTITY_MATRIX = T;
          const P = 1e7;
          S.MAX_IMAGE_SIZE_TO_CACHE = P;
          const f = 1.35;
          S.LINE_FACTOR = f;
          const y = 0.35;
          S.LINE_DESCENT_FACTOR = y;
          const c = y / f;
          S.BASELINE_FACTOR = c;
          const a = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            SAVE: 8,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          S.RenderingIntentFlag = a;
          const I = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          S.AnnotationMode = I;
          const A = "pdfjs_internal_editor_";
          S.AnnotationEditorPrefix = A;
          const g = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            STAMP: 13,
            INK: 15
          };
          S.AnnotationEditorType = g;
          const s = {
            RESIZE: 1,
            CREATE: 2,
            FREETEXT_SIZE: 11,
            FREETEXT_COLOR: 12,
            FREETEXT_OPACITY: 13,
            INK_COLOR: 21,
            INK_THICKNESS: 22,
            INK_OPACITY: 23
          };
          S.AnnotationEditorParamsType = s;
          const o = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          S.PermissionFlag = o;
          const l = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          S.TextRenderingMode = l;
          const u = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          S.ImageKind = u;
          const v = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          S.AnnotationType = v;
          const p = {
            GROUP: "Group",
            REPLY: "R"
          };
          S.AnnotationReplyType = p;
          const C = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          S.AnnotationFlag = C;
          const r = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          S.AnnotationFieldFlag = r;
          const i = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          S.AnnotationBorderStyleType = i;
          const w = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          S.AnnotationActionEventType = w;
          const x = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          S.DocumentActionEventType = x;
          const b = {
            O: "PageOpen",
            C: "PageClose"
          };
          S.PageActionEventType = b;
          const F = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          S.VerbosityLevel = F;
          const L = {
            NONE: 0,
            BINARY: 1
          };
          S.CMapCompressionType = L;
          const G = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          S.OPS = G;
          const nt = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          S.PasswordResponses = nt;
          let D = F.WARNINGS;
          function X(N) {
            Number.isInteger(N) && (D = N);
          }
          function q() {
            return D;
          }
          function j(N) {
            D >= F.INFOS && console.log(`Info: ${N}`);
          }
          function z(N) {
            D >= F.WARNINGS && console.log(`Warning: ${N}`);
          }
          function it(N) {
            throw new Error(N);
          }
          function Q(N, V) {
            N || it(V);
          }
          function Et(N) {
            switch (N == null ? void 0 : N.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function Ct(N) {
            let V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!N)
              return null;
            try {
              if (K && typeof N == "string") {
                if (K.addDefaultProtocol && N.startsWith("www.")) {
                  const ft = N.match(/\./g);
                  (ft == null ? void 0 : ft.length) >= 2 && (N = `http://${N}`);
                }
                if (K.tryConvertEncoding)
                  try {
                    N = ot(N);
                  } catch {
                  }
              }
              const st = V ? new URL(N, V) : new URL(N);
              if (Et(st))
                return st;
            } catch {
            }
            return null;
          }
          function H(N, V, K) {
            let st = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
            return Object.defineProperty(N, V, {
              value: K,
              enumerable: !st,
              configurable: !0,
              writable: !1
            }), K;
          }
          const m = function() {
            function V(K, st) {
              this.constructor === V && it("Cannot initialize BaseException."), this.message = K, this.name = st;
            }
            return V.prototype = new Error(), V.constructor = V, V;
          }();
          S.BaseException = m;
          class k extends m {
            constructor(V, K) {
              super(V, "PasswordException"), this.code = K;
            }
          }
          S.PasswordException = k;
          class d extends m {
            constructor(V, K) {
              super(V, "UnknownErrorException"), this.details = K;
            }
          }
          S.UnknownErrorException = d;
          class R extends m {
            constructor(V) {
              super(V, "InvalidPDFException");
            }
          }
          S.InvalidPDFException = R;
          class M extends m {
            constructor(V) {
              super(V, "MissingPDFException");
            }
          }
          S.MissingPDFException = M;
          class B extends m {
            constructor(V, K) {
              super(V, "UnexpectedResponseException"), this.status = K;
            }
          }
          S.UnexpectedResponseException = B;
          class _ extends m {
            constructor(V) {
              super(V, "FormatError");
            }
          }
          S.FormatError = _;
          class Z extends m {
            constructor(V) {
              super(V, "AbortException");
            }
          }
          S.AbortException = Z;
          function pt(N) {
            (typeof N != "object" || (N == null ? void 0 : N.length) === void 0) && it("Invalid argument for bytesToString");
            const V = N.length, K = 8192;
            if (V < K)
              return String.fromCharCode.apply(null, N);
            const st = [];
            for (let ft = 0; ft < V; ft += K) {
              const Y = Math.min(ft + K, V), U = N.subarray(ft, Y);
              st.push(String.fromCharCode.apply(null, U));
            }
            return st.join("");
          }
          function dt(N) {
            typeof N != "string" && it("Invalid argument for stringToBytes");
            const V = N.length, K = new Uint8Array(V);
            for (let st = 0; st < V; ++st)
              K[st] = N.charCodeAt(st) & 255;
            return K;
          }
          function Tt(N) {
            return String.fromCharCode(N >> 24 & 255, N >> 16 & 255, N >> 8 & 255, N & 255);
          }
          function lt(N) {
            return Object.keys(N).length;
          }
          function yt(N) {
            const V = /* @__PURE__ */ Object.create(null);
            for (const [K, st] of N)
              V[K] = st;
            return V;
          }
          function bt() {
            const N = new Uint8Array(4);
            return N[0] = 1, new Uint32Array(N.buffer, 0, 1)[0] === 1;
          }
          function It() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class Ot {
            static get isLittleEndian() {
              return H(this, "isLittleEndian", bt());
            }
            static get isEvalSupported() {
              return H(this, "isEvalSupported", It());
            }
            static get isOffscreenCanvasSupported() {
              return H(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
            static get platform() {
              return typeof navigator > "u" ? H(this, "platform", {
                isWin: !1,
                isMac: !1
              }) : H(this, "platform", {
                isWin: navigator.platform.includes("Win"),
                isMac: navigator.platform.includes("Mac")
              });
            }
            static get isCSSRoundSupported() {
              var V, K;
              return H(this, "isCSSRoundSupported", (K = (V = globalThis.CSS) == null ? void 0 : V.supports) == null ? void 0 : K.call(V, "width: round(1.5px, 1px)"));
            }
          }
          S.FeatureTest = Ot;
          const Mt = [...Array(256).keys()].map((N) => N.toString(16).padStart(2, "0"));
          class gt {
            static makeHexColor(V, K, st) {
              return `#${Mt[V]}${Mt[K]}${Mt[st]}`;
            }
            static scaleMinMax(V, K) {
              let st;
              V[0] ? (V[0] < 0 && (st = K[0], K[0] = K[1], K[1] = st), K[0] *= V[0], K[1] *= V[0], V[3] < 0 && (st = K[2], K[2] = K[3], K[3] = st), K[2] *= V[3], K[3] *= V[3]) : (st = K[0], K[0] = K[2], K[2] = st, st = K[1], K[1] = K[3], K[3] = st, V[1] < 0 && (st = K[2], K[2] = K[3], K[3] = st), K[2] *= V[1], K[3] *= V[1], V[2] < 0 && (st = K[0], K[0] = K[1], K[1] = st), K[0] *= V[2], K[1] *= V[2]), K[0] += V[4], K[1] += V[4], K[2] += V[5], K[3] += V[5];
            }
            static transform(V, K) {
              return [V[0] * K[0] + V[2] * K[1], V[1] * K[0] + V[3] * K[1], V[0] * K[2] + V[2] * K[3], V[1] * K[2] + V[3] * K[3], V[0] * K[4] + V[2] * K[5] + V[4], V[1] * K[4] + V[3] * K[5] + V[5]];
            }
            static applyTransform(V, K) {
              const st = V[0] * K[0] + V[1] * K[2] + K[4], ft = V[0] * K[1] + V[1] * K[3] + K[5];
              return [st, ft];
            }
            static applyInverseTransform(V, K) {
              const st = K[0] * K[3] - K[1] * K[2], ft = (V[0] * K[3] - V[1] * K[2] + K[2] * K[5] - K[4] * K[3]) / st, Y = (-V[0] * K[1] + V[1] * K[0] + K[4] * K[1] - K[5] * K[0]) / st;
              return [ft, Y];
            }
            static getAxialAlignedBoundingBox(V, K) {
              const st = this.applyTransform(V, K), ft = this.applyTransform(V.slice(2, 4), K), Y = this.applyTransform([V[0], V[3]], K), U = this.applyTransform([V[2], V[1]], K);
              return [Math.min(st[0], ft[0], Y[0], U[0]), Math.min(st[1], ft[1], Y[1], U[1]), Math.max(st[0], ft[0], Y[0], U[0]), Math.max(st[1], ft[1], Y[1], U[1])];
            }
            static inverseTransform(V) {
              const K = V[0] * V[3] - V[1] * V[2];
              return [V[3] / K, -V[1] / K, -V[2] / K, V[0] / K, (V[2] * V[5] - V[4] * V[3]) / K, (V[4] * V[1] - V[5] * V[0]) / K];
            }
            static singularValueDecompose2dScale(V) {
              const K = [V[0], V[2], V[1], V[3]], st = V[0] * K[0] + V[1] * K[2], ft = V[0] * K[1] + V[1] * K[3], Y = V[2] * K[0] + V[3] * K[2], U = V[2] * K[1] + V[3] * K[3], at = (st + U) / 2, St = Math.sqrt((st + U) ** 2 - 4 * (st * U - Y * ft)) / 2, At = at + St || 1, Rt = at - St || 1;
              return [Math.sqrt(At), Math.sqrt(Rt)];
            }
            static normalizeRect(V) {
              const K = V.slice(0);
              return V[0] > V[2] && (K[0] = V[2], K[2] = V[0]), V[1] > V[3] && (K[1] = V[3], K[3] = V[1]), K;
            }
            static intersect(V, K) {
              const st = Math.max(Math.min(V[0], V[2]), Math.min(K[0], K[2])), ft = Math.min(Math.max(V[0], V[2]), Math.max(K[0], K[2]));
              if (st > ft)
                return null;
              const Y = Math.max(Math.min(V[1], V[3]), Math.min(K[1], K[3])), U = Math.min(Math.max(V[1], V[3]), Math.max(K[1], K[3]));
              return Y > U ? null : [st, Y, ft, U];
            }
            static bezierBoundingBox(V, K, st, ft, Y, U, at, St) {
              const At = [], Rt = [[], []];
              let xt, Nt, kt, _t, Bt, et, E, $;
              for (let Pt = 0; Pt < 2; ++Pt) {
                if (Pt === 0 ? (Nt = 6 * V - 12 * st + 6 * Y, xt = -3 * V + 9 * st - 9 * Y + 3 * at, kt = 3 * st - 3 * V) : (Nt = 6 * K - 12 * ft + 6 * U, xt = -3 * K + 9 * ft - 9 * U + 3 * St, kt = 3 * ft - 3 * K), Math.abs(xt) < 1e-12) {
                  if (Math.abs(Nt) < 1e-12)
                    continue;
                  _t = -kt / Nt, 0 < _t && _t < 1 && At.push(_t);
                  continue;
                }
                E = Nt * Nt - 4 * kt * xt, $ = Math.sqrt(E), !(E < 0) && (Bt = (-Nt + $) / (2 * xt), 0 < Bt && Bt < 1 && At.push(Bt), et = (-Nt - $) / (2 * xt), 0 < et && et < 1 && At.push(et));
              }
              let tt = At.length, ht;
              const mt = tt;
              for (; tt--; )
                _t = At[tt], ht = 1 - _t, Rt[0][tt] = ht * ht * ht * V + 3 * ht * ht * _t * st + 3 * ht * _t * _t * Y + _t * _t * _t * at, Rt[1][tt] = ht * ht * ht * K + 3 * ht * ht * _t * ft + 3 * ht * _t * _t * U + _t * _t * _t * St;
              return Rt[0][mt] = V, Rt[1][mt] = K, Rt[0][mt + 1] = at, Rt[1][mt + 1] = St, Rt[0].length = Rt[1].length = mt + 2, [Math.min(...Rt[0]), Math.min(...Rt[1]), Math.max(...Rt[0]), Math.max(...Rt[1])];
            }
          }
          S.Util = gt;
          const ut = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function ct(N) {
            if (N[0] >= "ï") {
              let K;
              if (N[0] === "þ" && N[1] === "ÿ" ? K = "utf-16be" : N[0] === "ÿ" && N[1] === "þ" ? K = "utf-16le" : N[0] === "ï" && N[1] === "»" && N[2] === "¿" && (K = "utf-8"), K)
                try {
                  const st = new TextDecoder(K, {
                    fatal: !0
                  }), ft = dt(N);
                  return st.decode(ft);
                } catch (st) {
                  z(`stringToPDFString: "${st}".`);
                }
            }
            const V = [];
            for (let K = 0, st = N.length; K < st; K++) {
              const ft = ut[N.charCodeAt(K)];
              V.push(ft ? String.fromCharCode(ft) : N.charAt(K));
            }
            return V.join("");
          }
          function ot(N) {
            return decodeURIComponent(escape(N));
          }
          function vt(N) {
            return unescape(encodeURIComponent(N));
          }
          function wt(N) {
            return typeof N == "object" && (N == null ? void 0 : N.byteLength) !== void 0;
          }
          function Lt(N, V) {
            if (N.length !== V.length)
              return !1;
            for (let K = 0, st = N.length; K < st; K++)
              if (N[K] !== V[K])
                return !1;
            return !0;
          }
          function Ut() {
            let N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Date();
            return [N.getUTCFullYear().toString(), (N.getUTCMonth() + 1).toString().padStart(2, "0"), N.getUTCDate().toString().padStart(2, "0"), N.getUTCHours().toString().padStart(2, "0"), N.getUTCMinutes().toString().padStart(2, "0"), N.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          class Ht {
            constructor() {
              W(this, Yt, !1);
              this.promise = new Promise((V, K) => {
                this.resolve = (st) => {
                  rt(this, Yt, !0), V(st);
                }, this.reject = (st) => {
                  rt(this, Yt, !0), K(st);
                };
              });
            }
            get settled() {
              return e(this, Yt);
            }
          }
          Yt = new WeakMap(), S.PromiseCapability = Ht;
          let $t = null, Wt = null;
          function Jt(N) {
            return $t || ($t = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Wt = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), N.replaceAll($t, (V, K, st) => K ? K.normalize("NFKC") : Wt.get(st));
          }
          function Xt() {
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
              return crypto.randomUUID();
            const N = new Uint8Array(32);
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
              crypto.getRandomValues(N);
            else
              for (let V = 0; V < 32; V++)
                N[V] = Math.floor(Math.random() * 255);
            return pt(N);
          }
          const Zt = "pdfjs_internal_id_";
          S.AnnotationPrefix = Zt;
        },
        /* 2 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(4), T = t(69), P = t(70), f = "WebAssembly", y = h[f], c = Error("e", { cause: 7 }).cause !== 7, a = function(A, g) {
            var s = {};
            s[A] = P(A, g, c), n({
              global: !0,
              constructor: !0,
              arity: 1,
              forced: c
            }, s);
          }, I = function(A, g) {
            if (y && y[A]) {
              var s = {};
              s[A] = P(f + "." + A, g, c), n({
                target: f,
                stat: !0,
                constructor: !0,
                arity: 1,
                forced: c
              }, s);
            }
          };
          a("Error", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), a("EvalError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), a("RangeError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), a("ReferenceError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), a("SyntaxError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), a("TypeError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), a("URIError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), I("CompileError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), I("LinkError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          }), I("RuntimeError", function(A) {
            return function(s) {
              return T(A, this, arguments);
            };
          });
        },
        /* 3 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(5).f, T = t(44), P = t(48), f = t(38), y = t(56), c = t(68);
          O.exports = function(a, I) {
            var A = a.target, g = a.global, s = a.stat, o, l, u, v, p, C;
            if (g ? l = n : s ? l = n[A] || f(A, {}) : l = (n[A] || {}).prototype, l)
              for (u in I) {
                if (p = I[u], a.dontCallGetSet ? (C = h(l, u), v = C && C.value) : v = l[u], o = c(g ? u : A + (s ? "." : "#") + u, a.forced), !o && v !== void 0) {
                  if (typeof p == typeof v)
                    continue;
                  y(p, v);
                }
                (a.sham || v && v.sham) && T(p, "sham", !0), P(l, u, p, a);
              }
          };
        },
        /* 4 */
        /***/
        function(O) {
          var S = function(t) {
            return t && t.Math === Math && t;
          };
          O.exports = S(typeof globalThis == "object" && globalThis) || S(typeof window == "object" && window) || S(typeof self == "object" && self) || S(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
            return this;
          }() || this || Function("return this")();
        },
        /* 5 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(8), T = t(10), P = t(11), f = t(12), y = t(18), c = t(39), a = t(42), I = Object.getOwnPropertyDescriptor;
          S.f = n ? I : function(g, s) {
            if (g = f(g), s = y(s), a)
              try {
                return I(g, s);
              } catch {
              }
            if (c(g, s))
              return P(!h(T.f, g, s), g[s]);
          };
        },
        /* 6 */
        /***/
        (O, S, t) => {
          var n = t(7);
          O.exports = !n(function() {
            return Object.defineProperty({}, 1, {
              get: function() {
                return 7;
              }
            })[1] !== 7;
          });
        },
        /* 7 */
        /***/
        (O) => {
          O.exports = function(S) {
            try {
              return !!S();
            } catch {
              return !0;
            }
          };
        },
        /* 8 */
        /***/
        (O, S, t) => {
          var n = t(9), h = Function.prototype.call;
          O.exports = n ? h.bind(h) : function() {
            return h.apply(h, arguments);
          };
        },
        /* 9 */
        /***/
        (O, S, t) => {
          var n = t(7);
          O.exports = !n(function() {
            var h = (function() {
            }).bind();
            return typeof h != "function" || h.hasOwnProperty("prototype");
          });
        },
        /* 10 */
        /***/
        (O, S) => {
          var t = {}.propertyIsEnumerable, n = Object.getOwnPropertyDescriptor, h = n && !t.call({ 1: 2 }, 1);
          S.f = h ? function(P) {
            var f = n(this, P);
            return !!f && f.enumerable;
          } : t;
        },
        /* 11 */
        /***/
        (O) => {
          O.exports = function(S, t) {
            return {
              enumerable: !(S & 1),
              configurable: !(S & 2),
              writable: !(S & 4),
              value: t
            };
          };
        },
        /* 12 */
        /***/
        (O, S, t) => {
          var n = t(13), h = t(16);
          O.exports = function(T) {
            return n(h(T));
          };
        },
        /* 13 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(7), T = t(15), P = Object, f = n("".split);
          O.exports = h(function() {
            return !P("z").propertyIsEnumerable(0);
          }) ? function(y) {
            return T(y) === "String" ? f(y, "") : P(y);
          } : P;
        },
        /* 14 */
        /***/
        (O, S, t) => {
          var n = t(9), h = Function.prototype, T = h.call, P = n && h.bind.bind(T, T);
          O.exports = n ? P : function(f) {
            return function() {
              return T.apply(f, arguments);
            };
          };
        },
        /* 15 */
        /***/
        (O, S, t) => {
          var n = t(14), h = n({}.toString), T = n("".slice);
          O.exports = function(P) {
            return T(h(P), 8, -1);
          };
        },
        /* 16 */
        /***/
        (O, S, t) => {
          var n = t(17), h = TypeError;
          O.exports = function(T) {
            if (n(T))
              throw h("Can't call method on " + T);
            return T;
          };
        },
        /* 17 */
        /***/
        (O) => {
          O.exports = function(S) {
            return S == null;
          };
        },
        /* 18 */
        /***/
        (O, S, t) => {
          var n = t(19), h = t(23);
          O.exports = function(T) {
            var P = n(T, "string");
            return h(P) ? P : P + "";
          };
        },
        /* 19 */
        /***/
        (O, S, t) => {
          var n = t(8), h = t(20), T = t(23), P = t(30), f = t(33), y = t(34), c = TypeError, a = y("toPrimitive");
          O.exports = function(I, A) {
            if (!h(I) || T(I))
              return I;
            var g = P(I, a), s;
            if (g) {
              if (A === void 0 && (A = "default"), s = n(g, I, A), !h(s) || T(s))
                return s;
              throw c("Can't convert object to primitive value");
            }
            return A === void 0 && (A = "number"), f(I, A);
          };
        },
        /* 20 */
        /***/
        (O, S, t) => {
          var n = t(21), h = t(22), T = h.all;
          O.exports = h.IS_HTMLDDA ? function(P) {
            return typeof P == "object" ? P !== null : n(P) || P === T;
          } : function(P) {
            return typeof P == "object" ? P !== null : n(P);
          };
        },
        /* 21 */
        /***/
        (O, S, t) => {
          var n = t(22), h = n.all;
          O.exports = n.IS_HTMLDDA ? function(T) {
            return typeof T == "function" || T === h;
          } : function(T) {
            return typeof T == "function";
          };
        },
        /* 22 */
        /***/
        (O) => {
          var S = typeof document == "object" && document.all, t = typeof S > "u" && S !== void 0;
          O.exports = {
            all: S,
            IS_HTMLDDA: t
          };
        },
        /* 23 */
        /***/
        (O, S, t) => {
          var n = t(24), h = t(21), T = t(25), P = t(26), f = Object;
          O.exports = P ? function(y) {
            return typeof y == "symbol";
          } : function(y) {
            var c = n("Symbol");
            return h(c) && T(c.prototype, f(y));
          };
        },
        /* 24 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(21), T = function(P) {
            return h(P) ? P : void 0;
          };
          O.exports = function(P, f) {
            return arguments.length < 2 ? T(n[P]) : n[P] && n[P][f];
          };
        },
        /* 25 */
        /***/
        (O, S, t) => {
          var n = t(14);
          O.exports = n({}.isPrototypeOf);
        },
        /* 26 */
        /***/
        (O, S, t) => {
          var n = t(27);
          O.exports = n && !Symbol.sham && typeof Symbol.iterator == "symbol";
        },
        /* 27 */
        /***/
        (O, S, t) => {
          var n = t(28), h = t(7), T = t(4), P = T.String;
          O.exports = !!Object.getOwnPropertySymbols && !h(function() {
            var f = Symbol("symbol detection");
            return !P(f) || !(Object(f) instanceof Symbol) || !Symbol.sham && n && n < 41;
          });
        },
        /* 28 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(29), T = n.process, P = n.Deno, f = T && T.versions || P && P.version, y = f && f.v8, c, a;
          y && (c = y.split("."), a = c[0] > 0 && c[0] < 4 ? 1 : +(c[0] + c[1])), !a && h && (c = h.match(/Edge\/(\d+)/), (!c || c[1] >= 74) && (c = h.match(/Chrome\/(\d+)/), c && (a = +c[1]))), O.exports = a;
        },
        /* 29 */
        /***/
        (O) => {
          O.exports = typeof navigator < "u" && String(navigator.userAgent) || "";
        },
        /* 30 */
        /***/
        (O, S, t) => {
          var n = t(31), h = t(17);
          O.exports = function(T, P) {
            var f = T[P];
            return h(f) ? void 0 : n(f);
          };
        },
        /* 31 */
        /***/
        (O, S, t) => {
          var n = t(21), h = t(32), T = TypeError;
          O.exports = function(P) {
            if (n(P))
              return P;
            throw T(h(P) + " is not a function");
          };
        },
        /* 32 */
        /***/
        (O) => {
          var S = String;
          O.exports = function(t) {
            try {
              return S(t);
            } catch {
              return "Object";
            }
          };
        },
        /* 33 */
        /***/
        (O, S, t) => {
          var n = t(8), h = t(21), T = t(20), P = TypeError;
          O.exports = function(f, y) {
            var c, a;
            if (y === "string" && h(c = f.toString) && !T(a = n(c, f)) || h(c = f.valueOf) && !T(a = n(c, f)) || y !== "string" && h(c = f.toString) && !T(a = n(c, f)))
              return a;
            throw P("Can't convert object to primitive value");
          };
        },
        /* 34 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(35), T = t(39), P = t(41), f = t(27), y = t(26), c = n.Symbol, a = h("wks"), I = y ? c.for || c : c && c.withoutSetter || P;
          O.exports = function(A) {
            return T(a, A) || (a[A] = f && T(c, A) ? c[A] : I("Symbol." + A)), a[A];
          };
        },
        /* 35 */
        /***/
        (O, S, t) => {
          var n = t(36), h = t(37);
          (O.exports = function(T, P) {
            return h[T] || (h[T] = P !== void 0 ? P : {});
          })("versions", []).push({
            version: "3.32.2",
            mode: n ? "pure" : "global",
            copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.32.2/LICENSE",
            source: "https://github.com/zloirock/core-js"
          });
        },
        /* 36 */
        /***/
        (O) => {
          O.exports = !1;
        },
        /* 37 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(38), T = "__core-js_shared__", P = n[T] || h(T, {});
          O.exports = P;
        },
        /* 38 */
        /***/
        (O, S, t) => {
          var n = t(4), h = Object.defineProperty;
          O.exports = function(T, P) {
            try {
              h(n, T, {
                value: P,
                configurable: !0,
                writable: !0
              });
            } catch {
              n[T] = P;
            }
            return P;
          };
        },
        /* 39 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(40), T = n({}.hasOwnProperty);
          O.exports = Object.hasOwn || function(f, y) {
            return T(h(f), y);
          };
        },
        /* 40 */
        /***/
        (O, S, t) => {
          var n = t(16), h = Object;
          O.exports = function(T) {
            return h(n(T));
          };
        },
        /* 41 */
        /***/
        (O, S, t) => {
          var n = t(14), h = 0, T = Math.random(), P = n(1 .toString);
          O.exports = function(f) {
            return "Symbol(" + (f === void 0 ? "" : f) + ")_" + P(++h + T, 36);
          };
        },
        /* 42 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(7), T = t(43);
          O.exports = !n && !h(function() {
            return Object.defineProperty(T("div"), "a", {
              get: function() {
                return 7;
              }
            }).a !== 7;
          });
        },
        /* 43 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(20), T = n.document, P = h(T) && h(T.createElement);
          O.exports = function(f) {
            return P ? T.createElement(f) : {};
          };
        },
        /* 44 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(45), T = t(11);
          O.exports = n ? function(P, f, y) {
            return h.f(P, f, T(1, y));
          } : function(P, f, y) {
            return P[f] = y, P;
          };
        },
        /* 45 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(42), T = t(46), P = t(47), f = t(18), y = TypeError, c = Object.defineProperty, a = Object.getOwnPropertyDescriptor, I = "enumerable", A = "configurable", g = "writable";
          S.f = n ? T ? function(o, l, u) {
            if (P(o), l = f(l), P(u), typeof o == "function" && l === "prototype" && "value" in u && g in u && !u[g]) {
              var v = a(o, l);
              v && v[g] && (o[l] = u.value, u = {
                configurable: A in u ? u[A] : v[A],
                enumerable: I in u ? u[I] : v[I],
                writable: !1
              });
            }
            return c(o, l, u);
          } : c : function(o, l, u) {
            if (P(o), l = f(l), P(u), h)
              try {
                return c(o, l, u);
              } catch {
              }
            if ("get" in u || "set" in u)
              throw y("Accessors not supported");
            return "value" in u && (o[l] = u.value), o;
          };
        },
        /* 46 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(7);
          O.exports = n && h(function() {
            return Object.defineProperty(function() {
            }, "prototype", {
              value: 42,
              writable: !1
            }).prototype !== 42;
          });
        },
        /* 47 */
        /***/
        (O, S, t) => {
          var n = t(20), h = String, T = TypeError;
          O.exports = function(P) {
            if (n(P))
              return P;
            throw T(h(P) + " is not an object");
          };
        },
        /* 48 */
        /***/
        (O, S, t) => {
          var n = t(21), h = t(45), T = t(49), P = t(38);
          O.exports = function(f, y, c, a) {
            a || (a = {});
            var I = a.enumerable, A = a.name !== void 0 ? a.name : y;
            if (n(c) && T(c, A, a), a.global)
              I ? f[y] = c : P(y, c);
            else {
              try {
                a.unsafe ? f[y] && (I = !0) : delete f[y];
              } catch {
              }
              I ? f[y] = c : h.f(f, y, {
                value: c,
                enumerable: !1,
                configurable: !a.nonConfigurable,
                writable: !a.nonWritable
              });
            }
            return f;
          };
        },
        /* 49 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(7), T = t(21), P = t(39), f = t(6), y = t(50).CONFIGURABLE, c = t(51), a = t(52), I = a.enforce, A = a.get, g = String, s = Object.defineProperty, o = n("".slice), l = n("".replace), u = n([].join), v = f && !h(function() {
            return s(function() {
            }, "length", { value: 8 }).length !== 8;
          }), p = String(String).split("String"), C = O.exports = function(r, i, w) {
            o(g(i), 0, 7) === "Symbol(" && (i = "[" + l(g(i), /^Symbol\(([^)]*)\)/, "$1") + "]"), w && w.getter && (i = "get " + i), w && w.setter && (i = "set " + i), (!P(r, "name") || y && r.name !== i) && (f ? s(r, "name", {
              value: i,
              configurable: !0
            }) : r.name = i), v && w && P(w, "arity") && r.length !== w.arity && s(r, "length", { value: w.arity });
            try {
              w && P(w, "constructor") && w.constructor ? f && s(r, "prototype", { writable: !1 }) : r.prototype && (r.prototype = void 0);
            } catch {
            }
            var x = I(r);
            return P(x, "source") || (x.source = u(p, typeof i == "string" ? i : "")), r;
          };
          Function.prototype.toString = C(function() {
            return T(this) && A(this).source || c(this);
          }, "toString");
        },
        /* 50 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(39), T = Function.prototype, P = n && Object.getOwnPropertyDescriptor, f = h(T, "name"), y = f && (function() {
          }).name === "something", c = f && (!n || n && P(T, "name").configurable);
          O.exports = {
            EXISTS: f,
            PROPER: y,
            CONFIGURABLE: c
          };
        },
        /* 51 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(21), T = t(37), P = n(Function.toString);
          h(T.inspectSource) || (T.inspectSource = function(f) {
            return P(f);
          }), O.exports = T.inspectSource;
        },
        /* 52 */
        /***/
        (O, S, t) => {
          var n = t(53), h = t(4), T = t(20), P = t(44), f = t(39), y = t(37), c = t(54), a = t(55), I = "Object already initialized", A = h.TypeError, g = h.WeakMap, s, o, l, u = function(r) {
            return l(r) ? o(r) : s(r, {});
          }, v = function(r) {
            return function(i) {
              var w;
              if (!T(i) || (w = o(i)).type !== r)
                throw A("Incompatible receiver, " + r + " required");
              return w;
            };
          };
          if (n || y.state) {
            var p = y.state || (y.state = new g());
            p.get = p.get, p.has = p.has, p.set = p.set, s = function(r, i) {
              if (p.has(r))
                throw A(I);
              return i.facade = r, p.set(r, i), i;
            }, o = function(r) {
              return p.get(r) || {};
            }, l = function(r) {
              return p.has(r);
            };
          } else {
            var C = c("state");
            a[C] = !0, s = function(r, i) {
              if (f(r, C))
                throw A(I);
              return i.facade = r, P(r, C, i), i;
            }, o = function(r) {
              return f(r, C) ? r[C] : {};
            }, l = function(r) {
              return f(r, C);
            };
          }
          O.exports = {
            set: s,
            get: o,
            has: l,
            enforce: u,
            getterFor: v
          };
        },
        /* 53 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(21), T = n.WeakMap;
          O.exports = h(T) && /native code/.test(String(T));
        },
        /* 54 */
        /***/
        (O, S, t) => {
          var n = t(35), h = t(41), T = n("keys");
          O.exports = function(P) {
            return T[P] || (T[P] = h(P));
          };
        },
        /* 55 */
        /***/
        (O) => {
          O.exports = {};
        },
        /* 56 */
        /***/
        (O, S, t) => {
          var n = t(39), h = t(57), T = t(5), P = t(45);
          O.exports = function(f, y, c) {
            for (var a = h(y), I = P.f, A = T.f, g = 0; g < a.length; g++) {
              var s = a[g];
              !n(f, s) && !(c && n(c, s)) && I(f, s, A(y, s));
            }
          };
        },
        /* 57 */
        /***/
        (O, S, t) => {
          var n = t(24), h = t(14), T = t(58), P = t(67), f = t(47), y = h([].concat);
          O.exports = n("Reflect", "ownKeys") || function(a) {
            var I = T.f(f(a)), A = P.f;
            return A ? y(I, A(a)) : I;
          };
        },
        /* 58 */
        /***/
        (O, S, t) => {
          var n = t(59), h = t(66), T = h.concat("length", "prototype");
          S.f = Object.getOwnPropertyNames || function(f) {
            return n(f, T);
          };
        },
        /* 59 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(39), T = t(12), P = t(60).indexOf, f = t(55), y = n([].push);
          O.exports = function(c, a) {
            var I = T(c), A = 0, g = [], s;
            for (s in I)
              !h(f, s) && h(I, s) && y(g, s);
            for (; a.length > A; )
              h(I, s = a[A++]) && (~P(g, s) || y(g, s));
            return g;
          };
        },
        /* 60 */
        /***/
        (O, S, t) => {
          var n = t(12), h = t(61), T = t(64), P = function(f) {
            return function(y, c, a) {
              var I = n(y), A = T(I), g = h(a, A), s;
              if (f && c !== c) {
                for (; A > g; )
                  if (s = I[g++], s !== s)
                    return !0;
              } else
                for (; A > g; g++)
                  if ((f || g in I) && I[g] === c)
                    return f || g || 0;
              return !f && -1;
            };
          };
          O.exports = {
            includes: P(!0),
            indexOf: P(!1)
          };
        },
        /* 61 */
        /***/
        (O, S, t) => {
          var n = t(62), h = Math.max, T = Math.min;
          O.exports = function(P, f) {
            var y = n(P);
            return y < 0 ? h(y + f, 0) : T(y, f);
          };
        },
        /* 62 */
        /***/
        (O, S, t) => {
          var n = t(63);
          O.exports = function(h) {
            var T = +h;
            return T !== T || T === 0 ? 0 : n(T);
          };
        },
        /* 63 */
        /***/
        (O) => {
          var S = Math.ceil, t = Math.floor;
          O.exports = Math.trunc || function(h) {
            var T = +h;
            return (T > 0 ? t : S)(T);
          };
        },
        /* 64 */
        /***/
        (O, S, t) => {
          var n = t(65);
          O.exports = function(h) {
            return n(h.length);
          };
        },
        /* 65 */
        /***/
        (O, S, t) => {
          var n = t(62), h = Math.min;
          O.exports = function(T) {
            return T > 0 ? h(n(T), 9007199254740991) : 0;
          };
        },
        /* 66 */
        /***/
        (O) => {
          O.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        },
        /* 67 */
        /***/
        (O, S) => {
          S.f = Object.getOwnPropertySymbols;
        },
        /* 68 */
        /***/
        (O, S, t) => {
          var n = t(7), h = t(21), T = /#|\.prototype\./, P = function(I, A) {
            var g = y[f(I)];
            return g === a ? !0 : g === c ? !1 : h(A) ? n(A) : !!A;
          }, f = P.normalize = function(I) {
            return String(I).replace(T, ".").toLowerCase();
          }, y = P.data = {}, c = P.NATIVE = "N", a = P.POLYFILL = "P";
          O.exports = P;
        },
        /* 69 */
        /***/
        (O, S, t) => {
          var n = t(9), h = Function.prototype, T = h.apply, P = h.call;
          O.exports = typeof Reflect == "object" && Reflect.apply || (n ? P.bind(T) : function() {
            return P.apply(T, arguments);
          });
        },
        /* 70 */
        /***/
        (O, S, t) => {
          var n = t(24), h = t(39), T = t(44), P = t(25), f = t(71), y = t(56), c = t(74), a = t(75), I = t(76), A = t(80), g = t(81), s = t(6), o = t(36);
          O.exports = function(l, u, v, p) {
            var C = "stackTraceLimit", r = p ? 2 : 1, i = l.split("."), w = i[i.length - 1], x = n.apply(null, i);
            if (x) {
              var b = x.prototype;
              if (!o && h(b, "cause") && delete b.cause, !v)
                return x;
              var F = n("Error"), L = u(function(G, nt) {
                var D = I(p ? nt : G, void 0), X = p ? new x(G) : new x();
                return D !== void 0 && T(X, "message", D), g(X, L, X.stack, 2), this && P(b, this) && a(X, this, L), arguments.length > r && A(X, arguments[r]), X;
              });
              if (L.prototype = b, w !== "Error" ? f ? f(L, F) : y(L, F, { name: !0 }) : s && C in x && (c(L, x, C), c(L, x, "prepareStackTrace")), y(L, x), !o)
                try {
                  b.name !== w && T(b, "name", w), b.constructor = L;
                } catch {
                }
              return L;
            }
          };
        },
        /* 71 */
        /***/
        (O, S, t) => {
          var n = t(72), h = t(47), T = t(73);
          O.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var P = !1, f = {}, y;
            try {
              y = n(Object.prototype, "__proto__", "set"), y(f, []), P = f instanceof Array;
            } catch {
            }
            return function(a, I) {
              return h(a), T(I), P ? y(a, I) : a.__proto__ = I, a;
            };
          }() : void 0);
        },
        /* 72 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(31);
          O.exports = function(T, P, f) {
            try {
              return n(h(Object.getOwnPropertyDescriptor(T, P)[f]));
            } catch {
            }
          };
        },
        /* 73 */
        /***/
        (O, S, t) => {
          var n = t(21), h = String, T = TypeError;
          O.exports = function(P) {
            if (typeof P == "object" || n(P))
              return P;
            throw T("Can't set " + h(P) + " as a prototype");
          };
        },
        /* 74 */
        /***/
        (O, S, t) => {
          var n = t(45).f;
          O.exports = function(h, T, P) {
            P in h || n(h, P, {
              configurable: !0,
              get: function() {
                return T[P];
              },
              set: function(f) {
                T[P] = f;
              }
            });
          };
        },
        /* 75 */
        /***/
        (O, S, t) => {
          var n = t(21), h = t(20), T = t(71);
          O.exports = function(P, f, y) {
            var c, a;
            return T && n(c = f.constructor) && c !== y && h(a = c.prototype) && a !== y.prototype && T(P, a), P;
          };
        },
        /* 76 */
        /***/
        (O, S, t) => {
          var n = t(77);
          O.exports = function(h, T) {
            return h === void 0 ? arguments.length < 2 ? "" : T : n(h);
          };
        },
        /* 77 */
        /***/
        (O, S, t) => {
          var n = t(78), h = String;
          O.exports = function(T) {
            if (n(T) === "Symbol")
              throw TypeError("Cannot convert a Symbol value to a string");
            return h(T);
          };
        },
        /* 78 */
        /***/
        (O, S, t) => {
          var n = t(79), h = t(21), T = t(15), P = t(34), f = P("toStringTag"), y = Object, c = T(function() {
            return arguments;
          }()) === "Arguments", a = function(I, A) {
            try {
              return I[A];
            } catch {
            }
          };
          O.exports = n ? T : function(I) {
            var A, g, s;
            return I === void 0 ? "Undefined" : I === null ? "Null" : typeof (g = a(A = y(I), f)) == "string" ? g : c ? T(A) : (s = T(A)) === "Object" && h(A.callee) ? "Arguments" : s;
          };
        },
        /* 79 */
        /***/
        (O, S, t) => {
          var n = t(34), h = n("toStringTag"), T = {};
          T[h] = "z", O.exports = String(T) === "[object z]";
        },
        /* 80 */
        /***/
        (O, S, t) => {
          var n = t(20), h = t(44);
          O.exports = function(T, P) {
            n(P) && "cause" in P && h(T, "cause", P.cause);
          };
        },
        /* 81 */
        /***/
        (O, S, t) => {
          var n = t(44), h = t(82), T = t(83), P = Error.captureStackTrace;
          O.exports = function(f, y, c, a) {
            T && (P ? P(f, y) : n(f, "stack", h(c, a)));
          };
        },
        /* 82 */
        /***/
        (O, S, t) => {
          var n = t(14), h = Error, T = n("".replace), P = function(c) {
            return String(h(c).stack);
          }("zxcasd"), f = /\n\s*at [^:]*:[^\n]*/, y = f.test(P);
          O.exports = function(c, a) {
            if (y && typeof c == "string" && !h.prepareStackTrace)
              for (; a--; )
                c = T(c, f, "");
            return c;
          };
        },
        /* 83 */
        /***/
        (O, S, t) => {
          var n = t(7), h = t(11);
          O.exports = !n(function() {
            var T = Error("a");
            return "stack" in T ? (Object.defineProperty(T, "stack", h(1, 7)), T.stack !== 7) : !0;
          });
        },
        /* 84 */
        /***/
        (O, S, t) => {
          var n = t(48), h = t(14), T = t(77), P = t(85), f = URLSearchParams, y = f.prototype, c = h(y.append), a = h(y.delete), I = h(y.forEach), A = h([].push), g = new f("a=1&a=2&b=3");
          g.delete("a", 1), g.delete("b", void 0), g + "" != "a=2" && n(y, "delete", function(s) {
            var o = arguments.length, l = o < 2 ? void 0 : arguments[1];
            if (o && l === void 0)
              return a(this, s);
            var u = [];
            I(this, function(b, F) {
              A(u, {
                key: F,
                value: b
              });
            }), P(o, 1);
            for (var v = T(s), p = T(l), C = 0, r = 0, i = !1, w = u.length, x; C < w; )
              x = u[C++], i || x.key === v ? (i = !0, a(this, x.key)) : r++;
            for (; r < w; )
              x = u[r++], x.key === v && x.value === p || c(this, x.key, x.value);
          }, {
            enumerable: !0,
            unsafe: !0
          });
        },
        /* 85 */
        /***/
        (O) => {
          var S = TypeError;
          O.exports = function(t, n) {
            if (t < n)
              throw S("Not enough arguments");
            return t;
          };
        },
        /* 86 */
        /***/
        (O, S, t) => {
          var n = t(48), h = t(14), T = t(77), P = t(85), f = URLSearchParams, y = f.prototype, c = h(y.getAll), a = h(y.has), I = new f("a=1");
          (I.has("a", 2) || !I.has("a", void 0)) && n(y, "has", function(g) {
            var s = arguments.length, o = s < 2 ? void 0 : arguments[1];
            if (s && o === void 0)
              return a(this, g);
            var l = c(this, g);
            P(s, 1);
            for (var u = T(o), v = 0; v < l.length; )
              if (l[v++] === u)
                return !0;
            return !1;
          }, {
            enumerable: !0,
            unsafe: !0
          });
        },
        /* 87 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(14), T = t(88), P = URLSearchParams.prototype, f = h(P.forEach);
          n && !("size" in P) && T(P, "size", {
            get: function() {
              var c = 0;
              return f(this, function() {
                c++;
              }), c;
            },
            configurable: !0,
            enumerable: !0
          });
        },
        /* 88 */
        /***/
        (O, S, t) => {
          var n = t(49), h = t(45);
          O.exports = function(T, P, f) {
            return f.get && n(f.get, P, { getter: !0 }), f.set && n(f.set, P, { setter: !0 }), h.f(T, P, f);
          };
        },
        /* 89 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(40), T = t(64), P = t(90), f = t(92), y = t(7), c = y(function() {
            return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
          }), a = function() {
            try {
              Object.defineProperty([], "length", { writable: !1 }).push();
            } catch (A) {
              return A instanceof TypeError;
            }
          }, I = c || !a();
          n({
            target: "Array",
            proto: !0,
            arity: 1,
            forced: I
          }, {
            push: function(g) {
              var s = h(this), o = T(s), l = arguments.length;
              f(o + l);
              for (var u = 0; u < l; u++)
                s[o] = arguments[u], o++;
              return P(s, o), o;
            }
          });
        },
        /* 90 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(91), T = TypeError, P = Object.getOwnPropertyDescriptor, f = n && !function() {
            if (this !== void 0)
              return !0;
            try {
              Object.defineProperty([], "length", { writable: !1 }).length = 1;
            } catch (y) {
              return y instanceof TypeError;
            }
          }();
          O.exports = f ? function(y, c) {
            if (h(y) && !P(y, "length").writable)
              throw T("Cannot set read only .length");
            return y.length = c;
          } : function(y, c) {
            return y.length = c;
          };
        },
        /* 91 */
        /***/
        (O, S, t) => {
          var n = t(15);
          O.exports = Array.isArray || function(T) {
            return n(T) === "Array";
          };
        },
        /* 92 */
        /***/
        (O) => {
          var S = TypeError, t = 9007199254740991;
          O.exports = function(n) {
            if (n > t)
              throw S("Maximum allowed index exceeded");
            return n;
          };
        },
        /* 93 */
        /***/
        (O, S, t) => {
          var n = t(94), h = t(98).findLast, T = n.aTypedArray, P = n.exportTypedArrayMethod;
          P("findLast", function(y) {
            return h(T(this), y, arguments.length > 1 ? arguments[1] : void 0);
          });
        },
        /* 94 */
        /***/
        (O, S, t) => {
          var n = t(95), h = t(6), T = t(4), P = t(21), f = t(20), y = t(39), c = t(78), a = t(32), I = t(44), A = t(48), g = t(88), s = t(25), o = t(96), l = t(71), u = t(34), v = t(41), p = t(52), C = p.enforce, r = p.get, i = T.Int8Array, w = i && i.prototype, x = T.Uint8ClampedArray, b = x && x.prototype, F = i && o(i), L = w && o(w), G = Object.prototype, nt = T.TypeError, D = u("toStringTag"), X = v("TYPED_ARRAY_TAG"), q = "TypedArrayConstructor", j = n && !!l && c(T.opera) !== "Opera", z = !1, it, Q, Et, Ct = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
          }, H = {
            BigInt64Array: 8,
            BigUint64Array: 8
          }, m = function(pt) {
            if (!f(pt))
              return !1;
            var dt = c(pt);
            return dt === "DataView" || y(Ct, dt) || y(H, dt);
          }, k = function(Z) {
            var pt = o(Z);
            if (f(pt)) {
              var dt = r(pt);
              return dt && y(dt, q) ? dt[q] : k(pt);
            }
          }, d = function(Z) {
            if (!f(Z))
              return !1;
            var pt = c(Z);
            return y(Ct, pt) || y(H, pt);
          }, R = function(Z) {
            if (d(Z))
              return Z;
            throw nt("Target is not a typed array");
          }, M = function(Z) {
            if (P(Z) && (!l || s(F, Z)))
              return Z;
            throw nt(a(Z) + " is not a typed array constructor");
          }, B = function(Z, pt, dt, Tt) {
            if (h) {
              if (dt)
                for (var lt in Ct) {
                  var yt = T[lt];
                  if (yt && y(yt.prototype, Z))
                    try {
                      delete yt.prototype[Z];
                    } catch {
                      try {
                        yt.prototype[Z] = pt;
                      } catch {
                      }
                    }
                }
              (!L[Z] || dt) && A(L, Z, dt ? pt : j && w[Z] || pt, Tt);
            }
          }, _ = function(Z, pt, dt) {
            var Tt, lt;
            if (h) {
              if (l) {
                if (dt) {
                  for (Tt in Ct)
                    if (lt = T[Tt], lt && y(lt, Z))
                      try {
                        delete lt[Z];
                      } catch {
                      }
                }
                if (!F[Z] || dt)
                  try {
                    return A(F, Z, dt ? pt : j && F[Z] || pt);
                  } catch {
                  }
                else
                  return;
              }
              for (Tt in Ct)
                lt = T[Tt], lt && (!lt[Z] || dt) && A(lt, Z, pt);
            }
          };
          for (it in Ct)
            Q = T[it], Et = Q && Q.prototype, Et ? C(Et)[q] = Q : j = !1;
          for (it in H)
            Q = T[it], Et = Q && Q.prototype, Et && (C(Et)[q] = Q);
          if ((!j || !P(F) || F === Function.prototype) && (F = function() {
            throw nt("Incorrect invocation");
          }, j))
            for (it in Ct)
              T[it] && l(T[it], F);
          if ((!j || !L || L === G) && (L = F.prototype, j))
            for (it in Ct)
              T[it] && l(T[it].prototype, L);
          if (j && o(b) !== L && l(b, L), h && !y(L, D)) {
            z = !0, g(L, D, {
              configurable: !0,
              get: function() {
                return f(this) ? this[X] : void 0;
              }
            });
            for (it in Ct)
              T[it] && I(T[it], X, it);
          }
          O.exports = {
            NATIVE_ARRAY_BUFFER_VIEWS: j,
            TYPED_ARRAY_TAG: z && X,
            aTypedArray: R,
            aTypedArrayConstructor: M,
            exportTypedArrayMethod: B,
            exportTypedArrayStaticMethod: _,
            getTypedArrayConstructor: k,
            isView: m,
            isTypedArray: d,
            TypedArray: F,
            TypedArrayPrototype: L
          };
        },
        /* 95 */
        /***/
        (O) => {
          O.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
        },
        /* 96 */
        /***/
        (O, S, t) => {
          var n = t(39), h = t(21), T = t(40), P = t(54), f = t(97), y = P("IE_PROTO"), c = Object, a = c.prototype;
          O.exports = f ? c.getPrototypeOf : function(I) {
            var A = T(I);
            if (n(A, y))
              return A[y];
            var g = A.constructor;
            return h(g) && A instanceof g ? g.prototype : A instanceof c ? a : null;
          };
        },
        /* 97 */
        /***/
        (O, S, t) => {
          var n = t(7);
          O.exports = !n(function() {
            function h() {
            }
            return h.prototype.constructor = null, Object.getPrototypeOf(new h()) !== h.prototype;
          });
        },
        /* 98 */
        /***/
        (O, S, t) => {
          var n = t(99), h = t(13), T = t(40), P = t(64), f = function(y) {
            var c = y === 1;
            return function(a, I, A) {
              for (var g = T(a), s = h(g), o = n(I, A), l = P(s), u, v; l-- > 0; )
                if (u = s[l], v = o(u, l, g), v)
                  switch (y) {
                    case 0:
                      return u;
                    case 1:
                      return l;
                  }
              return c ? -1 : void 0;
            };
          };
          O.exports = {
            findLast: f(0),
            findLastIndex: f(1)
          };
        },
        /* 99 */
        /***/
        (O, S, t) => {
          var n = t(100), h = t(31), T = t(9), P = n(n.bind);
          O.exports = function(f, y) {
            return h(f), y === void 0 ? f : T ? P(f, y) : function() {
              return f.apply(y, arguments);
            };
          };
        },
        /* 100 */
        /***/
        (O, S, t) => {
          var n = t(15), h = t(14);
          O.exports = function(T) {
            if (n(T) === "Function")
              return h(T);
          };
        },
        /* 101 */
        /***/
        (O, S, t) => {
          var n = t(94), h = t(98).findLastIndex, T = n.aTypedArray, P = n.exportTypedArrayMethod;
          P("findLastIndex", function(y) {
            return h(T(this), y, arguments.length > 1 ? arguments[1] : void 0);
          });
        },
        /* 102 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(8), T = t(94), P = t(64), f = t(103), y = t(40), c = t(7), a = n.RangeError, I = n.Int8Array, A = I && I.prototype, g = A && A.set, s = T.aTypedArray, o = T.exportTypedArrayMethod, l = !c(function() {
            var v = new Uint8ClampedArray(2);
            return h(g, v, {
              length: 1,
              0: 3
            }, 1), v[1] !== 3;
          }), u = l && T.NATIVE_ARRAY_BUFFER_VIEWS && c(function() {
            var v = new I(2);
            return v.set(1), v.set("2", 1), v[0] !== 0 || v[1] !== 2;
          });
          o("set", function(p) {
            s(this);
            var C = f(arguments.length > 1 ? arguments[1] : void 0, 1), r = y(p);
            if (l)
              return h(g, this, r, C);
            var i = this.length, w = P(r), x = 0;
            if (w + C > i)
              throw a("Wrong length");
            for (; x < w; )
              this[C + x] = r[x++];
          }, !l || u);
        },
        /* 103 */
        /***/
        (O, S, t) => {
          var n = t(104), h = RangeError;
          O.exports = function(T, P) {
            var f = n(T);
            if (f % P)
              throw h("Wrong offset");
            return f;
          };
        },
        /* 104 */
        /***/
        (O, S, t) => {
          var n = t(62), h = RangeError;
          O.exports = function(T) {
            var P = n(T);
            if (P < 0)
              throw h("The argument can't be less than 0");
            return P;
          };
        },
        /* 105 */
        /***/
        (O, S, t) => {
          var n = t(106), h = t(94), T = h.aTypedArray, P = h.exportTypedArrayMethod, f = h.getTypedArrayConstructor;
          P("toReversed", function() {
            return n(T(this), f(this));
          });
        },
        /* 106 */
        /***/
        (O, S, t) => {
          var n = t(64);
          O.exports = function(h, T) {
            for (var P = n(h), f = new T(P), y = 0; y < P; y++)
              f[y] = h[P - y - 1];
            return f;
          };
        },
        /* 107 */
        /***/
        (O, S, t) => {
          var n = t(94), h = t(14), T = t(31), P = t(108), f = n.aTypedArray, y = n.getTypedArrayConstructor, c = n.exportTypedArrayMethod, a = h(n.TypedArrayPrototype.sort);
          c("toSorted", function(A) {
            A !== void 0 && T(A);
            var g = f(this), s = P(y(g), g);
            return a(s, A);
          });
        },
        /* 108 */
        /***/
        (O, S, t) => {
          var n = t(64);
          O.exports = function(h, T) {
            for (var P = 0, f = n(T), y = new h(f); f > P; )
              y[P] = T[P++];
            return y;
          };
        },
        /* 109 */
        /***/
        (O, S, t) => {
          var n = t(110), h = t(94), T = t(111), P = t(62), f = t(112), y = h.aTypedArray, c = h.getTypedArrayConstructor, a = h.exportTypedArrayMethod, I = !!function() {
            try {
              new Int8Array(1).with(2, {
                valueOf: function() {
                  throw 8;
                }
              });
            } catch (A) {
              return A === 8;
            }
          }();
          a("with", function(A, g) {
            var s = y(this), o = P(A), l = T(s) ? f(g) : +g;
            return n(s, c(s), o, l);
          }, !I);
        },
        /* 110 */
        /***/
        (O, S, t) => {
          var n = t(64), h = t(62), T = RangeError;
          O.exports = function(P, f, y, c) {
            var a = n(P), I = h(y), A = I < 0 ? a + I : I;
            if (A >= a || A < 0)
              throw T("Incorrect index");
            for (var g = new f(a), s = 0; s < a; s++)
              g[s] = s === A ? c : P[s];
            return g;
          };
        },
        /* 111 */
        /***/
        (O, S, t) => {
          var n = t(78);
          O.exports = function(h) {
            var T = n(h);
            return T === "BigInt64Array" || T === "BigUint64Array";
          };
        },
        /* 112 */
        /***/
        (O, S, t) => {
          var n = t(19), h = TypeError;
          O.exports = function(T) {
            var P = n(T, "number");
            if (typeof P == "number")
              throw h("Can't convert number to bigint");
            return BigInt(P);
          };
        },
        /* 113 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(88), T = t(114), P = ArrayBuffer.prototype;
          n && !("detached" in P) && h(P, "detached", {
            configurable: !0,
            get: function() {
              return T(this);
            }
          });
        },
        /* 114 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(115), T = n(ArrayBuffer.prototype.slice);
          O.exports = function(P) {
            if (h(P) !== 0)
              return !1;
            try {
              return T(P, 0, 0), !1;
            } catch {
              return !0;
            }
          };
        },
        /* 115 */
        /***/
        (O, S, t) => {
          var n = t(72), h = t(15), T = TypeError;
          O.exports = n(ArrayBuffer.prototype, "byteLength", "get") || function(P) {
            if (h(P) !== "ArrayBuffer")
              throw T("ArrayBuffer expected");
            return P.byteLength;
          };
        },
        /* 116 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(117);
          h && n({
            target: "ArrayBuffer",
            proto: !0
          }, {
            transfer: function() {
              return h(this, arguments.length ? arguments[0] : void 0, !0);
            }
          });
        },
        /* 117 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(14), T = t(72), P = t(118), f = t(114), y = t(115), c = t(119), a = n.TypeError, I = n.structuredClone, A = n.ArrayBuffer, g = n.DataView, s = Math.min, o = A.prototype, l = g.prototype, u = h(o.slice), v = T(o, "resizable", "get"), p = T(o, "maxByteLength", "get"), C = h(l.getInt8), r = h(l.setInt8);
          O.exports = c && function(i, w, x) {
            var b = y(i), F = w === void 0 ? b : P(w), L = !v || !v(i);
            if (f(i))
              throw a("ArrayBuffer is detached");
            var G = I(i, { transfer: [i] });
            if (b === F && (x || L))
              return G;
            if (b >= F && (!x || L))
              return u(G, 0, F);
            for (var nt = x && !L && p ? { maxByteLength: p(G) } : void 0, D = new A(F, nt), X = new g(G), q = new g(D), j = s(F, b), z = 0; z < j; z++)
              r(q, z, C(X, z));
            return D;
          };
        },
        /* 118 */
        /***/
        (O, S, t) => {
          var n = t(62), h = t(65), T = RangeError;
          O.exports = function(P) {
            if (P === void 0)
              return 0;
            var f = n(P), y = h(f);
            if (f !== y)
              throw T("Wrong length or index");
            return y;
          };
        },
        /* 119 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(7), T = t(28), P = t(120), f = t(121), y = t(122), c = n.structuredClone;
          O.exports = !!c && !h(function() {
            if (f && T > 92 || y && T > 94 || P && T > 97)
              return !1;
            var a = new ArrayBuffer(8), I = c(a, { transfer: [a] });
            return a.byteLength !== 0 || I.byteLength !== 8;
          });
        },
        /* 120 */
        /***/
        (O, S, t) => {
          var n = t(121), h = t(122);
          O.exports = !n && !h && typeof window == "object" && typeof document == "object";
        },
        /* 121 */
        /***/
        (O) => {
          O.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
        },
        /* 122 */
        /***/
        (O, S, t) => {
          var n = t(4), h = t(15);
          O.exports = h(n.process) === "process";
        },
        /* 123 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(117);
          h && n({
            target: "ArrayBuffer",
            proto: !0
          }, {
            transferToFixedLength: function() {
              return h(this, arguments.length ? arguments[0] : void 0, !1);
            }
          });
        },
        /* 124 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var O, t, n, h, de, P, ke, y, c, a, I, A, g, s, o, l, Me, v, p, Je, r, i;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
            enumerable: !0,
            get: function() {
              return _displaySvg.SVGGraphics;
            }
          }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0, __w_pdfjs_require__(84), __w_pdfjs_require__(86), __w_pdfjs_require__(87), __w_pdfjs_require__(2), __w_pdfjs_require__(93), __w_pdfjs_require__(101), __w_pdfjs_require__(102), __w_pdfjs_require__(105), __w_pdfjs_require__(107), __w_pdfjs_require__(109), __w_pdfjs_require__(113), __w_pdfjs_require__(116), __w_pdfjs_require__(123), __w_pdfjs_require__(89), __w_pdfjs_require__(125), __w_pdfjs_require__(136), __w_pdfjs_require__(138), __w_pdfjs_require__(141), __w_pdfjs_require__(143), __w_pdfjs_require__(145), __w_pdfjs_require__(147), __w_pdfjs_require__(149), __w_pdfjs_require__(152);
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(163), _display_utils = __w_pdfjs_require__(168), _font_loader = __w_pdfjs_require__(171), _displayNode_utils = __w_pdfjs_require__(172), _canvas = __w_pdfjs_require__(173), _worker_options = __w_pdfjs_require__(176), _message_handler = __w_pdfjs_require__(177), _metadata = __w_pdfjs_require__(178), _optional_content_config = __w_pdfjs_require__(179), _transport_stream = __w_pdfjs_require__(180), _displayFetch_stream = __w_pdfjs_require__(181), _displayNetwork = __w_pdfjs_require__(184), _displayNode_stream = __w_pdfjs_require__(185), _displaySvg = __w_pdfjs_require__(186), _xfa_text = __w_pdfjs_require__(194);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
          exports.DefaultFilterFactory = DefaultFilterFactory;
          const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
          function getDocument(x) {
            if (typeof x == "string" || x instanceof URL ? x = {
              url: x
            } : (0, _util.isArrayBuffer)(x) && (x = {
              data: x
            }), typeof x != "object")
              throw new Error("Invalid parameter in getDocument, need parameter object.");
            if (!x.url && !x.data && !x.range)
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            const b = new PDFDocumentLoadingTask(), {
              docId: F
            } = b, L = x.url ? getUrlProp(x.url) : null, G = x.data ? getDataProp(x.data) : null, nt = x.httpHeaders || null, D = x.withCredentials === !0, X = x.password ?? null, q = x.range instanceof PDFDataRangeTransport ? x.range : null, j = Number.isInteger(x.rangeChunkSize) && x.rangeChunkSize > 0 ? x.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
            let z = x.worker instanceof PDFWorker ? x.worker : null;
            const it = x.verbosity, Q = typeof x.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(x.docBaseUrl) ? x.docBaseUrl : null, Et = typeof x.cMapUrl == "string" ? x.cMapUrl : null, Ct = x.cMapPacked !== !1, H = x.CMapReaderFactory || DefaultCMapReaderFactory, m = typeof x.standardFontDataUrl == "string" ? x.standardFontDataUrl : null, k = x.StandardFontDataFactory || DefaultStandardFontDataFactory, d = x.stopAtErrors !== !0, R = Number.isInteger(x.maxImageSize) && x.maxImageSize > -1 ? x.maxImageSize : -1, M = x.isEvalSupported !== !1, B = typeof x.isOffscreenCanvasSupported == "boolean" ? x.isOffscreenCanvasSupported : !_util.isNodeJS, _ = Number.isInteger(x.canvasMaxAreaInBytes) ? x.canvasMaxAreaInBytes : -1, Z = typeof x.disableFontFace == "boolean" ? x.disableFontFace : _util.isNodeJS, pt = x.fontExtraProperties === !0, dt = x.enableXfa === !0, Tt = x.ownerDocument || globalThis.document, lt = x.disableRange === !0, yt = x.disableStream === !0, bt = x.disableAutoFetch === !0, It = x.pdfBug === !0, Ot = q ? q.length : x.length ?? NaN, Mt = typeof x.useSystemFonts == "boolean" ? x.useSystemFonts : !_util.isNodeJS && !Z, gt = typeof x.useWorkerFetch == "boolean" ? x.useWorkerFetch : H === _display_utils.DOMCMapReaderFactory && k === _display_utils.DOMStandardFontDataFactory && Et && m && (0, _display_utils.isValidFetchUrl)(Et, document.baseURI) && (0, _display_utils.isValidFetchUrl)(m, document.baseURI), ut = x.canvasFactory || new DefaultCanvasFactory({
              ownerDocument: Tt
            }), ct = x.filterFactory || new DefaultFilterFactory({
              docId: F,
              ownerDocument: Tt
            }), ot = null;
            (0, _util.setVerbosityLevel)(it);
            const vt = {
              canvasFactory: ut,
              filterFactory: ct
            };
            if (gt || (vt.cMapReaderFactory = new H({
              baseUrl: Et,
              isCompressed: Ct
            }), vt.standardFontDataFactory = new k({
              baseUrl: m
            })), !z) {
              const Ut = {
                verbosity: it,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              z = Ut.port ? PDFWorker.fromPort(Ut) : new PDFWorker(Ut), b._worker = z;
            }
            const wt = {
              docId: F,
              apiVersion: "3.11.174",
              data: G,
              password: X,
              disableAutoFetch: bt,
              rangeChunkSize: j,
              length: Ot,
              docBaseUrl: Q,
              enableXfa: dt,
              evaluatorOptions: {
                maxImageSize: R,
                disableFontFace: Z,
                ignoreErrors: d,
                isEvalSupported: M,
                isOffscreenCanvasSupported: B,
                canvasMaxAreaInBytes: _,
                fontExtraProperties: pt,
                useSystemFonts: Mt,
                cMapUrl: gt ? Et : null,
                standardFontDataUrl: gt ? m : null
              }
            }, Lt = {
              ignoreErrors: d,
              isEvalSupported: M,
              disableFontFace: Z,
              fontExtraProperties: pt,
              enableXfa: dt,
              ownerDocument: Tt,
              disableAutoFetch: bt,
              pdfBug: It,
              styleElement: ot
            };
            return z.promise.then(function() {
              if (b.destroyed)
                throw new Error("Loading aborted");
              const Ut = _fetchDocument(z, wt), Ht = new Promise(function($t) {
                let Wt;
                q ? Wt = new _transport_stream.PDFDataTransportStream({
                  length: Ot,
                  initialData: q.initialData,
                  progressiveDone: q.progressiveDone,
                  contentDispositionFilename: q.contentDispositionFilename,
                  disableRange: lt,
                  disableStream: yt
                }, q) : G || (Wt = ((Xt) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Xt) : (0, _display_utils.isValidFetchUrl)(Xt.url) ? new _displayFetch_stream.PDFFetchStream(Xt) : new _displayNetwork.PDFNetworkStream(Xt))({
                  url: L,
                  length: Ot,
                  httpHeaders: nt,
                  withCredentials: D,
                  rangeChunkSize: j,
                  disableRange: lt,
                  disableStream: yt
                })), $t(Wt);
              });
              return Promise.all([Ut, Ht]).then(function($t) {
                let [Wt, Jt] = $t;
                if (b.destroyed)
                  throw new Error("Loading aborted");
                const Xt = new _message_handler.MessageHandler(F, Wt, z.port), Zt = new WorkerTransport(Xt, b, Jt, Lt, vt);
                b._transport = Zt, Xt.send("Ready", null);
              });
            }).catch(b._capability.reject), b;
          }
          async function _fetchDocument(x, b) {
            if (x.destroyed)
              throw new Error("Worker was destroyed");
            const F = await x.messageHandler.sendWithPromise("GetDocRequest", b, b.data ? [b.data.buffer] : null);
            if (x.destroyed)
              throw new Error("Worker was destroyed");
            return F;
          }
          function getUrlProp(x) {
            if (x instanceof URL)
              return x.href;
            try {
              return new URL(x, window.location).href;
            } catch {
              if (_util.isNodeJS && typeof x == "string")
                return x;
            }
            throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
          }
          function getDataProp(x) {
            if (_util.isNodeJS && typeof Buffer < "u" && x instanceof Buffer)
              throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
            if (x instanceof Uint8Array && x.byteLength === x.buffer.byteLength)
              return x;
            if (typeof x == "string")
              return (0, _util.stringToBytes)(x);
            if (typeof x == "object" && !isNaN(x == null ? void 0 : x.length) || (0, _util.isArrayBuffer)(x))
              return new Uint8Array(x);
            throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
          }
          const S = class S {
            constructor() {
              this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${ue(S, O)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var b, F, L;
              this.destroyed = !0;
              try {
                (b = this._worker) != null && b.port && (this._worker._pendingDestroy = !0), await ((F = this._transport) == null ? void 0 : F.destroy());
              } catch (G) {
                throw (L = this._worker) != null && L.port && delete this._worker._pendingDestroy, G;
              }
              this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          O = new WeakMap(), W(S, O, 0);
          let PDFDocumentLoadingTask = S;
          exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(b, F) {
              let L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, G = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
              this.length = b, this.initialData = F, this.progressiveDone = L, this.contentDispositionFilename = G, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
            }
            addRangeListener(b) {
              this._rangeListeners.push(b);
            }
            addProgressListener(b) {
              this._progressListeners.push(b);
            }
            addProgressiveReadListener(b) {
              this._progressiveReadListeners.push(b);
            }
            addProgressiveDoneListener(b) {
              this._progressiveDoneListeners.push(b);
            }
            onDataRange(b, F) {
              for (const L of this._rangeListeners)
                L(b, F);
            }
            onDataProgress(b, F) {
              this._readyCapability.promise.then(() => {
                for (const L of this._progressListeners)
                  L(b, F);
              });
            }
            onDataProgressiveRead(b) {
              this._readyCapability.promise.then(() => {
                for (const F of this._progressiveReadListeners)
                  F(b);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const b of this._progressiveDoneListeners)
                  b();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(b, F) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(b, F) {
              this._pdfInfo = b, this._transport = F, Object.defineProperty(this, "getJavaScript", {
                value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((L) => {
                  if (!L)
                    return L;
                  const G = [];
                  for (const nt in L)
                    G.push(...L[nt]);
                  return G;
                }))
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(b) {
              return this._transport.getPage(b);
            }
            getPageIndex(b) {
              return this._transport.getPageIndex(b);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(b) {
              return this._transport.getDestination(b);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            saveDocument() {
              return this._transport.saveDocument();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup() {
              let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return this._transport.startCleanup(b || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(b, F, L) {
              W(this, h);
              W(this, P);
              W(this, t, null);
              W(this, n, !1);
              let G = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
              this._pageIndex = b, this._pageInfo = F, this._transport = L, this._stats = G ? new _display_utils.StatTimer() : null, this._pdfBug = G, this.commonObjs = L.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport() {
              let {
                scale: b,
                rotation: F = this.rotate,
                offsetX: L = 0,
                offsetY: G = 0,
                dontFlip: nt = !1
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: b,
                rotation: F,
                offsetX: L,
                offsetY: G,
                dontFlip: nt
              });
            }
            getAnnotations() {
              let {
                intent: b = "display"
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              const F = this._transport.getRenderingIntent(b);
              return this._transport.getAnnotations(this._pageIndex, F.renderingIntent);
            }
            getJSActions() {
              return this._transport.getPageJSActions(this._pageIndex);
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            async getXfa() {
              var b;
              return ((b = this._transport._htmlForXfa) == null ? void 0 : b.children[this._pageIndex]) || null;
            }
            render(b) {
              var d, R;
              let {
                canvasContext: F,
                viewport: L,
                intent: G = "display",
                annotationMode: nt = _util.AnnotationMode.ENABLE,
                transform: D = null,
                background: X = null,
                optionalContentConfigPromise: q = null,
                annotationCanvasMap: j = null,
                pageColors: z = null,
                printAnnotationStorage: it = null
              } = b;
              (d = this._stats) == null || d.time("Overall");
              const Q = this._transport.getRenderingIntent(G, nt, it);
              rt(this, n, !1), J(this, P, ke).call(this), q || (q = this._transport.getOptionalContentConfig());
              let Et = this._intentStates.get(Q.cacheKey);
              Et || (Et = /* @__PURE__ */ Object.create(null), this._intentStates.set(Q.cacheKey, Et)), Et.streamReaderCancelTimeout && (clearTimeout(Et.streamReaderCancelTimeout), Et.streamReaderCancelTimeout = null);
              const Ct = !!(Q.renderingIntent & _util.RenderingIntentFlag.PRINT);
              Et.displayReadyCapability || (Et.displayReadyCapability = new _util.PromiseCapability(), Et.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (R = this._stats) == null || R.time("Page Request"), this._pumpOperatorList(Q));
              const H = (M) => {
                var B, _;
                Et.renderTasks.delete(m), (this._maybeCleanupAfterRender || Ct) && rt(this, n, !0), J(this, h, de).call(this, !Ct), M ? (m.capability.reject(M), this._abortOperatorList({
                  intentState: Et,
                  reason: M instanceof Error ? M : new Error(M)
                })) : m.capability.resolve(), (B = this._stats) == null || B.timeEnd("Rendering"), (_ = this._stats) == null || _.timeEnd("Overall");
              }, m = new InternalRenderTask({
                callback: H,
                params: {
                  canvasContext: F,
                  viewport: L,
                  transform: D,
                  background: X
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: j,
                operatorList: Et.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: this._transport.canvasFactory,
                filterFactory: this._transport.filterFactory,
                useRequestAnimationFrame: !Ct,
                pdfBug: this._pdfBug,
                pageColors: z
              });
              (Et.renderTasks || (Et.renderTasks = /* @__PURE__ */ new Set())).add(m);
              const k = m.task;
              return Promise.all([Et.displayReadyCapability.promise, q]).then((M) => {
                var Z;
                let [B, _] = M;
                if (this.destroyed) {
                  H();
                  return;
                }
                (Z = this._stats) == null || Z.time("Rendering"), m.initializeGraphics({
                  transparency: B,
                  optionalContentConfig: _
                }), m.operatorListChanged();
              }).catch(H), k;
            }
            getOperatorList() {
              var q;
              let {
                intent: b = "display",
                annotationMode: F = _util.AnnotationMode.ENABLE,
                printAnnotationStorage: L = null
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              function G() {
                D.operatorList.lastChunk && (D.opListReadCapability.resolve(D.operatorList), D.renderTasks.delete(X));
              }
              const nt = this._transport.getRenderingIntent(b, F, L, !0);
              let D = this._intentStates.get(nt.cacheKey);
              D || (D = /* @__PURE__ */ Object.create(null), this._intentStates.set(nt.cacheKey, D));
              let X;
              return D.opListReadCapability || (X = /* @__PURE__ */ Object.create(null), X.operatorListChanged = G, D.opListReadCapability = new _util.PromiseCapability(), (D.renderTasks || (D.renderTasks = /* @__PURE__ */ new Set())).add(X), D.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (q = this._stats) == null || q.time("Page Request"), this._pumpOperatorList(nt)), D.opListReadCapability.promise;
            }
            streamTextContent() {
              let {
                includeMarkedContent: b = !1,
                disableNormalization: F = !1
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              const L = 100;
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                includeMarkedContent: b === !0,
                disableNormalization: F === !0
              }, {
                highWaterMark: L,
                size(G) {
                  return G.items.length;
                }
              });
            }
            getTextContent() {
              let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (this._transport._htmlForXfa)
                return this.getXfa().then((L) => _xfa_text.XfaText.textContent(L));
              const F = this.streamTextContent(b);
              return new Promise(function(L, G) {
                function nt() {
                  D.read().then(function(q) {
                    let {
                      value: j,
                      done: z
                    } = q;
                    if (z) {
                      L(X);
                      return;
                    }
                    Object.assign(X.styles, j.styles), X.items.push(...j.items), nt();
                  }, G);
                }
                const D = F.getReader(), X = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                nt();
              });
            }
            getStructTree() {
              return this._transport.getStructTree(this._pageIndex);
            }
            _destroy() {
              this.destroyed = !0;
              const b = [];
              for (const F of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: F,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !F.opListReadCapability)
                  for (const L of F.renderTasks)
                    b.push(L.completed), L.cancel();
              return this.objs.clear(), rt(this, n, !1), J(this, P, ke).call(this), Promise.all(b);
            }
            cleanup() {
              let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              rt(this, n, !0);
              const F = J(this, h, de).call(this, !1);
              return b && F && this._stats && (this._stats = new _display_utils.StatTimer()), F;
            }
            _startRenderPage(b, F) {
              var G, nt;
              const L = this._intentStates.get(F);
              L && ((G = this._stats) == null || G.timeEnd("Page Request"), (nt = L.displayReadyCapability) == null || nt.resolve(b));
            }
            _renderPageChunk(b, F) {
              for (let L = 0, G = b.length; L < G; L++)
                F.operatorList.fnArray.push(b.fnArray[L]), F.operatorList.argsArray.push(b.argsArray[L]);
              F.operatorList.lastChunk = b.lastChunk, F.operatorList.separateAnnots = b.separateAnnots;
              for (const L of F.renderTasks)
                L.operatorListChanged();
              b.lastChunk && J(this, h, de).call(this, !0);
            }
            _pumpOperatorList(b) {
              let {
                renderingIntent: F,
                cacheKey: L,
                annotationStorageSerializable: G
              } = b;
              const {
                map: nt,
                transfers: D
              } = G, q = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: F,
                cacheKey: L,
                annotationStorage: nt
              }, D).getReader(), j = this._intentStates.get(L);
              j.streamReader = q;
              const z = () => {
                q.read().then((it) => {
                  let {
                    value: Q,
                    done: Et
                  } = it;
                  if (Et) {
                    j.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(Q, j), z());
                }, (it) => {
                  if (j.streamReader = null, !this._transport.destroyed) {
                    if (j.operatorList) {
                      j.operatorList.lastChunk = !0;
                      for (const Q of j.renderTasks)
                        Q.operatorListChanged();
                      J(this, h, de).call(this, !0);
                    }
                    if (j.displayReadyCapability)
                      j.displayReadyCapability.reject(it);
                    else if (j.opListReadCapability)
                      j.opListReadCapability.reject(it);
                    else
                      throw it;
                  }
                });
              };
              z();
            }
            _abortOperatorList(b) {
              let {
                intentState: F,
                reason: L,
                force: G = !1
              } = b;
              if (F.streamReader) {
                if (F.streamReaderCancelTimeout && (clearTimeout(F.streamReaderCancelTimeout), F.streamReaderCancelTimeout = null), !G) {
                  if (F.renderTasks.size > 0)
                    return;
                  if (L instanceof _display_utils.RenderingCancelledException) {
                    let nt = RENDERING_CANCELLED_TIMEOUT;
                    L.extraDelay > 0 && L.extraDelay < 1e3 && (nt += L.extraDelay), F.streamReaderCancelTimeout = setTimeout(() => {
                      F.streamReaderCancelTimeout = null, this._abortOperatorList({
                        intentState: F,
                        reason: L,
                        force: !0
                      });
                    }, nt);
                    return;
                  }
                }
                if (F.streamReader.cancel(new _util.AbortException(L.message)).catch(() => {
                }), F.streamReader = null, !this._transport.destroyed) {
                  for (const [nt, D] of this._intentStates)
                    if (D === F) {
                      this._intentStates.delete(nt);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          t = new WeakMap(), n = new WeakMap(), h = new WeakSet(), de = function() {
            let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            if (J(this, P, ke).call(this), !e(this, n) || this.destroyed)
              return !1;
            if (b)
              return rt(this, t, setTimeout(() => {
                rt(this, t, null), J(this, h, de).call(this, !1);
              }, DELAYED_CLEANUP_TIMEOUT)), !1;
            for (const {
              renderTasks: F,
              operatorList: L
            } of this._intentStates.values())
              if (F.size > 0 || !L.lastChunk)
                return !1;
            return this._intentStates.clear(), this.objs.clear(), rt(this, n, !1), !0;
          }, P = new WeakSet(), ke = function() {
            e(this, t) && (clearTimeout(e(this, t)), rt(this, t, null));
          }, exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              W(this, y, /* @__PURE__ */ new Set());
              W(this, c, Promise.resolve());
            }
            postMessage(b, F) {
              const L = {
                data: structuredClone(b, null)
              };
              e(this, c).then(() => {
                for (const G of e(this, y))
                  G.call(this, L);
              });
            }
            addEventListener(b, F) {
              e(this, y).add(F);
            }
            removeEventListener(b, F) {
              e(this, y).delete(F);
            }
            terminate() {
              e(this, y).clear();
            }
          }
          y = new WeakMap(), c = new WeakMap(), exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_util.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const x = (a = document == null ? void 0 : document.currentScript) == null ? void 0 : a.src;
              x && (PDFWorkerUtil.fallbackWorkerSrc = x.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(x, b) {
              let F;
              try {
                if (F = new URL(x), !F.origin || F.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const L = new URL(b, F);
              return F.origin === L.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(x) {
              const b = `importScripts("${x}");`;
              return URL.createObjectURL(new Blob([b]));
            };
          }
          const _PDFWorker = class _PDFWorker {
            constructor() {
              var L;
              let {
                name: x = null,
                port: b = null,
                verbosity: F = (0, _util.getVerbosityLevel)()
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (this.name = x, this.destroyed = !1, this.verbosity = F, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, b) {
                if ((L = e(_PDFWorker, I)) != null && L.has(b))
                  throw new Error("Cannot use more than one PDFWorker per port.");
                (e(_PDFWorker, I) || rt(_PDFWorker, I, /* @__PURE__ */ new WeakMap())).set(b, this), this._initializeFromPort(b);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(x) {
              this._port = x, this._messageHandler = new _message_handler.MessageHandler("main", "worker", x), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: x
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, x) || (x = PDFWorkerUtil.createCDNWrapper(new URL(x, window.location).href));
                  const b = new Worker(x), F = new _message_handler.MessageHandler("main", "worker", b), L = () => {
                    b.removeEventListener("error", G), F.destroy(), b.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, G = () => {
                    this._webWorker || L();
                  };
                  b.addEventListener("error", G), F.on("test", (D) => {
                    if (b.removeEventListener("error", G), this.destroyed) {
                      L();
                      return;
                    }
                    D ? (this._messageHandler = F, this._port = b, this._webWorker = b, this._readyCapability.resolve(), F.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), F.destroy(), b.terminate());
                  }), F.on("ready", (D) => {
                    if (b.removeEventListener("error", G), this.destroyed) {
                      L();
                      return;
                    }
                    try {
                      nt();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const nt = () => {
                    const D = new Uint8Array();
                    F.send("test", D, [D.buffer]);
                  };
                  nt();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((x) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const b = new LoopbackPort();
                this._port = b;
                const F = `fake${PDFWorkerUtil.fakeWorkerId++}`, L = new _message_handler.MessageHandler(F + "_worker", F, b);
                x.setup(L, b);
                const G = new _message_handler.MessageHandler(F, F + "_worker", b);
                this._messageHandler = G, this._readyCapability.resolve(), G.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((x) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${x.message}".`));
              });
            }
            destroy() {
              var x;
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (x = e(_PDFWorker, I)) == null || x.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(x) {
              var F;
              if (!(x != null && x.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              const b = (F = e(this, I)) == null ? void 0 : F.get(x.port);
              if (b) {
                if (b._pendingDestroy)
                  throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                return b;
              }
              return new _PDFWorker(x);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var x;
              try {
                return ((x = globalThis.pdfjsWorker) == null ? void 0 : x.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_util.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          I = new WeakMap(), W(_PDFWorker, I, void 0);
          let PDFWorker = _PDFWorker;
          exports.PDFWorker = PDFWorker;
          class WorkerTransport {
            constructor(b, F, L, G, nt) {
              W(this, l);
              W(this, A, /* @__PURE__ */ new Map());
              W(this, g, /* @__PURE__ */ new Map());
              W(this, s, /* @__PURE__ */ new Map());
              W(this, o, null);
              this.messageHandler = b, this.loadingTask = F, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                ownerDocument: G.ownerDocument,
                styleElement: G.styleElement
              }), this._params = G, this.canvasFactory = nt.canvasFactory, this.filterFactory = nt.filterFactory, this.cMapReaderFactory = nt.cMapReaderFactory, this.standardFontDataFactory = nt.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = L, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            getRenderingIntent(b) {
              let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _util.AnnotationMode.ENABLE, L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, G = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, nt = _util.RenderingIntentFlag.DISPLAY, D = _annotation_storage.SerializableEmpty;
              switch (b) {
                case "any":
                  nt = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  nt = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${b}`);
              }
              switch (F) {
                case _util.AnnotationMode.DISABLE:
                  nt += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  nt += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  nt += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, D = (nt & _util.RenderingIntentFlag.PRINT && L instanceof _annotation_storage.PrintAnnotationStorage ? L : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${F}`);
              }
              return G && (nt += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: nt,
                cacheKey: `${nt}_${D.hash}`,
                annotationStorageSerializable: D
              };
            }
            destroy() {
              var L;
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (L = e(this, o)) == null || L.reject(new Error("Worker was destroyed during onPassword callback"));
              const b = [];
              for (const G of e(this, g).values())
                b.push(G._destroy());
              e(this, g).clear(), e(this, s).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const F = this.messageHandler.sendWithPromise("Terminate", null);
              return b.push(F), Promise.all(b).then(() => {
                var G;
                this.commonObjs.clear(), this.fontLoader.clear(), e(this, A).clear(), this.filterFactory.destroy(), (G = this._networkStream) == null || G.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: b,
                loadingTask: F
              } = this;
              b.on("GetReader", (L, G) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (nt) => {
                  this._lastProgress = {
                    loaded: nt.loaded,
                    total: nt.total
                  };
                }, G.onPull = () => {
                  this._fullReader.read().then(function(nt) {
                    let {
                      value: D,
                      done: X
                    } = nt;
                    if (X) {
                      G.close();
                      return;
                    }
                    (0, _util.assert)(D instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), G.enqueue(new Uint8Array(D), 1, [D]);
                  }).catch((nt) => {
                    G.error(nt);
                  });
                }, G.onCancel = (nt) => {
                  this._fullReader.cancel(nt), G.ready.catch((D) => {
                    if (!this.destroyed)
                      throw D;
                  });
                };
              }), b.on("ReaderHeadersReady", (L) => {
                const G = new _util.PromiseCapability(), nt = this._fullReader;
                return nt.headersReady.then(() => {
                  var D;
                  (!nt.isStreamingSupported || !nt.isRangeSupported) && (this._lastProgress && ((D = F.onProgress) == null || D.call(F, this._lastProgress)), nt.onProgress = (X) => {
                    var q;
                    (q = F.onProgress) == null || q.call(F, {
                      loaded: X.loaded,
                      total: X.total
                    });
                  }), G.resolve({
                    isStreamingSupported: nt.isStreamingSupported,
                    isRangeSupported: nt.isRangeSupported,
                    contentLength: nt.contentLength
                  });
                }, G.reject), G.promise;
              }), b.on("GetRangeReader", (L, G) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const nt = this._networkStream.getRangeReader(L.begin, L.end);
                if (!nt) {
                  G.close();
                  return;
                }
                G.onPull = () => {
                  nt.read().then(function(D) {
                    let {
                      value: X,
                      done: q
                    } = D;
                    if (q) {
                      G.close();
                      return;
                    }
                    (0, _util.assert)(X instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), G.enqueue(new Uint8Array(X), 1, [X]);
                  }).catch((D) => {
                    G.error(D);
                  });
                }, G.onCancel = (D) => {
                  nt.cancel(D), G.ready.catch((X) => {
                    if (!this.destroyed)
                      throw X;
                  });
                };
              }), b.on("GetDoc", (L) => {
                let {
                  pdfInfo: G
                } = L;
                this._numPages = G.numPages, this._htmlForXfa = G.htmlForXfa, delete G.htmlForXfa, F._capability.resolve(new PDFDocumentProxy(G, this));
              }), b.on("DocException", function(L) {
                let G;
                switch (L.name) {
                  case "PasswordException":
                    G = new _util.PasswordException(L.message, L.code);
                    break;
                  case "InvalidPDFException":
                    G = new _util.InvalidPDFException(L.message);
                    break;
                  case "MissingPDFException":
                    G = new _util.MissingPDFException(L.message);
                    break;
                  case "UnexpectedResponseException":
                    G = new _util.UnexpectedResponseException(L.message, L.status);
                    break;
                  case "UnknownErrorException":
                    G = new _util.UnknownErrorException(L.message, L.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                F._capability.reject(G);
              }), b.on("PasswordRequest", (L) => {
                if (rt(this, o, new _util.PromiseCapability()), F.onPassword) {
                  const G = (nt) => {
                    nt instanceof Error ? e(this, o).reject(nt) : e(this, o).resolve({
                      password: nt
                    });
                  };
                  try {
                    F.onPassword(G, L.code);
                  } catch (nt) {
                    e(this, o).reject(nt);
                  }
                } else
                  e(this, o).reject(new _util.PasswordException(L.message, L.code));
                return e(this, o).promise;
              }), b.on("DataLoaded", (L) => {
                var G;
                (G = F.onProgress) == null || G.call(F, {
                  loaded: L.length,
                  total: L.length
                }), this.downloadInfoCapability.resolve(L);
              }), b.on("StartRenderPage", (L) => {
                if (this.destroyed)
                  return;
                e(this, g).get(L.pageIndex)._startRenderPage(L.transparency, L.cacheKey);
              }), b.on("commonobj", (L) => {
                var X;
                let [G, nt, D] = L;
                if (!this.destroyed && !this.commonObjs.has(G))
                  switch (nt) {
                    case "Font":
                      const q = this._params;
                      if ("error" in D) {
                        const it = D.error;
                        (0, _util.warn)(`Error during font loading: ${it}`), this.commonObjs.resolve(G, it);
                        break;
                      }
                      const j = q.pdfBug && ((X = globalThis.FontInspector) != null && X.enabled) ? (it, Q) => globalThis.FontInspector.fontAdded(it, Q) : null, z = new _font_loader.FontFaceObject(D, {
                        isEvalSupported: q.isEvalSupported,
                        disableFontFace: q.disableFontFace,
                        ignoreErrors: q.ignoreErrors,
                        inspectFont: j
                      });
                      this.fontLoader.bind(z).catch((it) => b.sendWithPromise("FontFallback", {
                        id: G
                      })).finally(() => {
                        !q.fontExtraProperties && z.data && (z.data = null), this.commonObjs.resolve(G, z);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                    case "Pattern":
                      this.commonObjs.resolve(G, D);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${nt}`);
                  }
              }), b.on("obj", (L) => {
                var j;
                let [G, nt, D, X] = L;
                if (this.destroyed)
                  return;
                const q = e(this, g).get(nt);
                if (!q.objs.has(G))
                  switch (D) {
                    case "Image":
                      if (q.objs.resolve(G, X), X) {
                        let z;
                        if (X.bitmap) {
                          const {
                            width: it,
                            height: Q
                          } = X;
                          z = it * Q * 4;
                        } else
                          z = ((j = X.data) == null ? void 0 : j.length) || 0;
                        z > _util.MAX_IMAGE_SIZE_TO_CACHE && (q._maybeCleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      q.objs.resolve(G, X);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${D}`);
                  }
              }), b.on("DocProgress", (L) => {
                var G;
                this.destroyed || (G = F.onProgress) == null || G.call(F, {
                  loaded: L.loaded,
                  total: L.total
                });
              }), b.on("FetchBuiltInCMap", (L) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(L) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), b.on("FetchStandardFontData", (L) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(L) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            saveDocument() {
              var L;
              this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
              const {
                map: b,
                transfers: F
              } = this.annotationStorage.serializable;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: b,
                filename: ((L = this._fullReader) == null ? void 0 : L.filename) ?? null
              }, F).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getPage(b) {
              if (!Number.isInteger(b) || b <= 0 || b > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const F = b - 1, L = e(this, s).get(F);
              if (L)
                return L;
              const G = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: F
              }).then((nt) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const D = new PDFPageProxy(F, nt, this, this._params.pdfBug);
                return e(this, g).set(F, D), D;
              });
              return e(this, s).set(F, G), G;
            }
            getPageIndex(b) {
              return typeof b != "object" || b === null || !Number.isInteger(b.num) || b.num < 0 || !Number.isInteger(b.gen) || b.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: b.num,
                gen: b.gen
              });
            }
            getAnnotations(b, F) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: b,
                intent: F
              });
            }
            getFieldObjects() {
              return J(this, l, Me).call(this, "GetFieldObjects");
            }
            hasJSActions() {
              return J(this, l, Me).call(this, "HasJSActions");
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(b) {
              return typeof b != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: b
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getDocJSActions() {
              return J(this, l, Me).call(this, "GetDocJSActions");
            }
            getPageJSActions(b) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: b
              });
            }
            getStructTree(b) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: b
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((b) => new _optional_content_config.OptionalContentConfig(b));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              const b = "GetMetadata", F = e(this, A).get(b);
              if (F)
                return F;
              const L = this.messageHandler.sendWithPromise(b, null).then((G) => {
                var nt, D;
                return {
                  info: G[0],
                  metadata: G[1] ? new _metadata.Metadata(G[1]) : null,
                  contentDispositionFilename: ((nt = this._fullReader) == null ? void 0 : nt.filename) ?? null,
                  contentLength: ((D = this._fullReader) == null ? void 0 : D.contentLength) ?? null
                };
              });
              return e(this, A).set(b, L), L;
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup() {
              let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (!this.destroyed) {
                await this.messageHandler.sendWithPromise("Cleanup", null);
                for (const F of e(this, g).values())
                  if (!F.cleanup())
                    throw new Error(`startCleanup: Page ${F.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), b || this.fontLoader.clear(), e(this, A).clear(), this.filterFactory.destroy(!0);
              }
            }
            get loadingParams() {
              const {
                disableAutoFetch: b,
                enableXfa: F
              } = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: b,
                enableXfa: F
              });
            }
          }
          A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakSet(), Me = function(b) {
            let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            const L = e(this, A).get(b);
            if (L)
              return L;
            const G = this.messageHandler.sendWithPromise(b, F);
            return e(this, A).set(b, G), G;
          };
          class PDFObjects {
            constructor() {
              W(this, p);
              W(this, v, /* @__PURE__ */ Object.create(null));
            }
            get(b) {
              let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              if (F) {
                const G = J(this, p, Je).call(this, b);
                return G.capability.promise.then(() => F(G.data)), null;
              }
              const L = e(this, v)[b];
              if (!(L != null && L.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${b}.`);
              return L.data;
            }
            has(b) {
              const F = e(this, v)[b];
              return (F == null ? void 0 : F.capability.settled) || !1;
            }
            resolve(b) {
              let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              const L = J(this, p, Je).call(this, b);
              L.data = F, L.capability.resolve();
            }
            clear() {
              var b;
              for (const F in e(this, v)) {
                const {
                  data: L
                } = e(this, v)[F];
                (b = L == null ? void 0 : L.bitmap) == null || b.close();
              }
              rt(this, v, /* @__PURE__ */ Object.create(null));
            }
          }
          v = new WeakMap(), p = new WeakSet(), Je = function(b) {
            var F;
            return (F = e(this, v))[b] || (F[b] = {
              capability: new _util.PromiseCapability(),
              data: null
            });
          };
          class RenderTask {
            constructor(b) {
              W(this, r, null);
              rt(this, r, b), this.onContinue = null;
            }
            get promise() {
              return e(this, r).capability.promise;
            }
            cancel() {
              let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              e(this, r).cancel(null, b);
            }
            get separateAnnots() {
              const {
                separateAnnots: b
              } = e(this, r).operatorList;
              if (!b)
                return !1;
              const {
                annotationCanvasMap: F
              } = e(this, r);
              return b.form || b.canvas && (F == null ? void 0 : F.size) > 0;
            }
          }
          r = new WeakMap(), exports.RenderTask = RenderTask;
          const w = class w {
            constructor(b) {
              let {
                callback: F,
                params: L,
                objs: G,
                commonObjs: nt,
                annotationCanvasMap: D,
                operatorList: X,
                pageIndex: q,
                canvasFactory: j,
                filterFactory: z,
                useRequestAnimationFrame: it = !1,
                pdfBug: Q = !1,
                pageColors: Et = null
              } = b;
              this.callback = F, this.params = L, this.objs = G, this.commonObjs = nt, this.annotationCanvasMap = D, this.operatorListIdx = null, this.operatorList = X, this._pageIndex = q, this.canvasFactory = j, this.filterFactory = z, this._pdfBug = Q, this.pageColors = Et, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = it === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = L.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics(b) {
              var q, j;
              let {
                transparency: F = !1,
                optionalContentConfig: L
              } = b;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (e(w, i).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                e(w, i).add(this._canvas);
              }
              this._pdfBug && ((q = globalThis.StepperManager) != null && q.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: G,
                viewport: nt,
                transform: D,
                background: X
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(G, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                optionalContentConfig: L
              }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: D,
                viewport: nt,
                transparency: F,
                background: X
              }), this.operatorListIdx = 0, this.graphicsReady = !0, (j = this.graphicsReadyCallback) == null || j.call(this);
            }
            cancel() {
              var L;
              let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              this.running = !1, this.cancelled = !0, (L = this.gfx) == null || L.endDrawing(), e(w, i).delete(this._canvas), this.callback(b || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, F));
            }
            operatorListChanged() {
              var b;
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              (b = this.stepper) == null || b.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), e(w, i).delete(this._canvas), this.callback())));
            }
          };
          i = new WeakMap(), W(w, i, /* @__PURE__ */ new WeakSet());
          let InternalRenderTask = w;
          const version = "3.11.174";
          exports.version = version;
          const build = "ce8716743";
          exports.build = build;
        },
        /* 125 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(126), T = t(135);
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !T("difference")
          }, { difference: h });
        },
        /* 126 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(128), T = t(129), P = t(132), f = t(133), y = t(130), c = t(131), a = h.has, I = h.remove;
          O.exports = function(g) {
            var s = n(this), o = f(g), l = T(s);
            return P(s) <= o.size ? y(s, function(u) {
              o.includes(u) && I(l, u);
            }) : c(o.getIterator(), function(u) {
              a(s, u) && I(l, u);
            }), l;
          };
        },
        /* 127 */
        /***/
        (O, S, t) => {
          var n = t(128).has;
          O.exports = function(h) {
            return n(h), h;
          };
        },
        /* 128 */
        /***/
        (O, S, t) => {
          var n = t(14), h = Set.prototype;
          O.exports = {
            Set,
            add: n(h.add),
            has: n(h.has),
            remove: n(h.delete),
            proto: h
          };
        },
        /* 129 */
        /***/
        (O, S, t) => {
          var n = t(128), h = t(130), T = n.Set, P = n.add;
          O.exports = function(f) {
            var y = new T();
            return h(f, function(c) {
              P(y, c);
            }), y;
          };
        },
        /* 130 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(131), T = t(128), P = T.Set, f = T.proto, y = n(f.forEach), c = n(f.keys), a = c(new P()).next;
          O.exports = function(I, A, g) {
            return g ? h({
              iterator: c(I),
              next: a
            }, A) : y(I, A);
          };
        },
        /* 131 */
        /***/
        (O, S, t) => {
          var n = t(8);
          O.exports = function(h, T, P) {
            for (var f = P ? h : h.iterator, y = h.next, c, a; !(c = n(y, f)).done; )
              if (a = T(c.value), a !== void 0)
                return a;
          };
        },
        /* 132 */
        /***/
        (O, S, t) => {
          var n = t(72), h = t(128);
          O.exports = n(h.proto, "size", "get") || function(T) {
            return T.size;
          };
        },
        /* 133 */
        /***/
        (O, S, t) => {
          var n = t(31), h = t(47), T = t(8), P = t(62), f = t(134), y = "Invalid size", c = RangeError, a = TypeError, I = Math.max, A = function(g, s, o, l) {
            this.set = g, this.size = s, this.has = o, this.keys = l;
          };
          A.prototype = {
            getIterator: function() {
              return f(h(T(this.keys, this.set)));
            },
            includes: function(g) {
              return T(this.has, this.set, g);
            }
          }, O.exports = function(g) {
            h(g);
            var s = +g.size;
            if (s !== s)
              throw a(y);
            var o = P(s);
            if (o < 0)
              throw c(y);
            return new A(g, I(o, 0), n(g.has), n(g.keys));
          };
        },
        /* 134 */
        /***/
        (O) => {
          O.exports = function(S) {
            return {
              iterator: S,
              next: S.next,
              done: !1
            };
          };
        },
        /* 135 */
        /***/
        (O, S, t) => {
          var n = t(24), h = function(T) {
            return {
              size: T,
              has: function() {
                return !1;
              },
              keys: function() {
                return {
                  next: function() {
                    return { done: !0 };
                  }
                };
              }
            };
          };
          O.exports = function(T) {
            var P = n("Set");
            try {
              new P()[T](h(0));
              try {
                return new P()[T](h(-1)), !1;
              } catch {
                return !0;
              }
            } catch {
              return !1;
            }
          };
        },
        /* 136 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(7), T = t(137), P = t(135), f = !P("intersection") || h(function() {
            return Array.from((/* @__PURE__ */ new Set([
              1,
              2,
              3
            ])).intersection(/* @__PURE__ */ new Set([
              3,
              2
            ]))) !== "3,2";
          });
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: f
          }, { intersection: T });
        },
        /* 137 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(128), T = t(132), P = t(133), f = t(130), y = t(131), c = h.Set, a = h.add, I = h.has;
          O.exports = function(g) {
            var s = n(this), o = P(g), l = new c();
            return T(s) > o.size ? y(o.getIterator(), function(u) {
              I(s, u) && a(l, u);
            }) : f(s, function(u) {
              o.includes(u) && a(l, u);
            }), l;
          };
        },
        /* 138 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(139), T = t(135);
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !T("isDisjointFrom")
          }, { isDisjointFrom: h });
        },
        /* 139 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(128).has, T = t(132), P = t(133), f = t(130), y = t(131), c = t(140);
          O.exports = function(I) {
            var A = n(this), g = P(I);
            if (T(A) <= g.size)
              return f(A, function(o) {
                if (g.includes(o))
                  return !1;
              }, !0) !== !1;
            var s = g.getIterator();
            return y(s, function(o) {
              if (h(A, o))
                return c(s, "normal", !1);
            }) !== !1;
          };
        },
        /* 140 */
        /***/
        (O, S, t) => {
          var n = t(8), h = t(47), T = t(30);
          O.exports = function(P, f, y) {
            var c, a;
            h(P);
            try {
              if (c = T(P, "return"), !c) {
                if (f === "throw")
                  throw y;
                return y;
              }
              c = n(c, P);
            } catch (I) {
              a = !0, c = I;
            }
            if (f === "throw")
              throw y;
            if (a)
              throw c;
            return h(c), y;
          };
        },
        /* 141 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(142), T = t(135);
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !T("isSubsetOf")
          }, { isSubsetOf: h });
        },
        /* 142 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(132), T = t(130), P = t(133);
          O.exports = function(y) {
            var c = n(this), a = P(y);
            return h(c) > a.size ? !1 : T(c, function(I) {
              if (!a.includes(I))
                return !1;
            }, !0) !== !1;
          };
        },
        /* 143 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(144), T = t(135);
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !T("isSupersetOf")
          }, { isSupersetOf: h });
        },
        /* 144 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(128).has, T = t(132), P = t(133), f = t(131), y = t(140);
          O.exports = function(a) {
            var I = n(this), A = P(a);
            if (T(I) < A.size)
              return !1;
            var g = A.getIterator();
            return f(g, function(s) {
              if (!h(I, s))
                return y(g, "normal", !1);
            }) !== !1;
          };
        },
        /* 145 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(146), T = t(135);
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !T("symmetricDifference")
          }, { symmetricDifference: h });
        },
        /* 146 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(128), T = t(129), P = t(133), f = t(131), y = h.add, c = h.has, a = h.remove;
          O.exports = function(A) {
            var g = n(this), s = P(A).getIterator(), o = T(g);
            return f(s, function(l) {
              c(g, l) ? a(o, l) : y(o, l);
            }), o;
          };
        },
        /* 147 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(148), T = t(135);
          n({
            target: "Set",
            proto: !0,
            real: !0,
            forced: !T("union")
          }, { union: h });
        },
        /* 148 */
        /***/
        (O, S, t) => {
          var n = t(127), h = t(128).add, T = t(129), P = t(133), f = t(131);
          O.exports = function(c) {
            var a = n(this), I = P(c).getIterator(), A = T(a);
            return f(I, function(g) {
              h(A, g);
            }), A;
          };
        },
        /* 149 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(4), T = t(24), P = t(11), f = t(45).f, y = t(39), c = t(150), a = t(75), I = t(76), A = t(151), g = t(82), s = t(6), o = t(36), l = "DOMException", u = T("Error"), v = T(l), p = function() {
            c(this, C);
            var q = arguments.length, j = I(q < 1 ? void 0 : arguments[0]), z = I(q < 2 ? void 0 : arguments[1], "Error"), it = new v(j, z), Q = u(j);
            return Q.name = l, f(it, "stack", P(1, g(Q.stack, 1))), a(it, this, p), it;
          }, C = p.prototype = v.prototype, r = "stack" in u(l), i = "stack" in new v(1, 2), w = v && s && Object.getOwnPropertyDescriptor(h, l), x = !!w && !(w.writable && w.configurable), b = r && !x && !i;
          n({
            global: !0,
            constructor: !0,
            forced: o || b
          }, { DOMException: b ? p : v });
          var F = T(l), L = F.prototype;
          if (L.constructor !== F) {
            o || f(L, "constructor", P(1, F));
            for (var G in A)
              if (y(A, G)) {
                var nt = A[G], D = nt.s;
                y(F, D) || f(F, D, P(6, nt.c));
              }
          }
        },
        /* 150 */
        /***/
        (O, S, t) => {
          var n = t(25), h = TypeError;
          O.exports = function(T, P) {
            if (n(P, T))
              return T;
            throw h("Incorrect invocation");
          };
        },
        /* 151 */
        /***/
        (O) => {
          O.exports = {
            IndexSizeError: {
              s: "INDEX_SIZE_ERR",
              c: 1,
              m: 1
            },
            DOMStringSizeError: {
              s: "DOMSTRING_SIZE_ERR",
              c: 2,
              m: 0
            },
            HierarchyRequestError: {
              s: "HIERARCHY_REQUEST_ERR",
              c: 3,
              m: 1
            },
            WrongDocumentError: {
              s: "WRONG_DOCUMENT_ERR",
              c: 4,
              m: 1
            },
            InvalidCharacterError: {
              s: "INVALID_CHARACTER_ERR",
              c: 5,
              m: 1
            },
            NoDataAllowedError: {
              s: "NO_DATA_ALLOWED_ERR",
              c: 6,
              m: 0
            },
            NoModificationAllowedError: {
              s: "NO_MODIFICATION_ALLOWED_ERR",
              c: 7,
              m: 1
            },
            NotFoundError: {
              s: "NOT_FOUND_ERR",
              c: 8,
              m: 1
            },
            NotSupportedError: {
              s: "NOT_SUPPORTED_ERR",
              c: 9,
              m: 1
            },
            InUseAttributeError: {
              s: "INUSE_ATTRIBUTE_ERR",
              c: 10,
              m: 1
            },
            InvalidStateError: {
              s: "INVALID_STATE_ERR",
              c: 11,
              m: 1
            },
            SyntaxError: {
              s: "SYNTAX_ERR",
              c: 12,
              m: 1
            },
            InvalidModificationError: {
              s: "INVALID_MODIFICATION_ERR",
              c: 13,
              m: 1
            },
            NamespaceError: {
              s: "NAMESPACE_ERR",
              c: 14,
              m: 1
            },
            InvalidAccessError: {
              s: "INVALID_ACCESS_ERR",
              c: 15,
              m: 1
            },
            ValidationError: {
              s: "VALIDATION_ERR",
              c: 16,
              m: 0
            },
            TypeMismatchError: {
              s: "TYPE_MISMATCH_ERR",
              c: 17,
              m: 1
            },
            SecurityError: {
              s: "SECURITY_ERR",
              c: 18,
              m: 1
            },
            NetworkError: {
              s: "NETWORK_ERR",
              c: 19,
              m: 1
            },
            AbortError: {
              s: "ABORT_ERR",
              c: 20,
              m: 1
            },
            URLMismatchError: {
              s: "URL_MISMATCH_ERR",
              c: 21,
              m: 1
            },
            QuotaExceededError: {
              s: "QUOTA_EXCEEDED_ERR",
              c: 22,
              m: 1
            },
            TimeoutError: {
              s: "TIMEOUT_ERR",
              c: 23,
              m: 1
            },
            InvalidNodeTypeError: {
              s: "INVALID_NODE_TYPE_ERR",
              c: 24,
              m: 1
            },
            DataCloneError: {
              s: "DATA_CLONE_ERR",
              c: 25,
              m: 1
            }
          };
        },
        /* 152 */
        /***/
        (O, S, t) => {
          var n = t(36), h = t(3), T = t(4), P = t(24), f = t(14), y = t(7), c = t(41), a = t(21), I = t(153), A = t(17), g = t(20), s = t(23), o = t(154), l = t(47), u = t(78), v = t(39), p = t(159), C = t(44), r = t(64), i = t(85), w = t(160), x = t(162), b = t(128), F = t(83), L = t(119), G = T.Object, nt = T.Array, D = T.Date, X = T.Error, q = T.EvalError, j = T.RangeError, z = T.ReferenceError, it = T.SyntaxError, Q = T.TypeError, Et = T.URIError, Ct = T.PerformanceMark, H = T.WebAssembly, m = H && H.CompileError || X, k = H && H.LinkError || X, d = H && H.RuntimeError || X, R = P("DOMException"), M = x.Map, B = x.has, _ = x.get, Z = x.set, pt = b.Set, dt = b.add, Tt = P("Object", "keys"), lt = f([].push), yt = f((!0).valueOf), bt = f(1 .valueOf), It = f("".valueOf), Ot = f(D.prototype.getTime), Mt = c("structuredClone"), gt = "DataCloneError", ut = "Transferring", ct = function(Y) {
            return !y(function() {
              var U = new T.Set([7]), at = Y(U), St = Y(G(7));
              return at === U || !at.has(7) || typeof St != "object" || +St != 7;
            }) && Y;
          }, ot = function(Y, U) {
            return !y(function() {
              var at = new U(), St = Y({
                a: at,
                b: at
              });
              return !(St && St.a === St.b && St.a instanceof U && St.a.stack === at.stack);
            });
          }, vt = function(Y) {
            return !y(function() {
              var U = Y(new T.AggregateError([1], Mt, { cause: 3 }));
              return U.name !== "AggregateError" || U.errors[0] !== 1 || U.message !== Mt || U.cause !== 3;
            });
          }, wt = T.structuredClone, Lt = n || !ot(wt, X) || !ot(wt, R) || !vt(wt), Ut = !wt && ct(function(Y) {
            return new Ct(Mt, { detail: Y }).detail;
          }), Ht = ct(wt) || Ut, $t = function(Y) {
            throw new R("Uncloneable type: " + Y, gt);
          }, Wt = function(Y, U) {
            throw new R((U || "Cloning") + " of " + Y + " cannot be properly polyfilled in this engine", gt);
          }, Jt = function(Y, U) {
            return Ht || Wt(U), Ht(Y);
          }, Xt = function() {
            var Y;
            try {
              Y = new T.DataTransfer();
            } catch {
              try {
                Y = new T.ClipboardEvent("").clipboardData;
              } catch {
              }
            }
            return Y && Y.items && Y.files ? Y : null;
          }, Zt = function(Y, U, at) {
            if (B(U, Y))
              return _(U, Y);
            var St = at || u(Y), At, Rt, xt, Nt, kt, _t;
            if (St === "SharedArrayBuffer")
              Ht ? At = Ht(Y) : At = Y;
            else {
              var Bt = T.DataView;
              !Bt && typeof Y.slice != "function" && Wt("ArrayBuffer");
              try {
                if (typeof Y.slice == "function" && !Y.resizable)
                  At = Y.slice(0);
                else
                  for (Rt = Y.byteLength, xt = ("maxByteLength" in Y) ? { maxByteLength: Y.maxByteLength } : void 0, At = new ArrayBuffer(Rt, xt), Nt = new Bt(Y), kt = new Bt(At), _t = 0; _t < Rt; _t++)
                    kt.setUint8(_t, Nt.getUint8(_t));
              } catch {
                throw new R("ArrayBuffer is detached", gt);
              }
            }
            return Z(U, Y, At), At;
          }, Yt = function(Y, U, at, St, At) {
            var Rt = T[U];
            return g(Rt) || Wt(U), new Rt(Zt(Y.buffer, At), at, St);
          }, N = function(Y, U, at) {
            this.object = Y, this.type = U, this.metadata = at;
          }, V = function(Y, U, at) {
            if (s(Y) && $t("Symbol"), !g(Y))
              return Y;
            if (U) {
              if (B(U, Y))
                return _(U, Y);
            } else
              U = new M();
            var St = u(Y), At, Rt, xt, Nt, kt, _t, Bt, et;
            switch (St) {
              case "Array":
                xt = nt(r(Y));
                break;
              case "Object":
                xt = {};
                break;
              case "Map":
                xt = new M();
                break;
              case "Set":
                xt = new pt();
                break;
              case "RegExp":
                xt = new RegExp(Y.source, w(Y));
                break;
              case "Error":
                switch (Rt = Y.name, Rt) {
                  case "AggregateError":
                    xt = P("AggregateError")([]);
                    break;
                  case "EvalError":
                    xt = q();
                    break;
                  case "RangeError":
                    xt = j();
                    break;
                  case "ReferenceError":
                    xt = z();
                    break;
                  case "SyntaxError":
                    xt = it();
                    break;
                  case "TypeError":
                    xt = Q();
                    break;
                  case "URIError":
                    xt = Et();
                    break;
                  case "CompileError":
                    xt = m();
                    break;
                  case "LinkError":
                    xt = k();
                    break;
                  case "RuntimeError":
                    xt = d();
                    break;
                  default:
                    xt = X();
                }
                break;
              case "DOMException":
                xt = new R(Y.message, Y.name);
                break;
              case "ArrayBuffer":
              case "SharedArrayBuffer":
                xt = at ? new N(Y, St) : Zt(Y, U, St);
                break;
              case "DataView":
              case "Int8Array":
              case "Uint8Array":
              case "Uint8ClampedArray":
              case "Int16Array":
              case "Uint16Array":
              case "Int32Array":
              case "Uint32Array":
              case "Float16Array":
              case "Float32Array":
              case "Float64Array":
              case "BigInt64Array":
              case "BigUint64Array":
                _t = St === "DataView" ? Y.byteLength : Y.length, xt = at ? new N(Y, St, {
                  offset: Y.byteOffset,
                  length: _t
                }) : Yt(Y, St, Y.byteOffset, _t, U);
                break;
              case "DOMQuad":
                try {
                  xt = new DOMQuad(V(Y.p1, U, at), V(Y.p2, U, at), V(Y.p3, U, at), V(Y.p4, U, at));
                } catch {
                  xt = Jt(Y, St);
                }
                break;
              case "File":
                if (Ht)
                  try {
                    xt = Ht(Y), u(xt) !== St && (xt = void 0);
                  } catch {
                  }
                if (!xt)
                  try {
                    xt = new File([Y], Y.name, Y);
                  } catch {
                  }
                xt || Wt(St);
                break;
              case "FileList":
                if (Nt = Xt(), Nt) {
                  for (kt = 0, _t = r(Y); kt < _t; kt++)
                    Nt.items.add(V(Y[kt], U, at));
                  xt = Nt.files;
                } else
                  xt = Jt(Y, St);
                break;
              case "ImageData":
                try {
                  xt = new ImageData(V(Y.data, U, at), Y.width, Y.height, { colorSpace: Y.colorSpace });
                } catch {
                  xt = Jt(Y, St);
                }
                break;
              default:
                if (Ht)
                  xt = Ht(Y);
                else
                  switch (St) {
                    case "BigInt":
                      xt = G(Y.valueOf());
                      break;
                    case "Boolean":
                      xt = G(yt(Y));
                      break;
                    case "Number":
                      xt = G(bt(Y));
                      break;
                    case "String":
                      xt = G(It(Y));
                      break;
                    case "Date":
                      xt = new D(Ot(Y));
                      break;
                    case "Blob":
                      try {
                        xt = Y.slice(0, Y.size, Y.type);
                      } catch {
                        Wt(St);
                      }
                      break;
                    case "DOMPoint":
                    case "DOMPointReadOnly":
                      At = T[St];
                      try {
                        xt = At.fromPoint ? At.fromPoint(Y) : new At(Y.x, Y.y, Y.z, Y.w);
                      } catch {
                        Wt(St);
                      }
                      break;
                    case "DOMRect":
                    case "DOMRectReadOnly":
                      At = T[St];
                      try {
                        xt = At.fromRect ? At.fromRect(Y) : new At(Y.x, Y.y, Y.width, Y.height);
                      } catch {
                        Wt(St);
                      }
                      break;
                    case "DOMMatrix":
                    case "DOMMatrixReadOnly":
                      At = T[St];
                      try {
                        xt = At.fromMatrix ? At.fromMatrix(Y) : new At(Y);
                      } catch {
                        Wt(St);
                      }
                      break;
                    case "AudioData":
                    case "VideoFrame":
                      a(Y.clone) || Wt(St);
                      try {
                        xt = Y.clone();
                      } catch {
                        $t(St);
                      }
                      break;
                    case "CropTarget":
                    case "CryptoKey":
                    case "FileSystemDirectoryHandle":
                    case "FileSystemFileHandle":
                    case "FileSystemHandle":
                    case "GPUCompilationInfo":
                    case "GPUCompilationMessage":
                    case "ImageBitmap":
                    case "RTCCertificate":
                    case "WebAssembly.Module":
                      Wt(St);
                    default:
                      $t(St);
                  }
            }
            switch (Z(U, Y, xt), St) {
              case "Array":
              case "Object":
                for (Bt = Tt(Y), kt = 0, _t = r(Bt); kt < _t; kt++)
                  et = Bt[kt], p(xt, et, V(Y[et], U, at));
                break;
              case "Map":
                Y.forEach(function(E, $) {
                  Z(xt, V($, U, at), V(E, U, at));
                });
                break;
              case "Set":
                Y.forEach(function(E) {
                  dt(xt, V(E, U, at));
                });
                break;
              case "Error":
                C(xt, "message", V(Y.message, U, at)), v(Y, "cause") && C(xt, "cause", V(Y.cause, U, at)), Rt === "AggregateError" && (xt.errors = V(Y.errors, U, at));
              case "DOMException":
                F && C(xt, "stack", V(Y.stack, U, at));
            }
            return xt;
          }, K = function(Y, U) {
            if (!g(Y))
              return Y;
            if (B(U, Y))
              return _(U, Y);
            var at, St, At, Rt, xt, Nt, kt, _t;
            if (Y instanceof N)
              switch (at = Y.type, St = Y.object, at) {
                case "ArrayBuffer":
                case "SharedArrayBuffer":
                  _t = Zt(St, U, at);
                  break;
                case "DataView":
                case "Int8Array":
                case "Uint8Array":
                case "Uint8ClampedArray":
                case "Int16Array":
                case "Uint16Array":
                case "Int32Array":
                case "Uint32Array":
                case "Float16Array":
                case "Float32Array":
                case "Float64Array":
                case "BigInt64Array":
                case "BigUint64Array":
                  At = Y.metadata, _t = Yt(St, at, At.offset, At.length, U);
              }
            else
              switch (u(Y)) {
                case "Array":
                case "Object":
                  for (Nt = Tt(Y), Rt = 0, xt = r(Nt); Rt < xt; Rt++)
                    kt = Nt[Rt], Y[kt] = K(Y[kt], U);
                  break;
                case "Map":
                  _t = new M(), Y.forEach(function(Bt, et) {
                    Z(_t, K(et, U), K(Bt, U));
                  });
                  break;
                case "Set":
                  _t = new pt(), Y.forEach(function(Bt) {
                    dt(_t, K(Bt, U));
                  });
                  break;
                case "Error":
                  Y.message = K(Y.message, U), v(Y, "cause") && (Y.cause = K(Y.cause, U)), Y.name === "AggregateError" && (Y.errors = K(Y.errors, U));
                case "DOMException":
                  F && (Y.stack = K(Y.stack, U));
              }
            return Z(U, Y, _t || Y), _t || Y;
          }, st = function(Y, U) {
            if (!g(Y))
              throw Q("Transfer option cannot be converted to a sequence");
            var at = [];
            o(Y, function(E) {
              lt(at, l(E));
            });
            for (var St = 0, At = r(at), Rt = [], xt, Nt, kt, _t, Bt, et; St < At; ) {
              if (xt = at[St++], Nt = u(xt), Nt === "ArrayBuffer") {
                lt(Rt, xt);
                continue;
              }
              if (B(U, xt))
                throw new R("Duplicate transferable", gt);
              if (L)
                _t = wt(xt, { transfer: [xt] });
              else
                switch (Nt) {
                  case "ImageBitmap":
                    kt = T.OffscreenCanvas, I(kt) || Wt(Nt, ut);
                    try {
                      Bt = new kt(xt.width, xt.height), et = Bt.getContext("bitmaprenderer"), et.transferFromImageBitmap(xt), _t = Bt.transferToImageBitmap();
                    } catch {
                    }
                    break;
                  case "AudioData":
                  case "VideoFrame":
                    (!a(xt.clone) || !a(xt.close)) && Wt(Nt, ut);
                    try {
                      _t = xt.clone(), xt.close();
                    } catch {
                    }
                    break;
                  case "MediaSourceHandle":
                  case "MessagePort":
                  case "OffscreenCanvas":
                  case "ReadableStream":
                  case "TransformStream":
                  case "WritableStream":
                    Wt(Nt, ut);
                }
              if (_t === void 0)
                throw new R("This object cannot be transferred: " + Nt, gt);
              Z(U, xt, _t);
            }
            return Rt;
          }, ft = function(Y, U) {
            for (var at = 0, St = r(Y), At, Rt; at < St; ) {
              if (At = Y[at++], B(U, At))
                throw new R("Duplicate transferable", gt);
              L ? Rt = wt(At, { transfer: [At] }) : (a(At.transfer) || Wt("ArrayBuffer", ut), Rt = At.transfer()), Z(U, At, Rt);
            }
          };
          h({
            global: !0,
            enumerable: !0,
            sham: !L,
            forced: Lt
          }, {
            structuredClone: function(U) {
              var at = i(arguments.length, 1) > 1 && !A(arguments[1]) ? l(arguments[1]) : void 0, St = at ? at.transfer : void 0, At = !1, Rt, xt;
              St !== void 0 && (Rt = new M(), xt = st(St, Rt), At = !!r(xt));
              var Nt = V(U, Rt, At);
              return At && (Rt = new M(), ft(St, Rt), Nt = K(Nt, Rt)), Nt;
            }
          });
        },
        /* 153 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(7), T = t(21), P = t(78), f = t(24), y = t(51), c = function() {
          }, a = [], I = f("Reflect", "construct"), A = /^\s*(?:class|function)\b/, g = n(A.exec), s = !A.exec(c), o = function(v) {
            if (!T(v))
              return !1;
            try {
              return I(c, a, v), !0;
            } catch {
              return !1;
            }
          }, l = function(v) {
            if (!T(v))
              return !1;
            switch (P(v)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return !1;
            }
            try {
              return s || !!g(A, y(v));
            } catch {
              return !0;
            }
          };
          l.sham = !0, O.exports = !I || h(function() {
            var u;
            return o(o.call) || !o(Object) || !o(function() {
              u = !0;
            }) || u;
          }) ? l : o;
        },
        /* 154 */
        /***/
        (O, S, t) => {
          var n = t(99), h = t(8), T = t(47), P = t(32), f = t(155), y = t(64), c = t(25), a = t(157), I = t(158), A = t(140), g = TypeError, s = function(l, u) {
            this.stopped = l, this.result = u;
          }, o = s.prototype;
          O.exports = function(l, u, v) {
            var p = v && v.that, C = !!(v && v.AS_ENTRIES), r = !!(v && v.IS_RECORD), i = !!(v && v.IS_ITERATOR), w = !!(v && v.INTERRUPTED), x = n(u, p), b, F, L, G, nt, D, X, q = function(z) {
              return b && A(b, "normal", z), new s(!0, z);
            }, j = function(z) {
              return C ? (T(z), w ? x(z[0], z[1], q) : x(z[0], z[1])) : w ? x(z, q) : x(z);
            };
            if (r)
              b = l.iterator;
            else if (i)
              b = l;
            else {
              if (F = I(l), !F)
                throw g(P(l) + " is not iterable");
              if (f(F)) {
                for (L = 0, G = y(l); G > L; L++)
                  if (nt = j(l[L]), nt && c(o, nt))
                    return nt;
                return new s(!1);
              }
              b = a(l, F);
            }
            for (D = r ? l.next : b.next; !(X = h(D, b)).done; ) {
              try {
                nt = j(X.value);
              } catch (z) {
                A(b, "throw", z);
              }
              if (typeof nt == "object" && nt && c(o, nt))
                return nt;
            }
            return new s(!1);
          };
        },
        /* 155 */
        /***/
        (O, S, t) => {
          var n = t(34), h = t(156), T = n("iterator"), P = Array.prototype;
          O.exports = function(f) {
            return f !== void 0 && (h.Array === f || P[T] === f);
          };
        },
        /* 156 */
        /***/
        (O) => {
          O.exports = {};
        },
        /* 157 */
        /***/
        (O, S, t) => {
          var n = t(8), h = t(31), T = t(47), P = t(32), f = t(158), y = TypeError;
          O.exports = function(c, a) {
            var I = arguments.length < 2 ? f(c) : a;
            if (h(I))
              return T(n(I, c));
            throw y(P(c) + " is not iterable");
          };
        },
        /* 158 */
        /***/
        (O, S, t) => {
          var n = t(78), h = t(30), T = t(17), P = t(156), f = t(34), y = f("iterator");
          O.exports = function(c) {
            if (!T(c))
              return h(c, y) || h(c, "@@iterator") || P[n(c)];
          };
        },
        /* 159 */
        /***/
        (O, S, t) => {
          var n = t(18), h = t(45), T = t(11);
          O.exports = function(P, f, y) {
            var c = n(f);
            c in P ? h.f(P, c, T(0, y)) : P[c] = y;
          };
        },
        /* 160 */
        /***/
        (O, S, t) => {
          var n = t(8), h = t(39), T = t(25), P = t(161), f = RegExp.prototype;
          O.exports = function(y) {
            var c = y.flags;
            return c === void 0 && !("flags" in f) && !h(y, "flags") && T(f, y) ? n(P, y) : c;
          };
        },
        /* 161 */
        /***/
        (O, S, t) => {
          var n = t(47);
          O.exports = function() {
            var h = n(this), T = "";
            return h.hasIndices && (T += "d"), h.global && (T += "g"), h.ignoreCase && (T += "i"), h.multiline && (T += "m"), h.dotAll && (T += "s"), h.unicode && (T += "u"), h.unicodeSets && (T += "v"), h.sticky && (T += "y"), T;
          };
        },
        /* 162 */
        /***/
        (O, S, t) => {
          var n = t(14), h = Map.prototype;
          O.exports = {
            Map,
            set: n(h.set),
            get: n(h.get),
            has: n(h.has),
            remove: n(h.delete),
            proto: h
          };
        },
        /* 163 */
        /***/
        (O, S, t) => {
          var c, a, I, ti, g;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.SerializableEmpty = S.PrintAnnotationStorage = S.AnnotationStorage = void 0, t(89), t(149), t(152);
          var n = t(1), h = t(164), T = t(170);
          const P = Object.freeze({
            map: null,
            hash: "",
            transfers: void 0
          });
          S.SerializableEmpty = P;
          class f {
            constructor() {
              W(this, I);
              W(this, c, !1);
              W(this, a, /* @__PURE__ */ new Map());
              this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(o, l) {
              const u = e(this, a).get(o);
              return u === void 0 ? l : Object.assign(l, u);
            }
            getRawValue(o) {
              return e(this, a).get(o);
            }
            remove(o) {
              if (e(this, a).delete(o), e(this, a).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const l of e(this, a).values())
                  if (l instanceof h.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(o, l) {
              const u = e(this, a).get(o);
              let v = !1;
              if (u !== void 0)
                for (const [p, C] of Object.entries(l))
                  u[p] !== C && (v = !0, u[p] = C);
              else
                v = !0, e(this, a).set(o, l);
              v && J(this, I, ti).call(this), l instanceof h.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(l.constructor._type);
            }
            has(o) {
              return e(this, a).has(o);
            }
            getAll() {
              return e(this, a).size > 0 ? (0, n.objectFromMap)(e(this, a)) : null;
            }
            setAll(o) {
              for (const [l, u] of Object.entries(o))
                this.setValue(l, u);
            }
            get size() {
              return e(this, a).size;
            }
            resetModified() {
              e(this, c) && (rt(this, c, !1), typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new y(this);
            }
            get serializable() {
              if (e(this, a).size === 0)
                return P;
              const o = /* @__PURE__ */ new Map(), l = new T.MurmurHash3_64(), u = [], v = /* @__PURE__ */ Object.create(null);
              let p = !1;
              for (const [C, r] of e(this, a)) {
                const i = r instanceof h.AnnotationEditor ? r.serialize(!1, v) : r;
                i && (o.set(C, i), l.update(`${C}:${JSON.stringify(i)}`), p || (p = !!i.bitmap));
              }
              if (p)
                for (const C of o.values())
                  C.bitmap && u.push(C.bitmap);
              return o.size > 0 ? {
                map: o,
                hash: l.hexdigest(),
                transfers: u
              } : P;
            }
          }
          c = new WeakMap(), a = new WeakMap(), I = new WeakSet(), ti = function() {
            e(this, c) || (rt(this, c, !0), typeof this.onSetModified == "function" && this.onSetModified());
          }, S.AnnotationStorage = f;
          class y extends f {
            constructor(l) {
              super();
              W(this, g, void 0);
              const {
                map: u,
                hash: v,
                transfers: p
              } = l.serializable, C = structuredClone(u, null);
              rt(this, g, {
                map: C,
                hash: v,
                transfers: p
              });
            }
            get print() {
              (0, n.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return e(this, g);
            }
          }
          g = new WeakMap(), S.PrintAnnotationStorage = y;
        },
        /* 164 */
        /***/
        (O, S, t) => {
          var y, c, a, I, A, g, s, o, l, u, v, p, C, r, i, Qe, x, Ze, F, qe, G, tn, D, ei, q, ni, z, ii, Q, en, Ct, ri;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.AnnotationEditor = void 0, t(89), t(2);
          var n = t(165), h = t(1), T = t(168);
          const m = class m {
            constructor(d) {
              W(this, i);
              W(this, x);
              W(this, G);
              W(this, D);
              W(this, q);
              W(this, z);
              W(this, Q);
              W(this, Ct);
              W(this, y, "");
              W(this, c, !1);
              W(this, a, null);
              W(this, I, null);
              W(this, A, null);
              W(this, g, !1);
              W(this, s, null);
              W(this, o, this.focusin.bind(this));
              W(this, l, this.focusout.bind(this));
              W(this, u, !1);
              W(this, v, !1);
              W(this, p, !1);
              ee(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
              ee(this, "_uiManager", null);
              ee(this, "_focusEventsAllowed", !0);
              ee(this, "_l10nPromise", null);
              W(this, C, !1);
              W(this, r, m._zIndex++);
              this.constructor === m && (0, h.unreachable)("Cannot initialize AnnotationEditor."), this.parent = d.parent, this.id = d.id, this.width = this.height = null, this.pageIndex = d.parent.pageIndex, this.name = d.name, this.div = null, this._uiManager = d.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = d.isCentered, this._structTreeParentId = null;
              const {
                rotation: R,
                rawDims: {
                  pageWidth: M,
                  pageHeight: B,
                  pageX: _,
                  pageY: Z
                }
              } = this.parent.viewport;
              this.rotation = R, this.pageRotation = (360 + R - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [M, B], this.pageTranslation = [_, Z];
              const [pt, dt] = this.parentDimensions;
              this.x = d.x / pt, this.y = d.y / dt, this.isAttachedToDOM = !1, this.deleted = !1;
            }
            get editorType() {
              return Object.getPrototypeOf(this).constructor._type;
            }
            static get _defaultLineColor() {
              return (0, h.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            static deleteAnnotationElement(d) {
              const R = new f({
                id: d.parent.getNextId(),
                parent: d.parent,
                uiManager: d._uiManager
              });
              R.annotationElementId = d.annotationElementId, R.deleted = !0, R._uiManager.addToAnnotationStorage(R);
            }
            static initialize(d) {
              let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              if (m._l10nPromise || (m._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((B) => [B, d.get(B)]))), R != null && R.strings)
                for (const B of R.strings)
                  m._l10nPromise.set(B, d.get(B));
              if (m._borderLineWidth !== -1)
                return;
              const M = getComputedStyle(document.documentElement);
              m._borderLineWidth = parseFloat(M.getPropertyValue("--outline-width")) || 0;
            }
            static updateDefaultParams(d, R) {
            }
            static get defaultPropertiesToUpdate() {
              return [];
            }
            static isHandlingMimeForPasting(d) {
              return !1;
            }
            static paste(d, R) {
              (0, h.unreachable)("Not implemented");
            }
            get propertiesToUpdate() {
              return [];
            }
            get _isDraggable() {
              return e(this, C);
            }
            set _isDraggable(d) {
              var R;
              rt(this, C, d), (R = this.div) == null || R.classList.toggle("draggable", d);
            }
            center() {
              const [d, R] = this.pageDimensions;
              switch (this.parentRotation) {
                case 90:
                  this.x -= this.height * R / (d * 2), this.y += this.width * d / (R * 2);
                  break;
                case 180:
                  this.x += this.width / 2, this.y += this.height / 2;
                  break;
                case 270:
                  this.x += this.height * R / (d * 2), this.y -= this.width * d / (R * 2);
                  break;
                default:
                  this.x -= this.width / 2, this.y -= this.height / 2;
                  break;
              }
              this.fixAndSetPosition();
            }
            addCommands(d) {
              this._uiManager.addCommands(d);
            }
            get currentLayer() {
              return this._uiManager.currentLayer;
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = e(this, r);
            }
            setParent(d) {
              d !== null && (this.pageIndex = d.pageIndex, this.pageDimensions = d.pageDimensions), this.parent = d;
            }
            focusin(d) {
              this._focusEventsAllowed && (e(this, u) ? rt(this, u, !1) : this.parent.setSelected(this));
            }
            focusout(d) {
              var M;
              if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                return;
              const R = d.relatedTarget;
              R != null && R.closest(`#${this.id}`) || (d.preventDefault(), (M = this.parent) != null && M.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.addToAnnotationStorage();
            }
            addToAnnotationStorage() {
              this._uiManager.addToAnnotationStorage(this);
            }
            setAt(d, R, M, B) {
              const [_, Z] = this.parentDimensions;
              [M, B] = this.screenToPageTranslation(M, B), this.x = (d + M) / _, this.y = (R + B) / Z, this.fixAndSetPosition();
            }
            translate(d, R) {
              J(this, i, Qe).call(this, this.parentDimensions, d, R);
            }
            translateInPage(d, R) {
              J(this, i, Qe).call(this, this.pageDimensions, d, R), this.div.scrollIntoView({
                block: "nearest"
              });
            }
            drag(d, R) {
              const [M, B] = this.parentDimensions;
              if (this.x += d / M, this.y += R / B, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                const {
                  x: Tt,
                  y: lt
                } = this.div.getBoundingClientRect();
                this.parent.findNewParent(this, Tt, lt) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
              }
              let {
                x: _,
                y: Z
              } = this;
              const [pt, dt] = J(this, x, Ze).call(this);
              _ += pt, Z += dt, this.div.style.left = `${(100 * _).toFixed(2)}%`, this.div.style.top = `${(100 * Z).toFixed(2)}%`, this.div.scrollIntoView({
                block: "nearest"
              });
            }
            fixAndSetPosition() {
              const [d, R] = this.pageDimensions;
              let {
                x: M,
                y: B,
                width: _,
                height: Z
              } = this;
              switch (_ *= d, Z *= R, M *= d, B *= R, this.rotation) {
                case 0:
                  M = Math.max(0, Math.min(d - _, M)), B = Math.max(0, Math.min(R - Z, B));
                  break;
                case 90:
                  M = Math.max(0, Math.min(d - Z, M)), B = Math.min(R, Math.max(_, B));
                  break;
                case 180:
                  M = Math.min(d, Math.max(_, M)), B = Math.min(R, Math.max(Z, B));
                  break;
                case 270:
                  M = Math.min(d, Math.max(Z, M)), B = Math.max(0, Math.min(R - _, B));
                  break;
              }
              this.x = M /= d, this.y = B /= R;
              const [pt, dt] = J(this, x, Ze).call(this);
              M += pt, B += dt;
              const {
                style: Tt
              } = this.div;
              Tt.left = `${(100 * M).toFixed(2)}%`, Tt.top = `${(100 * B).toFixed(2)}%`, this.moveInDOM();
            }
            screenToPageTranslation(d, R) {
              var M;
              return J(M = m, F, qe).call(M, d, R, this.parentRotation);
            }
            pageTranslationToScreen(d, R) {
              var M;
              return J(M = m, F, qe).call(M, d, R, 360 - this.parentRotation);
            }
            get parentScale() {
              return this._uiManager.viewParameters.realScale;
            }
            get parentRotation() {
              return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
            }
            get parentDimensions() {
              const {
                parentScale: d,
                pageDimensions: [R, M]
              } = this, B = R * d, _ = M * d;
              return h.FeatureTest.isCSSRoundSupported ? [Math.round(B), Math.round(_)] : [B, _];
            }
            setDims(d, R) {
              var _;
              const [M, B] = this.parentDimensions;
              this.div.style.width = `${(100 * d / M).toFixed(2)}%`, e(this, g) || (this.div.style.height = `${(100 * R / B).toFixed(2)}%`), (_ = e(this, a)) == null || _.classList.toggle("small", d < m.SMALL_EDITOR_SIZE || R < m.SMALL_EDITOR_SIZE);
            }
            fixDims() {
              const {
                style: d
              } = this.div, {
                height: R,
                width: M
              } = d, B = M.endsWith("%"), _ = !e(this, g) && R.endsWith("%");
              if (B && _)
                return;
              const [Z, pt] = this.parentDimensions;
              B || (d.width = `${(100 * parseFloat(M) / Z).toFixed(2)}%`), !e(this, g) && !_ && (d.height = `${(100 * parseFloat(R) / pt).toFixed(2)}%`);
            }
            getInitialTranslation() {
              return [0, 0];
            }
            async addAltTextButton() {
              if (e(this, a))
                return;
              const d = rt(this, a, document.createElement("button"));
              d.className = "altText";
              const R = await m._l10nPromise.get("editor_alt_text_button_label");
              d.textContent = R, d.setAttribute("aria-label", R), d.tabIndex = "0", d.addEventListener("contextmenu", T.noContextMenu), d.addEventListener("pointerdown", (M) => M.stopPropagation()), d.addEventListener("click", (M) => {
                M.preventDefault(), this._uiManager.editAltText(this);
              }, {
                capture: !0
              }), d.addEventListener("keydown", (M) => {
                M.target === d && M.key === "Enter" && (M.preventDefault(), this._uiManager.editAltText(this));
              }), J(this, Q, en).call(this), this.div.append(d), m.SMALL_EDITOR_SIZE || (m.SMALL_EDITOR_SIZE = Math.min(128, Math.round(d.getBoundingClientRect().width * 1.4)));
            }
            getClientDimensions() {
              return this.div.getBoundingClientRect();
            }
            get altTextData() {
              return {
                altText: e(this, y),
                decorative: e(this, c)
              };
            }
            set altTextData(d) {
              let {
                altText: R,
                decorative: M
              } = d;
              e(this, y) === R && e(this, c) === M || (rt(this, y, R), rt(this, c, M), J(this, Q, en).call(this));
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", e(this, o)), this.div.addEventListener("focusout", e(this, l));
              const [d, R] = this.parentDimensions;
              this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * R / d).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * d / R).toFixed(2)}%`);
              const [M, B] = this.getInitialTranslation();
              return this.translate(M, B), (0, n.bindEvents)(this, this.div, ["pointerdown"]), this.div;
            }
            pointerdown(d) {
              const {
                isMac: R
              } = h.FeatureTest.platform;
              if (d.button !== 0 || d.ctrlKey && R) {
                d.preventDefault();
                return;
              }
              rt(this, u, !0), J(this, Ct, ri).call(this, d);
            }
            moveInDOM() {
              var d;
              (d = this.parent) == null || d.moveEditorInDOM(this);
            }
            _setParentAndPosition(d, R, M) {
              d.changeParent(this), this.x = R, this.y = M, this.fixAndSetPosition();
            }
            getRect(d, R) {
              const M = this.parentScale, [B, _] = this.pageDimensions, [Z, pt] = this.pageTranslation, dt = d / M, Tt = R / M, lt = this.x * B, yt = this.y * _, bt = this.width * B, It = this.height * _;
              switch (this.rotation) {
                case 0:
                  return [lt + dt + Z, _ - yt - Tt - It + pt, lt + dt + bt + Z, _ - yt - Tt + pt];
                case 90:
                  return [lt + Tt + Z, _ - yt + dt + pt, lt + Tt + It + Z, _ - yt + dt + bt + pt];
                case 180:
                  return [lt - dt - bt + Z, _ - yt + Tt + pt, lt - dt + Z, _ - yt + Tt + It + pt];
                case 270:
                  return [lt - Tt - It + Z, _ - yt - dt - bt + pt, lt - Tt + Z, _ - yt - dt + pt];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(d, R) {
              const [M, B, _, Z] = d, pt = _ - M, dt = Z - B;
              switch (this.rotation) {
                case 0:
                  return [M, R - Z, pt, dt];
                case 90:
                  return [M, R - B, dt, pt];
                case 180:
                  return [_, R - B, pt, dt];
                case 270:
                  return [_, R - Z, dt, pt];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              rt(this, p, !0);
            }
            disableEditMode() {
              rt(this, p, !1);
            }
            isInEditMode() {
              return e(this, p);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var d, R;
              (d = this.div) == null || d.addEventListener("focusin", e(this, o)), (R = this.div) == null || R.addEventListener("focusout", e(this, l));
            }
            serialize() {
              (0, h.unreachable)("An editor must be serializable");
            }
            static deserialize(d, R, M) {
              const B = new this.prototype.constructor({
                parent: R,
                id: R.getNextId(),
                uiManager: M
              });
              B.rotation = d.rotation;
              const [_, Z] = B.pageDimensions, [pt, dt, Tt, lt] = B.getRectInCurrentCoords(d.rect, Z);
              return B.x = pt / _, B.y = dt / Z, B.width = Tt / _, B.height = lt / Z, B;
            }
            remove() {
              var d;
              this.div.removeEventListener("focusin", e(this, o)), this.div.removeEventListener("focusout", e(this, l)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (d = e(this, a)) == null || d.remove(), rt(this, a, null), rt(this, I, null);
            }
            get isResizable() {
              return !1;
            }
            makeResizable() {
              this.isResizable && (J(this, D, ei).call(this), e(this, s).classList.remove("hidden"));
            }
            select() {
              var d;
              this.makeResizable(), (d = this.div) == null || d.classList.add("selectedEditor");
            }
            unselect() {
              var d, R, M;
              (d = e(this, s)) == null || d.classList.add("hidden"), (R = this.div) == null || R.classList.remove("selectedEditor"), (M = this.div) != null && M.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
            }
            updateParams(d, R) {
            }
            disableEditing() {
              e(this, a) && (e(this, a).hidden = !0);
            }
            enableEditing() {
              e(this, a) && (e(this, a).hidden = !1);
            }
            enterInEditMode() {
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return e(this, v);
            }
            set isEditing(d) {
              rt(this, v, d), this.parent && (d ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
            }
            setAspectRatio(d, R) {
              rt(this, g, !0);
              const M = d / R, {
                style: B
              } = this.div;
              B.aspectRatio = M, B.height = "auto";
            }
            static get MIN_SIZE() {
              return 16;
            }
          };
          y = new WeakMap(), c = new WeakMap(), a = new WeakMap(), I = new WeakMap(), A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakMap(), v = new WeakMap(), p = new WeakMap(), C = new WeakMap(), r = new WeakMap(), i = new WeakSet(), Qe = function(d, R, M) {
            let [B, _] = d;
            [R, M] = this.screenToPageTranslation(R, M), this.x += R / B, this.y += M / _, this.fixAndSetPosition();
          }, x = new WeakSet(), Ze = function() {
            const [d, R] = this.parentDimensions, {
              _borderLineWidth: M
            } = m, B = M / d, _ = M / R;
            switch (this.rotation) {
              case 90:
                return [-B, _];
              case 180:
                return [B, _];
              case 270:
                return [B, -_];
              default:
                return [-B, -_];
            }
          }, F = new WeakSet(), qe = function(d, R, M) {
            switch (M) {
              case 90:
                return [R, -d];
              case 180:
                return [-d, -R];
              case 270:
                return [-R, d];
              default:
                return [d, R];
            }
          }, G = new WeakSet(), tn = function(d) {
            switch (d) {
              case 90: {
                const [R, M] = this.pageDimensions;
                return [0, -R / M, M / R, 0];
              }
              case 180:
                return [-1, 0, 0, -1];
              case 270: {
                const [R, M] = this.pageDimensions;
                return [0, R / M, -M / R, 0];
              }
              default:
                return [1, 0, 0, 1];
            }
          }, D = new WeakSet(), ei = function() {
            if (e(this, s))
              return;
            rt(this, s, document.createElement("div")), e(this, s).classList.add("resizers");
            const d = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
            this._willKeepAspectRatio || d.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
            for (const R of d) {
              const M = document.createElement("div");
              e(this, s).append(M), M.classList.add("resizer", R), M.addEventListener("pointerdown", J(this, q, ni).bind(this, R)), M.addEventListener("contextmenu", T.noContextMenu);
            }
            this.div.prepend(e(this, s));
          }, q = new WeakSet(), ni = function(d, R) {
            R.preventDefault();
            const {
              isMac: M
            } = h.FeatureTest.platform;
            if (R.button !== 0 || R.ctrlKey && M)
              return;
            const B = J(this, z, ii).bind(this, d), _ = this._isDraggable;
            this._isDraggable = !1;
            const Z = {
              passive: !0,
              capture: !0
            };
            window.addEventListener("pointermove", B, Z);
            const pt = this.x, dt = this.y, Tt = this.width, lt = this.height, yt = this.parent.div.style.cursor, bt = this.div.style.cursor;
            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(R.target).cursor;
            const It = () => {
              this._isDraggable = _, window.removeEventListener("pointerup", It), window.removeEventListener("blur", It), window.removeEventListener("pointermove", B, Z), this.parent.div.style.cursor = yt, this.div.style.cursor = bt;
              const Ot = this.x, Mt = this.y, gt = this.width, ut = this.height;
              Ot === pt && Mt === dt && gt === Tt && ut === lt || this.addCommands({
                cmd: () => {
                  this.width = gt, this.height = ut, this.x = Ot, this.y = Mt;
                  const [ct, ot] = this.parentDimensions;
                  this.setDims(ct * gt, ot * ut), this.fixAndSetPosition();
                },
                undo: () => {
                  this.width = Tt, this.height = lt, this.x = pt, this.y = dt;
                  const [ct, ot] = this.parentDimensions;
                  this.setDims(ct * Tt, ot * lt), this.fixAndSetPosition();
                },
                mustExec: !0
              });
            };
            window.addEventListener("pointerup", It), window.addEventListener("blur", It);
          }, z = new WeakSet(), ii = function(d, R) {
            const [M, B] = this.parentDimensions, _ = this.x, Z = this.y, pt = this.width, dt = this.height, Tt = m.MIN_SIZE / M, lt = m.MIN_SIZE / B, yt = (K) => Math.round(K * 1e4) / 1e4, bt = J(this, G, tn).call(this, this.rotation), It = (K, st) => [bt[0] * K + bt[2] * st, bt[1] * K + bt[3] * st], Ot = J(this, G, tn).call(this, 360 - this.rotation), Mt = (K, st) => [Ot[0] * K + Ot[2] * st, Ot[1] * K + Ot[3] * st];
            let gt, ut, ct = !1, ot = !1;
            switch (d) {
              case "topLeft":
                ct = !0, gt = (K, st) => [0, 0], ut = (K, st) => [K, st];
                break;
              case "topMiddle":
                gt = (K, st) => [K / 2, 0], ut = (K, st) => [K / 2, st];
                break;
              case "topRight":
                ct = !0, gt = (K, st) => [K, 0], ut = (K, st) => [0, st];
                break;
              case "middleRight":
                ot = !0, gt = (K, st) => [K, st / 2], ut = (K, st) => [0, st / 2];
                break;
              case "bottomRight":
                ct = !0, gt = (K, st) => [K, st], ut = (K, st) => [0, 0];
                break;
              case "bottomMiddle":
                gt = (K, st) => [K / 2, st], ut = (K, st) => [K / 2, 0];
                break;
              case "bottomLeft":
                ct = !0, gt = (K, st) => [0, st], ut = (K, st) => [K, 0];
                break;
              case "middleLeft":
                ot = !0, gt = (K, st) => [0, st / 2], ut = (K, st) => [K, st / 2];
                break;
            }
            const vt = gt(pt, dt), wt = ut(pt, dt);
            let Lt = It(...wt);
            const Ut = yt(_ + Lt[0]), Ht = yt(Z + Lt[1]);
            let $t = 1, Wt = 1, [Jt, Xt] = this.screenToPageTranslation(R.movementX, R.movementY);
            if ([Jt, Xt] = Mt(Jt / M, Xt / B), ct) {
              const K = Math.hypot(pt, dt);
              $t = Wt = Math.max(Math.min(Math.hypot(wt[0] - vt[0] - Jt, wt[1] - vt[1] - Xt) / K, 1 / pt, 1 / dt), Tt / pt, lt / dt);
            } else
              ot ? $t = Math.max(Tt, Math.min(1, Math.abs(wt[0] - vt[0] - Jt))) / pt : Wt = Math.max(lt, Math.min(1, Math.abs(wt[1] - vt[1] - Xt))) / dt;
            const Zt = yt(pt * $t), Yt = yt(dt * Wt);
            Lt = It(...ut(Zt, Yt));
            const N = Ut - Lt[0], V = Ht - Lt[1];
            this.width = Zt, this.height = Yt, this.x = N, this.y = V, this.setDims(M * Zt, B * Yt), this.fixAndSetPosition();
          }, Q = new WeakSet(), en = async function() {
            var M;
            const d = e(this, a);
            if (!d)
              return;
            if (!e(this, y) && !e(this, c)) {
              d.classList.remove("done"), (M = e(this, I)) == null || M.remove();
              return;
            }
            m._l10nPromise.get("editor_alt_text_edit_button_label").then((B) => {
              d.setAttribute("aria-label", B);
            });
            let R = e(this, I);
            if (!R) {
              rt(this, I, R = document.createElement("span")), R.className = "tooltip", R.setAttribute("role", "tooltip");
              const B = R.id = `alt-text-tooltip-${this.id}`;
              d.setAttribute("aria-describedby", B);
              const _ = 100;
              d.addEventListener("mouseenter", () => {
                rt(this, A, setTimeout(() => {
                  rt(this, A, null), e(this, I).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                    source: this,
                    details: {
                      type: "editing",
                      subtype: this.editorType,
                      data: {
                        action: "alt_text_tooltip"
                      }
                    }
                  });
                }, _));
              }), d.addEventListener("mouseleave", () => {
                var Z;
                clearTimeout(e(this, A)), rt(this, A, null), (Z = e(this, I)) == null || Z.classList.remove("show");
              });
            }
            d.classList.add("done"), R.innerText = e(this, c) ? await m._l10nPromise.get("editor_alt_text_decorative_tooltip") : e(this, y), R.parentNode || d.append(R);
          }, Ct = new WeakSet(), ri = function(d) {
            if (!this._isDraggable)
              return;
            const R = this._uiManager.isSelected(this);
            this._uiManager.setUpDragSession();
            let M, B;
            R && (M = {
              passive: !0,
              capture: !0
            }, B = (Z) => {
              const [pt, dt] = this.screenToPageTranslation(Z.movementX, Z.movementY);
              this._uiManager.dragSelectedEditors(pt, dt);
            }, window.addEventListener("pointermove", B, M));
            const _ = () => {
              if (window.removeEventListener("pointerup", _), window.removeEventListener("blur", _), R && window.removeEventListener("pointermove", B, M), rt(this, u, !1), !this._uiManager.endDragSession()) {
                const {
                  isMac: Z
                } = h.FeatureTest.platform;
                d.ctrlKey && !Z || d.shiftKey || d.metaKey && Z ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
              }
            };
            window.addEventListener("pointerup", _), window.addEventListener("blur", _);
          }, W(m, F), ee(m, "_borderLineWidth", -1), ee(m, "_colorManager", new n.ColorManager()), ee(m, "_zIndex", 1), ee(m, "SMALL_EDITOR_SIZE", 0);
          let P = m;
          S.AnnotationEditor = P;
          class f extends P {
            constructor(d) {
              super(d), this.annotationElementId = d.annotationElementId, this.deleted = !0;
            }
            serialize() {
              return {
                id: this.annotationElementId,
                deleted: !0,
                pageIndex: this.pageIndex
              };
            }
          }
        },
        /* 165 */
        /***/
        (O, S, t) => {
          var g, s, o, l, u, nn, C, r, i, w, x, si, L, G, nt, D, X, q, j, z, it, Q, Et, Ct, H, m, k, d, R, M, B, _, Z, pt, dt, Tt, lt, yt, bt, It, Ot, Mt, gt, ut, ct, ot, vt, ai, Lt, rn, Ht, sn, Wt, Ie, Xt, an, Yt, on, V, se, st, be, Y, oi, at, li, At, ln, xt, ye, kt, cn;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.KeyboardManager = S.CommandManager = S.ColorManager = S.AnnotationEditorUIManager = void 0, S.bindEvents = T, S.opacityToHex = P, t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(2), t(89), t(125), t(136), t(138), t(141), t(143), t(145), t(147), t(166);
          var n = t(1), h = t(168);
          function T(et, E, $) {
            for (const tt of $)
              E.addEventListener(tt, et[tt].bind(et));
          }
          function P(et) {
            return Math.round(Math.min(255, Math.max(1, 255 * et))).toString(16).padStart(2, "0");
          }
          class f {
            constructor() {
              W(this, g, 0);
            }
            getId() {
              return `${n.AnnotationEditorPrefix}${ue(this, g)._++}`;
            }
          }
          g = new WeakMap();
          const p = class p {
            constructor() {
              W(this, u);
              W(this, s, (0, n.getUuid)());
              W(this, o, 0);
              W(this, l, null);
            }
            static get _isSVGFittingCanvas() {
              const E = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', tt = new OffscreenCanvas(1, 3).getContext("2d"), ht = new Image();
              ht.src = E;
              const mt = ht.decode().then(() => (tt.drawImage(ht, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(tt.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
              return (0, n.shadow)(this, "_isSVGFittingCanvas", mt);
            }
            async getFromFile(E) {
              const {
                lastModified: $,
                name: tt,
                size: ht,
                type: mt
              } = E;
              return J(this, u, nn).call(this, `${$}_${tt}_${ht}_${mt}`, E);
            }
            async getFromUrl(E) {
              return J(this, u, nn).call(this, E, E);
            }
            async getFromId(E) {
              e(this, l) || rt(this, l, /* @__PURE__ */ new Map());
              const $ = e(this, l).get(E);
              return $ ? $.bitmap ? ($.refCounter += 1, $) : $.file ? this.getFromFile($.file) : this.getFromUrl($.url) : null;
            }
            getSvgUrl(E) {
              const $ = e(this, l).get(E);
              return $ != null && $.isSvg ? $.svgUrl : null;
            }
            deleteId(E) {
              e(this, l) || rt(this, l, /* @__PURE__ */ new Map());
              const $ = e(this, l).get(E);
              $ && ($.refCounter -= 1, $.refCounter === 0 && ($.bitmap = null));
            }
            isValidId(E) {
              return E.startsWith(`image_${e(this, s)}_`);
            }
          };
          s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakSet(), nn = async function(E, $) {
            e(this, l) || rt(this, l, /* @__PURE__ */ new Map());
            let tt = e(this, l).get(E);
            if (tt === null)
              return null;
            if (tt != null && tt.bitmap)
              return tt.refCounter += 1, tt;
            try {
              tt || (tt = {
                bitmap: null,
                id: `image_${e(this, s)}_${ue(this, o)._++}`,
                refCounter: 0,
                isSvg: !1
              });
              let ht;
              if (typeof $ == "string") {
                tt.url = $;
                const mt = await fetch($);
                if (!mt.ok)
                  throw new Error(mt.statusText);
                ht = await mt.blob();
              } else
                ht = tt.file = $;
              if (ht.type === "image/svg+xml") {
                const mt = p._isSVGFittingCanvas, Pt = new FileReader(), Ft = new Image(), Vt = new Promise((Dt, Qt) => {
                  Ft.onload = () => {
                    tt.bitmap = Ft, tt.isSvg = !0, Dt();
                  }, Pt.onload = async () => {
                    const Gt = tt.svgUrl = Pt.result;
                    Ft.src = await mt ? `${Gt}#svgView(preserveAspectRatio(none))` : Gt;
                  }, Ft.onerror = Pt.onerror = Qt;
                });
                Pt.readAsDataURL(ht), await Vt;
              } else
                tt.bitmap = await createImageBitmap(ht);
              tt.refCounter = 1;
            } catch (ht) {
              console.error(ht), tt = null;
            }
            return e(this, l).set(E, tt), tt && e(this, l).set(tt.id, tt), tt;
          };
          let y = p;
          class c {
            constructor() {
              W(this, C, []);
              W(this, r, !1);
              W(this, i, void 0);
              W(this, w, -1);
              let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;
              rt(this, i, E);
            }
            add(E) {
              let {
                cmd: $,
                undo: tt,
                mustExec: ht,
                type: mt = NaN,
                overwriteIfSameType: Pt = !1,
                keepUndo: Ft = !1
              } = E;
              if (ht && $(), e(this, r))
                return;
              const Vt = {
                cmd: $,
                undo: tt,
                type: mt
              };
              if (e(this, w) === -1) {
                e(this, C).length > 0 && (e(this, C).length = 0), rt(this, w, 0), e(this, C).push(Vt);
                return;
              }
              if (Pt && e(this, C)[e(this, w)].type === mt) {
                Ft && (Vt.undo = e(this, C)[e(this, w)].undo), e(this, C)[e(this, w)] = Vt;
                return;
              }
              const Dt = e(this, w) + 1;
              Dt === e(this, i) ? e(this, C).splice(0, 1) : (rt(this, w, Dt), Dt < e(this, C).length && e(this, C).splice(Dt)), e(this, C).push(Vt);
            }
            undo() {
              e(this, w) !== -1 && (rt(this, r, !0), e(this, C)[e(this, w)].undo(), rt(this, r, !1), rt(this, w, e(this, w) - 1));
            }
            redo() {
              e(this, w) < e(this, C).length - 1 && (rt(this, w, e(this, w) + 1), rt(this, r, !0), e(this, C)[e(this, w)].cmd(), rt(this, r, !1));
            }
            hasSomethingToUndo() {
              return e(this, w) !== -1;
            }
            hasSomethingToRedo() {
              return e(this, w) < e(this, C).length - 1;
            }
            destroy() {
              rt(this, C, null);
            }
          }
          C = new WeakMap(), r = new WeakMap(), i = new WeakMap(), w = new WeakMap(), S.CommandManager = c;
          class a {
            constructor(E) {
              W(this, x);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const {
                isMac: $
              } = n.FeatureTest.platform;
              for (const [tt, ht, mt = {}] of E)
                for (const Pt of tt) {
                  const Ft = Pt.startsWith("mac+");
                  $ && Ft ? (this.callbacks.set(Pt.slice(4), {
                    callback: ht,
                    options: mt
                  }), this.allKeys.add(Pt.split("+").at(-1))) : !$ && !Ft && (this.callbacks.set(Pt, {
                    callback: ht,
                    options: mt
                  }), this.allKeys.add(Pt.split("+").at(-1)));
                }
            }
            exec(E, $) {
              if (!this.allKeys.has($.key))
                return;
              const tt = this.callbacks.get(J(this, x, si).call(this, $));
              if (!tt)
                return;
              const {
                callback: ht,
                options: {
                  bubbles: mt = !1,
                  args: Pt = [],
                  checker: Ft = null
                }
              } = tt;
              Ft && !Ft(E, $) || (ht.bind(E, ...Pt)(), mt || ($.stopPropagation(), $.preventDefault()));
            }
          }
          x = new WeakSet(), si = function(E) {
            E.altKey && this.buffer.push("alt"), E.ctrlKey && this.buffer.push("ctrl"), E.metaKey && this.buffer.push("meta"), E.shiftKey && this.buffer.push("shift"), this.buffer.push(E.key);
            const $ = this.buffer.join("+");
            return this.buffer.length = 0, $;
          }, S.KeyboardManager = a;
          const F = class F {
            get _colors() {
              const E = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, h.getColorValues)(E), (0, n.shadow)(this, "_colors", E);
            }
            convert(E) {
              const $ = (0, h.getRGB)(E);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return $;
              for (const [tt, ht] of this._colors)
                if (ht.every((mt, Pt) => mt === $[Pt]))
                  return F._colorsMapping.get(tt);
              return $;
            }
            getHexCode(E) {
              const $ = this._colors.get(E);
              return $ ? n.Util.makeHexColor(...$) : E;
            }
          };
          ee(F, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
          let I = F;
          S.ColorManager = I;
          const Bt = class Bt {
            constructor(E, $, tt, ht, mt, Pt) {
              W(this, vt);
              W(this, Lt);
              W(this, Ht);
              W(this, Wt);
              W(this, Xt);
              W(this, Yt);
              W(this, V);
              W(this, st);
              W(this, Y);
              W(this, at);
              W(this, At);
              W(this, xt);
              W(this, kt);
              W(this, L, null);
              W(this, G, /* @__PURE__ */ new Map());
              W(this, nt, /* @__PURE__ */ new Map());
              W(this, D, null);
              W(this, X, null);
              W(this, q, new c());
              W(this, j, 0);
              W(this, z, /* @__PURE__ */ new Set());
              W(this, it, null);
              W(this, Q, null);
              W(this, Et, /* @__PURE__ */ new Set());
              W(this, Ct, null);
              W(this, H, new f());
              W(this, m, !1);
              W(this, k, !1);
              W(this, d, null);
              W(this, R, n.AnnotationEditorType.NONE);
              W(this, M, /* @__PURE__ */ new Set());
              W(this, B, null);
              W(this, _, this.blur.bind(this));
              W(this, Z, this.focus.bind(this));
              W(this, pt, this.copy.bind(this));
              W(this, dt, this.cut.bind(this));
              W(this, Tt, this.paste.bind(this));
              W(this, lt, this.keydown.bind(this));
              W(this, yt, this.onEditingAction.bind(this));
              W(this, bt, this.onPageChanging.bind(this));
              W(this, It, this.onScaleChanging.bind(this));
              W(this, Ot, this.onRotationChanging.bind(this));
              W(this, Mt, {
                isEditing: !1,
                isEmpty: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              W(this, gt, [0, 0]);
              W(this, ut, null);
              W(this, ct, null);
              W(this, ot, null);
              rt(this, ct, E), rt(this, ot, $), rt(this, D, tt), this._eventBus = ht, this._eventBus._on("editingaction", e(this, yt)), this._eventBus._on("pagechanging", e(this, bt)), this._eventBus._on("scalechanging", e(this, It)), this._eventBus._on("rotationchanging", e(this, Ot)), rt(this, X, mt.annotationStorage), rt(this, Ct, mt.filterFactory), rt(this, B, Pt), this.viewParameters = {
                realScale: h.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: 0
              };
            }
            static get _keyboardManager() {
              const E = Bt.prototype, $ = (mt) => {
                const {
                  activeElement: Pt
                } = document;
                return Pt && e(mt, ct).contains(Pt) && mt.hasSomethingToControl();
              }, tt = this.TRANSLATE_SMALL, ht = this.TRANSLATE_BIG;
              return (0, n.shadow)(this, "_keyboardManager", new a([[["ctrl+a", "mac+meta+a"], E.selectAll], [["ctrl+z", "mac+meta+z"], E.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], E.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], E.delete], [["Escape", "mac+Escape"], E.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], E.translateSelectedEditors, {
                args: [-tt, 0],
                checker: $
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], E.translateSelectedEditors, {
                args: [-ht, 0],
                checker: $
              }], [["ArrowRight", "mac+ArrowRight"], E.translateSelectedEditors, {
                args: [tt, 0],
                checker: $
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], E.translateSelectedEditors, {
                args: [ht, 0],
                checker: $
              }], [["ArrowUp", "mac+ArrowUp"], E.translateSelectedEditors, {
                args: [0, -tt],
                checker: $
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], E.translateSelectedEditors, {
                args: [0, -ht],
                checker: $
              }], [["ArrowDown", "mac+ArrowDown"], E.translateSelectedEditors, {
                args: [0, tt],
                checker: $
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], E.translateSelectedEditors, {
                args: [0, ht],
                checker: $
              }]]));
            }
            destroy() {
              J(this, Wt, Ie).call(this), J(this, Lt, rn).call(this), this._eventBus._off("editingaction", e(this, yt)), this._eventBus._off("pagechanging", e(this, bt)), this._eventBus._off("scalechanging", e(this, It)), this._eventBus._off("rotationchanging", e(this, Ot));
              for (const E of e(this, nt).values())
                E.destroy();
              e(this, nt).clear(), e(this, G).clear(), e(this, Et).clear(), rt(this, L, null), e(this, M).clear(), e(this, q).destroy(), e(this, D).destroy();
            }
            get hcmFilter() {
              return (0, n.shadow)(this, "hcmFilter", e(this, B) ? e(this, Ct).addHCMFilter(e(this, B).foreground, e(this, B).background) : "none");
            }
            get direction() {
              return (0, n.shadow)(this, "direction", getComputedStyle(e(this, ct)).direction);
            }
            editAltText(E) {
              var $;
              ($ = e(this, D)) == null || $.editAltText(this, E);
            }
            onPageChanging(E) {
              let {
                pageNumber: $
              } = E;
              rt(this, j, $ - 1);
            }
            focusMainContainer() {
              e(this, ct).focus();
            }
            findParent(E, $) {
              for (const tt of e(this, nt).values()) {
                const {
                  x: ht,
                  y: mt,
                  width: Pt,
                  height: Ft
                } = tt.div.getBoundingClientRect();
                if (E >= ht && E <= ht + Pt && $ >= mt && $ <= mt + Ft)
                  return tt;
              }
              return null;
            }
            disableUserSelect() {
              let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              e(this, ot).classList.toggle("noUserSelect", E);
            }
            addShouldRescale(E) {
              e(this, Et).add(E);
            }
            removeShouldRescale(E) {
              e(this, Et).delete(E);
            }
            onScaleChanging(E) {
              let {
                scale: $
              } = E;
              this.commitOrRemove(), this.viewParameters.realScale = $ * h.PixelsPerInch.PDF_TO_CSS_UNITS;
              for (const tt of e(this, Et))
                tt.onScaleChanging();
            }
            onRotationChanging(E) {
              let {
                pagesRotation: $
              } = E;
              this.commitOrRemove(), this.viewParameters.rotation = $;
            }
            addToAnnotationStorage(E) {
              !E.isEmpty() && e(this, X) && !e(this, X).has(E.id) && e(this, X).setValue(E.id, E);
            }
            blur() {
              if (!this.hasSelection)
                return;
              const {
                activeElement: E
              } = document;
              for (const $ of e(this, M))
                if ($.div.contains(E)) {
                  rt(this, d, [$, E]), $._focusEventsAllowed = !1;
                  break;
                }
            }
            focus() {
              if (!e(this, d))
                return;
              const [E, $] = e(this, d);
              rt(this, d, null), $.addEventListener("focusin", () => {
                E._focusEventsAllowed = !0;
              }, {
                once: !0
              }), $.focus();
            }
            addEditListeners() {
              J(this, Ht, sn).call(this), J(this, Xt, an).call(this);
            }
            removeEditListeners() {
              J(this, Wt, Ie).call(this), J(this, Yt, on).call(this);
            }
            copy(E) {
              var tt;
              if (E.preventDefault(), (tt = e(this, L)) == null || tt.commitOrRemove(), !this.hasSelection)
                return;
              const $ = [];
              for (const ht of e(this, M)) {
                const mt = ht.serialize(!0);
                mt && $.push(mt);
              }
              $.length !== 0 && E.clipboardData.setData("application/pdfjs", JSON.stringify($));
            }
            cut(E) {
              this.copy(E), this.delete();
            }
            paste(E) {
              E.preventDefault();
              const {
                clipboardData: $
              } = E;
              for (const mt of $.items)
                for (const Pt of e(this, Q))
                  if (Pt.isHandlingMimeForPasting(mt.type)) {
                    Pt.paste(mt, this.currentLayer);
                    return;
                  }
              let tt = $.getData("application/pdfjs");
              if (!tt)
                return;
              try {
                tt = JSON.parse(tt);
              } catch (mt) {
                (0, n.warn)(`paste: "${mt.message}".`);
                return;
              }
              if (!Array.isArray(tt))
                return;
              this.unselectAll();
              const ht = this.currentLayer;
              try {
                const mt = [];
                for (const Vt of tt) {
                  const Dt = ht.deserialize(Vt);
                  if (!Dt)
                    return;
                  mt.push(Dt);
                }
                const Pt = () => {
                  for (const Vt of mt)
                    J(this, At, ln).call(this, Vt);
                  J(this, kt, cn).call(this, mt);
                }, Ft = () => {
                  for (const Vt of mt)
                    Vt.remove();
                };
                this.addCommands({
                  cmd: Pt,
                  undo: Ft,
                  mustExec: !0
                });
              } catch (mt) {
                (0, n.warn)(`paste: "${mt.message}".`);
              }
            }
            keydown(E) {
              var $;
              ($ = this.getActive()) != null && $.shouldGetKeyboardEvents() || Bt._keyboardManager.exec(this, E);
            }
            onEditingAction(E) {
              ["undo", "redo", "delete", "selectAll"].includes(E.name) && this[E.name]();
            }
            setEditingState(E) {
              E ? (J(this, vt, ai).call(this), J(this, Ht, sn).call(this), J(this, Xt, an).call(this), J(this, V, se).call(this, {
                isEditing: e(this, R) !== n.AnnotationEditorType.NONE,
                isEmpty: J(this, xt, ye).call(this),
                hasSomethingToUndo: e(this, q).hasSomethingToUndo(),
                hasSomethingToRedo: e(this, q).hasSomethingToRedo(),
                hasSelectedEditor: !1
              })) : (J(this, Lt, rn).call(this), J(this, Wt, Ie).call(this), J(this, Yt, on).call(this), J(this, V, se).call(this, {
                isEditing: !1
              }), this.disableUserSelect(!1));
            }
            registerEditorTypes(E) {
              if (!e(this, Q)) {
                rt(this, Q, E);
                for (const $ of e(this, Q))
                  J(this, st, be).call(this, $.defaultPropertiesToUpdate);
              }
            }
            getId() {
              return e(this, H).getId();
            }
            get currentLayer() {
              return e(this, nt).get(e(this, j));
            }
            getLayer(E) {
              return e(this, nt).get(E);
            }
            get currentPageIndex() {
              return e(this, j);
            }
            addLayer(E) {
              e(this, nt).set(E.pageIndex, E), e(this, m) ? E.enable() : E.disable();
            }
            removeLayer(E) {
              e(this, nt).delete(E.pageIndex);
            }
            updateMode(E) {
              let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              if (e(this, R) !== E) {
                if (rt(this, R, E), E === n.AnnotationEditorType.NONE) {
                  this.setEditingState(!1), J(this, at, li).call(this);
                  return;
                }
                this.setEditingState(!0), J(this, Y, oi).call(this), this.unselectAll();
                for (const tt of e(this, nt).values())
                  tt.updateMode(E);
                if ($) {
                  for (const tt of e(this, G).values())
                    if (tt.annotationElementId === $) {
                      this.setSelected(tt), tt.enterInEditMode();
                      break;
                    }
                }
              }
            }
            updateToolbar(E) {
              E !== e(this, R) && this._eventBus.dispatch("switchannotationeditormode", {
                source: this,
                mode: E
              });
            }
            updateParams(E, $) {
              if (e(this, Q)) {
                if (E === n.AnnotationEditorParamsType.CREATE) {
                  this.currentLayer.addNewEditor(E);
                  return;
                }
                for (const tt of e(this, M))
                  tt.updateParams(E, $);
                for (const tt of e(this, Q))
                  tt.updateDefaultParams(E, $);
              }
            }
            enableWaiting() {
              let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (e(this, k) !== E) {
                rt(this, k, E);
                for (const $ of e(this, nt).values())
                  E ? $.disableClick() : $.enableClick(), $.div.classList.toggle("waiting", E);
              }
            }
            getEditors(E) {
              const $ = [];
              for (const tt of e(this, G).values())
                tt.pageIndex === E && $.push(tt);
              return $;
            }
            getEditor(E) {
              return e(this, G).get(E);
            }
            addEditor(E) {
              e(this, G).set(E.id, E);
            }
            removeEditor(E) {
              var $;
              e(this, G).delete(E.id), this.unselect(E), (!E.annotationElementId || !e(this, z).has(E.annotationElementId)) && (($ = e(this, X)) == null || $.remove(E.id));
            }
            addDeletedAnnotationElement(E) {
              e(this, z).add(E.annotationElementId), E.deleted = !0;
            }
            isDeletedAnnotationElement(E) {
              return e(this, z).has(E);
            }
            removeDeletedAnnotationElement(E) {
              e(this, z).delete(E.annotationElementId), E.deleted = !1;
            }
            setActiveEditor(E) {
              e(this, L) !== E && (rt(this, L, E), E && J(this, st, be).call(this, E.propertiesToUpdate));
            }
            toggleSelected(E) {
              if (e(this, M).has(E)) {
                e(this, M).delete(E), E.unselect(), J(this, V, se).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              e(this, M).add(E), E.select(), J(this, st, be).call(this, E.propertiesToUpdate), J(this, V, se).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(E) {
              for (const $ of e(this, M))
                $ !== E && $.unselect();
              e(this, M).clear(), e(this, M).add(E), E.select(), J(this, st, be).call(this, E.propertiesToUpdate), J(this, V, se).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(E) {
              return e(this, M).has(E);
            }
            unselect(E) {
              E.unselect(), e(this, M).delete(E), J(this, V, se).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return e(this, M).size !== 0;
            }
            undo() {
              e(this, q).undo(), J(this, V, se).call(this, {
                hasSomethingToUndo: e(this, q).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: J(this, xt, ye).call(this)
              });
            }
            redo() {
              e(this, q).redo(), J(this, V, se).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: e(this, q).hasSomethingToRedo(),
                isEmpty: J(this, xt, ye).call(this)
              });
            }
            addCommands(E) {
              e(this, q).add(E), J(this, V, se).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: J(this, xt, ye).call(this)
              });
            }
            delete() {
              if (this.commitOrRemove(), !this.hasSelection)
                return;
              const E = [...e(this, M)], $ = () => {
                for (const ht of E)
                  ht.remove();
              }, tt = () => {
                for (const ht of E)
                  J(this, At, ln).call(this, ht);
              };
              this.addCommands({
                cmd: $,
                undo: tt,
                mustExec: !0
              });
            }
            commitOrRemove() {
              var E;
              (E = e(this, L)) == null || E.commitOrRemove();
            }
            hasSomethingToControl() {
              return e(this, L) || this.hasSelection;
            }
            selectAll() {
              for (const E of e(this, M))
                E.commit();
              J(this, kt, cn).call(this, e(this, G).values());
            }
            unselectAll() {
              if (e(this, L)) {
                e(this, L).commitOrRemove();
                return;
              }
              if (this.hasSelection) {
                for (const E of e(this, M))
                  E.unselect();
                e(this, M).clear(), J(this, V, se).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            translateSelectedEditors(E, $) {
              if ((arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1) || this.commitOrRemove(), !this.hasSelection)
                return;
              e(this, gt)[0] += E, e(this, gt)[1] += $;
              const [ht, mt] = e(this, gt), Pt = [...e(this, M)], Ft = 1e3;
              e(this, ut) && clearTimeout(e(this, ut)), rt(this, ut, setTimeout(() => {
                rt(this, ut, null), e(this, gt)[0] = e(this, gt)[1] = 0, this.addCommands({
                  cmd: () => {
                    for (const Vt of Pt)
                      e(this, G).has(Vt.id) && Vt.translateInPage(ht, mt);
                  },
                  undo: () => {
                    for (const Vt of Pt)
                      e(this, G).has(Vt.id) && Vt.translateInPage(-ht, -mt);
                  },
                  mustExec: !1
                });
              }, Ft));
              for (const Vt of Pt)
                Vt.translateInPage(E, $);
            }
            setUpDragSession() {
              if (this.hasSelection) {
                this.disableUserSelect(!0), rt(this, it, /* @__PURE__ */ new Map());
                for (const E of e(this, M))
                  e(this, it).set(E, {
                    savedX: E.x,
                    savedY: E.y,
                    savedPageIndex: E.pageIndex,
                    newX: 0,
                    newY: 0,
                    newPageIndex: -1
                  });
              }
            }
            endDragSession() {
              if (!e(this, it))
                return !1;
              this.disableUserSelect(!1);
              const E = e(this, it);
              rt(this, it, null);
              let $ = !1;
              for (const [{
                x: ht,
                y: mt,
                pageIndex: Pt
              }, Ft] of E)
                Ft.newX = ht, Ft.newY = mt, Ft.newPageIndex = Pt, $ || ($ = ht !== Ft.savedX || mt !== Ft.savedY || Pt !== Ft.savedPageIndex);
              if (!$)
                return !1;
              const tt = (ht, mt, Pt, Ft) => {
                if (e(this, G).has(ht.id)) {
                  const Vt = e(this, nt).get(Ft);
                  Vt ? ht._setParentAndPosition(Vt, mt, Pt) : (ht.pageIndex = Ft, ht.x = mt, ht.y = Pt);
                }
              };
              return this.addCommands({
                cmd: () => {
                  for (const [ht, {
                    newX: mt,
                    newY: Pt,
                    newPageIndex: Ft
                  }] of E)
                    tt(ht, mt, Pt, Ft);
                },
                undo: () => {
                  for (const [ht, {
                    savedX: mt,
                    savedY: Pt,
                    savedPageIndex: Ft
                  }] of E)
                    tt(ht, mt, Pt, Ft);
                },
                mustExec: !0
              }), !0;
            }
            dragSelectedEditors(E, $) {
              if (e(this, it))
                for (const tt of e(this, it).keys())
                  tt.drag(E, $);
            }
            rebuild(E) {
              if (E.parent === null) {
                const $ = this.getLayer(E.pageIndex);
                $ ? ($.changeParent(E), $.addOrRebuild(E)) : (this.addEditor(E), this.addToAnnotationStorage(E), E.rebuild());
              } else
                E.parent.addOrRebuild(E);
            }
            isActive(E) {
              return e(this, L) === E;
            }
            getActive() {
              return e(this, L);
            }
            getMode() {
              return e(this, R);
            }
            get imageManager() {
              return (0, n.shadow)(this, "imageManager", new y());
            }
          };
          L = new WeakMap(), G = new WeakMap(), nt = new WeakMap(), D = new WeakMap(), X = new WeakMap(), q = new WeakMap(), j = new WeakMap(), z = new WeakMap(), it = new WeakMap(), Q = new WeakMap(), Et = new WeakMap(), Ct = new WeakMap(), H = new WeakMap(), m = new WeakMap(), k = new WeakMap(), d = new WeakMap(), R = new WeakMap(), M = new WeakMap(), B = new WeakMap(), _ = new WeakMap(), Z = new WeakMap(), pt = new WeakMap(), dt = new WeakMap(), Tt = new WeakMap(), lt = new WeakMap(), yt = new WeakMap(), bt = new WeakMap(), It = new WeakMap(), Ot = new WeakMap(), Mt = new WeakMap(), gt = new WeakMap(), ut = new WeakMap(), ct = new WeakMap(), ot = new WeakMap(), vt = new WeakSet(), ai = function() {
            window.addEventListener("focus", e(this, Z)), window.addEventListener("blur", e(this, _));
          }, Lt = new WeakSet(), rn = function() {
            window.removeEventListener("focus", e(this, Z)), window.removeEventListener("blur", e(this, _));
          }, Ht = new WeakSet(), sn = function() {
            window.addEventListener("keydown", e(this, lt), {
              capture: !0
            });
          }, Wt = new WeakSet(), Ie = function() {
            window.removeEventListener("keydown", e(this, lt), {
              capture: !0
            });
          }, Xt = new WeakSet(), an = function() {
            document.addEventListener("copy", e(this, pt)), document.addEventListener("cut", e(this, dt)), document.addEventListener("paste", e(this, Tt));
          }, Yt = new WeakSet(), on = function() {
            document.removeEventListener("copy", e(this, pt)), document.removeEventListener("cut", e(this, dt)), document.removeEventListener("paste", e(this, Tt));
          }, V = new WeakSet(), se = function(E) {
            Object.entries(E).some((tt) => {
              let [ht, mt] = tt;
              return e(this, Mt)[ht] !== mt;
            }) && this._eventBus.dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(e(this, Mt), E)
            });
          }, st = new WeakSet(), be = function(E) {
            this._eventBus.dispatch("annotationeditorparamschanged", {
              source: this,
              details: E
            });
          }, Y = new WeakSet(), oi = function() {
            if (!e(this, m)) {
              rt(this, m, !0);
              for (const E of e(this, nt).values())
                E.enable();
            }
          }, at = new WeakSet(), li = function() {
            if (this.unselectAll(), e(this, m)) {
              rt(this, m, !1);
              for (const E of e(this, nt).values())
                E.disable();
            }
          }, At = new WeakSet(), ln = function(E) {
            const $ = e(this, nt).get(E.pageIndex);
            $ ? $.addOrRebuild(E) : this.addEditor(E);
          }, xt = new WeakSet(), ye = function() {
            if (e(this, G).size === 0)
              return !0;
            if (e(this, G).size === 1)
              for (const E of e(this, G).values())
                return E.isEmpty();
            return !1;
          }, kt = new WeakSet(), cn = function(E) {
            e(this, M).clear();
            for (const $ of E)
              $.isEmpty() || (e(this, M).add($), $.select());
            J(this, V, se).call(this, {
              hasSelectedEditor: !0
            });
          }, ee(Bt, "TRANSLATE_SMALL", 1), ee(Bt, "TRANSLATE_BIG", 10);
          let A = Bt;
          S.AnnotationEditorUIManager = A;
        },
        /* 166 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(6), T = t(4), P = t(24), f = t(14), y = t(8), c = t(21), a = t(20), I = t(91), A = t(39), g = t(77), s = t(64), o = t(159), l = t(7), u = t(167), v = t(27), p = T.JSON, C = T.Number, r = T.SyntaxError, i = p && p.parse, w = P("Object", "keys"), x = Object.getOwnPropertyDescriptor, b = f("".charAt), F = f("".slice), L = f(/./.exec), G = f([].push), nt = /^\d$/, D = /^[1-9]$/, X = /^(?:-|\d)$/, q = /^[\t\n\r ]$/, j = 0, z = 1, it = function(d, R) {
            d = g(d);
            var M = new H(d, 0), B = M.parse(), _ = B.value, Z = M.skip(q, B.end);
            if (Z < d.length)
              throw r('Unexpected extra character: "' + b(d, Z) + '" after the parsed data at: ' + Z);
            return c(R) ? Q({ "": _ }, "", R, B) : _;
          }, Q = function(d, R, M, B) {
            var _ = d[R], Z = B && _ === B.value, pt = Z && typeof B.source == "string" ? { source: B.source } : {}, dt, Tt, lt, yt, bt;
            if (a(_)) {
              var It = I(_), Ot = Z ? B.nodes : It ? [] : {};
              if (It)
                for (dt = Ot.length, lt = s(_), yt = 0; yt < lt; yt++)
                  Et(_, yt, Q(_, "" + yt, M, yt < dt ? Ot[yt] : void 0));
              else
                for (Tt = w(_), lt = s(Tt), yt = 0; yt < lt; yt++)
                  bt = Tt[yt], Et(_, bt, Q(_, bt, M, A(Ot, bt) ? Ot[bt] : void 0));
            }
            return y(M, d, R, _, pt);
          }, Et = function(d, R, M) {
            if (h) {
              var B = x(d, R);
              if (B && !B.configurable)
                return;
            }
            M === void 0 ? delete d[R] : o(d, R, M);
          }, Ct = function(d, R, M, B) {
            this.value = d, this.end = R, this.source = M, this.nodes = B;
          }, H = function(d, R) {
            this.source = d, this.index = R;
          };
          H.prototype = {
            fork: function(d) {
              return new H(this.source, d);
            },
            parse: function() {
              var d = this.source, R = this.skip(q, this.index), M = this.fork(R), B = b(d, R);
              if (L(X, B))
                return M.number();
              switch (B) {
                case "{":
                  return M.object();
                case "[":
                  return M.array();
                case '"':
                  return M.string();
                case "t":
                  return M.keyword(!0);
                case "f":
                  return M.keyword(!1);
                case "n":
                  return M.keyword(null);
              }
              throw r('Unexpected character: "' + B + '" at: ' + R);
            },
            node: function(d, R, M, B, _) {
              return new Ct(R, B, d ? null : F(this.source, M, B), _);
            },
            object: function() {
              for (var d = this.source, R = this.index + 1, M = !1, B = {}, _ = {}; R < d.length; ) {
                if (R = this.until([
                  '"',
                  "}"
                ], R), b(d, R) === "}" && !M) {
                  R++;
                  break;
                }
                var Z = this.fork(R).string(), pt = Z.value;
                R = Z.end, R = this.until([":"], R) + 1, R = this.skip(q, R), Z = this.fork(R).parse(), o(_, pt, Z), o(B, pt, Z.value), R = this.until([
                  ",",
                  "}"
                ], Z.end);
                var dt = b(d, R);
                if (dt === ",")
                  M = !0, R++;
                else if (dt === "}") {
                  R++;
                  break;
                }
              }
              return this.node(z, B, this.index, R, _);
            },
            array: function() {
              for (var d = this.source, R = this.index + 1, M = !1, B = [], _ = []; R < d.length; ) {
                if (R = this.skip(q, R), b(d, R) === "]" && !M) {
                  R++;
                  break;
                }
                var Z = this.fork(R).parse();
                if (G(_, Z), G(B, Z.value), R = this.until([
                  ",",
                  "]"
                ], Z.end), b(d, R) === ",")
                  M = !0, R++;
                else if (b(d, R) === "]") {
                  R++;
                  break;
                }
              }
              return this.node(z, B, this.index, R, _);
            },
            string: function() {
              var d = this.index, R = u(this.source, this.index + 1);
              return this.node(j, R.value, d, R.end);
            },
            number: function() {
              var d = this.source, R = this.index, M = R;
              if (b(d, M) === "-" && M++, b(d, M) === "0")
                M++;
              else if (L(D, b(d, M)))
                M = this.skip(nt, ++M);
              else
                throw r("Failed to parse number at: " + M);
              if (b(d, M) === "." && (M = this.skip(nt, ++M)), b(d, M) === "e" || b(d, M) === "E") {
                M++, (b(d, M) === "+" || b(d, M) === "-") && M++;
                var B = M;
                if (M = this.skip(nt, M), B === M)
                  throw r("Failed to parse number's exponent value at: " + M);
              }
              return this.node(j, C(F(d, R, M)), R, M);
            },
            keyword: function(d) {
              var R = "" + d, M = this.index, B = M + R.length;
              if (F(this.source, M, B) !== R)
                throw r("Failed to parse value at: " + M);
              return this.node(j, d, M, B);
            },
            skip: function(d, R) {
              for (var M = this.source; R < M.length && L(d, b(M, R)); R++)
                ;
              return R;
            },
            until: function(d, R) {
              R = this.skip(q, R);
              for (var M = b(this.source, R), B = 0; B < d.length; B++)
                if (d[B] === M)
                  return R;
              throw r('Unexpected character: "' + M + '" at: ' + R);
            }
          };
          var m = l(function() {
            var d = "9007199254740993", R;
            return i(d, function(M, B, _) {
              R = _.source;
            }), R !== d;
          }), k = v && !l(function() {
            return 1 / i("-0 	") !== -1 / 0;
          });
          n({
            target: "JSON",
            stat: !0,
            forced: m
          }, {
            parse: function(R, M) {
              return k && !c(M) ? i(R) : it(R, M);
            }
          });
        },
        /* 167 */
        /***/
        (O, S, t) => {
          var n = t(14), h = t(39), T = SyntaxError, P = parseInt, f = String.fromCharCode, y = n("".charAt), c = n("".slice), a = n(/./.exec), I = {
            '\\"': '"',
            "\\\\": "\\",
            "\\/": "/",
            "\\b": "\b",
            "\\f": "\f",
            "\\n": `
`,
            "\\r": "\r",
            "\\t": "	"
          }, A = /^[\da-f]{4}$/i, g = /^[\u0000-\u001F]$/;
          O.exports = function(s, o) {
            for (var l = !0, u = ""; o < s.length; ) {
              var v = y(s, o);
              if (v === "\\") {
                var p = c(s, o, o + 2);
                if (h(I, p))
                  u += I[p], o += 2;
                else if (p === "\\u") {
                  o += 2;
                  var C = c(s, o, o + 4);
                  if (!a(A, C))
                    throw T("Bad Unicode escape at: " + o);
                  u += f(P(C, 16)), o += 4;
                } else
                  throw T('Unknown escape sequence: "' + p + '"');
              } else if (v === '"') {
                l = !1, o++;
                break;
              } else {
                if (a(g, v))
                  throw T("Bad control character in string literal at: " + o);
                u += v, o++;
              }
            }
            if (l)
              throw T("Unterminated string at: " + o);
            return {
              value: u,
              end: o
            };
          };
        },
        /* 168 */
        /***/
        (O, S, t) => {
          var j, z, it, Q, Et, Ct, H, m, k, d, R, M, fe, _, pe, pt, hn, Tt, Le, yt, Oe, It, Ae, Mt, Se;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.StatTimer = S.RenderingCancelledException = S.PixelsPerInch = S.PageViewport = S.PDFDateString = S.DOMStandardFontDataFactory = S.DOMSVGFactory = S.DOMFilterFactory = S.DOMCanvasFactory = S.DOMCMapReaderFactory = void 0, S.deprecated = w, S.getColorValues = G, S.getCurrentTransform = nt, S.getCurrentTransformInverse = D, S.getFilenameFromUrl = u, S.getPdfFilenameFromUrl = v, S.getRGB = L, S.getXfaPageViewport = F, S.isDataScheme = o, S.isPdfFile = l, S.isValidFetchUrl = C, S.loadScript = i, S.noContextMenu = r, S.setLayerDimensions = X, t(2), t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(89), t(84), t(86), t(87);
          var n = t(169), h = t(1);
          const T = "http://www.w3.org/2000/svg", q = class q {
          };
          ee(q, "CSS", 96), ee(q, "PDF", 72), ee(q, "PDF_TO_CSS_UNITS", q.CSS / q.PDF);
          let P = q;
          S.PixelsPerInch = P;
          class f extends n.BaseFilterFactory {
            constructor() {
              let {
                docId: ot,
                ownerDocument: vt = globalThis.document
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super();
              W(this, M);
              W(this, _);
              W(this, pt);
              W(this, Tt);
              W(this, yt);
              W(this, It);
              W(this, Mt);
              W(this, j, void 0);
              W(this, z, void 0);
              W(this, it, void 0);
              W(this, Q, void 0);
              W(this, Et, void 0);
              W(this, Ct, void 0);
              W(this, H, void 0);
              W(this, m, void 0);
              W(this, k, void 0);
              W(this, d, void 0);
              W(this, R, 0);
              rt(this, it, ot), rt(this, Q, vt);
            }
            addFilter(ot) {
              if (!ot)
                return "none";
              let vt = e(this, M, fe).get(ot);
              if (vt)
                return vt;
              let wt, Lt, Ut, Ht;
              if (ot.length === 1) {
                const Xt = ot[0], Zt = new Array(256);
                for (let Yt = 0; Yt < 256; Yt++)
                  Zt[Yt] = Xt[Yt] / 255;
                Ht = wt = Lt = Ut = Zt.join(",");
              } else {
                const [Xt, Zt, Yt] = ot, N = new Array(256), V = new Array(256), K = new Array(256);
                for (let st = 0; st < 256; st++)
                  N[st] = Xt[st] / 255, V[st] = Zt[st] / 255, K[st] = Yt[st] / 255;
                wt = N.join(","), Lt = V.join(","), Ut = K.join(","), Ht = `${wt}${Lt}${Ut}`;
              }
              if (vt = e(this, M, fe).get(Ht), vt)
                return e(this, M, fe).set(ot, vt), vt;
              const $t = `g_${e(this, it)}_transfer_map_${ue(this, R)._++}`, Wt = `url(#${$t})`;
              e(this, M, fe).set(ot, Wt), e(this, M, fe).set(Ht, Wt);
              const Jt = J(this, Tt, Le).call(this, $t);
              return J(this, It, Ae).call(this, wt, Lt, Ut, Jt), Wt;
            }
            addHCMFilter(ot, vt) {
              var Zt;
              const wt = `${ot}-${vt}`;
              if (e(this, Ct) === wt)
                return e(this, H);
              if (rt(this, Ct, wt), rt(this, H, "none"), (Zt = e(this, Et)) == null || Zt.remove(), !ot || !vt)
                return e(this, H);
              const Lt = J(this, Mt, Se).call(this, ot);
              ot = h.Util.makeHexColor(...Lt);
              const Ut = J(this, Mt, Se).call(this, vt);
              if (vt = h.Util.makeHexColor(...Ut), e(this, _, pe).style.color = "", ot === "#000000" && vt === "#ffffff" || ot === vt)
                return e(this, H);
              const Ht = new Array(256);
              for (let Yt = 0; Yt <= 255; Yt++) {
                const N = Yt / 255;
                Ht[Yt] = N <= 0.03928 ? N / 12.92 : ((N + 0.055) / 1.055) ** 2.4;
              }
              const $t = Ht.join(","), Wt = `g_${e(this, it)}_hcm_filter`, Jt = rt(this, m, J(this, Tt, Le).call(this, Wt));
              J(this, It, Ae).call(this, $t, $t, $t, Jt), J(this, pt, hn).call(this, Jt);
              const Xt = (Yt, N) => {
                const V = Lt[Yt] / 255, K = Ut[Yt] / 255, st = new Array(N + 1);
                for (let ft = 0; ft <= N; ft++)
                  st[ft] = V + ft / N * (K - V);
                return st.join(",");
              };
              return J(this, It, Ae).call(this, Xt(0, 5), Xt(1, 5), Xt(2, 5), Jt), rt(this, H, `url(#${Wt})`), e(this, H);
            }
            addHighlightHCMFilter(ot, vt, wt, Lt) {
              var K;
              const Ut = `${ot}-${vt}-${wt}-${Lt}`;
              if (e(this, k) === Ut)
                return e(this, d);
              if (rt(this, k, Ut), rt(this, d, "none"), (K = e(this, m)) == null || K.remove(), !ot || !vt)
                return e(this, d);
              const [Ht, $t] = [ot, vt].map(J(this, Mt, Se).bind(this));
              let Wt = Math.round(0.2126 * Ht[0] + 0.7152 * Ht[1] + 0.0722 * Ht[2]), Jt = Math.round(0.2126 * $t[0] + 0.7152 * $t[1] + 0.0722 * $t[2]), [Xt, Zt] = [wt, Lt].map(J(this, Mt, Se).bind(this));
              Jt < Wt && ([Wt, Jt, Xt, Zt] = [Jt, Wt, Zt, Xt]), e(this, _, pe).style.color = "";
              const Yt = (st, ft, Y) => {
                const U = new Array(256), at = (Jt - Wt) / Y, St = st / 255, At = (ft - st) / (255 * Y);
                let Rt = 0;
                for (let xt = 0; xt <= Y; xt++) {
                  const Nt = Math.round(Wt + xt * at), kt = St + xt * At;
                  for (let _t = Rt; _t <= Nt; _t++)
                    U[_t] = kt;
                  Rt = Nt + 1;
                }
                for (let xt = Rt; xt < 256; xt++)
                  U[xt] = U[Rt - 1];
                return U.join(",");
              }, N = `g_${e(this, it)}_hcm_highlight_filter`, V = rt(this, m, J(this, Tt, Le).call(this, N));
              return J(this, pt, hn).call(this, V), J(this, It, Ae).call(this, Yt(Xt[0], Zt[0], 5), Yt(Xt[1], Zt[1], 5), Yt(Xt[2], Zt[2], 5), V), rt(this, d, `url(#${N})`), e(this, d);
            }
            destroy() {
              arguments.length > 0 && arguments[0] !== void 0 && arguments[0] && (e(this, H) || e(this, d)) || (e(this, z) && (e(this, z).parentNode.parentNode.remove(), rt(this, z, null)), e(this, j) && (e(this, j).clear(), rt(this, j, null)), rt(this, R, 0));
            }
          }
          j = new WeakMap(), z = new WeakMap(), it = new WeakMap(), Q = new WeakMap(), Et = new WeakMap(), Ct = new WeakMap(), H = new WeakMap(), m = new WeakMap(), k = new WeakMap(), d = new WeakMap(), R = new WeakMap(), M = new WeakSet(), fe = function() {
            return e(this, j) || rt(this, j, /* @__PURE__ */ new Map());
          }, _ = new WeakSet(), pe = function() {
            if (!e(this, z)) {
              const ot = e(this, Q).createElement("div"), {
                style: vt
              } = ot;
              vt.visibility = "hidden", vt.contain = "strict", vt.width = vt.height = 0, vt.position = "absolute", vt.top = vt.left = 0, vt.zIndex = -1;
              const wt = e(this, Q).createElementNS(T, "svg");
              wt.setAttribute("width", 0), wt.setAttribute("height", 0), rt(this, z, e(this, Q).createElementNS(T, "defs")), ot.append(wt), wt.append(e(this, z)), e(this, Q).body.append(ot);
            }
            return e(this, z);
          }, pt = new WeakSet(), hn = function(ot) {
            const vt = e(this, Q).createElementNS(T, "feColorMatrix");
            vt.setAttribute("type", "matrix"), vt.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), ot.append(vt);
          }, Tt = new WeakSet(), Le = function(ot) {
            const vt = e(this, Q).createElementNS(T, "filter");
            return vt.setAttribute("color-interpolation-filters", "sRGB"), vt.setAttribute("id", ot), e(this, _, pe).append(vt), vt;
          }, yt = new WeakSet(), Oe = function(ot, vt, wt) {
            const Lt = e(this, Q).createElementNS(T, vt);
            Lt.setAttribute("type", "discrete"), Lt.setAttribute("tableValues", wt), ot.append(Lt);
          }, It = new WeakSet(), Ae = function(ot, vt, wt, Lt) {
            const Ut = e(this, Q).createElementNS(T, "feComponentTransfer");
            Lt.append(Ut), J(this, yt, Oe).call(this, Ut, "feFuncR", ot), J(this, yt, Oe).call(this, Ut, "feFuncG", vt), J(this, yt, Oe).call(this, Ut, "feFuncB", wt);
          }, Mt = new WeakSet(), Se = function(ot) {
            return e(this, _, pe).style.color = ot, L(getComputedStyle(e(this, _, pe)).getPropertyValue("color"));
          }, S.DOMFilterFactory = f;
          class y extends n.BaseCanvasFactory {
            constructor() {
              let {
                ownerDocument: ct = globalThis.document
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              super(), this._document = ct;
            }
            _createCanvas(ct, ot) {
              const vt = this._document.createElement("canvas");
              return vt.width = ct, vt.height = ot, vt;
            }
          }
          S.DOMCanvasFactory = y;
          async function c(ut) {
            let ct = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            if (C(ut, document.baseURI)) {
              const ot = await fetch(ut);
              if (!ot.ok)
                throw new Error(ot.statusText);
              return ct ? new Uint8Array(await ot.arrayBuffer()) : (0, h.stringToBytes)(await ot.text());
            }
            return new Promise((ot, vt) => {
              const wt = new XMLHttpRequest();
              wt.open("GET", ut, !0), ct && (wt.responseType = "arraybuffer"), wt.onreadystatechange = () => {
                if (wt.readyState === XMLHttpRequest.DONE) {
                  if (wt.status === 200 || wt.status === 0) {
                    let Lt;
                    if (ct && wt.response ? Lt = new Uint8Array(wt.response) : !ct && wt.responseText && (Lt = (0, h.stringToBytes)(wt.responseText)), Lt) {
                      ot(Lt);
                      return;
                    }
                  }
                  vt(new Error(wt.statusText));
                }
              }, wt.send(null);
            });
          }
          class a extends n.BaseCMapReaderFactory {
            _fetchData(ct, ot) {
              return c(ct, this.isCompressed).then((vt) => ({
                cMapData: vt,
                compressionType: ot
              }));
            }
          }
          S.DOMCMapReaderFactory = a;
          class I extends n.BaseStandardFontDataFactory {
            _fetchData(ct) {
              return c(ct, !0);
            }
          }
          S.DOMStandardFontDataFactory = I;
          class A extends n.BaseSVGFactory {
            _createSVG(ct) {
              return document.createElementNS(T, ct);
            }
          }
          S.DOMSVGFactory = A;
          class g {
            constructor(ct) {
              let {
                viewBox: ot,
                scale: vt,
                rotation: wt,
                offsetX: Lt = 0,
                offsetY: Ut = 0,
                dontFlip: Ht = !1
              } = ct;
              this.viewBox = ot, this.scale = vt, this.rotation = wt, this.offsetX = Lt, this.offsetY = Ut;
              const $t = (ot[2] + ot[0]) / 2, Wt = (ot[3] + ot[1]) / 2;
              let Jt, Xt, Zt, Yt;
              switch (wt %= 360, wt < 0 && (wt += 360), wt) {
                case 180:
                  Jt = -1, Xt = 0, Zt = 0, Yt = 1;
                  break;
                case 90:
                  Jt = 0, Xt = 1, Zt = 1, Yt = 0;
                  break;
                case 270:
                  Jt = 0, Xt = -1, Zt = -1, Yt = 0;
                  break;
                case 0:
                  Jt = 1, Xt = 0, Zt = 0, Yt = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              Ht && (Zt = -Zt, Yt = -Yt);
              let N, V, K, st;
              Jt === 0 ? (N = Math.abs(Wt - ot[1]) * vt + Lt, V = Math.abs($t - ot[0]) * vt + Ut, K = (ot[3] - ot[1]) * vt, st = (ot[2] - ot[0]) * vt) : (N = Math.abs($t - ot[0]) * vt + Lt, V = Math.abs(Wt - ot[1]) * vt + Ut, K = (ot[2] - ot[0]) * vt, st = (ot[3] - ot[1]) * vt), this.transform = [Jt * vt, Xt * vt, Zt * vt, Yt * vt, N - Jt * vt * $t - Zt * vt * Wt, V - Xt * vt * $t - Yt * vt * Wt], this.width = K, this.height = st;
            }
            get rawDims() {
              const {
                viewBox: ct
              } = this;
              return (0, h.shadow)(this, "rawDims", {
                pageWidth: ct[2] - ct[0],
                pageHeight: ct[3] - ct[1],
                pageX: ct[0],
                pageY: ct[1]
              });
            }
            clone() {
              let {
                scale: ct = this.scale,
                rotation: ot = this.rotation,
                offsetX: vt = this.offsetX,
                offsetY: wt = this.offsetY,
                dontFlip: Lt = !1
              } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return new g({
                viewBox: this.viewBox.slice(),
                scale: ct,
                rotation: ot,
                offsetX: vt,
                offsetY: wt,
                dontFlip: Lt
              });
            }
            convertToViewportPoint(ct, ot) {
              return h.Util.applyTransform([ct, ot], this.transform);
            }
            convertToViewportRectangle(ct) {
              const ot = h.Util.applyTransform([ct[0], ct[1]], this.transform), vt = h.Util.applyTransform([ct[2], ct[3]], this.transform);
              return [ot[0], ot[1], vt[0], vt[1]];
            }
            convertToPdfPoint(ct, ot) {
              return h.Util.applyInverseTransform([ct, ot], this.transform);
            }
          }
          S.PageViewport = g;
          class s extends h.BaseException {
            constructor(ct) {
              let ot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              super(ct, "RenderingCancelledException"), this.extraDelay = ot;
            }
          }
          S.RenderingCancelledException = s;
          function o(ut) {
            const ct = ut.length;
            let ot = 0;
            for (; ot < ct && ut[ot].trim() === ""; )
              ot++;
            return ut.substring(ot, ot + 5).toLowerCase() === "data:";
          }
          function l(ut) {
            return typeof ut == "string" && /\.pdf$/i.test(ut);
          }
          function u(ut) {
            return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) || ([ut] = ut.split(/[#?]/, 1)), ut.substring(ut.lastIndexOf("/") + 1);
          }
          function v(ut) {
            let ct = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "document.pdf";
            if (typeof ut != "string")
              return ct;
            if (o(ut))
              return (0, h.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), ct;
            const ot = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, vt = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, wt = ot.exec(ut);
            let Lt = vt.exec(wt[1]) || vt.exec(wt[2]) || vt.exec(wt[3]);
            if (Lt && (Lt = Lt[0], Lt.includes("%")))
              try {
                Lt = vt.exec(decodeURIComponent(Lt))[0];
              } catch {
              }
            return Lt || ct;
          }
          class p {
            constructor() {
              ee(this, "started", /* @__PURE__ */ Object.create(null));
              ee(this, "times", []);
            }
            time(ct) {
              ct in this.started && (0, h.warn)(`Timer is already running for ${ct}`), this.started[ct] = Date.now();
            }
            timeEnd(ct) {
              ct in this.started || (0, h.warn)(`Timer has not been started for ${ct}`), this.times.push({
                name: ct,
                start: this.started[ct],
                end: Date.now()
              }), delete this.started[ct];
            }
            toString() {
              const ct = [];
              let ot = 0;
              for (const {
                name: vt
              } of this.times)
                ot = Math.max(vt.length, ot);
              for (const {
                name: vt,
                start: wt,
                end: Lt
              } of this.times)
                ct.push(`${vt.padEnd(ot)} ${Lt - wt}ms
`);
              return ct.join("");
            }
          }
          S.StatTimer = p;
          function C(ut, ct) {
            try {
              const {
                protocol: ot
              } = ct ? new URL(ut, ct) : new URL(ut);
              return ot === "http:" || ot === "https:";
            } catch {
              return !1;
            }
          }
          function r(ut) {
            ut.preventDefault();
          }
          function i(ut) {
            let ct = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return new Promise((ot, vt) => {
              const wt = document.createElement("script");
              wt.src = ut, wt.onload = function(Lt) {
                ct && wt.remove(), ot(Lt);
              }, wt.onerror = function() {
                vt(new Error(`Cannot load script at: ${wt.src}`));
              }, (document.head || document.documentElement).append(wt);
            });
          }
          function w(ut) {
            console.log("Deprecated API usage: " + ut);
          }
          let x;
          class b {
            static toDateObject(ct) {
              if (!ct || typeof ct != "string")
                return null;
              x || (x = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const ot = x.exec(ct);
              if (!ot)
                return null;
              const vt = parseInt(ot[1], 10);
              let wt = parseInt(ot[2], 10);
              wt = wt >= 1 && wt <= 12 ? wt - 1 : 0;
              let Lt = parseInt(ot[3], 10);
              Lt = Lt >= 1 && Lt <= 31 ? Lt : 1;
              let Ut = parseInt(ot[4], 10);
              Ut = Ut >= 0 && Ut <= 23 ? Ut : 0;
              let Ht = parseInt(ot[5], 10);
              Ht = Ht >= 0 && Ht <= 59 ? Ht : 0;
              let $t = parseInt(ot[6], 10);
              $t = $t >= 0 && $t <= 59 ? $t : 0;
              const Wt = ot[7] || "Z";
              let Jt = parseInt(ot[8], 10);
              Jt = Jt >= 0 && Jt <= 23 ? Jt : 0;
              let Xt = parseInt(ot[9], 10) || 0;
              return Xt = Xt >= 0 && Xt <= 59 ? Xt : 0, Wt === "-" ? (Ut += Jt, Ht += Xt) : Wt === "+" && (Ut -= Jt, Ht -= Xt), new Date(Date.UTC(vt, wt, Lt, Ut, Ht, $t));
            }
          }
          S.PDFDateString = b;
          function F(ut, ct) {
            let {
              scale: ot = 1,
              rotation: vt = 0
            } = ct;
            const {
              width: wt,
              height: Lt
            } = ut.attributes.style, Ut = [0, 0, parseInt(wt), parseInt(Lt)];
            return new g({
              viewBox: Ut,
              scale: ot,
              rotation: vt
            });
          }
          function L(ut) {
            if (ut.startsWith("#")) {
              const ct = parseInt(ut.slice(1), 16);
              return [(ct & 16711680) >> 16, (ct & 65280) >> 8, ct & 255];
            }
            return ut.startsWith("rgb(") ? ut.slice(4, -1).split(",").map((ct) => parseInt(ct)) : ut.startsWith("rgba(") ? ut.slice(5, -1).split(",").map((ct) => parseInt(ct)).slice(0, 3) : ((0, h.warn)(`Not a valid color format: "${ut}"`), [0, 0, 0]);
          }
          function G(ut) {
            const ct = document.createElement("span");
            ct.style.visibility = "hidden", document.body.append(ct);
            for (const ot of ut.keys()) {
              ct.style.color = ot;
              const vt = window.getComputedStyle(ct).color;
              ut.set(ot, L(vt));
            }
            ct.remove();
          }
          function nt(ut) {
            const {
              a: ct,
              b: ot,
              c: vt,
              d: wt,
              e: Lt,
              f: Ut
            } = ut.getTransform();
            return [ct, ot, vt, wt, Lt, Ut];
          }
          function D(ut) {
            const {
              a: ct,
              b: ot,
              c: vt,
              d: wt,
              e: Lt,
              f: Ut
            } = ut.getTransform().invertSelf();
            return [ct, ot, vt, wt, Lt, Ut];
          }
          function X(ut, ct) {
            let ot = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, vt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
            if (ct instanceof g) {
              const {
                pageWidth: wt,
                pageHeight: Lt
              } = ct.rawDims, {
                style: Ut
              } = ut, Ht = h.FeatureTest.isCSSRoundSupported, $t = `var(--scale-factor) * ${wt}px`, Wt = `var(--scale-factor) * ${Lt}px`, Jt = Ht ? `round(${$t}, 1px)` : `calc(${$t})`, Xt = Ht ? `round(${Wt}, 1px)` : `calc(${Wt})`;
              !ot || ct.rotation % 180 === 0 ? (Ut.width = Jt, Ut.height = Xt) : (Ut.width = Xt, Ut.height = Jt);
            }
            vt && ut.setAttribute("data-main-rotation", ct.rotation);
          }
        },
        /* 169 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.BaseStandardFontDataFactory = S.BaseSVGFactory = S.BaseFilterFactory = S.BaseCanvasFactory = S.BaseCMapReaderFactory = void 0, t(2);
          var n = t(1);
          class h {
            constructor() {
              this.constructor === h && (0, n.unreachable)("Cannot initialize BaseFilterFactory.");
            }
            addFilter(a) {
              return "none";
            }
            addHCMFilter(a, I) {
              return "none";
            }
            addHighlightHCMFilter(a, I, A, g) {
              return "none";
            }
            destroy() {
            }
          }
          S.BaseFilterFactory = h;
          class T {
            constructor() {
              this.constructor === T && (0, n.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(a, I) {
              if (a <= 0 || I <= 0)
                throw new Error("Invalid canvas size");
              const A = this._createCanvas(a, I);
              return {
                canvas: A,
                context: A.getContext("2d")
              };
            }
            reset(a, I, A) {
              if (!a.canvas)
                throw new Error("Canvas is not specified");
              if (I <= 0 || A <= 0)
                throw new Error("Invalid canvas size");
              a.canvas.width = I, a.canvas.height = A;
            }
            destroy(a) {
              if (!a.canvas)
                throw new Error("Canvas is not specified");
              a.canvas.width = 0, a.canvas.height = 0, a.canvas = null, a.context = null;
            }
            _createCanvas(a, I) {
              (0, n.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          S.BaseCanvasFactory = T;
          class P {
            constructor(a) {
              let {
                baseUrl: I = null,
                isCompressed: A = !0
              } = a;
              this.constructor === P && (0, n.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = I, this.isCompressed = A;
            }
            async fetch(a) {
              let {
                name: I
              } = a;
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!I)
                throw new Error("CMap name must be specified.");
              const A = this.baseUrl + I + (this.isCompressed ? ".bcmap" : ""), g = this.isCompressed ? n.CMapCompressionType.BINARY : n.CMapCompressionType.NONE;
              return this._fetchData(A, g).catch((s) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${A}`);
              });
            }
            _fetchData(a, I) {
              (0, n.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          S.BaseCMapReaderFactory = P;
          class f {
            constructor(a) {
              let {
                baseUrl: I = null
              } = a;
              this.constructor === f && (0, n.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = I;
            }
            async fetch(a) {
              let {
                filename: I
              } = a;
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!I)
                throw new Error("Font filename must be specified.");
              const A = `${this.baseUrl}${I}`;
              return this._fetchData(A).catch((g) => {
                throw new Error(`Unable to load font data at: ${A}`);
              });
            }
            _fetchData(a) {
              (0, n.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          S.BaseStandardFontDataFactory = f;
          class y {
            constructor() {
              this.constructor === y && (0, n.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(a, I) {
              let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              if (a <= 0 || I <= 0)
                throw new Error("Invalid SVG dimensions");
              const g = this._createSVG("svg:svg");
              return g.setAttribute("version", "1.1"), A || (g.setAttribute("width", `${a}px`), g.setAttribute("height", `${I}px`)), g.setAttribute("preserveAspectRatio", "none"), g.setAttribute("viewBox", `0 0 ${a} ${I}`), g;
            }
            createElement(a) {
              if (typeof a != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(a);
            }
            _createSVG(a) {
              (0, n.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          S.BaseSVGFactory = y;
        },
        /* 170 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.MurmurHash3_64 = void 0, t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(2);
          var n = t(1);
          const h = 3285377520, T = 4294901760, P = 65535;
          class f {
            constructor(c) {
              this.h1 = c ? c & 4294967295 : h, this.h2 = c ? c & 4294967295 : h;
            }
            update(c) {
              let a, I;
              if (typeof c == "string") {
                a = new Uint8Array(c.length * 2), I = 0;
                for (let w = 0, x = c.length; w < x; w++) {
                  const b = c.charCodeAt(w);
                  b <= 255 ? a[I++] = b : (a[I++] = b >>> 8, a[I++] = b & 255);
                }
              } else if ((0, n.isArrayBuffer)(c))
                a = c.slice(), I = a.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const A = I >> 2, g = I - A * 4, s = new Uint32Array(a.buffer, 0, A);
              let o = 0, l = 0, u = this.h1, v = this.h2;
              const p = 3432918353, C = 461845907, r = p & P, i = C & P;
              for (let w = 0; w < A; w++)
                w & 1 ? (o = s[w], o = o * p & T | o * r & P, o = o << 15 | o >>> 17, o = o * C & T | o * i & P, u ^= o, u = u << 13 | u >>> 19, u = u * 5 + 3864292196) : (l = s[w], l = l * p & T | l * r & P, l = l << 15 | l >>> 17, l = l * C & T | l * i & P, v ^= l, v = v << 13 | v >>> 19, v = v * 5 + 3864292196);
              switch (o = 0, g) {
                case 3:
                  o ^= a[A * 4 + 2] << 16;
                case 2:
                  o ^= a[A * 4 + 1] << 8;
                case 1:
                  o ^= a[A * 4], o = o * p & T | o * r & P, o = o << 15 | o >>> 17, o = o * C & T | o * i & P, A & 1 ? u ^= o : v ^= o;
              }
              this.h1 = u, this.h2 = v;
            }
            hexdigest() {
              let c = this.h1, a = this.h2;
              return c ^= a >>> 1, c = c * 3981806797 & T | c * 36045 & P, a = a * 4283543511 & T | ((a << 16 | c >>> 16) * 2950163797 & T) >>> 16, c ^= a >>> 1, c = c * 444984403 & T | c * 60499 & P, a = a * 3301882366 & T | ((a << 16 | c >>> 16) * 3120437893 & T) >>> 16, c ^= a >>> 1, (c >>> 0).toString(16).padStart(8, "0") + (a >>> 0).toString(16).padStart(8, "0");
            }
          }
          S.MurmurHash3_64 = f;
        },
        /* 171 */
        /***/
        (O, S, t) => {
          var P;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.FontLoader = S.FontFaceObject = void 0, t(125), t(136), t(138), t(141), t(143), t(145), t(147), t(89), t(149);
          var n = t(1);
          class h {
            constructor(y) {
              W(this, P, /* @__PURE__ */ new Set());
              let {
                ownerDocument: c = globalThis.document,
                styleElement: a = null
              } = y;
              this._document = c, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
            }
            addNativeFontFace(y) {
              this.nativeFontFaces.add(y), this._document.fonts.add(y);
            }
            removeNativeFontFace(y) {
              this.nativeFontFaces.delete(y), this._document.fonts.delete(y);
            }
            insertRule(y) {
              this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
              const c = this.styleElement.sheet;
              c.insertRule(y, c.cssRules.length);
            }
            clear() {
              for (const y of this.nativeFontFaces)
                this._document.fonts.delete(y);
              this.nativeFontFaces.clear(), e(this, P).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async loadSystemFont(y) {
              if (!(!y || e(this, P).has(y.loadedName))) {
                if ((0, n.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                  const {
                    loadedName: c,
                    src: a,
                    style: I
                  } = y, A = new FontFace(c, a, I);
                  this.addNativeFontFace(A);
                  try {
                    await A.load(), e(this, P).add(c);
                  } catch {
                    (0, n.warn)(`Cannot load system font: ${y.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(A);
                  }
                  return;
                }
                (0, n.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
              }
            }
            async bind(y) {
              if (y.attached || y.missingFile && !y.systemFontInfo)
                return;
              if (y.attached = !0, y.systemFontInfo) {
                await this.loadSystemFont(y.systemFontInfo);
                return;
              }
              if (this.isFontLoadingAPISupported) {
                const a = y.createNativeFontFace();
                if (a) {
                  this.addNativeFontFace(a);
                  try {
                    await a.loaded;
                  } catch (I) {
                    throw (0, n.warn)(`Failed to load font '${a.family}': '${I}'.`), y.disableFontFace = !0, I;
                  }
                }
                return;
              }
              const c = y.createFontFaceRule();
              if (c) {
                if (this.insertRule(c), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((a) => {
                  const I = this._queueLoadingCallback(a);
                  this._prepareFontLoadEvent(y, I);
                });
              }
            }
            get isFontLoadingAPISupported() {
              var c;
              const y = !!((c = this._document) != null && c.fonts);
              return (0, n.shadow)(this, "isFontLoadingAPISupported", y);
            }
            get isSyncFontLoadingSupported() {
              let y = !1;
              return (n.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (y = !0), (0, n.shadow)(this, "isSyncFontLoadingSupported", y);
            }
            _queueLoadingCallback(y) {
              function c() {
                for ((0, n.assert)(!I.done, "completeRequest() cannot be called twice."), I.done = !0; a.length > 0 && a[0].done; ) {
                  const A = a.shift();
                  setTimeout(A.callback, 0);
                }
              }
              const {
                loadingRequests: a
              } = this, I = {
                done: !1,
                complete: c,
                callback: y
              };
              return a.push(I), I;
            }
            get _loadTestFont() {
              const y = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              return (0, n.shadow)(this, "_loadTestFont", y);
            }
            _prepareFontLoadEvent(y, c) {
              function a(L, G) {
                return L.charCodeAt(G) << 24 | L.charCodeAt(G + 1) << 16 | L.charCodeAt(G + 2) << 8 | L.charCodeAt(G + 3) & 255;
              }
              function I(L, G, nt, D) {
                const X = L.substring(0, G), q = L.substring(G + nt);
                return X + D + q;
              }
              let A, g;
              const s = this._document.createElement("canvas");
              s.width = 1, s.height = 1;
              const o = s.getContext("2d");
              let l = 0;
              function u(L, G) {
                if (++l > 30) {
                  (0, n.warn)("Load test font never loaded."), G();
                  return;
                }
                if (o.font = "30px " + L, o.fillText(".", 0, 20), o.getImageData(0, 0, 1, 1).data[3] > 0) {
                  G();
                  return;
                }
                setTimeout(u.bind(null, L, G));
              }
              const v = `lt${Date.now()}${this.loadTestFontId++}`;
              let p = this._loadTestFont;
              p = I(p, 976, v.length, v);
              const r = 16, i = 1482184792;
              let w = a(p, r);
              for (A = 0, g = v.length - 3; A < g; A += 4)
                w = w - i + a(v, A) | 0;
              A < v.length && (w = w - i + a(v + "XXX", A) | 0), p = I(p, r, 4, (0, n.string32)(w));
              const x = `url(data:font/opentype;base64,${btoa(p)});`, b = `@font-face {font-family:"${v}";src:${x}}`;
              this.insertRule(b);
              const F = this._document.createElement("div");
              F.style.visibility = "hidden", F.style.width = F.style.height = "10px", F.style.position = "absolute", F.style.top = F.style.left = "0px";
              for (const L of [y.loadedName, v]) {
                const G = this._document.createElement("span");
                G.textContent = "Hi", G.style.fontFamily = L, F.append(G);
              }
              this._document.body.append(F), u(v, () => {
                F.remove(), c.complete();
              });
            }
          }
          P = new WeakMap(), S.FontLoader = h;
          class T {
            constructor(y, c) {
              let {
                isEvalSupported: a = !0,
                disableFontFace: I = !1,
                ignoreErrors: A = !1,
                inspectFont: g = null
              } = c;
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const s in y)
                this[s] = y[s];
              this.isEvalSupported = a !== !1, this.disableFontFace = I === !0, this.ignoreErrors = A === !0, this._inspectFont = g;
            }
            createNativeFontFace() {
              var c;
              if (!this.data || this.disableFontFace)
                return null;
              let y;
              if (!this.cssFontInfo)
                y = new FontFace(this.loadedName, this.data, {});
              else {
                const a = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (a.style = `oblique ${this.cssFontInfo.italicAngle}deg`), y = new FontFace(this.cssFontInfo.fontFamily, this.data, a);
              }
              return (c = this._inspectFont) == null || c.call(this, this), y;
            }
            createFontFaceRule() {
              var I;
              if (!this.data || this.disableFontFace)
                return null;
              const y = (0, n.bytesToString)(this.data), c = `url(data:${this.mimetype};base64,${btoa(y)});`;
              let a;
              if (!this.cssFontInfo)
                a = `@font-face {font-family:"${this.loadedName}";src:${c}}`;
              else {
                let A = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (A += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), a = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${A}src:${c}}`;
              }
              return (I = this._inspectFont) == null || I.call(this, this, c), a;
            }
            getPathGenerator(y, c) {
              if (this.compiledGlyphs[c] !== void 0)
                return this.compiledGlyphs[c];
              let a;
              try {
                a = y.get(this.loadedName + "_path_" + c);
              } catch (I) {
                if (!this.ignoreErrors)
                  throw I;
                return (0, n.warn)(`getPathGenerator - ignoring character: "${I}".`), this.compiledGlyphs[c] = function(A, g) {
                };
              }
              if (this.isEvalSupported && n.FeatureTest.isEvalSupported) {
                const I = [];
                for (const A of a) {
                  const g = A.args !== void 0 ? A.args.join(",") : "";
                  I.push("c.", A.cmd, "(", g, `);
`);
                }
                return this.compiledGlyphs[c] = new Function("c", "size", I.join(""));
              }
              return this.compiledGlyphs[c] = function(I, A) {
                for (const g of a)
                  g.cmd === "scale" && (g.args = [A, -A]), I[g.cmd].apply(I, g.args);
              };
            }
          }
          S.FontFaceObject = T;
        },
        /* 172 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.NodeStandardFontDataFactory = S.NodeFilterFactory = S.NodeCanvasFactory = S.NodeCMapReaderFactory = void 0, t(2), t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123);
          var n = t(169), h = t(1);
          (function() {
            if (!(globalThis.DOMMatrix || !h.isNodeJS))
              try {
                globalThis.DOMMatrix = require$$6.DOMMatrix;
              } catch (I) {
                (0, h.warn)(`Cannot polyfill \`DOMMatrix\`, rendering may be broken: "${I}".`);
              }
          })(), function() {
            if (!(globalThis.Path2D || !h.isNodeJS))
              try {
                const {
                  CanvasRenderingContext2D: I
                } = require$$6, {
                  polyfillPath2D: A
                } = requirePath2dPolyfill_esm();
                globalThis.CanvasRenderingContext2D = I, A(globalThis);
              } catch (I) {
                (0, h.warn)(`Cannot polyfill \`Path2D\`, rendering may be broken: "${I}".`);
              }
          }();
          const T = function(a) {
            return new Promise((I, A) => {
              require$$6.readFile(a, (s, o) => {
                if (s || !o) {
                  A(new Error(s));
                  return;
                }
                I(new Uint8Array(o));
              });
            });
          };
          class P extends n.BaseFilterFactory {
          }
          S.NodeFilterFactory = P;
          class f extends n.BaseCanvasFactory {
            _createCanvas(I, A) {
              return require$$6.createCanvas(I, A);
            }
          }
          S.NodeCanvasFactory = f;
          class y extends n.BaseCMapReaderFactory {
            _fetchData(I, A) {
              return T(I).then((g) => ({
                cMapData: g,
                compressionType: A
              }));
            }
          }
          S.NodeCMapReaderFactory = y;
          class c extends n.BaseStandardFontDataFactory {
            _fetchData(I) {
              return T(I);
            }
          }
          S.NodeStandardFontDataFactory = c;
        },
        /* 173 */
        /***/
        (O, S, t) => {
          var z, un, Q, dn;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.CanvasGraphics = void 0, t(2), t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(89);
          var n = t(1), h = t(168), T = t(174), P = t(175);
          const f = 16, y = 100, c = 4096, a = 15, I = 10, A = 1e3, g = 16;
          function s(H, m) {
            if (H._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            H.__originalSave = H.save, H.__originalRestore = H.restore, H.__originalRotate = H.rotate, H.__originalScale = H.scale, H.__originalTranslate = H.translate, H.__originalTransform = H.transform, H.__originalSetTransform = H.setTransform, H.__originalResetTransform = H.resetTransform, H.__originalClip = H.clip, H.__originalMoveTo = H.moveTo, H.__originalLineTo = H.lineTo, H.__originalBezierCurveTo = H.bezierCurveTo, H.__originalRect = H.rect, H.__originalClosePath = H.closePath, H.__originalBeginPath = H.beginPath, H._removeMirroring = () => {
              H.save = H.__originalSave, H.restore = H.__originalRestore, H.rotate = H.__originalRotate, H.scale = H.__originalScale, H.translate = H.__originalTranslate, H.transform = H.__originalTransform, H.setTransform = H.__originalSetTransform, H.resetTransform = H.__originalResetTransform, H.clip = H.__originalClip, H.moveTo = H.__originalMoveTo, H.lineTo = H.__originalLineTo, H.bezierCurveTo = H.__originalBezierCurveTo, H.rect = H.__originalRect, H.closePath = H.__originalClosePath, H.beginPath = H.__originalBeginPath, delete H._removeMirroring;
            }, H.save = function() {
              m.save(), this.__originalSave();
            }, H.restore = function() {
              m.restore(), this.__originalRestore();
            }, H.translate = function(d, R) {
              m.translate(d, R), this.__originalTranslate(d, R);
            }, H.scale = function(d, R) {
              m.scale(d, R), this.__originalScale(d, R);
            }, H.transform = function(d, R, M, B, _, Z) {
              m.transform(d, R, M, B, _, Z), this.__originalTransform(d, R, M, B, _, Z);
            }, H.setTransform = function(d, R, M, B, _, Z) {
              m.setTransform(d, R, M, B, _, Z), this.__originalSetTransform(d, R, M, B, _, Z);
            }, H.resetTransform = function() {
              m.resetTransform(), this.__originalResetTransform();
            }, H.rotate = function(d) {
              m.rotate(d), this.__originalRotate(d);
            }, H.clip = function(d) {
              m.clip(d), this.__originalClip(d);
            }, H.moveTo = function(k, d) {
              m.moveTo(k, d), this.__originalMoveTo(k, d);
            }, H.lineTo = function(k, d) {
              m.lineTo(k, d), this.__originalLineTo(k, d);
            }, H.bezierCurveTo = function(k, d, R, M, B, _) {
              m.bezierCurveTo(k, d, R, M, B, _), this.__originalBezierCurveTo(k, d, R, M, B, _);
            }, H.rect = function(k, d, R, M) {
              m.rect(k, d, R, M), this.__originalRect(k, d, R, M);
            }, H.closePath = function() {
              m.closePath(), this.__originalClosePath();
            }, H.beginPath = function() {
              m.beginPath(), this.__originalBeginPath();
            };
          }
          class o {
            constructor(m) {
              this.canvasFactory = m, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(m, k, d) {
              let R;
              return this.cache[m] !== void 0 ? (R = this.cache[m], this.canvasFactory.reset(R, k, d)) : (R = this.canvasFactory.create(k, d), this.cache[m] = R), R;
            }
            delete(m) {
              delete this.cache[m];
            }
            clear() {
              for (const m in this.cache) {
                const k = this.cache[m];
                this.canvasFactory.destroy(k), delete this.cache[m];
              }
            }
          }
          function l(H, m, k, d, R, M, B, _, Z, pt) {
            const [dt, Tt, lt, yt, bt, It] = (0, h.getCurrentTransform)(H);
            if (Tt === 0 && lt === 0) {
              const gt = B * dt + bt, ut = Math.round(gt), ct = _ * yt + It, ot = Math.round(ct), vt = (B + Z) * dt + bt, wt = Math.abs(Math.round(vt) - ut) || 1, Lt = (_ + pt) * yt + It, Ut = Math.abs(Math.round(Lt) - ot) || 1;
              return H.setTransform(Math.sign(dt), 0, 0, Math.sign(yt), ut, ot), H.drawImage(m, k, d, R, M, 0, 0, wt, Ut), H.setTransform(dt, Tt, lt, yt, bt, It), [wt, Ut];
            }
            if (dt === 0 && yt === 0) {
              const gt = _ * lt + bt, ut = Math.round(gt), ct = B * Tt + It, ot = Math.round(ct), vt = (_ + pt) * lt + bt, wt = Math.abs(Math.round(vt) - ut) || 1, Lt = (B + Z) * Tt + It, Ut = Math.abs(Math.round(Lt) - ot) || 1;
              return H.setTransform(0, Math.sign(Tt), Math.sign(lt), 0, ut, ot), H.drawImage(m, k, d, R, M, 0, 0, Ut, wt), H.setTransform(dt, Tt, lt, yt, bt, It), [Ut, wt];
            }
            H.drawImage(m, k, d, R, M, B, _, Z, pt);
            const Ot = Math.hypot(dt, Tt), Mt = Math.hypot(lt, yt);
            return [Ot * Z, Mt * pt];
          }
          function u(H) {
            const {
              width: m,
              height: k
            } = H;
            if (m > A || k > A)
              return null;
            const d = 1e3, R = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), M = m + 1;
            let B = new Uint8Array(M * (k + 1)), _, Z, pt;
            const dt = m + 7 & -8;
            let Tt = new Uint8Array(dt * k), lt = 0;
            for (const Mt of H.data) {
              let gt = 128;
              for (; gt > 0; )
                Tt[lt++] = Mt & gt ? 0 : 255, gt >>= 1;
            }
            let yt = 0;
            for (lt = 0, Tt[lt] !== 0 && (B[0] = 1, ++yt), Z = 1; Z < m; Z++)
              Tt[lt] !== Tt[lt + 1] && (B[Z] = Tt[lt] ? 2 : 1, ++yt), lt++;
            for (Tt[lt] !== 0 && (B[Z] = 2, ++yt), _ = 1; _ < k; _++) {
              lt = _ * dt, pt = _ * M, Tt[lt - dt] !== Tt[lt] && (B[pt] = Tt[lt] ? 1 : 8, ++yt);
              let Mt = (Tt[lt] ? 4 : 0) + (Tt[lt - dt] ? 8 : 0);
              for (Z = 1; Z < m; Z++)
                Mt = (Mt >> 2) + (Tt[lt + 1] ? 4 : 0) + (Tt[lt - dt + 1] ? 8 : 0), R[Mt] && (B[pt + Z] = R[Mt], ++yt), lt++;
              if (Tt[lt - dt] !== Tt[lt] && (B[pt + Z] = Tt[lt] ? 2 : 4, ++yt), yt > d)
                return null;
            }
            for (lt = dt * (k - 1), pt = _ * M, Tt[lt] !== 0 && (B[pt] = 8, ++yt), Z = 1; Z < m; Z++)
              Tt[lt] !== Tt[lt + 1] && (B[pt + Z] = Tt[lt] ? 4 : 8, ++yt), lt++;
            if (Tt[lt] !== 0 && (B[pt + Z] = 4, ++yt), yt > d)
              return null;
            const bt = new Int32Array([0, M, -1, 0, -M, 0, 0, 0, 1]), It = new Path2D();
            for (_ = 0; yt && _ <= k; _++) {
              let Mt = _ * M;
              const gt = Mt + m;
              for (; Mt < gt && !B[Mt]; )
                Mt++;
              if (Mt === gt)
                continue;
              It.moveTo(Mt % M, _);
              const ut = Mt;
              let ct = B[Mt];
              do {
                const ot = bt[ct];
                do
                  Mt += ot;
                while (!B[Mt]);
                const vt = B[Mt];
                vt !== 5 && vt !== 10 ? (ct = vt, B[Mt] = 0) : (ct = vt & 51 * ct >> 4, B[Mt] &= ct >> 2 | ct << 2), It.lineTo(Mt % M, Mt / M | 0), B[Mt] || --yt;
              } while (ut !== Mt);
              --_;
            }
            return Tt = null, B = null, function(Mt) {
              Mt.save(), Mt.scale(1 / m, -1 / k), Mt.translate(0, -k), Mt.fill(It), Mt.beginPath(), Mt.restore();
            };
          }
          class v {
            constructor(m, k) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = n.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = n.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, m, k]);
            }
            clone() {
              const m = Object.create(this);
              return m.clipBox = this.clipBox.slice(), m;
            }
            setCurrentPoint(m, k) {
              this.x = m, this.y = k;
            }
            updatePathMinMax(m, k, d) {
              [k, d] = n.Util.applyTransform([k, d], m), this.minX = Math.min(this.minX, k), this.minY = Math.min(this.minY, d), this.maxX = Math.max(this.maxX, k), this.maxY = Math.max(this.maxY, d);
            }
            updateRectMinMax(m, k) {
              const d = n.Util.applyTransform(k, m), R = n.Util.applyTransform(k.slice(2), m);
              this.minX = Math.min(this.minX, d[0], R[0]), this.minY = Math.min(this.minY, d[1], R[1]), this.maxX = Math.max(this.maxX, d[0], R[0]), this.maxY = Math.max(this.maxY, d[1], R[1]);
            }
            updateScalingPathMinMax(m, k) {
              n.Util.scaleMinMax(m, k), this.minX = Math.min(this.minX, k[0]), this.maxX = Math.max(this.maxX, k[1]), this.minY = Math.min(this.minY, k[2]), this.maxY = Math.max(this.maxY, k[3]);
            }
            updateCurvePathMinMax(m, k, d, R, M, B, _, Z, pt, dt) {
              const Tt = n.Util.bezierBoundingBox(k, d, R, M, B, _, Z, pt);
              if (dt) {
                dt[0] = Math.min(dt[0], Tt[0], Tt[2]), dt[1] = Math.max(dt[1], Tt[0], Tt[2]), dt[2] = Math.min(dt[2], Tt[1], Tt[3]), dt[3] = Math.max(dt[3], Tt[1], Tt[3]);
                return;
              }
              this.updateRectMinMax(m, Tt);
            }
            getPathBoundingBox() {
              let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : T.PathType.FILL, k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              const d = [this.minX, this.minY, this.maxX, this.maxY];
              if (m === T.PathType.STROKE) {
                k || (0, n.unreachable)("Stroke bounding box must include transform.");
                const R = n.Util.singularValueDecompose2dScale(k), M = R[0] * this.lineWidth / 2, B = R[1] * this.lineWidth / 2;
                d[0] -= M, d[1] -= B, d[2] += M, d[3] += B;
              }
              return d;
            }
            updateClipFromPath() {
              const m = n.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(m || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(m) {
              this.clipBox = m, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox() {
              let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : T.PathType.FILL, k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              return n.Util.intersect(this.clipBox, this.getPathBoundingBox(m, k));
            }
          }
          function p(H, m) {
            if (typeof ImageData < "u" && m instanceof ImageData) {
              H.putImageData(m, 0, 0);
              return;
            }
            const k = m.height, d = m.width, R = k % g, M = (k - R) / g, B = R === 0 ? M : M + 1, _ = H.createImageData(d, g);
            let Z = 0, pt;
            const dt = m.data, Tt = _.data;
            let lt, yt, bt, It;
            if (m.kind === n.ImageKind.GRAYSCALE_1BPP) {
              const Ot = dt.byteLength, Mt = new Uint32Array(Tt.buffer, 0, Tt.byteLength >> 2), gt = Mt.length, ut = d + 7 >> 3, ct = 4294967295, ot = n.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (lt = 0; lt < B; lt++) {
                for (bt = lt < M ? g : R, pt = 0, yt = 0; yt < bt; yt++) {
                  const vt = Ot - Z;
                  let wt = 0;
                  const Lt = vt > ut ? d : vt * 8 - 7, Ut = Lt & -8;
                  let Ht = 0, $t = 0;
                  for (; wt < Ut; wt += 8)
                    $t = dt[Z++], Mt[pt++] = $t & 128 ? ct : ot, Mt[pt++] = $t & 64 ? ct : ot, Mt[pt++] = $t & 32 ? ct : ot, Mt[pt++] = $t & 16 ? ct : ot, Mt[pt++] = $t & 8 ? ct : ot, Mt[pt++] = $t & 4 ? ct : ot, Mt[pt++] = $t & 2 ? ct : ot, Mt[pt++] = $t & 1 ? ct : ot;
                  for (; wt < Lt; wt++)
                    Ht === 0 && ($t = dt[Z++], Ht = 128), Mt[pt++] = $t & Ht ? ct : ot, Ht >>= 1;
                }
                for (; pt < gt; )
                  Mt[pt++] = 0;
                H.putImageData(_, 0, lt * g);
              }
            } else if (m.kind === n.ImageKind.RGBA_32BPP) {
              for (yt = 0, It = d * g * 4, lt = 0; lt < M; lt++)
                Tt.set(dt.subarray(Z, Z + It)), Z += It, H.putImageData(_, 0, yt), yt += g;
              lt < B && (It = d * R * 4, Tt.set(dt.subarray(Z, Z + It)), H.putImageData(_, 0, yt));
            } else if (m.kind === n.ImageKind.RGB_24BPP)
              for (bt = g, It = d * bt, lt = 0; lt < B; lt++) {
                for (lt >= M && (bt = R, It = d * bt), pt = 0, yt = It; yt--; )
                  Tt[pt++] = dt[Z++], Tt[pt++] = dt[Z++], Tt[pt++] = dt[Z++], Tt[pt++] = 255;
                H.putImageData(_, 0, lt * g);
              }
            else
              throw new Error(`bad image kind: ${m.kind}`);
          }
          function C(H, m) {
            if (m.bitmap) {
              H.drawImage(m.bitmap, 0, 0);
              return;
            }
            const k = m.height, d = m.width, R = k % g, M = (k - R) / g, B = R === 0 ? M : M + 1, _ = H.createImageData(d, g);
            let Z = 0;
            const pt = m.data, dt = _.data;
            for (let Tt = 0; Tt < B; Tt++) {
              const lt = Tt < M ? g : R;
              ({
                srcPos: Z
              } = (0, P.convertBlackAndWhiteToRGBA)({
                src: pt,
                srcPos: Z,
                dest: dt,
                width: d,
                height: lt,
                nonBlackColor: 0
              })), H.putImageData(_, 0, Tt * g);
            }
          }
          function r(H, m) {
            const k = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
            for (const d of k)
              H[d] !== void 0 && (m[d] = H[d]);
            H.setLineDash !== void 0 && (m.setLineDash(H.getLineDash()), m.lineDashOffset = H.lineDashOffset);
          }
          function i(H) {
            if (H.strokeStyle = H.fillStyle = "#000000", H.fillRule = "nonzero", H.globalAlpha = 1, H.lineWidth = 1, H.lineCap = "butt", H.lineJoin = "miter", H.miterLimit = 10, H.globalCompositeOperation = "source-over", H.font = "10px sans-serif", H.setLineDash !== void 0 && (H.setLineDash([]), H.lineDashOffset = 0), !n.isNodeJS) {
              const {
                filter: m
              } = H;
              m !== "none" && m !== "" && (H.filter = "none");
            }
          }
          function w(H, m, k, d) {
            const R = H.length;
            for (let M = 3; M < R; M += 4) {
              const B = H[M];
              if (B === 0)
                H[M - 3] = m, H[M - 2] = k, H[M - 1] = d;
              else if (B < 255) {
                const _ = 255 - B;
                H[M - 3] = H[M - 3] * B + m * _ >> 8, H[M - 2] = H[M - 2] * B + k * _ >> 8, H[M - 1] = H[M - 1] * B + d * _ >> 8;
              }
            }
          }
          function x(H, m, k) {
            const d = H.length, R = 1 / 255;
            for (let M = 3; M < d; M += 4) {
              const B = k ? k[H[M]] : H[M];
              m[M] = m[M] * B * R | 0;
            }
          }
          function b(H, m, k) {
            const d = H.length;
            for (let R = 3; R < d; R += 4) {
              const M = H[R - 3] * 77 + H[R - 2] * 152 + H[R - 1] * 28;
              m[R] = k ? m[R] * k[M >> 8] >> 8 : m[R] * M >> 16;
            }
          }
          function F(H, m, k, d, R, M, B, _, Z, pt, dt) {
            const Tt = !!M, lt = Tt ? M[0] : 0, yt = Tt ? M[1] : 0, bt = Tt ? M[2] : 0, It = R === "Luminosity" ? b : x, Mt = Math.min(d, Math.ceil(1048576 / k));
            for (let gt = 0; gt < d; gt += Mt) {
              const ut = Math.min(Mt, d - gt), ct = H.getImageData(_ - pt, gt + (Z - dt), k, ut), ot = m.getImageData(_, gt + Z, k, ut);
              Tt && w(ct.data, lt, yt, bt), It(ct.data, ot.data, B), m.putImageData(ot, _, gt + Z);
            }
          }
          function L(H, m, k, d) {
            const R = d[0], M = d[1], B = d[2] - R, _ = d[3] - M;
            B === 0 || _ === 0 || (F(m.context, k, B, _, m.subtype, m.backdrop, m.transferMap, R, M, m.offsetX, m.offsetY), H.save(), H.globalAlpha = 1, H.globalCompositeOperation = "source-over", H.setTransform(1, 0, 0, 1, 0, 0), H.drawImage(k.canvas, 0, 0), H.restore());
          }
          function G(H, m) {
            const k = n.Util.singularValueDecompose2dScale(H);
            k[0] = Math.fround(k[0]), k[1] = Math.fround(k[1]);
            const d = Math.fround((globalThis.devicePixelRatio || 1) * h.PixelsPerInch.PDF_TO_CSS_UNITS);
            return m !== void 0 ? m : k[0] <= d || k[1] <= d;
          }
          const nt = ["butt", "round", "square"], D = ["miter", "round", "bevel"], X = {}, q = {}, Ct = class Ct {
            constructor(m, k, d, R, M, B, _, Z) {
              W(this, z);
              W(this, Q);
              let {
                optionalContentConfig: pt,
                markedContentStack: dt = null
              } = B;
              this.ctx = m, this.current = new v(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = k, this.objs = d, this.canvasFactory = R, this.filterFactory = M, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = dt || [], this.optionalContentConfig = pt, this.cachedCanvases = new o(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = _, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = Z, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(m) {
              let k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              return typeof m == "string" ? m.startsWith("g_") ? this.commonObjs.get(m) : this.objs.get(m) : k;
            }
            beginDrawing(m) {
              let {
                transform: k,
                viewport: d,
                transparency: R = !1,
                background: M = null
              } = m;
              const B = this.ctx.canvas.width, _ = this.ctx.canvas.height, Z = this.ctx.fillStyle;
              if (this.ctx.fillStyle = M || "#ffffff", this.ctx.fillRect(0, 0, B, _), this.ctx.fillStyle = Z, R) {
                const pt = this.cachedCanvases.getCanvas("transparent", B, _);
                this.compositeCtx = this.ctx, this.transparentCanvas = pt.canvas, this.ctx = pt.context, this.ctx.save(), this.ctx.transform(...(0, h.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), i(this.ctx), k && (this.ctx.transform(...k), this.outputScaleX = k[0], this.outputScaleY = k[0]), this.ctx.transform(...d.transform), this.viewportScale = d.scale, this.baseTransform = (0, h.getCurrentTransform)(this.ctx);
            }
            executeOperatorList(m, k, d, R) {
              const M = m.argsArray, B = m.fnArray;
              let _ = k || 0;
              const Z = M.length;
              if (Z === _)
                return _;
              const pt = Z - _ > I && typeof d == "function", dt = pt ? Date.now() + a : 0;
              let Tt = 0;
              const lt = this.commonObjs, yt = this.objs;
              let bt;
              for (; ; ) {
                if (R !== void 0 && _ === R.nextBreakPoint)
                  return R.breakIt(_, d), _;
                if (bt = B[_], bt !== n.OPS.dependency)
                  this[bt].apply(this, M[_]);
                else
                  for (const It of M[_]) {
                    const Ot = It.startsWith("g_") ? lt : yt;
                    if (!Ot.has(It))
                      return Ot.get(It, d), _;
                  }
                if (_++, _ === Z)
                  return _;
                if (pt && ++Tt > I) {
                  if (Date.now() > dt)
                    return d(), _;
                  Tt = 0;
                }
              }
            }
            endDrawing() {
              J(this, z, un).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const m of this._cachedBitmapsMap.values()) {
                for (const k of m.values())
                  typeof HTMLCanvasElement < "u" && k instanceof HTMLCanvasElement && (k.width = k.height = 0);
                m.clear();
              }
              this._cachedBitmapsMap.clear(), J(this, Q, dn).call(this);
            }
            _scaleImage(m, k) {
              const d = m.width, R = m.height;
              let M = Math.max(Math.hypot(k[0], k[1]), 1), B = Math.max(Math.hypot(k[2], k[3]), 1), _ = d, Z = R, pt = "prescale1", dt, Tt;
              for (; M > 2 && _ > 1 || B > 2 && Z > 1; ) {
                let lt = _, yt = Z;
                M > 2 && _ > 1 && (lt = _ >= 16384 ? Math.floor(_ / 2) - 1 || 1 : Math.ceil(_ / 2), M /= _ / lt), B > 2 && Z > 1 && (yt = Z >= 16384 ? Math.floor(Z / 2) - 1 || 1 : Math.ceil(Z) / 2, B /= Z / yt), dt = this.cachedCanvases.getCanvas(pt, lt, yt), Tt = dt.context, Tt.clearRect(0, 0, lt, yt), Tt.drawImage(m, 0, 0, _, Z, 0, 0, lt, yt), m = dt.canvas, _ = lt, Z = yt, pt = pt === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: m,
                paintWidth: _,
                paintHeight: Z
              };
            }
            _createMaskCanvas(m) {
              const k = this.ctx, {
                width: d,
                height: R
              } = m, M = this.current.fillColor, B = this.current.patternFill, _ = (0, h.getCurrentTransform)(k);
              let Z, pt, dt, Tt;
              if ((m.bitmap || m.data) && m.count > 1) {
                const wt = m.bitmap || m.data.buffer;
                pt = JSON.stringify(B ? _ : [_.slice(0, 4), M]), Z = this._cachedBitmapsMap.get(wt), Z || (Z = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(wt, Z));
                const Lt = Z.get(pt);
                if (Lt && !B) {
                  const Ut = Math.round(Math.min(_[0], _[2]) + _[4]), Ht = Math.round(Math.min(_[1], _[3]) + _[5]);
                  return {
                    canvas: Lt,
                    offsetX: Ut,
                    offsetY: Ht
                  };
                }
                dt = Lt;
              }
              dt || (Tt = this.cachedCanvases.getCanvas("maskCanvas", d, R), C(Tt.context, m));
              let lt = n.Util.transform(_, [1 / d, 0, 0, -1 / R, 0, 0]);
              lt = n.Util.transform(lt, [1, 0, 0, 1, 0, -R]);
              const yt = n.Util.applyTransform([0, 0], lt), bt = n.Util.applyTransform([d, R], lt), It = n.Util.normalizeRect([yt[0], yt[1], bt[0], bt[1]]), Ot = Math.round(It[2] - It[0]) || 1, Mt = Math.round(It[3] - It[1]) || 1, gt = this.cachedCanvases.getCanvas("fillCanvas", Ot, Mt), ut = gt.context, ct = Math.min(yt[0], bt[0]), ot = Math.min(yt[1], bt[1]);
              ut.translate(-ct, -ot), ut.transform(...lt), dt || (dt = this._scaleImage(Tt.canvas, (0, h.getCurrentTransformInverse)(ut)), dt = dt.img, Z && B && Z.set(pt, dt)), ut.imageSmoothingEnabled = G((0, h.getCurrentTransform)(ut), m.interpolate), l(ut, dt, 0, 0, dt.width, dt.height, 0, 0, d, R), ut.globalCompositeOperation = "source-in";
              const vt = n.Util.transform((0, h.getCurrentTransformInverse)(ut), [1, 0, 0, 1, -ct, -ot]);
              return ut.fillStyle = B ? M.getPattern(k, this, vt, T.PathType.FILL) : M, ut.fillRect(0, 0, d, R), Z && !B && (this.cachedCanvases.delete("fillCanvas"), Z.set(pt, gt.canvas)), {
                canvas: gt.canvas,
                offsetX: Math.round(ct),
                offsetY: Math.round(ot)
              };
            }
            setLineWidth(m) {
              m !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = m, this.ctx.lineWidth = m;
            }
            setLineCap(m) {
              this.ctx.lineCap = nt[m];
            }
            setLineJoin(m) {
              this.ctx.lineJoin = D[m];
            }
            setMiterLimit(m) {
              this.ctx.miterLimit = m;
            }
            setDash(m, k) {
              const d = this.ctx;
              d.setLineDash !== void 0 && (d.setLineDash(m), d.lineDashOffset = k);
            }
            setRenderingIntent(m) {
            }
            setFlatness(m) {
            }
            setGState(m) {
              for (const [k, d] of m)
                switch (k) {
                  case "LW":
                    this.setLineWidth(d);
                    break;
                  case "LC":
                    this.setLineCap(d);
                    break;
                  case "LJ":
                    this.setLineJoin(d);
                    break;
                  case "ML":
                    this.setMiterLimit(d);
                    break;
                  case "D":
                    this.setDash(d[0], d[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(d);
                    break;
                  case "FL":
                    this.setFlatness(d);
                    break;
                  case "Font":
                    this.setFont(d[0], d[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = d;
                    break;
                  case "ca":
                    this.current.fillAlpha = d, this.ctx.globalAlpha = d;
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = d;
                    break;
                  case "SMask":
                    this.current.activeSMask = d ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(d);
                    break;
                }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const m = this.inSMaskMode;
              this.current.activeSMask && !m ? this.beginSMaskMode() : !this.current.activeSMask && m && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const m = this.ctx.canvas.width, k = this.ctx.canvas.height, d = "smaskGroupAt" + this.groupLevel, R = this.cachedCanvases.getCanvas(d, m, k);
              this.suspendedCtx = this.ctx, this.ctx = R.context;
              const M = this.ctx;
              M.setTransform(...(0, h.getCurrentTransform)(this.suspendedCtx)), r(this.suspendedCtx, M), s(M, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), r(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(m) {
              if (!this.current.activeSMask)
                return;
              m ? (m[0] = Math.floor(m[0]), m[1] = Math.floor(m[1]), m[2] = Math.ceil(m[2]), m[3] = Math.ceil(m[3])) : m = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const k = this.current.activeSMask, d = this.suspendedCtx;
              L(d, k, this.ctx, m), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (r(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const m = this.current;
              this.stateStack.push(m), this.current = m.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), r(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
            }
            transform(m, k, d, R, M, B) {
              this.ctx.transform(m, k, d, R, M, B), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(m, k, d) {
              const R = this.ctx, M = this.current;
              let B = M.x, _ = M.y, Z, pt;
              const dt = (0, h.getCurrentTransform)(R), Tt = dt[0] === 0 && dt[3] === 0 || dt[1] === 0 && dt[2] === 0, lt = Tt ? d.slice(0) : null;
              for (let yt = 0, bt = 0, It = m.length; yt < It; yt++)
                switch (m[yt] | 0) {
                  case n.OPS.rectangle:
                    B = k[bt++], _ = k[bt++];
                    const Ot = k[bt++], Mt = k[bt++], gt = B + Ot, ut = _ + Mt;
                    R.moveTo(B, _), Ot === 0 || Mt === 0 ? R.lineTo(gt, ut) : (R.lineTo(gt, _), R.lineTo(gt, ut), R.lineTo(B, ut)), Tt || M.updateRectMinMax(dt, [B, _, gt, ut]), R.closePath();
                    break;
                  case n.OPS.moveTo:
                    B = k[bt++], _ = k[bt++], R.moveTo(B, _), Tt || M.updatePathMinMax(dt, B, _);
                    break;
                  case n.OPS.lineTo:
                    B = k[bt++], _ = k[bt++], R.lineTo(B, _), Tt || M.updatePathMinMax(dt, B, _);
                    break;
                  case n.OPS.curveTo:
                    Z = B, pt = _, B = k[bt + 4], _ = k[bt + 5], R.bezierCurveTo(k[bt], k[bt + 1], k[bt + 2], k[bt + 3], B, _), M.updateCurvePathMinMax(dt, Z, pt, k[bt], k[bt + 1], k[bt + 2], k[bt + 3], B, _, lt), bt += 6;
                    break;
                  case n.OPS.curveTo2:
                    Z = B, pt = _, R.bezierCurveTo(B, _, k[bt], k[bt + 1], k[bt + 2], k[bt + 3]), M.updateCurvePathMinMax(dt, Z, pt, B, _, k[bt], k[bt + 1], k[bt + 2], k[bt + 3], lt), B = k[bt + 2], _ = k[bt + 3], bt += 4;
                    break;
                  case n.OPS.curveTo3:
                    Z = B, pt = _, B = k[bt + 2], _ = k[bt + 3], R.bezierCurveTo(k[bt], k[bt + 1], B, _, B, _), M.updateCurvePathMinMax(dt, Z, pt, k[bt], k[bt + 1], B, _, B, _, lt), bt += 4;
                    break;
                  case n.OPS.closePath:
                    R.closePath();
                    break;
                }
              Tt && M.updateScalingPathMinMax(dt, lt), M.setCurrentPoint(B, _);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke() {
              let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
              const k = this.ctx, d = this.current.strokeColor;
              k.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof d == "object" && (d != null && d.getPattern) ? (k.save(), k.strokeStyle = d.getPattern(k, this, (0, h.getCurrentTransformInverse)(k), T.PathType.STROKE), this.rescaleAndStroke(!1), k.restore()) : this.rescaleAndStroke(!0)), m && this.consumePath(this.current.getClippedPathBoundingBox()), k.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill() {
              let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
              const k = this.ctx, d = this.current.fillColor, R = this.current.patternFill;
              let M = !1;
              R && (k.save(), k.fillStyle = d.getPattern(k, this, (0, h.getCurrentTransformInverse)(k), T.PathType.FILL), M = !0);
              const B = this.current.getClippedPathBoundingBox();
              this.contentVisible && B !== null && (this.pendingEOFill ? (k.fill("evenodd"), this.pendingEOFill = !1) : k.fill()), M && k.restore(), m && this.consumePath(B);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = X;
            }
            eoClip() {
              this.pendingClip = q;
            }
            beginText() {
              this.current.textMatrix = n.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const m = this.pendingTextPaths, k = this.ctx;
              if (m === void 0) {
                k.beginPath();
                return;
              }
              k.save(), k.beginPath();
              for (const d of m)
                k.setTransform(...d.transform), k.translate(d.x, d.y), d.addToPath(k, d.fontSize);
              k.restore(), k.clip(), k.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(m) {
              this.current.charSpacing = m;
            }
            setWordSpacing(m) {
              this.current.wordSpacing = m;
            }
            setHScale(m) {
              this.current.textHScale = m / 100;
            }
            setLeading(m) {
              this.current.leading = -m;
            }
            setFont(m, k) {
              var dt;
              const d = this.commonObjs.get(m), R = this.current;
              if (!d)
                throw new Error(`Can't find font for ${m}`);
              if (R.fontMatrix = d.fontMatrix || n.FONT_IDENTITY_MATRIX, (R.fontMatrix[0] === 0 || R.fontMatrix[3] === 0) && (0, n.warn)("Invalid font matrix for font " + m), k < 0 ? (k = -k, R.fontDirection = -1) : R.fontDirection = 1, this.current.font = d, this.current.fontSize = k, d.isType3Font)
                return;
              const M = d.loadedName || "sans-serif", B = ((dt = d.systemFontInfo) == null ? void 0 : dt.css) || `"${M}", ${d.fallbackName}`;
              let _ = "normal";
              d.black ? _ = "900" : d.bold && (_ = "bold");
              const Z = d.italic ? "italic" : "normal";
              let pt = k;
              k < f ? pt = f : k > y && (pt = y), this.current.fontSizeScale = k / pt, this.ctx.font = `${Z} ${_} ${pt}px ${B}`;
            }
            setTextRenderingMode(m) {
              this.current.textRenderingMode = m;
            }
            setTextRise(m) {
              this.current.textRise = m;
            }
            moveText(m, k) {
              this.current.x = this.current.lineX += m, this.current.y = this.current.lineY += k;
            }
            setLeadingMoveText(m, k) {
              this.setLeading(-k), this.moveText(m, k);
            }
            setTextMatrix(m, k, d, R, M, B) {
              this.current.textMatrix = [m, k, d, R, M, B], this.current.textMatrixScale = Math.hypot(m, k), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(m, k, d, R) {
              const M = this.ctx, B = this.current, _ = B.font, Z = B.textRenderingMode, pt = B.fontSize / B.fontSizeScale, dt = Z & n.TextRenderingMode.FILL_STROKE_MASK, Tt = !!(Z & n.TextRenderingMode.ADD_TO_PATH_FLAG), lt = B.patternFill && !_.missingFile;
              let yt;
              (_.disableFontFace || Tt || lt) && (yt = _.getPathGenerator(this.commonObjs, m)), _.disableFontFace || lt ? (M.save(), M.translate(k, d), M.beginPath(), yt(M, pt), R && M.setTransform(...R), (dt === n.TextRenderingMode.FILL || dt === n.TextRenderingMode.FILL_STROKE) && M.fill(), (dt === n.TextRenderingMode.STROKE || dt === n.TextRenderingMode.FILL_STROKE) && M.stroke(), M.restore()) : ((dt === n.TextRenderingMode.FILL || dt === n.TextRenderingMode.FILL_STROKE) && M.fillText(m, k, d), (dt === n.TextRenderingMode.STROKE || dt === n.TextRenderingMode.FILL_STROKE) && M.strokeText(m, k, d)), Tt && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, h.getCurrentTransform)(M),
                x: k,
                y: d,
                fontSize: pt,
                addToPath: yt
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: m
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              m.scale(1.5, 1), m.fillText("I", 0, 10);
              const k = m.getImageData(0, 0, 10, 10).data;
              let d = !1;
              for (let R = 3; R < k.length; R += 4)
                if (k[R] > 0 && k[R] < 255) {
                  d = !0;
                  break;
                }
              return (0, n.shadow)(this, "isFontSubpixelAAEnabled", d);
            }
            showText(m) {
              const k = this.current, d = k.font;
              if (d.isType3Font)
                return this.showType3Text(m);
              const R = k.fontSize;
              if (R === 0)
                return;
              const M = this.ctx, B = k.fontSizeScale, _ = k.charSpacing, Z = k.wordSpacing, pt = k.fontDirection, dt = k.textHScale * pt, Tt = m.length, lt = d.vertical, yt = lt ? 1 : -1, bt = d.defaultVMetrics, It = R * k.fontMatrix[0], Ot = k.textRenderingMode === n.TextRenderingMode.FILL && !d.disableFontFace && !k.patternFill;
              M.save(), M.transform(...k.textMatrix), M.translate(k.x, k.y + k.textRise), pt > 0 ? M.scale(dt, -1) : M.scale(dt, 1);
              let Mt;
              if (k.patternFill) {
                M.save();
                const vt = k.fillColor.getPattern(M, this, (0, h.getCurrentTransformInverse)(M), T.PathType.FILL);
                Mt = (0, h.getCurrentTransform)(M), M.restore(), M.fillStyle = vt;
              }
              let gt = k.lineWidth;
              const ut = k.textMatrixScale;
              if (ut === 0 || gt === 0) {
                const vt = k.textRenderingMode & n.TextRenderingMode.FILL_STROKE_MASK;
                (vt === n.TextRenderingMode.STROKE || vt === n.TextRenderingMode.FILL_STROKE) && (gt = this.getSinglePixelWidth());
              } else
                gt /= ut;
              if (B !== 1 && (M.scale(B, B), gt /= B), M.lineWidth = gt, d.isInvalidPDFjsFont) {
                const vt = [];
                let wt = 0;
                for (const Lt of m)
                  vt.push(Lt.unicode), wt += Lt.width;
                M.fillText(vt.join(""), 0, 0), k.x += wt * It * dt, M.restore(), this.compose();
                return;
              }
              let ct = 0, ot;
              for (ot = 0; ot < Tt; ++ot) {
                const vt = m[ot];
                if (typeof vt == "number") {
                  ct += yt * vt * R / 1e3;
                  continue;
                }
                let wt = !1;
                const Lt = (vt.isSpace ? Z : 0) + _, Ut = vt.fontChar, Ht = vt.accent;
                let $t, Wt, Jt = vt.width;
                if (lt) {
                  const Zt = vt.vmetric || bt, Yt = -(vt.vmetric ? Zt[1] : Jt * 0.5) * It, N = Zt[2] * It;
                  Jt = Zt ? -Zt[0] : Jt, $t = Yt / B, Wt = (ct + N) / B;
                } else
                  $t = ct / B, Wt = 0;
                if (d.remeasure && Jt > 0) {
                  const Zt = M.measureText(Ut).width * 1e3 / R * B;
                  if (Jt < Zt && this.isFontSubpixelAAEnabled) {
                    const Yt = Jt / Zt;
                    wt = !0, M.save(), M.scale(Yt, 1), $t /= Yt;
                  } else
                    Jt !== Zt && ($t += (Jt - Zt) / 2e3 * R / B);
                }
                if (this.contentVisible && (vt.isInFont || d.missingFile)) {
                  if (Ot && !Ht)
                    M.fillText(Ut, $t, Wt);
                  else if (this.paintChar(Ut, $t, Wt, Mt), Ht) {
                    const Zt = $t + R * Ht.offset.x / B, Yt = Wt - R * Ht.offset.y / B;
                    this.paintChar(Ht.fontChar, Zt, Yt, Mt);
                  }
                }
                const Xt = lt ? Jt * It - Lt * pt : Jt * It + Lt * pt;
                ct += Xt, wt && M.restore();
              }
              lt ? k.y -= ct : k.x += ct * dt, M.restore(), this.compose();
            }
            showType3Text(m) {
              const k = this.ctx, d = this.current, R = d.font, M = d.fontSize, B = d.fontDirection, _ = R.vertical ? 1 : -1, Z = d.charSpacing, pt = d.wordSpacing, dt = d.textHScale * B, Tt = d.fontMatrix || n.FONT_IDENTITY_MATRIX, lt = m.length, yt = d.textRenderingMode === n.TextRenderingMode.INVISIBLE;
              let bt, It, Ot, Mt;
              if (!(yt || M === 0)) {
                for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, k.save(), k.transform(...d.textMatrix), k.translate(d.x, d.y), k.scale(dt, B), bt = 0; bt < lt; ++bt) {
                  if (It = m[bt], typeof It == "number") {
                    Mt = _ * It * M / 1e3, this.ctx.translate(Mt, 0), d.x += Mt * dt;
                    continue;
                  }
                  const gt = (It.isSpace ? pt : 0) + Z, ut = R.charProcOperatorList[It.operatorListId];
                  if (!ut) {
                    (0, n.warn)(`Type3 character "${It.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = It, this.save(), k.scale(M, M), k.transform(...Tt), this.executeOperatorList(ut), this.restore()), Ot = n.Util.applyTransform([It.width, 0], Tt)[0] * M + gt, k.translate(Ot, 0), d.x += Ot * dt;
                }
                k.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(m, k) {
            }
            setCharWidthAndBounds(m, k, d, R, M, B) {
              this.ctx.rect(d, R, M - d, B - R), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(m) {
              let k;
              if (m[0] === "TilingPattern") {
                const d = m[1], R = this.baseTransform || (0, h.getCurrentTransform)(this.ctx), M = {
                  createCanvasGraphics: (B) => new Ct(B, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                    optionalContentConfig: this.optionalContentConfig,
                    markedContentStack: this.markedContentStack
                  })
                };
                k = new T.TilingPattern(m, d, this.ctx, M, R);
              } else
                k = this._getPattern(m[1], m[2]);
              return k;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(m, k, d) {
              const R = n.Util.makeHexColor(m, k, d);
              this.ctx.strokeStyle = R, this.current.strokeColor = R;
            }
            setFillRGBColor(m, k, d) {
              const R = n.Util.makeHexColor(m, k, d);
              this.ctx.fillStyle = R, this.current.fillColor = R, this.current.patternFill = !1;
            }
            _getPattern(m) {
              let k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, d;
              return this.cachedPatterns.has(m) ? d = this.cachedPatterns.get(m) : (d = (0, T.getShadingPattern)(this.getObject(m)), this.cachedPatterns.set(m, d)), k && (d.matrix = k), d;
            }
            shadingFill(m) {
              if (!this.contentVisible)
                return;
              const k = this.ctx;
              this.save();
              const d = this._getPattern(m);
              k.fillStyle = d.getPattern(k, this, (0, h.getCurrentTransformInverse)(k), T.PathType.SHADING);
              const R = (0, h.getCurrentTransformInverse)(k);
              if (R) {
                const {
                  width: M,
                  height: B
                } = k.canvas, [_, Z, pt, dt] = n.Util.getAxialAlignedBoundingBox([0, 0, M, B], R);
                this.ctx.fillRect(_, Z, pt - _, dt - Z);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, n.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, n.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(m, k) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(m) && m.length === 6 && this.transform(...m), this.baseTransform = (0, h.getCurrentTransform)(this.ctx), k)) {
                const d = k[2] - k[0], R = k[3] - k[1];
                this.ctx.rect(k[0], k[1], d, R), this.current.updateRectMinMax((0, h.getCurrentTransform)(this.ctx), k), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(m) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const k = this.ctx;
              m.isolated || (0, n.info)("TODO: Support non-isolated groups."), m.knockout && (0, n.warn)("Knockout groups not supported.");
              const d = (0, h.getCurrentTransform)(k);
              if (m.matrix && k.transform(...m.matrix), !m.bbox)
                throw new Error("Bounding box is required.");
              let R = n.Util.getAxialAlignedBoundingBox(m.bbox, (0, h.getCurrentTransform)(k));
              const M = [0, 0, k.canvas.width, k.canvas.height];
              R = n.Util.intersect(R, M) || [0, 0, 0, 0];
              const B = Math.floor(R[0]), _ = Math.floor(R[1]);
              let Z = Math.max(Math.ceil(R[2]) - B, 1), pt = Math.max(Math.ceil(R[3]) - _, 1), dt = 1, Tt = 1;
              Z > c && (dt = Z / c, Z = c), pt > c && (Tt = pt / c, pt = c), this.current.startNewPathAndClipBox([0, 0, Z, pt]);
              let lt = "groupAt" + this.groupLevel;
              m.smask && (lt += "_smask_" + this.smaskCounter++ % 2);
              const yt = this.cachedCanvases.getCanvas(lt, Z, pt), bt = yt.context;
              bt.scale(1 / dt, 1 / Tt), bt.translate(-B, -_), bt.transform(...d), m.smask ? this.smaskStack.push({
                canvas: yt.canvas,
                context: bt,
                offsetX: B,
                offsetY: _,
                scaleX: dt,
                scaleY: Tt,
                subtype: m.smask.subtype,
                backdrop: m.smask.backdrop,
                transferMap: m.smask.transferMap || null,
                startTransformInverse: null
              }) : (k.setTransform(1, 0, 0, 1, 0, 0), k.translate(B, _), k.scale(dt, Tt), k.save()), r(k, bt), this.ctx = bt, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(k), this.groupLevel++;
            }
            endGroup(m) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const k = this.ctx, d = this.groupStack.pop();
              if (this.ctx = d, this.ctx.imageSmoothingEnabled = !1, m.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const R = (0, h.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...R);
                const M = n.Util.getAxialAlignedBoundingBox([0, 0, k.canvas.width, k.canvas.height], R);
                this.ctx.drawImage(k.canvas, 0, 0), this.ctx.restore(), this.compose(M);
              }
            }
            beginAnnotation(m, k, d, R, M) {
              if (J(this, z, un).call(this), i(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(k) && k.length === 4) {
                const B = k[2] - k[0], _ = k[3] - k[1];
                if (M && this.annotationCanvasMap) {
                  d = d.slice(), d[4] -= k[0], d[5] -= k[1], k = k.slice(), k[0] = k[1] = 0, k[2] = B, k[3] = _;
                  const [Z, pt] = n.Util.singularValueDecompose2dScale((0, h.getCurrentTransform)(this.ctx)), {
                    viewportScale: dt
                  } = this, Tt = Math.ceil(B * this.outputScaleX * dt), lt = Math.ceil(_ * this.outputScaleY * dt);
                  this.annotationCanvas = this.canvasFactory.create(Tt, lt);
                  const {
                    canvas: yt,
                    context: bt
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(m, yt), this.annotationCanvas.savedCtx = this.ctx, this.ctx = bt, this.ctx.save(), this.ctx.setTransform(Z, 0, 0, -pt, 0, _ * pt), i(this.ctx);
                } else
                  i(this.ctx), this.ctx.rect(k[0], k[1], B, _), this.ctx.clip(), this.endPath();
              }
              this.current = new v(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...d), this.transform(...R);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx.restore(), J(this, Q, dn).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(m) {
              if (!this.contentVisible)
                return;
              const k = m.count;
              m = this.getObject(m.data, m), m.count = k;
              const d = this.ctx, R = this.processingType3;
              if (R && (R.compiled === void 0 && (R.compiled = u(m)), R.compiled)) {
                R.compiled(d);
                return;
              }
              const M = this._createMaskCanvas(m), B = M.canvas;
              d.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.drawImage(B, M.offsetX, M.offsetY), d.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(m, k) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, R = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, M = arguments.length > 4 ? arguments[4] : void 0, B = arguments.length > 5 ? arguments[5] : void 0;
              if (!this.contentVisible)
                return;
              m = this.getObject(m.data, m);
              const _ = this.ctx;
              _.save();
              const Z = (0, h.getCurrentTransform)(_);
              _.transform(k, d, R, M, 0, 0);
              const pt = this._createMaskCanvas(m);
              _.setTransform(1, 0, 0, 1, pt.offsetX - Z[4], pt.offsetY - Z[5]);
              for (let dt = 0, Tt = B.length; dt < Tt; dt += 2) {
                const lt = n.Util.transform(Z, [k, d, R, M, B[dt], B[dt + 1]]), [yt, bt] = n.Util.applyTransform([0, 0], lt);
                _.drawImage(pt.canvas, yt, bt);
              }
              _.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(m) {
              if (!this.contentVisible)
                return;
              const k = this.ctx, d = this.current.fillColor, R = this.current.patternFill;
              for (const M of m) {
                const {
                  data: B,
                  width: _,
                  height: Z,
                  transform: pt
                } = M, dt = this.cachedCanvases.getCanvas("maskCanvas", _, Z), Tt = dt.context;
                Tt.save();
                const lt = this.getObject(B, M);
                C(Tt, lt), Tt.globalCompositeOperation = "source-in", Tt.fillStyle = R ? d.getPattern(Tt, this, (0, h.getCurrentTransformInverse)(k), T.PathType.FILL) : d, Tt.fillRect(0, 0, _, Z), Tt.restore(), k.save(), k.transform(...pt), k.scale(1, -1), l(k, dt.canvas, 0, 0, _, Z, 0, -1, 1, 1), k.restore();
              }
              this.compose();
            }
            paintImageXObject(m) {
              if (!this.contentVisible)
                return;
              const k = this.getObject(m);
              if (!k) {
                (0, n.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(k);
            }
            paintImageXObjectRepeat(m, k, d, R) {
              if (!this.contentVisible)
                return;
              const M = this.getObject(m);
              if (!M) {
                (0, n.warn)("Dependent image isn't ready yet");
                return;
              }
              const B = M.width, _ = M.height, Z = [];
              for (let pt = 0, dt = R.length; pt < dt; pt += 2)
                Z.push({
                  transform: [k, 0, 0, d, R[pt], R[pt + 1]],
                  x: 0,
                  y: 0,
                  w: B,
                  h: _
                });
              this.paintInlineImageXObjectGroup(M, Z);
            }
            applyTransferMapsToCanvas(m) {
              return this.current.transferMaps !== "none" && (m.filter = this.current.transferMaps, m.drawImage(m.canvas, 0, 0), m.filter = "none"), m.canvas;
            }
            applyTransferMapsToBitmap(m) {
              if (this.current.transferMaps === "none")
                return m.bitmap;
              const {
                bitmap: k,
                width: d,
                height: R
              } = m, M = this.cachedCanvases.getCanvas("inlineImage", d, R), B = M.context;
              return B.filter = this.current.transferMaps, B.drawImage(k, 0, 0), B.filter = "none", M.canvas;
            }
            paintInlineImageXObject(m) {
              if (!this.contentVisible)
                return;
              const k = m.width, d = m.height, R = this.ctx;
              if (this.save(), !n.isNodeJS) {
                const {
                  filter: _
                } = R;
                _ !== "none" && _ !== "" && (R.filter = "none");
              }
              R.scale(1 / k, -1 / d);
              let M;
              if (m.bitmap)
                M = this.applyTransferMapsToBitmap(m);
              else if (typeof HTMLElement == "function" && m instanceof HTMLElement || !m.data)
                M = m;
              else {
                const Z = this.cachedCanvases.getCanvas("inlineImage", k, d).context;
                p(Z, m), M = this.applyTransferMapsToCanvas(Z);
              }
              const B = this._scaleImage(M, (0, h.getCurrentTransformInverse)(R));
              R.imageSmoothingEnabled = G((0, h.getCurrentTransform)(R), m.interpolate), l(R, B.img, 0, 0, B.paintWidth, B.paintHeight, 0, -d, k, d), this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(m, k) {
              if (!this.contentVisible)
                return;
              const d = this.ctx;
              let R;
              if (m.bitmap)
                R = m.bitmap;
              else {
                const M = m.width, B = m.height, Z = this.cachedCanvases.getCanvas("inlineImage", M, B).context;
                p(Z, m), R = this.applyTransferMapsToCanvas(Z);
              }
              for (const M of k)
                d.save(), d.transform(...M.transform), d.scale(1, -1), l(d, R, M.x, M.y, M.w, M.h, 0, -1, 1, 1), d.restore();
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(m) {
            }
            markPointProps(m, k) {
            }
            beginMarkedContent(m) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(m, k) {
              m === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(k)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(m) {
              const k = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(m);
              const d = this.ctx;
              this.pendingClip && (k || (this.pendingClip === q ? d.clip("evenodd") : d.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), d.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const m = (0, h.getCurrentTransform)(this.ctx);
                if (m[1] === 0 && m[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                else {
                  const k = Math.abs(m[0] * m[3] - m[2] * m[1]), d = Math.hypot(m[0], m[2]), R = Math.hypot(m[1], m[3]);
                  this._cachedGetSinglePixelWidth = Math.max(d, R) / k;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (this._cachedScaleForStroking[0] === -1) {
                const {
                  lineWidth: m
                } = this.current, {
                  a: k,
                  b: d,
                  c: R,
                  d: M
                } = this.ctx.getTransform();
                let B, _;
                if (d === 0 && R === 0) {
                  const Z = Math.abs(k), pt = Math.abs(M);
                  if (Z === pt)
                    if (m === 0)
                      B = _ = 1 / Z;
                    else {
                      const dt = Z * m;
                      B = _ = dt < 1 ? 1 / dt : 1;
                    }
                  else if (m === 0)
                    B = 1 / Z, _ = 1 / pt;
                  else {
                    const dt = Z * m, Tt = pt * m;
                    B = dt < 1 ? 1 / dt : 1, _ = Tt < 1 ? 1 / Tt : 1;
                  }
                } else {
                  const Z = Math.abs(k * M - d * R), pt = Math.hypot(k, d), dt = Math.hypot(R, M);
                  if (m === 0)
                    B = dt / Z, _ = pt / Z;
                  else {
                    const Tt = m * Z;
                    B = dt > Tt ? dt / Tt : 1, _ = pt > Tt ? pt / Tt : 1;
                  }
                }
                this._cachedScaleForStroking[0] = B, this._cachedScaleForStroking[1] = _;
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(m) {
              const {
                ctx: k
              } = this, {
                lineWidth: d
              } = this.current, [R, M] = this.getScaleForStroking();
              if (k.lineWidth = d || 1, R === 1 && M === 1) {
                k.stroke();
                return;
              }
              const B = k.getLineDash();
              if (m && k.save(), k.scale(R, M), B.length > 0) {
                const _ = Math.max(R, M);
                k.setLineDash(B.map((Z) => Z / _)), k.lineDashOffset /= _;
              }
              k.stroke(), m && k.restore();
            }
            isContentVisible() {
              for (let m = this.markedContentStack.length - 1; m >= 0; m--)
                if (!this.markedContentStack[m].visible)
                  return !1;
              return !0;
            }
          };
          z = new WeakSet(), un = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, Q = new WeakSet(), dn = function() {
            if (this.pageColors) {
              const m = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
              if (m !== "none") {
                const k = this.ctx.filter;
                this.ctx.filter = m, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = k;
              }
            }
          };
          let j = Ct;
          S.CanvasGraphics = j;
          for (const H in n.OPS)
            j.prototype[H] !== void 0 && (j.prototype[n.OPS[H]] = j.prototype[H]);
        },
        /* 174 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.TilingPattern = S.PathType = void 0, S.getShadingPattern = g, t(2);
          var n = t(1), h = t(168);
          const T = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          S.PathType = T;
          function P(u, v) {
            if (!v)
              return;
            const p = v[2] - v[0], C = v[3] - v[1], r = new Path2D();
            r.rect(v[0], v[1], p, C), u.clip(r);
          }
          class f {
            constructor() {
              this.constructor === f && (0, n.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, n.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class y extends f {
            constructor(v) {
              super(), this._type = v[1], this._bbox = v[2], this._colorStops = v[3], this._p0 = v[4], this._p1 = v[5], this._r0 = v[6], this._r1 = v[7], this.matrix = null;
            }
            _createGradient(v) {
              let p;
              this._type === "axial" ? p = v.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (p = v.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const C of this._colorStops)
                p.addColorStop(C[0], C[1]);
              return p;
            }
            getPattern(v, p, C, r) {
              let i;
              if (r === T.STROKE || r === T.FILL) {
                const w = p.current.getClippedPathBoundingBox(r, (0, h.getCurrentTransform)(v)) || [0, 0, 0, 0], x = Math.ceil(w[2] - w[0]) || 1, b = Math.ceil(w[3] - w[1]) || 1, F = p.cachedCanvases.getCanvas("pattern", x, b, !0), L = F.context;
                L.clearRect(0, 0, L.canvas.width, L.canvas.height), L.beginPath(), L.rect(0, 0, L.canvas.width, L.canvas.height), L.translate(-w[0], -w[1]), C = n.Util.transform(C, [1, 0, 0, 1, w[0], w[1]]), L.transform(...p.baseTransform), this.matrix && L.transform(...this.matrix), P(L, this._bbox), L.fillStyle = this._createGradient(L), L.fill(), i = v.createPattern(F.canvas, "no-repeat");
                const G = new DOMMatrix(C);
                i.setTransform(G);
              } else
                P(v, this._bbox), i = this._createGradient(v);
              return i;
            }
          }
          function c(u, v, p, C, r, i, w, x) {
            const b = v.coords, F = v.colors, L = u.data, G = u.width * 4;
            let nt;
            b[p + 1] > b[C + 1] && (nt = p, p = C, C = nt, nt = i, i = w, w = nt), b[C + 1] > b[r + 1] && (nt = C, C = r, r = nt, nt = w, w = x, x = nt), b[p + 1] > b[C + 1] && (nt = p, p = C, C = nt, nt = i, i = w, w = nt);
            const D = (b[p] + v.offsetX) * v.scaleX, X = (b[p + 1] + v.offsetY) * v.scaleY, q = (b[C] + v.offsetX) * v.scaleX, j = (b[C + 1] + v.offsetY) * v.scaleY, z = (b[r] + v.offsetX) * v.scaleX, it = (b[r + 1] + v.offsetY) * v.scaleY;
            if (X >= it)
              return;
            const Q = F[i], Et = F[i + 1], Ct = F[i + 2], H = F[w], m = F[w + 1], k = F[w + 2], d = F[x], R = F[x + 1], M = F[x + 2], B = Math.round(X), _ = Math.round(it);
            let Z, pt, dt, Tt, lt, yt, bt, It;
            for (let Ot = B; Ot <= _; Ot++) {
              if (Ot < j) {
                const ot = Ot < X ? 0 : (X - Ot) / (X - j);
                Z = D - (D - q) * ot, pt = Q - (Q - H) * ot, dt = Et - (Et - m) * ot, Tt = Ct - (Ct - k) * ot;
              } else {
                let ot;
                Ot > it ? ot = 1 : j === it ? ot = 0 : ot = (j - Ot) / (j - it), Z = q - (q - z) * ot, pt = H - (H - d) * ot, dt = m - (m - R) * ot, Tt = k - (k - M) * ot;
              }
              let Mt;
              Ot < X ? Mt = 0 : Ot > it ? Mt = 1 : Mt = (X - Ot) / (X - it), lt = D - (D - z) * Mt, yt = Q - (Q - d) * Mt, bt = Et - (Et - R) * Mt, It = Ct - (Ct - M) * Mt;
              const gt = Math.round(Math.min(Z, lt)), ut = Math.round(Math.max(Z, lt));
              let ct = G * Ot + gt * 4;
              for (let ot = gt; ot <= ut; ot++)
                Mt = (Z - ot) / (Z - lt), Mt < 0 ? Mt = 0 : Mt > 1 && (Mt = 1), L[ct++] = pt - (pt - yt) * Mt | 0, L[ct++] = dt - (dt - bt) * Mt | 0, L[ct++] = Tt - (Tt - It) * Mt | 0, L[ct++] = 255;
            }
          }
          function a(u, v, p) {
            const C = v.coords, r = v.colors;
            let i, w;
            switch (v.type) {
              case "lattice":
                const x = v.verticesPerRow, b = Math.floor(C.length / x) - 1, F = x - 1;
                for (i = 0; i < b; i++) {
                  let L = i * x;
                  for (let G = 0; G < F; G++, L++)
                    c(u, p, C[L], C[L + 1], C[L + x], r[L], r[L + 1], r[L + x]), c(u, p, C[L + x + 1], C[L + 1], C[L + x], r[L + x + 1], r[L + 1], r[L + x]);
                }
                break;
              case "triangles":
                for (i = 0, w = C.length; i < w; i += 3)
                  c(u, p, C[i], C[i + 1], C[i + 2], r[i], r[i + 1], r[i + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class I extends f {
            constructor(v) {
              super(), this._coords = v[2], this._colors = v[3], this._figures = v[4], this._bounds = v[5], this._bbox = v[7], this._background = v[8], this.matrix = null;
            }
            _createMeshCanvas(v, p, C) {
              const x = Math.floor(this._bounds[0]), b = Math.floor(this._bounds[1]), F = Math.ceil(this._bounds[2]) - x, L = Math.ceil(this._bounds[3]) - b, G = Math.min(Math.ceil(Math.abs(F * v[0] * 1.1)), 3e3), nt = Math.min(Math.ceil(Math.abs(L * v[1] * 1.1)), 3e3), D = F / G, X = L / nt, q = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -x,
                offsetY: -b,
                scaleX: 1 / D,
                scaleY: 1 / X
              }, j = G + 2 * 2, z = nt + 2 * 2, it = C.getCanvas("mesh", j, z, !1), Q = it.context, Et = Q.createImageData(G, nt);
              if (p) {
                const H = Et.data;
                for (let m = 0, k = H.length; m < k; m += 4)
                  H[m] = p[0], H[m + 1] = p[1], H[m + 2] = p[2], H[m + 3] = 255;
              }
              for (const H of this._figures)
                a(Et, H, q);
              return Q.putImageData(Et, 2, 2), {
                canvas: it.canvas,
                offsetX: x - 2 * D,
                offsetY: b - 2 * X,
                scaleX: D,
                scaleY: X
              };
            }
            getPattern(v, p, C, r) {
              P(v, this._bbox);
              let i;
              if (r === T.SHADING)
                i = n.Util.singularValueDecompose2dScale((0, h.getCurrentTransform)(v));
              else if (i = n.Util.singularValueDecompose2dScale(p.baseTransform), this.matrix) {
                const x = n.Util.singularValueDecompose2dScale(this.matrix);
                i = [i[0] * x[0], i[1] * x[1]];
              }
              const w = this._createMeshCanvas(i, r === T.SHADING ? null : this._background, p.cachedCanvases);
              return r !== T.SHADING && (v.setTransform(...p.baseTransform), this.matrix && v.transform(...this.matrix)), v.translate(w.offsetX, w.offsetY), v.scale(w.scaleX, w.scaleY), v.createPattern(w.canvas, "no-repeat");
            }
          }
          class A extends f {
            getPattern() {
              return "hotpink";
            }
          }
          function g(u) {
            switch (u[0]) {
              case "RadialAxial":
                return new y(u);
              case "Mesh":
                return new I(u);
              case "Dummy":
                return new A();
            }
            throw new Error(`Unknown IR type: ${u[0]}`);
          }
          const s = {
            COLORED: 1,
            UNCOLORED: 2
          }, l = class l {
            constructor(v, p, C, r, i) {
              this.operatorList = v[2], this.matrix = v[3] || [1, 0, 0, 1, 0, 0], this.bbox = v[4], this.xstep = v[5], this.ystep = v[6], this.paintType = v[7], this.tilingType = v[8], this.color = p, this.ctx = C, this.canvasGraphicsFactory = r, this.baseTransform = i;
            }
            createPatternCanvas(v) {
              const p = this.operatorList, C = this.bbox, r = this.xstep, i = this.ystep, w = this.paintType, x = this.tilingType, b = this.color, F = this.canvasGraphicsFactory;
              (0, n.info)("TilingType: " + x);
              const L = C[0], G = C[1], nt = C[2], D = C[3], X = n.Util.singularValueDecompose2dScale(this.matrix), q = n.Util.singularValueDecompose2dScale(this.baseTransform), j = [X[0] * q[0], X[1] * q[1]], z = this.getSizeAndScale(r, this.ctx.canvas.width, j[0]), it = this.getSizeAndScale(i, this.ctx.canvas.height, j[1]), Q = v.cachedCanvases.getCanvas("pattern", z.size, it.size, !0), Et = Q.context, Ct = F.createCanvasGraphics(Et);
              Ct.groupLevel = v.groupLevel, this.setFillAndStrokeStyleToContext(Ct, w, b);
              let H = L, m = G, k = nt, d = D;
              return L < 0 && (H = 0, k += Math.abs(L)), G < 0 && (m = 0, d += Math.abs(G)), Et.translate(-(z.scale * H), -(it.scale * m)), Ct.transform(z.scale, 0, 0, it.scale, 0, 0), Et.save(), this.clipBbox(Ct, H, m, k, d), Ct.baseTransform = (0, h.getCurrentTransform)(Ct.ctx), Ct.executeOperatorList(p), Ct.endDrawing(), {
                canvas: Q.canvas,
                scaleX: z.scale,
                scaleY: it.scale,
                offsetX: H,
                offsetY: m
              };
            }
            getSizeAndScale(v, p, C) {
              v = Math.abs(v);
              const r = Math.max(l.MAX_PATTERN_SIZE, p);
              let i = Math.ceil(v * C);
              return i >= r ? i = r : C = i / v, {
                scale: C,
                size: i
              };
            }
            clipBbox(v, p, C, r, i) {
              const w = r - p, x = i - C;
              v.ctx.rect(p, C, w, x), v.current.updateRectMinMax((0, h.getCurrentTransform)(v.ctx), [p, C, r, i]), v.clip(), v.endPath();
            }
            setFillAndStrokeStyleToContext(v, p, C) {
              const r = v.ctx, i = v.current;
              switch (p) {
                case s.COLORED:
                  const w = this.ctx;
                  r.fillStyle = w.fillStyle, r.strokeStyle = w.strokeStyle, i.fillColor = w.fillStyle, i.strokeColor = w.strokeStyle;
                  break;
                case s.UNCOLORED:
                  const x = n.Util.makeHexColor(C[0], C[1], C[2]);
                  r.fillStyle = x, r.strokeStyle = x, i.fillColor = x, i.strokeColor = x;
                  break;
                default:
                  throw new n.FormatError(`Unsupported paint type: ${p}`);
              }
            }
            getPattern(v, p, C, r) {
              let i = C;
              r !== T.SHADING && (i = n.Util.transform(i, p.baseTransform), this.matrix && (i = n.Util.transform(i, this.matrix)));
              const w = this.createPatternCanvas(p);
              let x = new DOMMatrix(i);
              x = x.translate(w.offsetX, w.offsetY), x = x.scale(1 / w.scaleX, 1 / w.scaleY);
              const b = v.createPattern(w.canvas, "repeat");
              return b.setTransform(x), b;
            }
          };
          ee(l, "MAX_PATTERN_SIZE", 3e3);
          let o = l;
          S.TilingPattern = o;
        },
        /* 175 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.convertBlackAndWhiteToRGBA = T, S.convertToRGBA = h, S.grayToRGBA = f, t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123);
          var n = t(1);
          function h(y) {
            switch (y.kind) {
              case n.ImageKind.GRAYSCALE_1BPP:
                return T(y);
              case n.ImageKind.RGB_24BPP:
                return P(y);
            }
            return null;
          }
          function T(y) {
            let {
              src: c,
              srcPos: a = 0,
              dest: I,
              width: A,
              height: g,
              nonBlackColor: s = 4294967295,
              inverseDecode: o = !1
            } = y;
            const l = n.FeatureTest.isLittleEndian ? 4278190080 : 255, [u, v] = o ? [s, l] : [l, s], p = A >> 3, C = A & 7, r = c.length;
            I = new Uint32Array(I.buffer);
            let i = 0;
            for (let w = 0; w < g; w++) {
              for (const b = a + p; a < b; a++) {
                const F = a < r ? c[a] : 255;
                I[i++] = F & 128 ? v : u, I[i++] = F & 64 ? v : u, I[i++] = F & 32 ? v : u, I[i++] = F & 16 ? v : u, I[i++] = F & 8 ? v : u, I[i++] = F & 4 ? v : u, I[i++] = F & 2 ? v : u, I[i++] = F & 1 ? v : u;
              }
              if (C === 0)
                continue;
              const x = a < r ? c[a++] : 255;
              for (let b = 0; b < C; b++)
                I[i++] = x & 1 << 7 - b ? v : u;
            }
            return {
              srcPos: a,
              destPos: i
            };
          }
          function P(y) {
            let {
              src: c,
              srcPos: a = 0,
              dest: I,
              destPos: A = 0,
              width: g,
              height: s
            } = y, o = 0;
            const l = c.length >> 2, u = new Uint32Array(c.buffer, a, l);
            if (n.FeatureTest.isLittleEndian) {
              for (; o < l - 2; o += 3, A += 4) {
                const v = u[o], p = u[o + 1], C = u[o + 2];
                I[A] = v | 4278190080, I[A + 1] = v >>> 24 | p << 8 | 4278190080, I[A + 2] = p >>> 16 | C << 16 | 4278190080, I[A + 3] = C >>> 8 | 4278190080;
              }
              for (let v = o * 4, p = c.length; v < p; v += 3)
                I[A++] = c[v] | c[v + 1] << 8 | c[v + 2] << 16 | 4278190080;
            } else {
              for (; o < l - 2; o += 3, A += 4) {
                const v = u[o], p = u[o + 1], C = u[o + 2];
                I[A] = v | 255, I[A + 1] = v << 24 | p >>> 8 | 255, I[A + 2] = p << 16 | C >>> 16 | 255, I[A + 3] = C << 8 | 255;
              }
              for (let v = o * 4, p = c.length; v < p; v += 3)
                I[A++] = c[v] << 24 | c[v + 1] << 16 | c[v + 2] << 8 | 255;
            }
            return {
              srcPos: a,
              destPos: A
            };
          }
          function f(y, c) {
            if (n.FeatureTest.isLittleEndian)
              for (let a = 0, I = y.length; a < I; a++)
                c[a] = y[a] * 65793 | 4278190080;
            else
              for (let a = 0, I = y.length; a < I; a++)
                c[a] = y[a] * 16843008 | 255;
          }
        },
        /* 176 */
        /***/
        (O, S) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.GlobalWorkerOptions = void 0;
          const t = /* @__PURE__ */ Object.create(null);
          S.GlobalWorkerOptions = t, t.workerPort = null, t.workerSrc = "";
        },
        /* 177 */
        /***/
        (O, S, t) => {
          var y, ci, a, hi, A, Fe;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.MessageHandler = void 0, t(2);
          var n = t(1);
          const h = {
            UNKNOWN: 0,
            DATA: 1,
            ERROR: 2
          }, T = {
            UNKNOWN: 0,
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function P(s) {
            switch (s instanceof Error || typeof s == "object" && s !== null || (0, n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), s.name) {
              case "AbortException":
                return new n.AbortException(s.message);
              case "MissingPDFException":
                return new n.MissingPDFException(s.message);
              case "PasswordException":
                return new n.PasswordException(s.message, s.code);
              case "UnexpectedResponseException":
                return new n.UnexpectedResponseException(s.message, s.status);
              case "UnknownErrorException":
                return new n.UnknownErrorException(s.message, s.details);
              default:
                return new n.UnknownErrorException(s.message, s.toString());
            }
          }
          class f {
            constructor(o, l, u) {
              W(this, y);
              W(this, a);
              W(this, A);
              this.sourceName = o, this.targetName = l, this.comObj = u, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (v) => {
                const p = v.data;
                if (p.targetName !== this.sourceName)
                  return;
                if (p.stream) {
                  J(this, a, hi).call(this, p);
                  return;
                }
                if (p.callback) {
                  const r = p.callbackId, i = this.callbackCapabilities[r];
                  if (!i)
                    throw new Error(`Cannot resolve callback ${r}`);
                  if (delete this.callbackCapabilities[r], p.callback === h.DATA)
                    i.resolve(p.data);
                  else if (p.callback === h.ERROR)
                    i.reject(P(p.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const C = this.actionHandler[p.action];
                if (!C)
                  throw new Error(`Unknown action from worker: ${p.action}`);
                if (p.callbackId) {
                  const r = this.sourceName, i = p.sourceName;
                  new Promise(function(w) {
                    w(C(p.data));
                  }).then(function(w) {
                    u.postMessage({
                      sourceName: r,
                      targetName: i,
                      callback: h.DATA,
                      callbackId: p.callbackId,
                      data: w
                    });
                  }, function(w) {
                    u.postMessage({
                      sourceName: r,
                      targetName: i,
                      callback: h.ERROR,
                      callbackId: p.callbackId,
                      reason: P(w)
                    });
                  });
                  return;
                }
                if (p.streamId) {
                  J(this, y, ci).call(this, p);
                  return;
                }
                C(p.data);
              }, u.addEventListener("message", this._onComObjOnMessage);
            }
            on(o, l) {
              const u = this.actionHandler;
              if (u[o])
                throw new Error(`There is already an actionName called "${o}"`);
              u[o] = l;
            }
            send(o, l, u) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: o,
                data: l
              }, u);
            }
            sendWithPromise(o, l, u) {
              const v = this.callbackId++, p = new n.PromiseCapability();
              this.callbackCapabilities[v] = p;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: o,
                  callbackId: v,
                  data: l
                }, u);
              } catch (C) {
                p.reject(C);
              }
              return p.promise;
            }
            sendWithStream(o, l, u, v) {
              const p = this.streamId++, C = this.sourceName, r = this.targetName, i = this.comObj;
              return new ReadableStream({
                start: (w) => {
                  const x = new n.PromiseCapability();
                  return this.streamControllers[p] = {
                    controller: w,
                    startCall: x,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, i.postMessage({
                    sourceName: C,
                    targetName: r,
                    action: o,
                    streamId: p,
                    data: l,
                    desiredSize: w.desiredSize
                  }, v), x.promise;
                },
                pull: (w) => {
                  const x = new n.PromiseCapability();
                  return this.streamControllers[p].pullCall = x, i.postMessage({
                    sourceName: C,
                    targetName: r,
                    stream: T.PULL,
                    streamId: p,
                    desiredSize: w.desiredSize
                  }), x.promise;
                },
                cancel: (w) => {
                  (0, n.assert)(w instanceof Error, "cancel must have a valid reason");
                  const x = new n.PromiseCapability();
                  return this.streamControllers[p].cancelCall = x, this.streamControllers[p].isClosed = !0, i.postMessage({
                    sourceName: C,
                    targetName: r,
                    stream: T.CANCEL,
                    streamId: p,
                    reason: P(w)
                  }), x.promise;
                }
              }, u);
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          y = new WeakSet(), ci = function(o) {
            const l = o.streamId, u = this.sourceName, v = o.sourceName, p = this.comObj, C = this, r = this.actionHandler[o.action], i = {
              enqueue(w) {
                let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, b = arguments.length > 2 ? arguments[2] : void 0;
                if (this.isCancelled)
                  return;
                const F = this.desiredSize;
                this.desiredSize -= x, F > 0 && this.desiredSize <= 0 && (this.sinkCapability = new n.PromiseCapability(), this.ready = this.sinkCapability.promise), p.postMessage({
                  sourceName: u,
                  targetName: v,
                  stream: T.ENQUEUE,
                  streamId: l,
                  chunk: w
                }, b);
              },
              close() {
                this.isCancelled || (this.isCancelled = !0, p.postMessage({
                  sourceName: u,
                  targetName: v,
                  stream: T.CLOSE,
                  streamId: l
                }), delete C.streamSinks[l]);
              },
              error(w) {
                (0, n.assert)(w instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, p.postMessage({
                  sourceName: u,
                  targetName: v,
                  stream: T.ERROR,
                  streamId: l,
                  reason: P(w)
                }));
              },
              sinkCapability: new n.PromiseCapability(),
              onPull: null,
              onCancel: null,
              isCancelled: !1,
              desiredSize: o.desiredSize,
              ready: null
            };
            i.sinkCapability.resolve(), i.ready = i.sinkCapability.promise, this.streamSinks[l] = i, new Promise(function(w) {
              w(r(o.data, i));
            }).then(function() {
              p.postMessage({
                sourceName: u,
                targetName: v,
                stream: T.START_COMPLETE,
                streamId: l,
                success: !0
              });
            }, function(w) {
              p.postMessage({
                sourceName: u,
                targetName: v,
                stream: T.START_COMPLETE,
                streamId: l,
                reason: P(w)
              });
            });
          }, a = new WeakSet(), hi = function(o) {
            const l = o.streamId, u = this.sourceName, v = o.sourceName, p = this.comObj, C = this.streamControllers[l], r = this.streamSinks[l];
            switch (o.stream) {
              case T.START_COMPLETE:
                o.success ? C.startCall.resolve() : C.startCall.reject(P(o.reason));
                break;
              case T.PULL_COMPLETE:
                o.success ? C.pullCall.resolve() : C.pullCall.reject(P(o.reason));
                break;
              case T.PULL:
                if (!r) {
                  p.postMessage({
                    sourceName: u,
                    targetName: v,
                    stream: T.PULL_COMPLETE,
                    streamId: l,
                    success: !0
                  });
                  break;
                }
                r.desiredSize <= 0 && o.desiredSize > 0 && r.sinkCapability.resolve(), r.desiredSize = o.desiredSize, new Promise(function(i) {
                  var w;
                  i((w = r.onPull) == null ? void 0 : w.call(r));
                }).then(function() {
                  p.postMessage({
                    sourceName: u,
                    targetName: v,
                    stream: T.PULL_COMPLETE,
                    streamId: l,
                    success: !0
                  });
                }, function(i) {
                  p.postMessage({
                    sourceName: u,
                    targetName: v,
                    stream: T.PULL_COMPLETE,
                    streamId: l,
                    reason: P(i)
                  });
                });
                break;
              case T.ENQUEUE:
                if ((0, n.assert)(C, "enqueue should have stream controller"), C.isClosed)
                  break;
                C.controller.enqueue(o.chunk);
                break;
              case T.CLOSE:
                if ((0, n.assert)(C, "close should have stream controller"), C.isClosed)
                  break;
                C.isClosed = !0, C.controller.close(), J(this, A, Fe).call(this, C, l);
                break;
              case T.ERROR:
                (0, n.assert)(C, "error should have stream controller"), C.controller.error(P(o.reason)), J(this, A, Fe).call(this, C, l);
                break;
              case T.CANCEL_COMPLETE:
                o.success ? C.cancelCall.resolve() : C.cancelCall.reject(P(o.reason)), J(this, A, Fe).call(this, C, l);
                break;
              case T.CANCEL:
                if (!r)
                  break;
                new Promise(function(i) {
                  var w;
                  i((w = r.onCancel) == null ? void 0 : w.call(r, P(o.reason)));
                }).then(function() {
                  p.postMessage({
                    sourceName: u,
                    targetName: v,
                    stream: T.CANCEL_COMPLETE,
                    streamId: l,
                    success: !0
                  });
                }, function(i) {
                  p.postMessage({
                    sourceName: u,
                    targetName: v,
                    stream: T.CANCEL_COMPLETE,
                    streamId: l,
                    reason: P(i)
                  });
                }), r.sinkCapability.reject(P(o.reason)), r.isCancelled = !0, delete this.streamSinks[l];
                break;
              default:
                throw new Error("Unexpected stream case");
            }
          }, A = new WeakSet(), Fe = async function(o, l) {
            var u, v, p;
            await Promise.allSettled([(u = o.startCall) == null ? void 0 : u.promise, (v = o.pullCall) == null ? void 0 : v.promise, (p = o.cancelCall) == null ? void 0 : p.promise]), delete this.streamControllers[l];
          }, S.MessageHandler = f;
        },
        /* 178 */
        /***/
        (O, S, t) => {
          var T, P;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.Metadata = void 0;
          var n = t(1);
          class h {
            constructor(y) {
              W(this, T, void 0);
              W(this, P, void 0);
              let {
                parsedData: c,
                rawData: a
              } = y;
              rt(this, T, c), rt(this, P, a);
            }
            getRaw() {
              return e(this, P);
            }
            get(y) {
              return e(this, T).get(y) ?? null;
            }
            getAll() {
              return (0, n.objectFromMap)(e(this, T));
            }
            has(y) {
              return e(this, T).has(y);
            }
          }
          T = new WeakMap(), P = new WeakMap(), S.Metadata = h;
        },
        /* 179 */
        /***/
        (O, S, t) => {
          var y, c, a, I, A, g, fn;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.OptionalContentConfig = void 0;
          var n = t(1), h = t(170);
          const T = Symbol("INTERNAL");
          class P {
            constructor(l, u) {
              W(this, y, !0);
              this.name = l, this.intent = u;
            }
            get visible() {
              return e(this, y);
            }
            _setVisible(l, u) {
              l !== T && (0, n.unreachable)("Internal method `_setVisible` called."), rt(this, y, u);
            }
          }
          y = new WeakMap();
          class f {
            constructor(l) {
              W(this, g);
              W(this, c, null);
              W(this, a, /* @__PURE__ */ new Map());
              W(this, I, null);
              W(this, A, null);
              if (this.name = null, this.creator = null, l !== null) {
                this.name = l.name, this.creator = l.creator, rt(this, A, l.order);
                for (const u of l.groups)
                  e(this, a).set(u.id, new P(u.name, u.intent));
                if (l.baseState === "OFF")
                  for (const u of e(this, a).values())
                    u._setVisible(T, !1);
                for (const u of l.on)
                  e(this, a).get(u)._setVisible(T, !0);
                for (const u of l.off)
                  e(this, a).get(u)._setVisible(T, !1);
                rt(this, I, this.getHash());
              }
            }
            isVisible(l) {
              if (e(this, a).size === 0)
                return !0;
              if (!l)
                return (0, n.warn)("Optional content group not defined."), !0;
              if (l.type === "OCG")
                return e(this, a).has(l.id) ? e(this, a).get(l.id).visible : ((0, n.warn)(`Optional content group not found: ${l.id}`), !0);
              if (l.type === "OCMD") {
                if (l.expression)
                  return J(this, g, fn).call(this, l.expression);
                if (!l.policy || l.policy === "AnyOn") {
                  for (const u of l.ids) {
                    if (!e(this, a).has(u))
                      return (0, n.warn)(`Optional content group not found: ${u}`), !0;
                    if (e(this, a).get(u).visible)
                      return !0;
                  }
                  return !1;
                } else if (l.policy === "AllOn") {
                  for (const u of l.ids) {
                    if (!e(this, a).has(u))
                      return (0, n.warn)(`Optional content group not found: ${u}`), !0;
                    if (!e(this, a).get(u).visible)
                      return !1;
                  }
                  return !0;
                } else if (l.policy === "AnyOff") {
                  for (const u of l.ids) {
                    if (!e(this, a).has(u))
                      return (0, n.warn)(`Optional content group not found: ${u}`), !0;
                    if (!e(this, a).get(u).visible)
                      return !0;
                  }
                  return !1;
                } else if (l.policy === "AllOff") {
                  for (const u of l.ids) {
                    if (!e(this, a).has(u))
                      return (0, n.warn)(`Optional content group not found: ${u}`), !0;
                    if (e(this, a).get(u).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, n.warn)(`Unknown optional content policy ${l.policy}.`), !0;
              }
              return (0, n.warn)(`Unknown group type ${l.type}.`), !0;
            }
            setVisibility(l) {
              let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
              if (!e(this, a).has(l)) {
                (0, n.warn)(`Optional content group not found: ${l}`);
                return;
              }
              e(this, a).get(l)._setVisible(T, !!u), rt(this, c, null);
            }
            get hasInitialVisibility() {
              return e(this, I) === null || this.getHash() === e(this, I);
            }
            getOrder() {
              return e(this, a).size ? e(this, A) ? e(this, A).slice() : [...e(this, a).keys()] : null;
            }
            getGroups() {
              return e(this, a).size > 0 ? (0, n.objectFromMap)(e(this, a)) : null;
            }
            getGroup(l) {
              return e(this, a).get(l) || null;
            }
            getHash() {
              if (e(this, c) !== null)
                return e(this, c);
              const l = new h.MurmurHash3_64();
              for (const [u, v] of e(this, a))
                l.update(`${u}:${v.visible}`);
              return rt(this, c, l.hexdigest());
            }
          }
          c = new WeakMap(), a = new WeakMap(), I = new WeakMap(), A = new WeakMap(), g = new WeakSet(), fn = function(l) {
            const u = l.length;
            if (u < 2)
              return !0;
            const v = l[0];
            for (let p = 1; p < u; p++) {
              const C = l[p];
              let r;
              if (Array.isArray(C))
                r = J(this, g, fn).call(this, C);
              else if (e(this, a).has(C))
                r = e(this, a).get(C).visible;
              else
                return (0, n.warn)(`Optional content group not found: ${C}`), !0;
              switch (v) {
                case "And":
                  if (!r)
                    return !1;
                  break;
                case "Or":
                  if (r)
                    return !0;
                  break;
                case "Not":
                  return !r;
                default:
                  return !0;
              }
            }
            return v === "And";
          }, S.OptionalContentConfig = f;
        },
        /* 180 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.PDFDataTransportStream = void 0, t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(89);
          var n = t(1), h = t(168);
          class T {
            constructor(c, a) {
              let {
                length: I,
                initialData: A,
                progressiveDone: g = !1,
                contentDispositionFilename: s = null,
                disableRange: o = !1,
                disableStream: l = !1
              } = c;
              if ((0, n.assert)(a, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = g, this._contentDispositionFilename = s, (A == null ? void 0 : A.length) > 0) {
                const u = A instanceof Uint8Array && A.byteLength === A.buffer.byteLength ? A.buffer : new Uint8Array(A).buffer;
                this._queuedChunks.push(u);
              }
              this._pdfDataRangeTransport = a, this._isStreamingSupported = !l, this._isRangeSupported = !o, this._contentLength = I, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((u, v) => {
                this._onReceiveData({
                  begin: u,
                  chunk: v
                });
              }), this._pdfDataRangeTransport.addProgressListener((u, v) => {
                this._onProgress({
                  loaded: u,
                  total: v
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((u) => {
                this._onReceiveData({
                  chunk: u
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData(c) {
              let {
                begin: a,
                chunk: I
              } = c;
              const A = I instanceof Uint8Array && I.byteLength === I.buffer.byteLength ? I.buffer : new Uint8Array(I).buffer;
              if (a === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(A) : this._queuedChunks.push(A);
              else {
                const g = this._rangeReaders.some(function(s) {
                  return s._begin !== a ? !1 : (s._enqueue(A), !0);
                });
                (0, n.assert)(g, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var c;
              return ((c = this._fullRequestReader) == null ? void 0 : c._loaded) ?? 0;
            }
            _onProgress(c) {
              var a, I, A, g;
              c.total === void 0 ? (I = (a = this._rangeReaders[0]) == null ? void 0 : a.onProgress) == null || I.call(a, {
                loaded: c.loaded
              }) : (g = (A = this._fullRequestReader) == null ? void 0 : A.onProgress) == null || g.call(A, {
                loaded: c.loaded,
                total: c.total
              });
            }
            _onProgressiveDone() {
              var c;
              (c = this._fullRequestReader) == null || c.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(c) {
              const a = this._rangeReaders.indexOf(c);
              a >= 0 && this._rangeReaders.splice(a, 1);
            }
            getFullReader() {
              (0, n.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const c = this._queuedChunks;
              return this._queuedChunks = null, new P(this, c, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(c, a) {
              if (a <= this._progressiveDataLength)
                return null;
              const I = new f(this, c, a);
              return this._pdfDataRangeTransport.requestDataRange(c, a), this._rangeReaders.push(I), I;
            }
            cancelAllRequests(c) {
              var a;
              (a = this._fullRequestReader) == null || a.cancel(c);
              for (const I of this._rangeReaders.slice(0))
                I.cancel(c);
              this._pdfDataRangeTransport.abort();
            }
          }
          S.PDFDataTransportStream = T;
          class P {
            constructor(c, a) {
              let I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, A = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
              this._stream = c, this._done = I || !1, this._filename = (0, h.isPdfFile)(A) ? A : null, this._queuedChunks = a || [], this._loaded = 0;
              for (const g of this._queuedChunks)
                this._loaded += g.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), c._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(c) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: c,
                done: !1
              }) : this._queuedChunks.push(c), this._loaded += c.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const c = new n.PromiseCapability();
              return this._requests.push(c), c.promise;
            }
            cancel(c) {
              this._done = !0;
              for (const a of this._requests)
                a.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class f {
            constructor(c, a, I) {
              this._stream = c, this._begin = a, this._end = I, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(c) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = c;
                else {
                  this._requests.shift().resolve({
                    value: c,
                    done: !1
                  });
                  for (const I of this._requests)
                    I.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const a = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: a,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const c = new n.PromiseCapability();
              return this._requests.push(c), c.promise;
            }
            cancel(c) {
              this._done = !0;
              for (const a of this._requests)
                a.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 181 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.PDFFetchStream = void 0, t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(89);
          var n = t(1), h = t(182);
          function T(I, A, g) {
            return {
              method: "GET",
              headers: I,
              signal: g.signal,
              mode: "cors",
              credentials: A ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function P(I) {
            const A = new Headers();
            for (const g in I) {
              const s = I[g];
              s !== void 0 && A.append(g, s);
            }
            return A;
          }
          function f(I) {
            return I instanceof Uint8Array ? I.buffer : I instanceof ArrayBuffer ? I : ((0, n.warn)(`getArrayBuffer - unexpected data format: ${I}`), new Uint8Array(I).buffer);
          }
          class y {
            constructor(A) {
              this.source = A, this.isHttp = /^https?:/i.test(A.url), this.httpHeaders = this.isHttp && A.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var A;
              return ((A = this._fullRequestReader) == null ? void 0 : A._loaded) ?? 0;
            }
            getFullReader() {
              return (0, n.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new c(this), this._fullRequestReader;
            }
            getRangeReader(A, g) {
              if (g <= this._progressiveDataLength)
                return null;
              const s = new a(this, A, g);
              return this._rangeRequestReaders.push(s), s;
            }
            cancelAllRequests(A) {
              var g;
              (g = this._fullRequestReader) == null || g.cancel(A);
              for (const s of this._rangeRequestReaders.slice(0))
                s.cancel(A);
            }
          }
          S.PDFFetchStream = y;
          class c {
            constructor(A) {
              this._stream = A, this._reader = null, this._loaded = 0, this._filename = null;
              const g = A.source;
              this._withCredentials = g.withCredentials || !1, this._contentLength = g.length, this._headersCapability = new n.PromiseCapability(), this._disableRange = g.disableRange || !1, this._rangeChunkSize = g.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !g.disableStream, this._isRangeSupported = !g.disableRange, this._headers = P(this._stream.httpHeaders);
              const s = g.url;
              fetch(s, T(this._headers, this._withCredentials, this._abortController)).then((o) => {
                if (!(0, h.validateResponseStatus)(o.status))
                  throw (0, h.createResponseStatusError)(o.status, s);
                this._reader = o.body.getReader(), this._headersCapability.resolve();
                const l = (p) => o.headers.get(p), {
                  allowRangeRequests: u,
                  suggestedLength: v
                } = (0, h.validateRangeRequestCapabilities)({
                  getResponseHeader: l,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = u, this._contentLength = v || this._contentLength, this._filename = (0, h.extractFilenameFromHeader)(l), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new n.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var s;
              await this._headersCapability.promise;
              const {
                value: A,
                done: g
              } = await this._reader.read();
              return g ? {
                value: A,
                done: g
              } : (this._loaded += A.byteLength, (s = this.onProgress) == null || s.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: f(A),
                done: !1
              });
            }
            cancel(A) {
              var g;
              (g = this._reader) == null || g.cancel(A), this._abortController.abort();
            }
          }
          class a {
            constructor(A, g, s) {
              this._stream = A, this._reader = null, this._loaded = 0;
              const o = A.source;
              this._withCredentials = o.withCredentials || !1, this._readCapability = new n.PromiseCapability(), this._isStreamingSupported = !o.disableStream, this._abortController = new AbortController(), this._headers = P(this._stream.httpHeaders), this._headers.append("Range", `bytes=${g}-${s - 1}`);
              const l = o.url;
              fetch(l, T(this._headers, this._withCredentials, this._abortController)).then((u) => {
                if (!(0, h.validateResponseStatus)(u.status))
                  throw (0, h.createResponseStatusError)(u.status, l);
                this._readCapability.resolve(), this._reader = u.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var s;
              await this._readCapability.promise;
              const {
                value: A,
                done: g
              } = await this._reader.read();
              return g ? {
                value: A,
                done: g
              } : (this._loaded += A.byteLength, (s = this.onProgress) == null || s.call(this, {
                loaded: this._loaded
              }), {
                value: f(A),
                done: !1
              });
            }
            cancel(A) {
              var g;
              (g = this._reader) == null || g.cancel(A), this._abortController.abort();
            }
          }
        },
        /* 182 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.createResponseStatusError = y, S.extractFilenameFromHeader = f, S.validateRangeRequestCapabilities = P, S.validateResponseStatus = c;
          var n = t(1), h = t(183), T = t(168);
          function P(a) {
            let {
              getResponseHeader: I,
              isHttp: A,
              rangeChunkSize: g,
              disableRange: s
            } = a;
            const o = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, l = parseInt(I("Content-Length"), 10);
            return !Number.isInteger(l) || (o.suggestedLength = l, l <= 2 * g) || s || !A || I("Accept-Ranges") !== "bytes" || (I("Content-Encoding") || "identity") !== "identity" || (o.allowRangeRequests = !0), o;
          }
          function f(a) {
            const I = a("Content-Disposition");
            if (I) {
              let A = (0, h.getFilenameFromContentDispositionHeader)(I);
              if (A.includes("%"))
                try {
                  A = decodeURIComponent(A);
                } catch {
                }
              if ((0, T.isPdfFile)(A))
                return A;
            }
            return null;
          }
          function y(a, I) {
            return a === 404 || a === 0 && I.startsWith("file:") ? new n.MissingPDFException('Missing PDF "' + I + '".') : new n.UnexpectedResponseException(`Unexpected server response (${a}) while retrieving PDF "${I}".`, a);
          }
          function c(a) {
            return a === 200 || a === 206;
          }
        },
        /* 183 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.getFilenameFromContentDispositionHeader = h, t(89), t(149);
          var n = t(1);
          function h(T) {
            let P = !0, f = y("filename\\*", "i").exec(T);
            if (f) {
              f = f[1];
              let o = A(f);
              return o = unescape(o), o = g(o), o = s(o), a(o);
            }
            if (f = I(T), f) {
              const o = s(f);
              return a(o);
            }
            if (f = y("filename", "i").exec(T), f) {
              f = f[1];
              let o = A(f);
              return o = s(o), a(o);
            }
            function y(o, l) {
              return new RegExp("(?:^|;)\\s*" + o + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', l);
            }
            function c(o, l) {
              if (o) {
                if (!/^[\x00-\xFF]+$/.test(l))
                  return l;
                try {
                  const u = new TextDecoder(o, {
                    fatal: !0
                  }), v = (0, n.stringToBytes)(l);
                  l = u.decode(v), P = !1;
                } catch {
                }
              }
              return l;
            }
            function a(o) {
              return P && /[\x80-\xff]/.test(o) && (o = c("utf-8", o), P && (o = c("iso-8859-1", o))), o;
            }
            function I(o) {
              const l = [];
              let u;
              const v = y("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (u = v.exec(o)) !== null; ) {
                let [, C, r, i] = u;
                if (C = parseInt(C, 10), C in l) {
                  if (C === 0)
                    break;
                  continue;
                }
                l[C] = [r, i];
              }
              const p = [];
              for (let C = 0; C < l.length && C in l; ++C) {
                let [r, i] = l[C];
                i = A(i), r && (i = unescape(i), C === 0 && (i = g(i))), p.push(i);
              }
              return p.join("");
            }
            function A(o) {
              if (o.startsWith('"')) {
                const l = o.slice(1).split('\\"');
                for (let u = 0; u < l.length; ++u) {
                  const v = l[u].indexOf('"');
                  v !== -1 && (l[u] = l[u].slice(0, v), l.length = u + 1), l[u] = l[u].replaceAll(/\\(.)/g, "$1");
                }
                o = l.join('"');
              }
              return o;
            }
            function g(o) {
              const l = o.indexOf("'");
              if (l === -1)
                return o;
              const u = o.slice(0, l), p = o.slice(l + 1).replace(/^[^']*'/, "");
              return c(u, p);
            }
            function s(o) {
              return !o.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(o) ? o : o.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(l, u, v, p) {
                if (v === "q" || v === "Q")
                  return p = p.replaceAll("_", " "), p = p.replaceAll(/=([0-9a-fA-F]{2})/g, function(C, r) {
                    return String.fromCharCode(parseInt(r, 16));
                  }), c(u, p);
                try {
                  p = atob(p);
                } catch {
                }
                return c(u, p);
              });
            }
            return "";
          }
        },
        /* 184 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.PDFNetworkStream = void 0, t(89);
          var n = t(1), h = t(182);
          const T = 200, P = 206;
          function f(A) {
            const g = A.response;
            return typeof g != "string" ? g : (0, n.stringToBytes)(g).buffer;
          }
          class y {
            constructor(g) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.url = g, this.isHttp = /^https?:/i.test(g), this.httpHeaders = this.isHttp && s.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = s.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(g, s, o) {
              const l = {
                begin: g,
                end: s
              };
              for (const u in o)
                l[u] = o[u];
              return this.request(l);
            }
            requestFull(g) {
              return this.request(g);
            }
            request(g) {
              const s = new XMLHttpRequest(), o = this.currXhrId++, l = this.pendingRequests[o] = {
                xhr: s
              };
              s.open("GET", this.url), s.withCredentials = this.withCredentials;
              for (const u in this.httpHeaders) {
                const v = this.httpHeaders[u];
                v !== void 0 && s.setRequestHeader(u, v);
              }
              return this.isHttp && "begin" in g && "end" in g ? (s.setRequestHeader("Range", `bytes=${g.begin}-${g.end - 1}`), l.expectedStatus = P) : l.expectedStatus = T, s.responseType = "arraybuffer", g.onError && (s.onerror = function(u) {
                g.onError(s.status);
              }), s.onreadystatechange = this.onStateChange.bind(this, o), s.onprogress = this.onProgress.bind(this, o), l.onHeadersReceived = g.onHeadersReceived, l.onDone = g.onDone, l.onError = g.onError, l.onProgress = g.onProgress, s.send(null), o;
            }
            onProgress(g, s) {
              var l;
              const o = this.pendingRequests[g];
              o && ((l = o.onProgress) == null || l.call(o, s));
            }
            onStateChange(g, s) {
              var C, r, i;
              const o = this.pendingRequests[g];
              if (!o)
                return;
              const l = o.xhr;
              if (l.readyState >= 2 && o.onHeadersReceived && (o.onHeadersReceived(), delete o.onHeadersReceived), l.readyState !== 4 || !(g in this.pendingRequests))
                return;
              if (delete this.pendingRequests[g], l.status === 0 && this.isHttp) {
                (C = o.onError) == null || C.call(o, l.status);
                return;
              }
              const u = l.status || T;
              if (!(u === T && o.expectedStatus === P) && u !== o.expectedStatus) {
                (r = o.onError) == null || r.call(o, l.status);
                return;
              }
              const p = f(l);
              if (u === P) {
                const w = l.getResponseHeader("Content-Range"), x = /bytes (\d+)-(\d+)\/(\d+)/.exec(w);
                o.onDone({
                  begin: parseInt(x[1], 10),
                  chunk: p
                });
              } else
                p ? o.onDone({
                  begin: 0,
                  chunk: p
                }) : (i = o.onError) == null || i.call(o, l.status);
            }
            getRequestXhr(g) {
              return this.pendingRequests[g].xhr;
            }
            isPendingRequest(g) {
              return g in this.pendingRequests;
            }
            abortRequest(g) {
              const s = this.pendingRequests[g].xhr;
              delete this.pendingRequests[g], s.abort();
            }
          }
          class c {
            constructor(g) {
              this._source = g, this._manager = new y(g.url, {
                httpHeaders: g.httpHeaders,
                withCredentials: g.withCredentials
              }), this._rangeChunkSize = g.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(g) {
              const s = this._rangeRequestReaders.indexOf(g);
              s >= 0 && this._rangeRequestReaders.splice(s, 1);
            }
            getFullReader() {
              return (0, n.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new a(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(g, s) {
              const o = new I(this._manager, g, s);
              return o.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(o), o;
            }
            cancelAllRequests(g) {
              var s;
              (s = this._fullRequestReader) == null || s.cancel(g);
              for (const o of this._rangeRequestReaders.slice(0))
                o.cancel(g);
            }
          }
          S.PDFNetworkStream = c;
          class a {
            constructor(g, s) {
              this._manager = g;
              const o = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = s.url, this._fullRequestId = g.requestFull(o), this._headersReceivedCapability = new n.PromiseCapability(), this._disableRange = s.disableRange || !1, this._contentLength = s.length, this._rangeChunkSize = s.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const g = this._fullRequestId, s = this._manager.getRequestXhr(g), o = (v) => s.getResponseHeader(v), {
                allowRangeRequests: l,
                suggestedLength: u
              } = (0, h.validateRangeRequestCapabilities)({
                getResponseHeader: o,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              l && (this._isRangeSupported = !0), this._contentLength = u || this._contentLength, this._filename = (0, h.extractFilenameFromHeader)(o), this._isRangeSupported && this._manager.abortRequest(g), this._headersReceivedCapability.resolve();
            }
            _onDone(g) {
              if (g && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: g.chunk,
                done: !1
              }) : this._cachedChunks.push(g.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const s of this._requests)
                  s.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(g) {
              this._storedError = (0, h.createResponseStatusError)(g, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const s of this._requests)
                s.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(g) {
              var s;
              (s = this.onProgress) == null || s.call(this, {
                loaded: g.loaded,
                total: g.lengthComputable ? g.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const g = new n.PromiseCapability();
              return this._requests.push(g), g.promise;
            }
            cancel(g) {
              this._done = !0, this._headersReceivedCapability.reject(g);
              for (const s of this._requests)
                s.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class I {
            constructor(g, s, o) {
              this._manager = g;
              const l = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = g.url, this._requestId = g.requestRange(s, o, l), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var g;
              (g = this.onClosed) == null || g.call(this, this);
            }
            _onDone(g) {
              const s = g.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: s,
                done: !1
              }) : this._queuedChunk = s, this._done = !0;
              for (const o of this._requests)
                o.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(g) {
              this._storedError = (0, h.createResponseStatusError)(g, this._url);
              for (const s of this._requests)
                s.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(g) {
              var s;
              this.isStreamingSupported || (s = this.onProgress) == null || s.call(this, {
                loaded: g.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const s = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: s,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const g = new n.PromiseCapability();
              return this._requests.push(g), g.promise;
            }
            cancel(g) {
              this._done = !0;
              for (const s of this._requests)
                s.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 185 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.PDFNodeStream = void 0, t(89), t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123);
          var n = t(1), h = t(182);
          const T = /^file:\/\/\/[a-zA-Z]:\//;
          function P(o) {
            const l = require$$6, u = l.parse(o);
            return u.protocol === "file:" || u.host ? u : /^[a-z]:[/\\]/i.test(o) ? l.parse(`file:///${o}`) : (u.host || (u.protocol = "file:"), u);
          }
          class f {
            constructor(l) {
              this.source = l, this.url = P(l.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && l.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var l;
              return ((l = this._fullRequestReader) == null ? void 0 : l._loaded) ?? 0;
            }
            getFullReader() {
              return (0, n.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new g(this) : new I(this), this._fullRequestReader;
            }
            getRangeReader(l, u) {
              if (u <= this._progressiveDataLength)
                return null;
              const v = this.isFsUrl ? new s(this, l, u) : new A(this, l, u);
              return this._rangeRequestReaders.push(v), v;
            }
            cancelAllRequests(l) {
              var u;
              (u = this._fullRequestReader) == null || u.cancel(l);
              for (const v of this._rangeRequestReaders.slice(0))
                v.cancel(l);
            }
          }
          S.PDFNodeStream = f;
          class y {
            constructor(l) {
              this._url = l.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const u = l.source;
              this._contentLength = u.length, this._loaded = 0, this._filename = null, this._disableRange = u.disableRange || !1, this._rangeChunkSize = u.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !u.disableStream, this._isRangeSupported = !u.disableRange, this._readableStream = null, this._readCapability = new n.PromiseCapability(), this._headersCapability = new n.PromiseCapability();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var v;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const l = this._readableStream.read();
              return l === null ? (this._readCapability = new n.PromiseCapability(), this.read()) : (this._loaded += l.length, (v = this.onProgress) == null || v.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(l).buffer,
                done: !1
              });
            }
            cancel(l) {
              if (!this._readableStream) {
                this._error(l);
                return;
              }
              this._readableStream.destroy(l);
            }
            _error(l) {
              this._storedError = l, this._readCapability.resolve();
            }
            _setReadableStream(l) {
              this._readableStream = l, l.on("readable", () => {
                this._readCapability.resolve();
              }), l.on("end", () => {
                l.destroy(), this._done = !0, this._readCapability.resolve();
              }), l.on("error", (u) => {
                this._error(u);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new n.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class c {
            constructor(l) {
              this._url = l.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new n.PromiseCapability();
              const u = l.source;
              this._isStreamingSupported = !u.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var v;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const l = this._readableStream.read();
              return l === null ? (this._readCapability = new n.PromiseCapability(), this.read()) : (this._loaded += l.length, (v = this.onProgress) == null || v.call(this, {
                loaded: this._loaded
              }), {
                value: new Uint8Array(l).buffer,
                done: !1
              });
            }
            cancel(l) {
              if (!this._readableStream) {
                this._error(l);
                return;
              }
              this._readableStream.destroy(l);
            }
            _error(l) {
              this._storedError = l, this._readCapability.resolve();
            }
            _setReadableStream(l) {
              this._readableStream = l, l.on("readable", () => {
                this._readCapability.resolve();
              }), l.on("end", () => {
                l.destroy(), this._done = !0, this._readCapability.resolve();
              }), l.on("error", (u) => {
                this._error(u);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function a(o, l) {
            return {
              protocol: o.protocol,
              auth: o.auth,
              host: o.hostname,
              port: o.port,
              path: o.path,
              method: "GET",
              headers: l
            };
          }
          class I extends y {
            constructor(l) {
              super(l);
              const u = (v) => {
                if (v.statusCode === 404) {
                  const i = new n.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = i, this._headersCapability.reject(i);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(v);
                const p = (i) => this._readableStream.headers[i.toLowerCase()], {
                  allowRangeRequests: C,
                  suggestedLength: r
                } = (0, h.validateRangeRequestCapabilities)({
                  getResponseHeader: p,
                  isHttp: l.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = C, this._contentLength = r || this._contentLength, this._filename = (0, h.extractFilenameFromHeader)(p);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const v = require$$6;
                this._request = v.request(a(this._url, l.httpHeaders), u);
              } else {
                const v = require$$6;
                this._request = v.request(a(this._url, l.httpHeaders), u);
              }
              this._request.on("error", (v) => {
                this._storedError = v, this._headersCapability.reject(v);
              }), this._request.end();
            }
          }
          class A extends c {
            constructor(l, u, v) {
              super(l), this._httpHeaders = {};
              for (const C in l.httpHeaders) {
                const r = l.httpHeaders[C];
                r !== void 0 && (this._httpHeaders[C] = r);
              }
              this._httpHeaders.Range = `bytes=${u}-${v - 1}`;
              const p = (C) => {
                if (C.statusCode === 404) {
                  const r = new n.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = r;
                  return;
                }
                this._setReadableStream(C);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const C = require$$6;
                this._request = C.request(a(this._url, this._httpHeaders), p);
              } else {
                const C = require$$6;
                this._request = C.request(a(this._url, this._httpHeaders), p);
              }
              this._request.on("error", (C) => {
                this._storedError = C;
              }), this._request.end();
            }
          }
          class g extends y {
            constructor(l) {
              super(l);
              let u = decodeURIComponent(this._url.path);
              T.test(this._url.href) && (u = u.replace(/^\//, ""));
              const v = require$$6;
              v.lstat(u, (p, C) => {
                if (p) {
                  p.code === "ENOENT" && (p = new n.MissingPDFException(`Missing PDF "${u}".`)), this._storedError = p, this._headersCapability.reject(p);
                  return;
                }
                this._contentLength = C.size, this._setReadableStream(v.createReadStream(u)), this._headersCapability.resolve();
              });
            }
          }
          class s extends c {
            constructor(l, u, v) {
              super(l);
              let p = decodeURIComponent(this._url.path);
              T.test(this._url.href) && (p = p.replace(/^\//, ""));
              const C = require$$6;
              this._setReadableStream(C.createReadStream(p, {
                start: u,
                end: v - 1
              }));
            }
          }
        },
        /* 186 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.SVGGraphics = void 0, t(84), t(86), t(87), t(93), t(101), t(102), t(105), t(107), t(109), t(113), t(116), t(123), t(2), t(89), t(187);
          var n = t(168), h = t(1);
          const T = {
            fontStyle: "normal",
            fontWeight: "normal",
            fillColor: "#000000"
          }, P = "http://www.w3.org/XML/1998/namespace", f = "http://www.w3.org/1999/xlink", y = ["butt", "round", "square"], c = ["miter", "round", "bevel"], a = function(C) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            if (URL.createObjectURL && typeof Blob < "u" && !i)
              return URL.createObjectURL(new Blob([C], {
                type: r
              }));
            const w = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            let x = `data:${r};base64,`;
            for (let b = 0, F = C.length; b < F; b += 3) {
              const L = C[b] & 255, G = C[b + 1] & 255, nt = C[b + 2] & 255, D = L >> 2, X = (L & 3) << 4 | G >> 4, q = b + 1 < F ? (G & 15) << 2 | nt >> 6 : 64, j = b + 2 < F ? nt & 63 : 64;
              x += w[D] + w[X] + w[q] + w[j];
            }
            return x;
          }, I = function() {
            const C = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), r = 12, i = new Int32Array(256);
            for (let nt = 0; nt < 256; nt++) {
              let D = nt;
              for (let X = 0; X < 8; X++)
                D = D & 1 ? 3988292384 ^ D >> 1 & 2147483647 : D >> 1 & 2147483647;
              i[nt] = D;
            }
            function w(nt, D, X) {
              let q = -1;
              for (let j = D; j < X; j++) {
                const z = (q ^ nt[j]) & 255, it = i[z];
                q = q >>> 8 ^ it;
              }
              return q ^ -1;
            }
            function x(nt, D, X, q) {
              let j = q;
              const z = D.length;
              X[j] = z >> 24 & 255, X[j + 1] = z >> 16 & 255, X[j + 2] = z >> 8 & 255, X[j + 3] = z & 255, j += 4, X[j] = nt.charCodeAt(0) & 255, X[j + 1] = nt.charCodeAt(1) & 255, X[j + 2] = nt.charCodeAt(2) & 255, X[j + 3] = nt.charCodeAt(3) & 255, j += 4, X.set(D, j), j += D.length;
              const it = w(X, q + 4, j);
              X[j] = it >> 24 & 255, X[j + 1] = it >> 16 & 255, X[j + 2] = it >> 8 & 255, X[j + 3] = it & 255;
            }
            function b(nt, D, X) {
              let q = 1, j = 0;
              for (let z = D; z < X; ++z)
                q = (q + (nt[z] & 255)) % 65521, j = (j + q) % 65521;
              return j << 16 | q;
            }
            function F(nt) {
              if (!h.isNodeJS)
                return L(nt);
              try {
                const D = parseInt(process.versions.node) >= 8 ? nt : Buffer.from(nt), X = require$$6.deflateSync(D, {
                  level: 9
                });
                return X instanceof Uint8Array ? X : new Uint8Array(X);
              } catch (D) {
                (0, h.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + D);
              }
              return L(nt);
            }
            function L(nt) {
              let D = nt.length;
              const X = 65535, q = Math.ceil(D / X), j = new Uint8Array(2 + D + q * 5 + 4);
              let z = 0;
              j[z++] = 120, j[z++] = 156;
              let it = 0;
              for (; D > X; )
                j[z++] = 0, j[z++] = 255, j[z++] = 255, j[z++] = 0, j[z++] = 0, j.set(nt.subarray(it, it + X), z), z += X, it += X, D -= X;
              j[z++] = 1, j[z++] = D & 255, j[z++] = D >> 8 & 255, j[z++] = ~D & 65535 & 255, j[z++] = (~D & 65535) >> 8 & 255, j.set(nt.subarray(it), z), z += nt.length - it;
              const Q = b(nt, 0, nt.length);
              return j[z++] = Q >> 24 & 255, j[z++] = Q >> 16 & 255, j[z++] = Q >> 8 & 255, j[z++] = Q & 255, j;
            }
            function G(nt, D, X, q) {
              const j = nt.width, z = nt.height;
              let it, Q, Et;
              const Ct = nt.data;
              switch (D) {
                case h.ImageKind.GRAYSCALE_1BPP:
                  Q = 0, it = 1, Et = j + 7 >> 3;
                  break;
                case h.ImageKind.RGB_24BPP:
                  Q = 2, it = 8, Et = j * 3;
                  break;
                case h.ImageKind.RGBA_32BPP:
                  Q = 6, it = 8, Et = j * 4;
                  break;
                default:
                  throw new Error("invalid format");
              }
              const H = new Uint8Array((1 + Et) * z);
              let m = 0, k = 0;
              for (let Z = 0; Z < z; ++Z)
                H[m++] = 0, H.set(Ct.subarray(k, k + Et), m), k += Et, m += Et;
              if (D === h.ImageKind.GRAYSCALE_1BPP && q) {
                m = 0;
                for (let Z = 0; Z < z; Z++) {
                  m++;
                  for (let pt = 0; pt < Et; pt++)
                    H[m++] ^= 255;
                }
              }
              const d = new Uint8Array([j >> 24 & 255, j >> 16 & 255, j >> 8 & 255, j & 255, z >> 24 & 255, z >> 16 & 255, z >> 8 & 255, z & 255, it, Q, 0, 0, 0]), R = F(H), M = C.length + r * 3 + d.length + R.length, B = new Uint8Array(M);
              let _ = 0;
              return B.set(C, _), _ += C.length, x("IHDR", d, B, _), _ += r + d.length, x("IDATA", R, B, _), _ += r + R.length, x("IEND", new Uint8Array(0), B, _), a(B, "image/png", X);
            }
            return function(D, X, q) {
              const j = D.kind === void 0 ? h.ImageKind.GRAYSCALE_1BPP : D.kind;
              return G(D, j, X, q);
            };
          }();
          class A {
            constructor() {
              this.fontSizeScale = 1, this.fontWeight = T.fontWeight, this.fontSize = 0, this.textMatrix = h.IDENTITY_MATRIX, this.fontMatrix = h.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = h.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = T.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
            }
            clone() {
              return Object.create(this);
            }
            setCurrentPoint(r, i) {
              this.x = r, this.y = i;
            }
          }
          function g(C) {
            let r = [];
            const i = [];
            for (const w of C) {
              if (w.fn === "save") {
                r.push({
                  fnId: 92,
                  fn: "group",
                  items: []
                }), i.push(r), r = r.at(-1).items;
                continue;
              }
              w.fn === "restore" ? r = i.pop() : r.push(w);
            }
            return r;
          }
          function s(C) {
            if (Number.isInteger(C))
              return C.toString();
            const r = C.toFixed(10);
            let i = r.length - 1;
            if (r[i] !== "0")
              return r;
            do
              i--;
            while (r[i] === "0");
            return r.substring(0, r[i] === "." ? i : i + 1);
          }
          function o(C) {
            if (C[4] === 0 && C[5] === 0) {
              if (C[1] === 0 && C[2] === 0)
                return C[0] === 1 && C[3] === 1 ? "" : `scale(${s(C[0])} ${s(C[3])})`;
              if (C[0] === C[3] && C[1] === -C[2]) {
                const r = Math.acos(C[0]) * 180 / Math.PI;
                return `rotate(${s(r)})`;
              }
            } else if (C[0] === 1 && C[1] === 0 && C[2] === 0 && C[3] === 1)
              return `translate(${s(C[4])} ${s(C[5])})`;
            return `matrix(${s(C[0])} ${s(C[1])} ${s(C[2])} ${s(C[3])} ${s(C[4])} ${s(C[5])})`;
          }
          let l = 0, u = 0, v = 0;
          class p {
            constructor(r, i) {
              let w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              (0, n.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new n.DOMSVGFactory(), this.current = new A(), this.transformMatrix = h.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = r, this.objs = i, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!w, this._operatorIdMapping = [];
              for (const x in h.OPS)
                this._operatorIdMapping[h.OPS[x]] = x;
            }
            getObject(r) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              return typeof r == "string" ? r.startsWith("g_") ? this.commonObjs.get(r) : this.objs.get(r) : i;
            }
            save() {
              this.transformStack.push(this.transformMatrix);
              const r = this.current;
              this.extraStack.push(r), this.current = r.clone();
            }
            restore() {
              this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
            }
            group(r) {
              this.save(), this.executeOpTree(r), this.restore();
            }
            loadDependencies(r) {
              const i = r.fnArray, w = r.argsArray;
              for (let x = 0, b = i.length; x < b; x++)
                if (i[x] === h.OPS.dependency)
                  for (const F of w[x]) {
                    const L = F.startsWith("g_") ? this.commonObjs : this.objs, G = new Promise((nt) => {
                      L.get(F, nt);
                    });
                    this.current.dependencies.push(G);
                  }
              return Promise.all(this.current.dependencies);
            }
            transform(r, i, w, x, b, F) {
              const L = [r, i, w, x, b, F];
              this.transformMatrix = h.Util.transform(this.transformMatrix, L), this.tgrp = null;
            }
            getSVG(r, i) {
              this.viewport = i;
              const w = this._initialize(i);
              return this.loadDependencies(r).then(() => (this.transformMatrix = h.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(r)), w));
            }
            convertOpList(r) {
              const i = this._operatorIdMapping, w = r.argsArray, x = r.fnArray, b = [];
              for (let F = 0, L = x.length; F < L; F++) {
                const G = x[F];
                b.push({
                  fnId: G,
                  fn: i[G],
                  args: w[F]
                });
              }
              return g(b);
            }
            executeOpTree(r) {
              for (const i of r) {
                const w = i.fn, x = i.fnId, b = i.args;
                switch (x | 0) {
                  case h.OPS.beginText:
                    this.beginText();
                    break;
                  case h.OPS.dependency:
                    break;
                  case h.OPS.setLeading:
                    this.setLeading(b);
                    break;
                  case h.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(b[0], b[1]);
                    break;
                  case h.OPS.setFont:
                    this.setFont(b);
                    break;
                  case h.OPS.showText:
                    this.showText(b[0]);
                    break;
                  case h.OPS.showSpacedText:
                    this.showText(b[0]);
                    break;
                  case h.OPS.endText:
                    this.endText();
                    break;
                  case h.OPS.moveText:
                    this.moveText(b[0], b[1]);
                    break;
                  case h.OPS.setCharSpacing:
                    this.setCharSpacing(b[0]);
                    break;
                  case h.OPS.setWordSpacing:
                    this.setWordSpacing(b[0]);
                    break;
                  case h.OPS.setHScale:
                    this.setHScale(b[0]);
                    break;
                  case h.OPS.setTextMatrix:
                    this.setTextMatrix(b[0], b[1], b[2], b[3], b[4], b[5]);
                    break;
                  case h.OPS.setTextRise:
                    this.setTextRise(b[0]);
                    break;
                  case h.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(b[0]);
                    break;
                  case h.OPS.setLineWidth:
                    this.setLineWidth(b[0]);
                    break;
                  case h.OPS.setLineJoin:
                    this.setLineJoin(b[0]);
                    break;
                  case h.OPS.setLineCap:
                    this.setLineCap(b[0]);
                    break;
                  case h.OPS.setMiterLimit:
                    this.setMiterLimit(b[0]);
                    break;
                  case h.OPS.setFillRGBColor:
                    this.setFillRGBColor(b[0], b[1], b[2]);
                    break;
                  case h.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(b[0], b[1], b[2]);
                    break;
                  case h.OPS.setStrokeColorN:
                    this.setStrokeColorN(b);
                    break;
                  case h.OPS.setFillColorN:
                    this.setFillColorN(b);
                    break;
                  case h.OPS.shadingFill:
                    this.shadingFill(b[0]);
                    break;
                  case h.OPS.setDash:
                    this.setDash(b[0], b[1]);
                    break;
                  case h.OPS.setRenderingIntent:
                    this.setRenderingIntent(b[0]);
                    break;
                  case h.OPS.setFlatness:
                    this.setFlatness(b[0]);
                    break;
                  case h.OPS.setGState:
                    this.setGState(b[0]);
                    break;
                  case h.OPS.fill:
                    this.fill();
                    break;
                  case h.OPS.eoFill:
                    this.eoFill();
                    break;
                  case h.OPS.stroke:
                    this.stroke();
                    break;
                  case h.OPS.fillStroke:
                    this.fillStroke();
                    break;
                  case h.OPS.eoFillStroke:
                    this.eoFillStroke();
                    break;
                  case h.OPS.clip:
                    this.clip("nonzero");
                    break;
                  case h.OPS.eoClip:
                    this.clip("evenodd");
                    break;
                  case h.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask();
                    break;
                  case h.OPS.paintImageXObject:
                    this.paintImageXObject(b[0]);
                    break;
                  case h.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(b[0]);
                    break;
                  case h.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(b[0]);
                    break;
                  case h.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(b[0], b[1]);
                    break;
                  case h.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd();
                    break;
                  case h.OPS.closePath:
                    this.closePath();
                    break;
                  case h.OPS.closeStroke:
                    this.closeStroke();
                    break;
                  case h.OPS.closeFillStroke:
                    this.closeFillStroke();
                    break;
                  case h.OPS.closeEOFillStroke:
                    this.closeEOFillStroke();
                    break;
                  case h.OPS.nextLine:
                    this.nextLine();
                    break;
                  case h.OPS.transform:
                    this.transform(b[0], b[1], b[2], b[3], b[4], b[5]);
                    break;
                  case h.OPS.constructPath:
                    this.constructPath(b[0], b[1]);
                    break;
                  case h.OPS.endPath:
                    this.endPath();
                    break;
                  case 92:
                    this.group(i.items);
                    break;
                  default:
                    (0, h.warn)(`Unimplemented operator ${w}`);
                    break;
                }
              }
            }
            setWordSpacing(r) {
              this.current.wordSpacing = r;
            }
            setCharSpacing(r) {
              this.current.charSpacing = r;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            setTextMatrix(r, i, w, x, b, F) {
              const L = this.current;
              L.textMatrix = L.lineMatrix = [r, i, w, x, b, F], L.textMatrixScale = Math.hypot(r, i), L.x = L.lineX = 0, L.y = L.lineY = 0, L.xcoords = [], L.ycoords = [], L.tspan = this.svgFactory.createElement("svg:tspan"), L.tspan.setAttributeNS(null, "font-family", L.fontFamily), L.tspan.setAttributeNS(null, "font-size", `${s(L.fontSize)}px`), L.tspan.setAttributeNS(null, "y", s(-L.y)), L.txtElement = this.svgFactory.createElement("svg:text"), L.txtElement.append(L.tspan);
            }
            beginText() {
              const r = this.current;
              r.x = r.lineX = 0, r.y = r.lineY = 0, r.textMatrix = h.IDENTITY_MATRIX, r.lineMatrix = h.IDENTITY_MATRIX, r.textMatrixScale = 1, r.tspan = this.svgFactory.createElement("svg:tspan"), r.txtElement = this.svgFactory.createElement("svg:text"), r.txtgrp = this.svgFactory.createElement("svg:g"), r.xcoords = [], r.ycoords = [];
            }
            moveText(r, i) {
              const w = this.current;
              w.x = w.lineX += r, w.y = w.lineY += i, w.xcoords = [], w.ycoords = [], w.tspan = this.svgFactory.createElement("svg:tspan"), w.tspan.setAttributeNS(null, "font-family", w.fontFamily), w.tspan.setAttributeNS(null, "font-size", `${s(w.fontSize)}px`), w.tspan.setAttributeNS(null, "y", s(-w.y));
            }
            showText(r) {
              const i = this.current, w = i.font, x = i.fontSize;
              if (x === 0)
                return;
              const b = i.fontSizeScale, F = i.charSpacing, L = i.wordSpacing, G = i.fontDirection, nt = i.textHScale * G, D = w.vertical, X = D ? 1 : -1, q = w.defaultVMetrics, j = x * i.fontMatrix[0];
              let z = 0;
              for (const Et of r) {
                if (Et === null) {
                  z += G * L;
                  continue;
                } else if (typeof Et == "number") {
                  z += X * Et * x / 1e3;
                  continue;
                }
                const Ct = (Et.isSpace ? L : 0) + F, H = Et.fontChar;
                let m, k, d = Et.width;
                if (D) {
                  let M;
                  const B = Et.vmetric || q;
                  M = Et.vmetric ? B[1] : d * 0.5, M = -M * j;
                  const _ = B[2] * j;
                  d = B ? -B[0] : d, m = M / b, k = (z + _) / b;
                } else
                  m = z / b, k = 0;
                (Et.isInFont || w.missingFile) && (i.xcoords.push(i.x + m), D && i.ycoords.push(-i.y + k), i.tspan.textContent += H);
                const R = D ? d * j - Ct * G : d * j + Ct * G;
                z += R;
              }
              i.tspan.setAttributeNS(null, "x", i.xcoords.map(s).join(" ")), D ? i.tspan.setAttributeNS(null, "y", i.ycoords.map(s).join(" ")) : i.tspan.setAttributeNS(null, "y", s(-i.y)), D ? i.y -= z : i.x += z * nt, i.tspan.setAttributeNS(null, "font-family", i.fontFamily), i.tspan.setAttributeNS(null, "font-size", `${s(i.fontSize)}px`), i.fontStyle !== T.fontStyle && i.tspan.setAttributeNS(null, "font-style", i.fontStyle), i.fontWeight !== T.fontWeight && i.tspan.setAttributeNS(null, "font-weight", i.fontWeight);
              const it = i.textRenderingMode & h.TextRenderingMode.FILL_STROKE_MASK;
              if (it === h.TextRenderingMode.FILL || it === h.TextRenderingMode.FILL_STROKE ? (i.fillColor !== T.fillColor && i.tspan.setAttributeNS(null, "fill", i.fillColor), i.fillAlpha < 1 && i.tspan.setAttributeNS(null, "fill-opacity", i.fillAlpha)) : i.textRenderingMode === h.TextRenderingMode.ADD_TO_PATH ? i.tspan.setAttributeNS(null, "fill", "transparent") : i.tspan.setAttributeNS(null, "fill", "none"), it === h.TextRenderingMode.STROKE || it === h.TextRenderingMode.FILL_STROKE) {
                const Et = 1 / (i.textMatrixScale || 1);
                this._setStrokeAttributes(i.tspan, Et);
              }
              let Q = i.textMatrix;
              i.textRise !== 0 && (Q = Q.slice(), Q[5] += i.textRise), i.txtElement.setAttributeNS(null, "transform", `${o(Q)} scale(${s(nt)}, -1)`), i.txtElement.setAttributeNS(P, "xml:space", "preserve"), i.txtElement.append(i.tspan), i.txtgrp.append(i.txtElement), this._ensureTransformGroup().append(i.txtElement);
            }
            setLeadingMoveText(r, i) {
              this.setLeading(-i), this.moveText(r, i);
            }
            addFontStyle(r) {
              if (!r.data)
                throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
              this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
              const i = a(r.data, r.mimetype, this.forceDataSchema);
              this.cssStyle.textContent += `@font-face { font-family: "${r.loadedName}"; src: url(${i}); }
`;
            }
            setFont(r) {
              const i = this.current, w = this.commonObjs.get(r[0]);
              let x = r[1];
              i.font = w, this.embedFonts && !w.missingFile && !this.embeddedFonts[w.loadedName] && (this.addFontStyle(w), this.embeddedFonts[w.loadedName] = w), i.fontMatrix = w.fontMatrix || h.FONT_IDENTITY_MATRIX;
              let b = "normal";
              w.black ? b = "900" : w.bold && (b = "bold");
              const F = w.italic ? "italic" : "normal";
              x < 0 ? (x = -x, i.fontDirection = -1) : i.fontDirection = 1, i.fontSize = x, i.fontFamily = w.loadedName, i.fontWeight = b, i.fontStyle = F, i.tspan = this.svgFactory.createElement("svg:tspan"), i.tspan.setAttributeNS(null, "y", s(-i.y)), i.xcoords = [], i.ycoords = [];
            }
            endText() {
              var i;
              const r = this.current;
              r.textRenderingMode & h.TextRenderingMode.ADD_TO_PATH_FLAG && ((i = r.txtElement) != null && i.hasChildNodes()) && (r.element = r.txtElement, this.clip("nonzero"), this.endPath());
            }
            setLineWidth(r) {
              r > 0 && (this.current.lineWidth = r);
            }
            setLineCap(r) {
              this.current.lineCap = y[r];
            }
            setLineJoin(r) {
              this.current.lineJoin = c[r];
            }
            setMiterLimit(r) {
              this.current.miterLimit = r;
            }
            setStrokeAlpha(r) {
              this.current.strokeAlpha = r;
            }
            setStrokeRGBColor(r, i, w) {
              this.current.strokeColor = h.Util.makeHexColor(r, i, w);
            }
            setFillAlpha(r) {
              this.current.fillAlpha = r;
            }
            setFillRGBColor(r, i, w) {
              this.current.fillColor = h.Util.makeHexColor(r, i, w), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
            }
            setStrokeColorN(r) {
              this.current.strokeColor = this._makeColorN_Pattern(r);
            }
            setFillColorN(r) {
              this.current.fillColor = this._makeColorN_Pattern(r);
            }
            shadingFill(r) {
              const {
                width: i,
                height: w
              } = this.viewport, x = h.Util.inverseTransform(this.transformMatrix), [b, F, L, G] = h.Util.getAxialAlignedBoundingBox([0, 0, i, w], x), nt = this.svgFactory.createElement("svg:rect");
              nt.setAttributeNS(null, "x", b), nt.setAttributeNS(null, "y", F), nt.setAttributeNS(null, "width", L - b), nt.setAttributeNS(null, "height", G - F), nt.setAttributeNS(null, "fill", this._makeShadingPattern(r)), this.current.fillAlpha < 1 && nt.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(nt);
            }
            _makeColorN_Pattern(r) {
              return r[0] === "TilingPattern" ? this._makeTilingPattern(r) : this._makeShadingPattern(r);
            }
            _makeTilingPattern(r) {
              const i = r[1], w = r[2], x = r[3] || h.IDENTITY_MATRIX, [b, F, L, G] = r[4], nt = r[5], D = r[6], X = r[7], q = `shading${v++}`, [j, z, it, Q] = h.Util.normalizeRect([...h.Util.applyTransform([b, F], x), ...h.Util.applyTransform([L, G], x)]), [Et, Ct] = h.Util.singularValueDecompose2dScale(x), H = nt * Et, m = D * Ct, k = this.svgFactory.createElement("svg:pattern");
              k.setAttributeNS(null, "id", q), k.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), k.setAttributeNS(null, "width", H), k.setAttributeNS(null, "height", m), k.setAttributeNS(null, "x", `${j}`), k.setAttributeNS(null, "y", `${z}`);
              const d = this.svg, R = this.transformMatrix, M = this.current.fillColor, B = this.current.strokeColor, _ = this.svgFactory.create(it - j, Q - z);
              if (this.svg = _, this.transformMatrix = x, X === 2) {
                const Z = h.Util.makeHexColor(...i);
                this.current.fillColor = Z, this.current.strokeColor = Z;
              }
              return this.executeOpTree(this.convertOpList(w)), this.svg = d, this.transformMatrix = R, this.current.fillColor = M, this.current.strokeColor = B, k.append(_.childNodes[0]), this.defs.append(k), `url(#${q})`;
            }
            _makeShadingPattern(r) {
              switch (typeof r == "string" && (r = this.objs.get(r)), r[0]) {
                case "RadialAxial":
                  const i = `shading${v++}`, w = r[3];
                  let x;
                  switch (r[1]) {
                    case "axial":
                      const b = r[4], F = r[5];
                      x = this.svgFactory.createElement("svg:linearGradient"), x.setAttributeNS(null, "id", i), x.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), x.setAttributeNS(null, "x1", b[0]), x.setAttributeNS(null, "y1", b[1]), x.setAttributeNS(null, "x2", F[0]), x.setAttributeNS(null, "y2", F[1]);
                      break;
                    case "radial":
                      const L = r[4], G = r[5], nt = r[6], D = r[7];
                      x = this.svgFactory.createElement("svg:radialGradient"), x.setAttributeNS(null, "id", i), x.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), x.setAttributeNS(null, "cx", G[0]), x.setAttributeNS(null, "cy", G[1]), x.setAttributeNS(null, "r", D), x.setAttributeNS(null, "fx", L[0]), x.setAttributeNS(null, "fy", L[1]), x.setAttributeNS(null, "fr", nt);
                      break;
                    default:
                      throw new Error(`Unknown RadialAxial type: ${r[1]}`);
                  }
                  for (const b of w) {
                    const F = this.svgFactory.createElement("svg:stop");
                    F.setAttributeNS(null, "offset", b[0]), F.setAttributeNS(null, "stop-color", b[1]), x.append(F);
                  }
                  return this.defs.append(x), `url(#${i})`;
                case "Mesh":
                  return (0, h.warn)("Unimplemented pattern Mesh"), null;
                case "Dummy":
                  return "hotpink";
                default:
                  throw new Error(`Unknown IR type: ${r[0]}`);
              }
            }
            setDash(r, i) {
              this.current.dashArray = r, this.current.dashPhase = i;
            }
            constructPath(r, i) {
              const w = this.current;
              let x = w.x, b = w.y, F = [], L = 0;
              for (const G of r)
                switch (G | 0) {
                  case h.OPS.rectangle:
                    x = i[L++], b = i[L++];
                    const nt = i[L++], D = i[L++], X = x + nt, q = b + D;
                    F.push("M", s(x), s(b), "L", s(X), s(b), "L", s(X), s(q), "L", s(x), s(q), "Z");
                    break;
                  case h.OPS.moveTo:
                    x = i[L++], b = i[L++], F.push("M", s(x), s(b));
                    break;
                  case h.OPS.lineTo:
                    x = i[L++], b = i[L++], F.push("L", s(x), s(b));
                    break;
                  case h.OPS.curveTo:
                    x = i[L + 4], b = i[L + 5], F.push("C", s(i[L]), s(i[L + 1]), s(i[L + 2]), s(i[L + 3]), s(x), s(b)), L += 6;
                    break;
                  case h.OPS.curveTo2:
                    F.push("C", s(x), s(b), s(i[L]), s(i[L + 1]), s(i[L + 2]), s(i[L + 3])), x = i[L + 2], b = i[L + 3], L += 4;
                    break;
                  case h.OPS.curveTo3:
                    x = i[L + 2], b = i[L + 3], F.push("C", s(i[L]), s(i[L + 1]), s(x), s(b), s(x), s(b)), L += 4;
                    break;
                  case h.OPS.closePath:
                    F.push("Z");
                    break;
                }
              F = F.join(" "), w.path && r.length > 0 && r[0] !== h.OPS.rectangle && r[0] !== h.OPS.moveTo ? F = w.path.getAttributeNS(null, "d") + F : (w.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(w.path)), w.path.setAttributeNS(null, "d", F), w.path.setAttributeNS(null, "fill", "none"), w.element = w.path, w.setCurrentPoint(x, b);
            }
            endPath() {
              const r = this.current;
              if (r.path = null, !this.pendingClip)
                return;
              if (!r.element) {
                this.pendingClip = null;
                return;
              }
              const i = `clippath${l++}`, w = this.svgFactory.createElement("svg:clipPath");
              w.setAttributeNS(null, "id", i), w.setAttributeNS(null, "transform", o(this.transformMatrix));
              const x = r.element.cloneNode(!0);
              if (this.pendingClip === "evenodd" ? x.setAttributeNS(null, "clip-rule", "evenodd") : x.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, w.append(x), this.defs.append(w), r.activeClipUrl) {
                r.clipGroup = null;
                for (const b of this.extraStack)
                  b.clipGroup = null;
                w.setAttributeNS(null, "clip-path", r.activeClipUrl);
              }
              r.activeClipUrl = `url(#${i})`, this.tgrp = null;
            }
            clip(r) {
              this.pendingClip = r;
            }
            closePath() {
              const r = this.current;
              if (r.path) {
                const i = `${r.path.getAttributeNS(null, "d")}Z`;
                r.path.setAttributeNS(null, "d", i);
              }
            }
            setLeading(r) {
              this.current.leading = -r;
            }
            setTextRise(r) {
              this.current.textRise = r;
            }
            setTextRenderingMode(r) {
              this.current.textRenderingMode = r;
            }
            setHScale(r) {
              this.current.textHScale = r / 100;
            }
            setRenderingIntent(r) {
            }
            setFlatness(r) {
            }
            setGState(r) {
              for (const [i, w] of r)
                switch (i) {
                  case "LW":
                    this.setLineWidth(w);
                    break;
                  case "LC":
                    this.setLineCap(w);
                    break;
                  case "LJ":
                    this.setLineJoin(w);
                    break;
                  case "ML":
                    this.setMiterLimit(w);
                    break;
                  case "D":
                    this.setDash(w[0], w[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(w);
                    break;
                  case "FL":
                    this.setFlatness(w);
                    break;
                  case "Font":
                    this.setFont(w);
                    break;
                  case "CA":
                    this.setStrokeAlpha(w);
                    break;
                  case "ca":
                    this.setFillAlpha(w);
                    break;
                  default:
                    (0, h.warn)(`Unimplemented graphic state operator ${i}`);
                    break;
                }
            }
            fill() {
              const r = this.current;
              r.element && (r.element.setAttributeNS(null, "fill", r.fillColor), r.element.setAttributeNS(null, "fill-opacity", r.fillAlpha), this.endPath());
            }
            stroke() {
              const r = this.current;
              r.element && (this._setStrokeAttributes(r.element), r.element.setAttributeNS(null, "fill", "none"), this.endPath());
            }
            _setStrokeAttributes(r) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              const w = this.current;
              let x = w.dashArray;
              i !== 1 && x.length > 0 && (x = x.map(function(b) {
                return i * b;
              })), r.setAttributeNS(null, "stroke", w.strokeColor), r.setAttributeNS(null, "stroke-opacity", w.strokeAlpha), r.setAttributeNS(null, "stroke-miterlimit", s(w.miterLimit)), r.setAttributeNS(null, "stroke-linecap", w.lineCap), r.setAttributeNS(null, "stroke-linejoin", w.lineJoin), r.setAttributeNS(null, "stroke-width", s(i * w.lineWidth) + "px"), r.setAttributeNS(null, "stroke-dasharray", x.map(s).join(" ")), r.setAttributeNS(null, "stroke-dashoffset", s(i * w.dashPhase) + "px");
            }
            eoFill() {
              var r;
              (r = this.current.element) == null || r.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
            }
            fillStroke() {
              this.stroke(), this.fill();
            }
            eoFillStroke() {
              var r;
              (r = this.current.element) == null || r.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.closePath(), this.eoFillStroke();
            }
            paintSolidColorImageMask() {
              const r = this.svgFactory.createElement("svg:rect");
              r.setAttributeNS(null, "x", "0"), r.setAttributeNS(null, "y", "0"), r.setAttributeNS(null, "width", "1px"), r.setAttributeNS(null, "height", "1px"), r.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(r);
            }
            paintImageXObject(r) {
              const i = this.getObject(r);
              if (!i) {
                (0, h.warn)(`Dependent image with object ID ${r} is not ready yet`);
                return;
              }
              this.paintInlineImageXObject(i);
            }
            paintInlineImageXObject(r, i) {
              const w = r.width, x = r.height, b = I(r, this.forceDataSchema, !!i), F = this.svgFactory.createElement("svg:rect");
              F.setAttributeNS(null, "x", "0"), F.setAttributeNS(null, "y", "0"), F.setAttributeNS(null, "width", s(w)), F.setAttributeNS(null, "height", s(x)), this.current.element = F, this.clip("nonzero");
              const L = this.svgFactory.createElement("svg:image");
              L.setAttributeNS(f, "xlink:href", b), L.setAttributeNS(null, "x", "0"), L.setAttributeNS(null, "y", s(-x)), L.setAttributeNS(null, "width", s(w) + "px"), L.setAttributeNS(null, "height", s(x) + "px"), L.setAttributeNS(null, "transform", `scale(${s(1 / w)} ${s(-1 / x)})`), i ? i.append(L) : this._ensureTransformGroup().append(L);
            }
            paintImageMaskXObject(r) {
              const i = this.getObject(r.data, r);
              if (i.bitmap) {
                (0, h.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                return;
              }
              const w = this.current, x = i.width, b = i.height, F = w.fillColor;
              w.maskId = `mask${u++}`;
              const L = this.svgFactory.createElement("svg:mask");
              L.setAttributeNS(null, "id", w.maskId);
              const G = this.svgFactory.createElement("svg:rect");
              G.setAttributeNS(null, "x", "0"), G.setAttributeNS(null, "y", "0"), G.setAttributeNS(null, "width", s(x)), G.setAttributeNS(null, "height", s(b)), G.setAttributeNS(null, "fill", F), G.setAttributeNS(null, "mask", `url(#${w.maskId})`), this.defs.append(L), this._ensureTransformGroup().append(G), this.paintInlineImageXObject(i, L);
            }
            paintFormXObjectBegin(r, i) {
              if (Array.isArray(r) && r.length === 6 && this.transform(r[0], r[1], r[2], r[3], r[4], r[5]), i) {
                const w = i[2] - i[0], x = i[3] - i[1], b = this.svgFactory.createElement("svg:rect");
                b.setAttributeNS(null, "x", i[0]), b.setAttributeNS(null, "y", i[1]), b.setAttributeNS(null, "width", s(w)), b.setAttributeNS(null, "height", s(x)), this.current.element = b, this.clip("nonzero"), this.endPath();
              }
            }
            paintFormXObjectEnd() {
            }
            _initialize(r) {
              const i = this.svgFactory.create(r.width, r.height), w = this.svgFactory.createElement("svg:defs");
              i.append(w), this.defs = w;
              const x = this.svgFactory.createElement("svg:g");
              return x.setAttributeNS(null, "transform", o(r.transform)), i.append(x), this.svg = x, i;
            }
            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                const r = this.svgFactory.createElement("svg:g");
                r.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(r), this.current.clipGroup = r;
              }
              return this.current.clipGroup;
            }
            _ensureTransformGroup() {
              return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", o(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
            }
          }
          S.SVGGraphics = p;
        },
        /* 187 */
        /***/
        (O, S, t) => {
          var n = t(3), h = t(188), T = t(193);
          n({
            target: "Array",
            proto: !0
          }, {
            group: function(f) {
              var y = arguments.length > 1 ? arguments[1] : void 0;
              return h(this, f, y);
            }
          }), T("group");
        },
        /* 188 */
        /***/
        (O, S, t) => {
          var n = t(99), h = t(14), T = t(13), P = t(40), f = t(18), y = t(64), c = t(189), a = t(108), I = Array, A = h([].push);
          O.exports = function(g, s, o, l) {
            for (var u = P(g), v = T(u), p = n(s, o), C = c(null), r = y(v), i = 0, w, x, b; r > i; i++)
              b = v[i], x = f(p(b, i, u)), x in C ? A(C[x], b) : C[x] = [b];
            if (l && (w = l(u), w !== I))
              for (x in C)
                C[x] = a(w, C[x]);
            return C;
          };
        },
        /* 189 */
        /***/
        (O, S, t) => {
          var n = t(47), h = t(190), T = t(66), P = t(55), f = t(192), y = t(43), c = t(54), a = ">", I = "<", A = "prototype", g = "script", s = c("IE_PROTO"), o = function() {
          }, l = function(r) {
            return I + g + a + r + I + "/" + g + a;
          }, u = function(r) {
            r.write(l("")), r.close();
            var i = r.parentWindow.Object;
            return r = null, i;
          }, v = function() {
            var r = y("iframe"), i = "java" + g + ":", w;
            return r.style.display = "none", f.appendChild(r), r.src = String(i), w = r.contentWindow.document, w.open(), w.write(l("document.F=Object")), w.close(), w.F;
          }, p, C = function() {
            try {
              p = new ActiveXObject("htmlfile");
            } catch {
            }
            C = typeof document < "u" ? document.domain && p ? u(p) : v() : u(p);
            for (var r = T.length; r--; )
              delete C[A][T[r]];
            return C();
          };
          P[s] = !0, O.exports = Object.create || function(i, w) {
            var x;
            return i !== null ? (o[A] = n(i), x = new o(), o[A] = null, x[s] = i) : x = C(), w === void 0 ? x : h.f(x, w);
          };
        },
        /* 190 */
        /***/
        (O, S, t) => {
          var n = t(6), h = t(46), T = t(45), P = t(47), f = t(12), y = t(191);
          S.f = n && !h ? Object.defineProperties : function(a, I) {
            P(a);
            for (var A = f(I), g = y(I), s = g.length, o = 0, l; s > o; )
              T.f(a, l = g[o++], A[l]);
            return a;
          };
        },
        /* 191 */
        /***/
        (O, S, t) => {
          var n = t(59), h = t(66);
          O.exports = Object.keys || function(P) {
            return n(P, h);
          };
        },
        /* 192 */
        /***/
        (O, S, t) => {
          var n = t(24);
          O.exports = n("document", "documentElement");
        },
        /* 193 */
        /***/
        (O, S, t) => {
          var n = t(34), h = t(189), T = t(45).f, P = n("unscopables"), f = Array.prototype;
          f[P] === void 0 && T(f, P, {
            configurable: !0,
            value: h(null)
          }), O.exports = function(y) {
            f[P][y] = !0;
          };
        },
        /* 194 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.XfaText = void 0, t(89);
          class n {
            static textContent(T) {
              const P = [], f = {
                items: P,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function y(c) {
                var A;
                if (!c)
                  return;
                let a = null;
                const I = c.name;
                if (I === "#text")
                  a = c.value;
                else if (n.shouldBuildText(I))
                  (A = c == null ? void 0 : c.attributes) != null && A.textContent ? a = c.attributes.textContent : c.value && (a = c.value);
                else
                  return;
                if (a !== null && P.push({
                  str: a
                }), !!c.children)
                  for (const g of c.children)
                    y(g);
              }
              return y(T), f;
            }
            static shouldBuildText(T) {
              return !(T === "textarea" || T === "input" || T === "option" || T === "select");
            }
          }
          S.XfaText = n;
        },
        /* 195 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.TextLayerRenderTask = void 0, S.renderTextLayer = o, S.updateTextLayer = l, t(89), t(2);
          var n = t(1), h = t(168);
          const T = 1e5, P = 30, f = 0.8, y = /* @__PURE__ */ new Map();
          function c(u, v) {
            let p;
            if (v && n.FeatureTest.isOffscreenCanvasSupported)
              p = new OffscreenCanvas(u, u).getContext("2d", {
                alpha: !1
              });
            else {
              const C = document.createElement("canvas");
              C.width = C.height = u, p = C.getContext("2d", {
                alpha: !1
              });
            }
            return p;
          }
          function a(u, v) {
            const p = y.get(u);
            if (p)
              return p;
            const C = c(P, v);
            C.font = `${P}px ${u}`;
            const r = C.measureText("");
            let i = r.fontBoundingBoxAscent, w = Math.abs(r.fontBoundingBoxDescent);
            if (i) {
              const b = i / (i + w);
              return y.set(u, b), C.canvas.width = C.canvas.height = 0, b;
            }
            C.strokeStyle = "red", C.clearRect(0, 0, P, P), C.strokeText("g", 0, 0);
            let x = C.getImageData(0, 0, P, P).data;
            w = 0;
            for (let b = x.length - 1 - 3; b >= 0; b -= 4)
              if (x[b] > 0) {
                w = Math.ceil(b / 4 / P);
                break;
              }
            C.clearRect(0, 0, P, P), C.strokeText("A", 0, P), x = C.getImageData(0, 0, P, P).data, i = 0;
            for (let b = 0, F = x.length; b < F; b += 4)
              if (x[b] > 0) {
                i = P - Math.floor(b / 4 / P);
                break;
              }
            if (C.canvas.width = C.canvas.height = 0, i) {
              const b = i / (i + w);
              return y.set(u, b), b;
            }
            return y.set(u, f), f;
          }
          function I(u, v, p) {
            const C = document.createElement("span"), r = {
              angle: 0,
              canvasWidth: 0,
              hasText: v.str !== "",
              hasEOL: v.hasEOL,
              fontSize: 0
            };
            u._textDivs.push(C);
            const i = n.Util.transform(u._transform, v.transform);
            let w = Math.atan2(i[1], i[0]);
            const x = p[v.fontName];
            x.vertical && (w += Math.PI / 2);
            const b = Math.hypot(i[2], i[3]), F = b * a(x.fontFamily, u._isOffscreenCanvasSupported);
            let L, G;
            w === 0 ? (L = i[4], G = i[5] - F) : (L = i[4] + F * Math.sin(w), G = i[5] - F * Math.cos(w));
            const nt = "calc(var(--scale-factor)*", D = C.style;
            u._container === u._rootContainer ? (D.left = `${(100 * L / u._pageWidth).toFixed(2)}%`, D.top = `${(100 * G / u._pageHeight).toFixed(2)}%`) : (D.left = `${nt}${L.toFixed(2)}px)`, D.top = `${nt}${G.toFixed(2)}px)`), D.fontSize = `${nt}${b.toFixed(2)}px)`, D.fontFamily = x.fontFamily, r.fontSize = b, C.setAttribute("role", "presentation"), C.textContent = v.str, C.dir = v.dir, u._fontInspectorEnabled && (C.dataset.fontName = v.fontName), w !== 0 && (r.angle = w * (180 / Math.PI));
            let X = !1;
            if (v.str.length > 1)
              X = !0;
            else if (v.str !== " " && v.transform[0] !== v.transform[3]) {
              const q = Math.abs(v.transform[0]), j = Math.abs(v.transform[3]);
              q !== j && Math.max(q, j) / Math.min(q, j) > 1.5 && (X = !0);
            }
            X && (r.canvasWidth = x.vertical ? v.height : v.width), u._textDivProperties.set(C, r), u._isReadableStream && u._layoutText(C);
          }
          function A(u) {
            const {
              div: v,
              scale: p,
              properties: C,
              ctx: r,
              prevFontSize: i,
              prevFontFamily: w
            } = u, {
              style: x
            } = v;
            let b = "";
            if (C.canvasWidth !== 0 && C.hasText) {
              const {
                fontFamily: F
              } = x, {
                canvasWidth: L,
                fontSize: G
              } = C;
              (i !== G || w !== F) && (r.font = `${G * p}px ${F}`, u.prevFontSize = G, u.prevFontFamily = F);
              const {
                width: nt
              } = r.measureText(v.textContent);
              nt > 0 && (b = `scaleX(${L * p / nt})`);
            }
            C.angle !== 0 && (b = `rotate(${C.angle}deg) ${b}`), b.length > 0 && (x.transform = b);
          }
          function g(u) {
            if (u._canceled)
              return;
            const v = u._textDivs, p = u._capability;
            if (v.length > T) {
              p.resolve();
              return;
            }
            if (!u._isReadableStream)
              for (const r of v)
                u._layoutText(r);
            p.resolve();
          }
          class s {
            constructor(v) {
              var D;
              let {
                textContentSource: p,
                container: C,
                viewport: r,
                textDivs: i,
                textDivProperties: w,
                textContentItemsStr: x,
                isOffscreenCanvasSupported: b
              } = v;
              this._textContentSource = p, this._isReadableStream = p instanceof ReadableStream, this._container = this._rootContainer = C, this._textDivs = i || [], this._textContentItemsStr = x || [], this._isOffscreenCanvasSupported = b, this._fontInspectorEnabled = !!((D = globalThis.FontInspector) != null && D.enabled), this._reader = null, this._textDivProperties = w || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new n.PromiseCapability(), this._layoutTextParams = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: r.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: c(0, b)
              };
              const {
                pageWidth: F,
                pageHeight: L,
                pageX: G,
                pageY: nt
              } = r.rawDims;
              this._transform = [1, 0, 0, -1, -G, nt + L], this._pageWidth = F, this._pageHeight = L, (0, h.setLayerDimensions)(C, r), this._capability.promise.finally(() => {
                this._layoutTextParams = null;
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new n.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._capability.reject(new n.AbortException("TextLayer task cancelled."));
            }
            _processItems(v, p) {
              for (const C of v) {
                if (C.str === void 0) {
                  if (C.type === "beginMarkedContentProps" || C.type === "beginMarkedContent") {
                    const r = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), C.id !== null && this._container.setAttribute("id", `${C.id}`), r.append(this._container);
                  } else
                    C.type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(C.str), I(this, C, p);
              }
            }
            _layoutText(v) {
              const p = this._layoutTextParams.properties = this._textDivProperties.get(v);
              if (this._layoutTextParams.div = v, A(this._layoutTextParams), p.hasText && this._container.append(v), p.hasEOL) {
                const C = document.createElement("br");
                C.setAttribute("role", "presentation"), this._container.append(C);
              }
            }
            _render() {
              const v = new n.PromiseCapability();
              let p = /* @__PURE__ */ Object.create(null);
              if (this._isReadableStream) {
                const C = () => {
                  this._reader.read().then((r) => {
                    let {
                      value: i,
                      done: w
                    } = r;
                    if (w) {
                      v.resolve();
                      return;
                    }
                    Object.assign(p, i.styles), this._processItems(i.items, p), C();
                  }, v.reject);
                };
                this._reader = this._textContentSource.getReader(), C();
              } else if (this._textContentSource) {
                const {
                  items: C,
                  styles: r
                } = this._textContentSource;
                this._processItems(C, r), v.resolve();
              } else
                throw new Error('No "textContentSource" parameter specified.');
              v.promise.then(() => {
                p = null, g(this);
              }, this._capability.reject);
            }
          }
          S.TextLayerRenderTask = s;
          function o(u) {
            !u.textContentSource && (u.textContent || u.textContentStream) && ((0, h.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), u.textContentSource = u.textContent || u.textContentStream);
            const {
              container: v,
              viewport: p
            } = u, C = getComputedStyle(v), r = C.getPropertyValue("visibility"), i = parseFloat(C.getPropertyValue("--scale-factor"));
            r === "visible" && (!i || Math.abs(i - p.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
            const w = new s(u);
            return w._render(), w;
          }
          function l(u) {
            let {
              container: v,
              viewport: p,
              textDivs: C,
              textDivProperties: r,
              isOffscreenCanvasSupported: i,
              mustRotate: w = !0,
              mustRescale: x = !0
            } = u;
            if (w && (0, h.setLayerDimensions)(v, {
              rotation: p.rotation
            }), x) {
              const b = c(0, i), L = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: p.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: b
              };
              for (const G of C)
                L.properties = r.get(G), L.div = G, A(L);
            }
          }
        },
        /* 196 */
        /***/
        (O, S, t) => {
          var a, I, A, g, s, o, l, u, v, p, C, pn, i, De, x, gn, F, mn;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.AnnotationEditorLayer = void 0, t(125), t(136), t(138), t(141), t(143), t(145), t(147);
          var n = t(1), h = t(164), T = t(197), P = t(202), f = t(168), y = t(203);
          const G = class G {
            constructor(D) {
              W(this, C);
              W(this, i);
              W(this, x);
              W(this, F);
              W(this, a, void 0);
              W(this, I, !1);
              W(this, A, null);
              W(this, g, this.pointerup.bind(this));
              W(this, s, this.pointerdown.bind(this));
              W(this, o, /* @__PURE__ */ new Map());
              W(this, l, !1);
              W(this, u, !1);
              W(this, v, !1);
              W(this, p, void 0);
              let {
                uiManager: X,
                pageIndex: q,
                div: j,
                accessibilityManager: z,
                annotationLayer: it,
                viewport: Q,
                l10n: Et
              } = D;
              const Ct = [T.FreeTextEditor, P.InkEditor, y.StampEditor];
              if (!G._initialized) {
                G._initialized = !0;
                for (const H of Ct)
                  H.initialize(Et);
              }
              X.registerEditorTypes(Ct), rt(this, p, X), this.pageIndex = q, this.div = j, rt(this, a, z), rt(this, A, it), this.viewport = Q, e(this, p).addLayer(this);
            }
            get isEmpty() {
              return e(this, o).size === 0;
            }
            updateToolbar(D) {
              e(this, p).updateToolbar(D);
            }
            updateMode() {
              let D = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e(this, p).getMode();
              J(this, F, mn).call(this), D === n.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), D !== n.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", D === n.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", D === n.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", D === n.AnnotationEditorType.STAMP), this.div.hidden = !1);
            }
            addInkEditorIfNeeded(D) {
              if (!D && e(this, p).getMode() !== n.AnnotationEditorType.INK)
                return;
              if (!D) {
                for (const q of e(this, o).values())
                  if (q.isEmpty()) {
                    q.setInBackground();
                    return;
                  }
              }
              J(this, i, De).call(this, {
                offsetX: 0,
                offsetY: 0
              }, !1).setInBackground();
            }
            setEditingState(D) {
              e(this, p).setEditingState(D);
            }
            addCommands(D) {
              e(this, p).addCommands(D);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              const D = /* @__PURE__ */ new Set();
              for (const q of e(this, o).values())
                q.enableEditing(), q.annotationElementId && D.add(q.annotationElementId);
              if (!e(this, A))
                return;
              const X = e(this, A).getEditableAnnotations();
              for (const q of X) {
                if (q.hide(), e(this, p).isDeletedAnnotationElement(q.data.id) || D.has(q.data.id))
                  continue;
                const j = this.deserialize(q);
                j && (this.addOrRebuild(j), j.enableEditing());
              }
            }
            disable() {
              var X;
              rt(this, v, !0), this.div.style.pointerEvents = "none";
              const D = /* @__PURE__ */ new Set();
              for (const q of e(this, o).values()) {
                if (q.disableEditing(), !q.annotationElementId || q.serialize() !== null) {
                  D.add(q.annotationElementId);
                  continue;
                }
                (X = this.getEditableAnnotation(q.annotationElementId)) == null || X.show(), q.remove();
              }
              if (e(this, A)) {
                const q = e(this, A).getEditableAnnotations();
                for (const j of q) {
                  const {
                    id: z
                  } = j.data;
                  D.has(z) || e(this, p).isDeletedAnnotationElement(z) || j.show();
                }
              }
              J(this, F, mn).call(this), this.isEmpty && (this.div.hidden = !0), rt(this, v, !1);
            }
            getEditableAnnotation(D) {
              var X;
              return ((X = e(this, A)) == null ? void 0 : X.getEditableAnnotation(D)) || null;
            }
            setActiveEditor(D) {
              e(this, p).getActive() !== D && e(this, p).setActiveEditor(D);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", e(this, s)), this.div.addEventListener("pointerup", e(this, g));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", e(this, s)), this.div.removeEventListener("pointerup", e(this, g));
            }
            attach(D) {
              e(this, o).set(D.id, D);
              const {
                annotationElementId: X
              } = D;
              X && e(this, p).isDeletedAnnotationElement(X) && e(this, p).removeDeletedAnnotationElement(D);
            }
            detach(D) {
              var X;
              e(this, o).delete(D.id), (X = e(this, a)) == null || X.removePointerInTextLayer(D.contentDiv), !e(this, v) && D.annotationElementId && e(this, p).addDeletedAnnotationElement(D);
            }
            remove(D) {
              this.detach(D), e(this, p).removeEditor(D), D.div.contains(document.activeElement) && setTimeout(() => {
                e(this, p).focusMainContainer();
              }, 0), D.div.remove(), D.isAttachedToDOM = !1, e(this, u) || this.addInkEditorIfNeeded(!1);
            }
            changeParent(D) {
              var X;
              D.parent !== this && (D.annotationElementId && (e(this, p).addDeletedAnnotationElement(D.annotationElementId), h.AnnotationEditor.deleteAnnotationElement(D), D.annotationElementId = null), this.attach(D), (X = D.parent) == null || X.detach(D), D.setParent(this), D.div && D.isAttachedToDOM && (D.div.remove(), this.div.append(D.div)));
            }
            add(D) {
              if (this.changeParent(D), e(this, p).addEditor(D), this.attach(D), !D.isAttachedToDOM) {
                const X = D.render();
                this.div.append(X), D.isAttachedToDOM = !0;
              }
              D.fixAndSetPosition(), D.onceAdded(), e(this, p).addToAnnotationStorage(D);
            }
            moveEditorInDOM(D) {
              var q;
              if (!D.isAttachedToDOM)
                return;
              const {
                activeElement: X
              } = document;
              D.div.contains(X) && (D._focusEventsAllowed = !1, setTimeout(() => {
                D.div.contains(document.activeElement) ? D._focusEventsAllowed = !0 : (D.div.addEventListener("focusin", () => {
                  D._focusEventsAllowed = !0;
                }, {
                  once: !0
                }), X.focus());
              }, 0)), D._structTreeParentId = (q = e(this, a)) == null ? void 0 : q.moveElementInDOM(this.div, D.div, D.contentDiv, !0);
            }
            addOrRebuild(D) {
              D.needsToBeRebuilt() ? D.rebuild() : this.add(D);
            }
            addUndoableEditor(D) {
              const X = () => D._uiManager.rebuild(D), q = () => {
                D.remove();
              };
              this.addCommands({
                cmd: X,
                undo: q,
                mustExec: !1
              });
            }
            getNextId() {
              return e(this, p).getId();
            }
            pasteEditor(D, X) {
              e(this, p).updateToolbar(D), e(this, p).updateMode(D);
              const {
                offsetX: q,
                offsetY: j
              } = J(this, x, gn).call(this), z = this.getNextId(), it = J(this, C, pn).call(this, {
                parent: this,
                id: z,
                x: q,
                y: j,
                uiManager: e(this, p),
                isCentered: !0,
                ...X
              });
              it && this.add(it);
            }
            deserialize(D) {
              switch (D.annotationType ?? D.annotationEditorType) {
                case n.AnnotationEditorType.FREETEXT:
                  return T.FreeTextEditor.deserialize(D, this, e(this, p));
                case n.AnnotationEditorType.INK:
                  return P.InkEditor.deserialize(D, this, e(this, p));
                case n.AnnotationEditorType.STAMP:
                  return y.StampEditor.deserialize(D, this, e(this, p));
              }
              return null;
            }
            addNewEditor() {
              J(this, i, De).call(this, J(this, x, gn).call(this), !0);
            }
            setSelected(D) {
              e(this, p).setSelected(D);
            }
            toggleSelected(D) {
              e(this, p).toggleSelected(D);
            }
            isSelected(D) {
              return e(this, p).isSelected(D);
            }
            unselect(D) {
              e(this, p).unselect(D);
            }
            pointerup(D) {
              const {
                isMac: X
              } = n.FeatureTest.platform;
              if (!(D.button !== 0 || D.ctrlKey && X) && D.target === this.div && e(this, l)) {
                if (rt(this, l, !1), !e(this, I)) {
                  rt(this, I, !0);
                  return;
                }
                if (e(this, p).getMode() === n.AnnotationEditorType.STAMP) {
                  e(this, p).unselectAll();
                  return;
                }
                J(this, i, De).call(this, D, !1);
              }
            }
            pointerdown(D) {
              if (e(this, l)) {
                rt(this, l, !1);
                return;
              }
              const {
                isMac: X
              } = n.FeatureTest.platform;
              if (D.button !== 0 || D.ctrlKey && X || D.target !== this.div)
                return;
              rt(this, l, !0);
              const q = e(this, p).getActive();
              rt(this, I, !q || q.isEmpty());
            }
            findNewParent(D, X, q) {
              const j = e(this, p).findParent(X, q);
              return j === null || j === this ? !1 : (j.changeParent(D), !0);
            }
            destroy() {
              var D, X;
              ((D = e(this, p).getActive()) == null ? void 0 : D.parent) === this && (e(this, p).commitOrRemove(), e(this, p).setActiveEditor(null));
              for (const q of e(this, o).values())
                (X = e(this, a)) == null || X.removePointerInTextLayer(q.contentDiv), q.setParent(null), q.isAttachedToDOM = !1, q.div.remove();
              this.div = null, e(this, o).clear(), e(this, p).removeLayer(this);
            }
            render(D) {
              let {
                viewport: X
              } = D;
              this.viewport = X, (0, f.setLayerDimensions)(this.div, X);
              for (const q of e(this, p).getEditors(this.pageIndex))
                this.add(q);
              this.updateMode();
            }
            update(D) {
              let {
                viewport: X
              } = D;
              e(this, p).commitOrRemove(), this.viewport = X, (0, f.setLayerDimensions)(this.div, {
                rotation: X.rotation
              }), this.updateMode();
            }
            get pageDimensions() {
              const {
                pageWidth: D,
                pageHeight: X
              } = this.viewport.rawDims;
              return [D, X];
            }
          };
          a = new WeakMap(), I = new WeakMap(), A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakMap(), v = new WeakMap(), p = new WeakMap(), C = new WeakSet(), pn = function(D) {
            switch (e(this, p).getMode()) {
              case n.AnnotationEditorType.FREETEXT:
                return new T.FreeTextEditor(D);
              case n.AnnotationEditorType.INK:
                return new P.InkEditor(D);
              case n.AnnotationEditorType.STAMP:
                return new y.StampEditor(D);
            }
            return null;
          }, i = new WeakSet(), De = function(D, X) {
            const q = this.getNextId(), j = J(this, C, pn).call(this, {
              parent: this,
              id: q,
              x: D.offsetX,
              y: D.offsetY,
              uiManager: e(this, p),
              isCentered: X
            });
            return j && this.add(j), j;
          }, x = new WeakSet(), gn = function() {
            const {
              x: D,
              y: X,
              width: q,
              height: j
            } = this.div.getBoundingClientRect(), z = Math.max(0, D), it = Math.max(0, X), Q = Math.min(window.innerWidth, D + q), Et = Math.min(window.innerHeight, X + j), Ct = (z + Q) / 2 - D, H = (it + Et) / 2 - X, [m, k] = this.viewport.rotation % 180 === 0 ? [Ct, H] : [H, Ct];
            return {
              offsetX: m,
              offsetY: k
            };
          }, F = new WeakSet(), mn = function() {
            rt(this, u, !0);
            for (const D of e(this, o).values())
              D.isEmpty() && D.remove();
            rt(this, u, !1);
          }, ee(G, "_initialized", !1);
          let c = G;
          S.AnnotationEditorLayer = c;
        },
        /* 197 */
        /***/
        (O, S, t) => {
          var y, c, a, I, A, g, s, o, l, u, ui, p, di, r, fi, w, Ee, b, vn, L, pi, nt, bn;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.FreeTextEditor = void 0, t(89);
          var n = t(1), h = t(165), T = t(164), P = t(198);
          const X = class X extends T.AnnotationEditor {
            constructor(z) {
              super({
                ...z,
                name: "freeTextEditor"
              });
              W(this, u);
              W(this, p);
              W(this, r);
              W(this, w);
              W(this, b);
              W(this, L);
              W(this, nt);
              W(this, y, this.editorDivBlur.bind(this));
              W(this, c, this.editorDivFocus.bind(this));
              W(this, a, this.editorDivInput.bind(this));
              W(this, I, this.editorDivKeydown.bind(this));
              W(this, A, void 0);
              W(this, g, "");
              W(this, s, `${this.id}-editor`);
              W(this, o, void 0);
              W(this, l, null);
              rt(this, A, z.color || X._defaultColor || T.AnnotationEditor._defaultLineColor), rt(this, o, z.fontSize || X._defaultFontSize);
            }
            static get _keyboardManager() {
              const z = X.prototype, it = (Ct) => Ct.isEmpty(), Q = h.AnnotationEditorUIManager.TRANSLATE_SMALL, Et = h.AnnotationEditorUIManager.TRANSLATE_BIG;
              return (0, n.shadow)(this, "_keyboardManager", new h.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], z.commitOrRemove, {
                bubbles: !0
              }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], z.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], z._translateEmpty, {
                args: [-Q, 0],
                checker: it
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], z._translateEmpty, {
                args: [-Et, 0],
                checker: it
              }], [["ArrowRight", "mac+ArrowRight"], z._translateEmpty, {
                args: [Q, 0],
                checker: it
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], z._translateEmpty, {
                args: [Et, 0],
                checker: it
              }], [["ArrowUp", "mac+ArrowUp"], z._translateEmpty, {
                args: [0, -Q],
                checker: it
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], z._translateEmpty, {
                args: [0, -Et],
                checker: it
              }], [["ArrowDown", "mac+ArrowDown"], z._translateEmpty, {
                args: [0, Q],
                checker: it
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], z._translateEmpty, {
                args: [0, Et],
                checker: it
              }]]));
            }
            static initialize(z) {
              T.AnnotationEditor.initialize(z, {
                strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
              });
              const it = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(it.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(z, it) {
              switch (z) {
                case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                  X._defaultFontSize = it;
                  break;
                case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                  X._defaultColor = it;
                  break;
              }
            }
            updateParams(z, it) {
              switch (z) {
                case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                  J(this, u, ui).call(this, it);
                  break;
                case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                  J(this, p, di).call(this, it);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[n.AnnotationEditorParamsType.FREETEXT_SIZE, X._defaultFontSize], [n.AnnotationEditorParamsType.FREETEXT_COLOR, X._defaultColor || T.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[n.AnnotationEditorParamsType.FREETEXT_SIZE, e(this, o)], [n.AnnotationEditorParamsType.FREETEXT_COLOR, e(this, A)]];
            }
            _translateEmpty(z, it) {
              this._uiManager.translateSelectedEditors(z, it, !0);
            }
            getInitialTranslation() {
              const z = this.parentScale;
              return [-X._internalPadding * z, -(X._internalPadding + e(this, o)) * z];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(n.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", e(this, I)), this.editorDiv.addEventListener("focus", e(this, c)), this.editorDiv.addEventListener("blur", e(this, y)), this.editorDiv.addEventListener("input", e(this, a)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", e(this, s)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", e(this, I)), this.editorDiv.removeEventListener("focus", e(this, c)), this.editorDiv.removeEventListener("blur", e(this, y)), this.editorDiv.removeEventListener("input", e(this, a)), this.div.focus({
                preventScroll: !0
              }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
            }
            focusin(z) {
              this._focusEventsAllowed && (super.focusin(z), z.target !== this.editorDiv && this.editorDiv.focus());
            }
            onceAdded() {
              var z;
              if (this.width) {
                J(this, nt, bn).call(this);
                return;
              }
              this.enableEditMode(), this.editorDiv.focus(), (z = this._initialOptions) != null && z.isCentered && this.center(), this._initialOptions = null;
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
            }
            commit() {
              if (!this.isInEditMode())
                return;
              super.commit(), this.disableEditMode();
              const z = e(this, g), it = rt(this, g, J(this, r, fi).call(this).trimEnd());
              if (z === it)
                return;
              const Q = (Et) => {
                if (rt(this, g, Et), !Et) {
                  this.remove();
                  return;
                }
                J(this, b, vn).call(this), this._uiManager.rebuild(this), J(this, w, Ee).call(this);
              };
              this.addCommands({
                cmd: () => {
                  Q(it);
                },
                undo: () => {
                  Q(z);
                },
                mustExec: !1
              }), J(this, w, Ee).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            enterInEditMode() {
              this.enableEditMode(), this.editorDiv.focus();
            }
            dblclick(z) {
              this.enterInEditMode();
            }
            keydown(z) {
              z.target === this.div && z.key === "Enter" && (this.enterInEditMode(), z.preventDefault());
            }
            editorDivKeydown(z) {
              X._keyboardManager.exec(this, z);
            }
            editorDivFocus(z) {
              this.isEditing = !0;
            }
            editorDivBlur(z) {
              this.isEditing = !1;
            }
            editorDivInput(z) {
              this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let z, it;
              this.width && (z = this.x, it = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", e(this, s)), this.enableEditing(), T.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((Et) => {
                var Ct;
                return (Ct = this.editorDiv) == null ? void 0 : Ct.setAttribute("aria-label", Et);
              }), T.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((Et) => {
                var Ct;
                return (Ct = this.editorDiv) == null ? void 0 : Ct.setAttribute("default-content", Et);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: Q
              } = this.editorDiv;
              if (Q.fontSize = `calc(${e(this, o)}px * var(--scale-factor))`, Q.color = e(this, A), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, h.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [Et, Ct] = this.parentDimensions;
                if (this.annotationElementId) {
                  const {
                    position: H
                  } = e(this, l);
                  let [m, k] = this.getInitialTranslation();
                  [m, k] = this.pageTranslationToScreen(m, k);
                  const [d, R] = this.pageDimensions, [M, B] = this.pageTranslation;
                  let _, Z;
                  switch (this.rotation) {
                    case 0:
                      _ = z + (H[0] - M) / d, Z = it + this.height - (H[1] - B) / R;
                      break;
                    case 90:
                      _ = z + (H[0] - M) / d, Z = it - (H[1] - B) / R, [m, k] = [k, -m];
                      break;
                    case 180:
                      _ = z - this.width + (H[0] - M) / d, Z = it - (H[1] - B) / R, [m, k] = [-m, -k];
                      break;
                    case 270:
                      _ = z + (H[0] - M - this.height * R) / d, Z = it + (H[1] - B - this.width * d) / R, [m, k] = [-k, m];
                      break;
                  }
                  this.setAt(_ * Et, Z * Ct, m, k);
                } else
                  this.setAt(z * Et, it * Ct, this.width * Et, this.height * Ct);
                J(this, b, vn).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this._isDraggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(z, it, Q) {
              let Et = null;
              if (z instanceof P.FreeTextAnnotationElement) {
                const {
                  data: {
                    defaultAppearanceData: {
                      fontSize: H,
                      fontColor: m
                    },
                    rect: k,
                    rotation: d,
                    id: R
                  },
                  textContent: M,
                  textPosition: B,
                  parent: {
                    page: {
                      pageNumber: _
                    }
                  }
                } = z;
                if (!M || M.length === 0)
                  return null;
                Et = z = {
                  annotationType: n.AnnotationEditorType.FREETEXT,
                  color: Array.from(m),
                  fontSize: H,
                  value: M.join(`
`),
                  position: B,
                  pageIndex: _ - 1,
                  rect: k,
                  rotation: d,
                  id: R,
                  deleted: !1
                };
              }
              const Ct = super.deserialize(z, it, Q);
              return rt(Ct, o, z.fontSize), rt(Ct, A, n.Util.makeHexColor(...z.color)), rt(Ct, g, z.value), Ct.annotationElementId = z.id || null, rt(Ct, l, Et), Ct;
            }
            serialize() {
              let z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              if (this.isEmpty())
                return null;
              if (this.deleted)
                return {
                  pageIndex: this.pageIndex,
                  id: this.annotationElementId,
                  deleted: !0
                };
              const it = X._internalPadding * this.parentScale, Q = this.getRect(it, it), Et = T.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : e(this, A)), Ct = {
                annotationType: n.AnnotationEditorType.FREETEXT,
                color: Et,
                fontSize: e(this, o),
                value: e(this, g),
                pageIndex: this.pageIndex,
                rect: Q,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
              return z ? Ct : this.annotationElementId && !J(this, L, pi).call(this, Ct) ? null : (Ct.id = this.annotationElementId, Ct);
            }
          };
          y = new WeakMap(), c = new WeakMap(), a = new WeakMap(), I = new WeakMap(), A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakSet(), ui = function(z) {
            const it = (Et) => {
              this.editorDiv.style.fontSize = `calc(${Et}px * var(--scale-factor))`, this.translate(0, -(Et - e(this, o)) * this.parentScale), rt(this, o, Et), J(this, w, Ee).call(this);
            }, Q = e(this, o);
            this.addCommands({
              cmd: () => {
                it(z);
              },
              undo: () => {
                it(Q);
              },
              mustExec: !0,
              type: n.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, p = new WeakSet(), di = function(z) {
            const it = e(this, A);
            this.addCommands({
              cmd: () => {
                rt(this, A, this.editorDiv.style.color = z);
              },
              undo: () => {
                rt(this, A, this.editorDiv.style.color = it);
              },
              mustExec: !0,
              type: n.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, r = new WeakSet(), fi = function() {
            const z = this.editorDiv.getElementsByTagName("div");
            if (z.length === 0)
              return this.editorDiv.innerText;
            const it = [];
            for (const Q of z)
              it.push(Q.innerText.replace(/\r\n?|\n/, ""));
            return it.join(`
`);
          }, w = new WeakSet(), Ee = function() {
            const [z, it] = this.parentDimensions;
            let Q;
            if (this.isAttachedToDOM)
              Q = this.div.getBoundingClientRect();
            else {
              const {
                currentLayer: Et,
                div: Ct
              } = this, H = Ct.style.display;
              Ct.style.display = "hidden", Et.div.append(this.div), Q = Ct.getBoundingClientRect(), Ct.remove(), Ct.style.display = H;
            }
            this.rotation % 180 === this.parentRotation % 180 ? (this.width = Q.width / z, this.height = Q.height / it) : (this.width = Q.height / z, this.height = Q.width / it), this.fixAndSetPosition();
          }, b = new WeakSet(), vn = function() {
            if (this.editorDiv.replaceChildren(), !!e(this, g))
              for (const z of e(this, g).split(`
`)) {
                const it = document.createElement("div");
                it.append(z ? document.createTextNode(z) : document.createElement("br")), this.editorDiv.append(it);
              }
          }, L = new WeakSet(), pi = function(z) {
            const {
              value: it,
              fontSize: Q,
              color: Et,
              rect: Ct,
              pageIndex: H
            } = e(this, l);
            return z.value !== it || z.fontSize !== Q || z.rect.some((m, k) => Math.abs(m - Ct[k]) >= 1) || z.color.some((m, k) => m !== Et[k]) || z.pageIndex !== H;
          }, nt = new WeakSet(), bn = function() {
            let z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            if (!this.annotationElementId)
              return;
            if (J(this, w, Ee).call(this), !z && (this.width === 0 || this.height === 0)) {
              setTimeout(() => J(this, nt, bn).call(this, !0), 0);
              return;
            }
            const it = X._internalPadding * this.parentScale;
            e(this, l).rect = this.getRect(it, it);
          }, ee(X, "_freeTextDefaultContent", ""), ee(X, "_internalPadding", 0), ee(X, "_defaultColor", null), ee(X, "_defaultFontSize", 10), ee(X, "_type", "freetext");
          let f = X;
          S.FreeTextEditor = f;
        },
        /* 198 */
        /***/
        (O, S, t) => {
          var k, R, he, B, gi, Z, pt, dt, Tt, lt, yt, bt, It, Ot, Mt, gt, ut, ct, ot, vt, wt, Lt, Ut, mi, $t, _e, Jt, yn, Zt, An, N, V, K, st, ft, Y, U, Sn, St, At, Rt, xt, vi, kt, En;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.StampAnnotationElement = S.InkAnnotationElement = S.FreeTextAnnotationElement = S.AnnotationLayer = void 0, t(89), t(125), t(136), t(138), t(141), t(143), t(145), t(147);
          var n = t(1), h = t(168), T = t(163), P = t(199), f = t(200), y = t(201);
          const c = 1e3, a = 9, I = /* @__PURE__ */ new WeakSet();
          function A(Bt) {
            return {
              width: Bt[2] - Bt[0],
              height: Bt[3] - Bt[1]
            };
          }
          class g {
            static create(et) {
              switch (et.data.annotationType) {
                case n.AnnotationType.LINK:
                  return new o(et);
                case n.AnnotationType.TEXT:
                  return new l(et);
                case n.AnnotationType.WIDGET:
                  switch (et.data.fieldType) {
                    case "Tx":
                      return new v(et);
                    case "Btn":
                      return et.data.radioButton ? new r(et) : et.data.checkBox ? new C(et) : new i(et);
                    case "Ch":
                      return new w(et);
                    case "Sig":
                      return new p(et);
                  }
                  return new u(et);
                case n.AnnotationType.POPUP:
                  return new x(et);
                case n.AnnotationType.FREETEXT:
                  return new F(et);
                case n.AnnotationType.LINE:
                  return new L(et);
                case n.AnnotationType.SQUARE:
                  return new G(et);
                case n.AnnotationType.CIRCLE:
                  return new nt(et);
                case n.AnnotationType.POLYLINE:
                  return new D(et);
                case n.AnnotationType.CARET:
                  return new q(et);
                case n.AnnotationType.INK:
                  return new j(et);
                case n.AnnotationType.POLYGON:
                  return new X(et);
                case n.AnnotationType.HIGHLIGHT:
                  return new z(et);
                case n.AnnotationType.UNDERLINE:
                  return new it(et);
                case n.AnnotationType.SQUIGGLY:
                  return new Q(et);
                case n.AnnotationType.STRIKEOUT:
                  return new Et(et);
                case n.AnnotationType.STAMP:
                  return new Ct(et);
                case n.AnnotationType.FILEATTACHMENT:
                  return new H(et);
                default:
                  return new s(et);
              }
            }
          }
          const d = class d {
            constructor(et) {
              W(this, k, !1);
              let {
                isRenderable: E = !1,
                ignoreBorder: $ = !1,
                createQuadrilaterals: tt = !1
              } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.isRenderable = E, this.data = et.data, this.layer = et.layer, this.linkService = et.linkService, this.downloadManager = et.downloadManager, this.imageResourcesPath = et.imageResourcesPath, this.renderForms = et.renderForms, this.svgFactory = et.svgFactory, this.annotationStorage = et.annotationStorage, this.enableScripting = et.enableScripting, this.hasJSActions = et.hasJSActions, this._fieldObjects = et.fieldObjects, this.parent = et.parent, E && (this.container = this._createContainer($)), tt && this._createQuadrilaterals();
            }
            static _hasPopupData(et) {
              let {
                titleObj: E,
                contentsObj: $,
                richText: tt
              } = et;
              return !!(E != null && E.str || $ != null && $.str || tt != null && tt.str);
            }
            get hasPopupData() {
              return d._hasPopupData(this.data);
            }
            _createContainer(et) {
              const {
                data: E,
                parent: {
                  page: $,
                  viewport: tt
                }
              } = this, ht = document.createElement("section");
              ht.setAttribute("data-annotation-id", E.id), this instanceof u || (ht.tabIndex = c), ht.style.zIndex = this.parent.zIndex++, this.data.popupRef && ht.setAttribute("aria-haspopup", "dialog"), E.noRotate && ht.classList.add("norotate");
              const {
                pageWidth: mt,
                pageHeight: Pt,
                pageX: Ft,
                pageY: Vt
              } = tt.rawDims;
              if (!E.rect || this instanceof x) {
                const {
                  rotation: Kt
                } = E;
                return !E.hasOwnCanvas && Kt !== 0 && this.setRotation(Kt, ht), ht;
              }
              const {
                width: Dt,
                height: Qt
              } = A(E.rect), Gt = n.Util.normalizeRect([E.rect[0], $.view[3] - E.rect[1] + $.view[1], E.rect[2], $.view[3] - E.rect[3] + $.view[1]]);
              if (!et && E.borderStyle.width > 0) {
                ht.style.borderWidth = `${E.borderStyle.width}px`;
                const Kt = E.borderStyle.horizontalCornerRadius, jt = E.borderStyle.verticalCornerRadius;
                if (Kt > 0 || jt > 0) {
                  const te = `calc(${Kt}px * var(--scale-factor)) / calc(${jt}px * var(--scale-factor))`;
                  ht.style.borderRadius = te;
                } else if (this instanceof r) {
                  const te = `calc(${Dt}px * var(--scale-factor)) / calc(${Qt}px * var(--scale-factor))`;
                  ht.style.borderRadius = te;
                }
                switch (E.borderStyle.style) {
                  case n.AnnotationBorderStyleType.SOLID:
                    ht.style.borderStyle = "solid";
                    break;
                  case n.AnnotationBorderStyleType.DASHED:
                    ht.style.borderStyle = "dashed";
                    break;
                  case n.AnnotationBorderStyleType.BEVELED:
                    (0, n.warn)("Unimplemented border style: beveled");
                    break;
                  case n.AnnotationBorderStyleType.INSET:
                    (0, n.warn)("Unimplemented border style: inset");
                    break;
                  case n.AnnotationBorderStyleType.UNDERLINE:
                    ht.style.borderBottomStyle = "solid";
                    break;
                }
                const qt = E.borderColor || null;
                qt ? (rt(this, k, !0), ht.style.borderColor = n.Util.makeHexColor(qt[0] | 0, qt[1] | 0, qt[2] | 0)) : ht.style.borderWidth = 0;
              }
              ht.style.left = `${100 * (Gt[0] - Ft) / mt}%`, ht.style.top = `${100 * (Gt[1] - Vt) / Pt}%`;
              const {
                rotation: zt
              } = E;
              return E.hasOwnCanvas || zt === 0 ? (ht.style.width = `${100 * Dt / mt}%`, ht.style.height = `${100 * Qt / Pt}%`) : this.setRotation(zt, ht), ht;
            }
            setRotation(et) {
              let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.container;
              if (!this.data.rect)
                return;
              const {
                pageWidth: $,
                pageHeight: tt
              } = this.parent.viewport.rawDims, {
                width: ht,
                height: mt
              } = A(this.data.rect);
              let Pt, Ft;
              et % 180 === 0 ? (Pt = 100 * ht / $, Ft = 100 * mt / tt) : (Pt = 100 * mt / $, Ft = 100 * ht / tt), E.style.width = `${Pt}%`, E.style.height = `${Ft}%`, E.setAttribute("data-main-rotation", (360 - et) % 360);
            }
            get _commonActions() {
              const et = (E, $, tt) => {
                const ht = tt.detail[E], mt = ht[0], Pt = ht.slice(1);
                tt.target.style[$] = P.ColorConverters[`${mt}_HTML`](Pt), this.annotationStorage.setValue(this.data.id, {
                  [$]: P.ColorConverters[`${mt}_rgb`](Pt)
                });
              };
              return (0, n.shadow)(this, "_commonActions", {
                display: (E) => {
                  const {
                    display: $
                  } = E.detail, tt = $ % 2 === 1;
                  this.container.style.visibility = tt ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noView: tt,
                    noPrint: $ === 1 || $ === 2
                  });
                },
                print: (E) => {
                  this.annotationStorage.setValue(this.data.id, {
                    noPrint: !E.detail.print
                  });
                },
                hidden: (E) => {
                  const {
                    hidden: $
                  } = E.detail;
                  this.container.style.visibility = $ ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noPrint: $,
                    noView: $
                  });
                },
                focus: (E) => {
                  setTimeout(() => E.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (E) => {
                  E.target.title = E.detail.userName;
                },
                readonly: (E) => {
                  E.target.disabled = E.detail.readonly;
                },
                required: (E) => {
                  this._setRequired(E.target, E.detail.required);
                },
                bgColor: (E) => {
                  et("bgColor", "backgroundColor", E);
                },
                fillColor: (E) => {
                  et("fillColor", "backgroundColor", E);
                },
                fgColor: (E) => {
                  et("fgColor", "color", E);
                },
                textColor: (E) => {
                  et("textColor", "color", E);
                },
                borderColor: (E) => {
                  et("borderColor", "borderColor", E);
                },
                strokeColor: (E) => {
                  et("strokeColor", "borderColor", E);
                },
                rotation: (E) => {
                  const $ = E.detail.rotation;
                  this.setRotation($), this.annotationStorage.setValue(this.data.id, {
                    rotation: $
                  });
                }
              });
            }
            _dispatchEventFromSandbox(et, E) {
              const $ = this._commonActions;
              for (const tt of Object.keys(E.detail)) {
                const ht = et[tt] || $[tt];
                ht == null || ht(E);
              }
            }
            _setDefaultPropertiesFromJS(et) {
              if (!this.enableScripting)
                return;
              const E = this.annotationStorage.getRawValue(this.data.id);
              if (!E)
                return;
              const $ = this._commonActions;
              for (const [tt, ht] of Object.entries(E)) {
                const mt = $[tt];
                if (mt) {
                  const Pt = {
                    detail: {
                      [tt]: ht
                    },
                    target: et
                  };
                  mt(Pt), delete E[tt];
                }
              }
            }
            _createQuadrilaterals() {
              if (!this.container)
                return;
              const {
                quadPoints: et
              } = this.data;
              if (!et)
                return;
              const [E, $, tt, ht] = this.data.rect;
              if (et.length === 1) {
                const [, {
                  x: jt,
                  y: qt
                }, {
                  x: te,
                  y: ie
                }] = et[0];
                if (tt === jt && ht === qt && E === te && $ === ie)
                  return;
              }
              const {
                style: mt
              } = this.container;
              let Pt;
              if (e(this, k)) {
                const {
                  borderColor: jt,
                  borderWidth: qt
                } = mt;
                mt.borderWidth = 0, Pt = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${jt}" stroke-width="${qt}">`], this.container.classList.add("hasBorder");
              }
              const Ft = tt - E, Vt = ht - $, {
                svgFactory: Dt
              } = this, Qt = Dt.createElement("svg");
              Qt.classList.add("quadrilateralsContainer"), Qt.setAttribute("width", 0), Qt.setAttribute("height", 0);
              const Gt = Dt.createElement("defs");
              Qt.append(Gt);
              const zt = Dt.createElement("clipPath"), Kt = `clippath_${this.data.id}`;
              zt.setAttribute("id", Kt), zt.setAttribute("clipPathUnits", "objectBoundingBox"), Gt.append(zt);
              for (const [, {
                x: jt,
                y: qt
              }, {
                x: te,
                y: ie
              }] of et) {
                const ne = Dt.createElement("rect"), re = (te - E) / Ft, le = (ht - qt) / Vt, ce = (jt - te) / Ft, qn = (qt - ie) / Vt;
                ne.setAttribute("x", re), ne.setAttribute("y", le), ne.setAttribute("width", ce), ne.setAttribute("height", qn), zt.append(ne), Pt == null || Pt.push(`<rect vector-effect="non-scaling-stroke" x="${re}" y="${le}" width="${ce}" height="${qn}"/>`);
              }
              e(this, k) && (Pt.push("</g></svg>')"), mt.backgroundImage = Pt.join("")), this.container.append(Qt), this.container.style.clipPath = `url(#${Kt})`;
            }
            _createPopup() {
              const {
                container: et,
                data: E
              } = this;
              et.setAttribute("aria-haspopup", "dialog");
              const $ = new x({
                data: {
                  color: E.color,
                  titleObj: E.titleObj,
                  modificationDate: E.modificationDate,
                  contentsObj: E.contentsObj,
                  richText: E.richText,
                  parentRect: E.rect,
                  borderStyle: 0,
                  id: `popup_${E.id}`,
                  rotation: E.rotation
                },
                parent: this.parent,
                elements: [this]
              });
              this.parent.div.append($.render());
            }
            render() {
              (0, n.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(et) {
              let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              const $ = [];
              if (this._fieldObjects) {
                const tt = this._fieldObjects[et];
                if (tt)
                  for (const {
                    page: ht,
                    id: mt,
                    exportValues: Pt
                  } of tt) {
                    if (ht === -1 || mt === E)
                      continue;
                    const Ft = typeof Pt == "string" ? Pt : null, Vt = document.querySelector(`[data-element-id="${mt}"]`);
                    if (Vt && !I.has(Vt)) {
                      (0, n.warn)(`_getElementsByName - element not allowed: ${mt}`);
                      continue;
                    }
                    $.push({
                      id: mt,
                      exportValue: Ft,
                      domElement: Vt
                    });
                  }
                return $;
              }
              for (const tt of document.getElementsByName(et)) {
                const {
                  exportValue: ht
                } = tt, mt = tt.getAttribute("data-element-id");
                mt !== E && I.has(tt) && $.push({
                  id: mt,
                  exportValue: ht,
                  domElement: tt
                });
              }
              return $;
            }
            show() {
              var et;
              this.container && (this.container.hidden = !1), (et = this.popup) == null || et.maybeShow();
            }
            hide() {
              var et;
              this.container && (this.container.hidden = !0), (et = this.popup) == null || et.forceHide();
            }
            getElementsToTriggerPopup() {
              return this.container;
            }
            addHighlightArea() {
              const et = this.getElementsToTriggerPopup();
              if (Array.isArray(et))
                for (const E of et)
                  E.classList.add("highlightArea");
              else
                et.classList.add("highlightArea");
            }
            _editOnDoubleClick() {
              const {
                annotationEditorType: et,
                data: {
                  id: E
                }
              } = this;
              this.container.addEventListener("dblclick", () => {
                var $;
                ($ = this.linkService.eventBus) == null || $.dispatch("switchannotationeditormode", {
                  source: this,
                  mode: et,
                  editId: E
                });
              });
            }
          };
          k = new WeakMap();
          let s = d;
          class o extends s {
            constructor(E) {
              let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              super(E, {
                isRenderable: !0,
                ignoreBorder: !!($ != null && $.ignoreBorder),
                createQuadrilaterals: !0
              });
              W(this, R);
              W(this, B);
              this.isTooltipOnly = E.data.isTooltipOnly;
            }
            render() {
              const {
                data: E,
                linkService: $
              } = this, tt = document.createElement("a");
              tt.setAttribute("data-element-id", E.id);
              let ht = !1;
              return E.url ? ($.addLinkAttributes(tt, E.url, E.newWindow), ht = !0) : E.action ? (this._bindNamedAction(tt, E.action), ht = !0) : E.attachment ? (this._bindAttachment(tt, E.attachment), ht = !0) : E.setOCGState ? (J(this, B, gi).call(this, tt, E.setOCGState), ht = !0) : E.dest ? (this._bindLink(tt, E.dest), ht = !0) : (E.actions && (E.actions.Action || E.actions["Mouse Up"] || E.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(tt, E), ht = !0), E.resetForm ? (this._bindResetFormAction(tt, E.resetForm), ht = !0) : this.isTooltipOnly && !ht && (this._bindLink(tt, ""), ht = !0)), this.container.classList.add("linkAnnotation"), ht && this.container.append(tt), this.container;
            }
            _bindLink(E, $) {
              E.href = this.linkService.getDestinationHash($), E.onclick = () => ($ && this.linkService.goToDestination($), !1), ($ || $ === "") && J(this, R, he).call(this);
            }
            _bindNamedAction(E, $) {
              E.href = this.linkService.getAnchorUrl(""), E.onclick = () => (this.linkService.executeNamedAction($), !1), J(this, R, he).call(this);
            }
            _bindAttachment(E, $) {
              E.href = this.linkService.getAnchorUrl(""), E.onclick = () => {
                var tt;
                return (tt = this.downloadManager) == null || tt.openOrDownloadData(this.container, $.content, $.filename), !1;
              }, J(this, R, he).call(this);
            }
            _bindJSAction(E, $) {
              E.href = this.linkService.getAnchorUrl("");
              const tt = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const ht of Object.keys($.actions)) {
                const mt = tt.get(ht);
                mt && (E[mt] = () => {
                  var Pt;
                  return (Pt = this.linkService.eventBus) == null || Pt.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: $.id,
                      name: ht
                    }
                  }), !1;
                });
              }
              E.onclick || (E.onclick = () => !1), J(this, R, he).call(this);
            }
            _bindResetFormAction(E, $) {
              const tt = E.onclick;
              if (tt || (E.href = this.linkService.getAnchorUrl("")), J(this, R, he).call(this), !this._fieldObjects) {
                (0, n.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), tt || (E.onclick = () => !1);
                return;
              }
              E.onclick = () => {
                var Qt;
                tt == null || tt();
                const {
                  fields: ht,
                  refs: mt,
                  include: Pt
                } = $, Ft = [];
                if (ht.length !== 0 || mt.length !== 0) {
                  const Gt = new Set(mt);
                  for (const zt of ht) {
                    const Kt = this._fieldObjects[zt] || [];
                    for (const {
                      id: jt
                    } of Kt)
                      Gt.add(jt);
                  }
                  for (const zt of Object.values(this._fieldObjects))
                    for (const Kt of zt)
                      Gt.has(Kt.id) === Pt && Ft.push(Kt);
                } else
                  for (const Gt of Object.values(this._fieldObjects))
                    Ft.push(...Gt);
                const Vt = this.annotationStorage, Dt = [];
                for (const Gt of Ft) {
                  const {
                    id: zt
                  } = Gt;
                  switch (Dt.push(zt), Gt.type) {
                    case "text": {
                      const jt = Gt.defaultValue || "";
                      Vt.setValue(zt, {
                        value: jt
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const jt = Gt.defaultValue === Gt.exportValues;
                      Vt.setValue(zt, {
                        value: jt
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const jt = Gt.defaultValue || "";
                      Vt.setValue(zt, {
                        value: jt
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const Kt = document.querySelector(`[data-element-id="${zt}"]`);
                  if (Kt) {
                    if (!I.has(Kt)) {
                      (0, n.warn)(`_bindResetFormAction - element not allowed: ${zt}`);
                      continue;
                    }
                  } else
                    continue;
                  Kt.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((Qt = this.linkService.eventBus) == null || Qt.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: Dt,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          R = new WeakSet(), he = function() {
            this.container.setAttribute("data-internal-link", "");
          }, B = new WeakSet(), gi = function(E, $) {
            E.href = this.linkService.getAnchorUrl(""), E.onclick = () => (this.linkService.executeSetOCGState($), !1), J(this, R, he).call(this);
          };
          class l extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0
              });
            }
            render() {
              this.container.classList.add("textAnnotation");
              const et = document.createElement("img");
              return et.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", et.alt = "[{{type}} Annotation]", et.dataset.l10nId = "text_annotation_type", et.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(et), this.container;
            }
          }
          class u extends s {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            showElementAndHideCanvas(et) {
              var E;
              this.data.hasOwnCanvas && (((E = et.previousSibling) == null ? void 0 : E.nodeName) === "CANVAS" && (et.previousSibling.hidden = !0), et.hidden = !1);
            }
            _getKeyModifier(et) {
              const {
                isWin: E,
                isMac: $
              } = n.FeatureTest.platform;
              return E && et.ctrlKey || $ && et.metaKey;
            }
            _setEventListener(et, E, $, tt, ht) {
              $.includes("mouse") ? et.addEventListener($, (mt) => {
                var Pt;
                (Pt = this.linkService.eventBus) == null || Pt.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: tt,
                    value: ht(mt),
                    shift: mt.shiftKey,
                    modifier: this._getKeyModifier(mt)
                  }
                });
              }) : et.addEventListener($, (mt) => {
                var Pt;
                if ($ === "blur") {
                  if (!E.focused || !mt.relatedTarget)
                    return;
                  E.focused = !1;
                } else if ($ === "focus") {
                  if (E.focused)
                    return;
                  E.focused = !0;
                }
                ht && ((Pt = this.linkService.eventBus) == null || Pt.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: tt,
                    value: ht(mt)
                  }
                }));
              });
            }
            _setEventListeners(et, E, $, tt) {
              var ht, mt, Pt;
              for (const [Ft, Vt] of $)
                (Vt === "Action" || (ht = this.data.actions) != null && ht[Vt]) && ((Vt === "Focus" || Vt === "Blur") && (E || (E = {
                  focused: !1
                })), this._setEventListener(et, E, Ft, Vt, tt), Vt === "Focus" && !((mt = this.data.actions) != null && mt.Blur) ? this._setEventListener(et, E, "blur", "Blur", null) : Vt === "Blur" && !((Pt = this.data.actions) != null && Pt.Focus) && this._setEventListener(et, E, "focus", "Focus", null));
            }
            _setBackgroundColor(et) {
              const E = this.data.backgroundColor || null;
              et.style.backgroundColor = E === null ? "transparent" : n.Util.makeHexColor(E[0], E[1], E[2]);
            }
            _setTextStyle(et) {
              const E = ["left", "center", "right"], {
                fontColor: $
              } = this.data.defaultAppearanceData, tt = this.data.defaultAppearanceData.fontSize || a, ht = et.style;
              let mt;
              const Pt = 2, Ft = (Vt) => Math.round(10 * Vt) / 10;
              if (this.data.multiLine) {
                const Vt = Math.abs(this.data.rect[3] - this.data.rect[1] - Pt), Dt = Math.round(Vt / (n.LINE_FACTOR * tt)) || 1, Qt = Vt / Dt;
                mt = Math.min(tt, Ft(Qt / n.LINE_FACTOR));
              } else {
                const Vt = Math.abs(this.data.rect[3] - this.data.rect[1] - Pt);
                mt = Math.min(tt, Ft(Vt / n.LINE_FACTOR));
              }
              ht.fontSize = `calc(${mt}px * var(--scale-factor))`, ht.color = n.Util.makeHexColor($[0], $[1], $[2]), this.data.textAlignment !== null && (ht.textAlign = E[this.data.textAlignment]);
            }
            _setRequired(et, E) {
              E ? et.setAttribute("required", !0) : et.removeAttribute("required"), et.setAttribute("aria-required", E);
            }
          }
          class v extends u {
            constructor(et) {
              const E = et.renderForms || !et.data.hasAppearance && !!et.data.fieldValue;
              super(et, {
                isRenderable: E
              });
            }
            setPropertyOnSiblings(et, E, $, tt) {
              const ht = this.annotationStorage;
              for (const mt of this._getElementsByName(et.name, et.id))
                mt.domElement && (mt.domElement[E] = $), ht.setValue(mt.id, {
                  [tt]: $
                });
            }
            render() {
              var tt, ht;
              const et = this.annotationStorage, E = this.data.id;
              this.container.classList.add("textWidgetAnnotation");
              let $ = null;
              if (this.renderForms) {
                const mt = et.getValue(E, {
                  value: this.data.fieldValue
                });
                let Pt = mt.value || "";
                const Ft = et.getValue(E, {
                  charLimit: this.data.maxLen
                }).charLimit;
                Ft && Pt.length > Ft && (Pt = Pt.slice(0, Ft));
                let Vt = mt.formattedValue || ((tt = this.data.textContent) == null ? void 0 : tt.join(`
`)) || null;
                Vt && this.data.comb && (Vt = Vt.replaceAll(/\s+/g, ""));
                const Dt = {
                  userValue: Pt,
                  formattedValue: Vt,
                  lastCommittedValue: null,
                  commitKey: 1,
                  focused: !1
                };
                this.data.multiLine ? ($ = document.createElement("textarea"), $.textContent = Vt ?? Pt, this.data.doNotScroll && ($.style.overflowY = "hidden")) : ($ = document.createElement("input"), $.type = "text", $.setAttribute("value", Vt ?? Pt), this.data.doNotScroll && ($.style.overflowX = "hidden")), this.data.hasOwnCanvas && ($.hidden = !0), I.add($), $.setAttribute("data-element-id", E), $.disabled = this.data.readOnly, $.name = this.data.fieldName, $.tabIndex = c, this._setRequired($, this.data.required), Ft && ($.maxLength = Ft), $.addEventListener("input", (Gt) => {
                  et.setValue(E, {
                    value: Gt.target.value
                  }), this.setPropertyOnSiblings($, "value", Gt.target.value, "value"), Dt.formattedValue = null;
                }), $.addEventListener("resetform", (Gt) => {
                  const zt = this.data.defaultFieldValue ?? "";
                  $.value = Dt.userValue = zt, Dt.formattedValue = null;
                });
                let Qt = (Gt) => {
                  const {
                    formattedValue: zt
                  } = Dt;
                  zt != null && (Gt.target.value = zt), Gt.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  $.addEventListener("focus", (zt) => {
                    if (Dt.focused)
                      return;
                    const {
                      target: Kt
                    } = zt;
                    Dt.userValue && (Kt.value = Dt.userValue), Dt.lastCommittedValue = Kt.value, Dt.commitKey = 1, Dt.focused = !0;
                  }), $.addEventListener("updatefromsandbox", (zt) => {
                    this.showElementAndHideCanvas(zt.target);
                    const Kt = {
                      value(jt) {
                        Dt.userValue = jt.detail.value ?? "", et.setValue(E, {
                          value: Dt.userValue.toString()
                        }), jt.target.value = Dt.userValue;
                      },
                      formattedValue(jt) {
                        const {
                          formattedValue: qt
                        } = jt.detail;
                        Dt.formattedValue = qt, qt != null && jt.target !== document.activeElement && (jt.target.value = qt), et.setValue(E, {
                          formattedValue: qt
                        });
                      },
                      selRange(jt) {
                        jt.target.setSelectionRange(...jt.detail.selRange);
                      },
                      charLimit: (jt) => {
                        var ne;
                        const {
                          charLimit: qt
                        } = jt.detail, {
                          target: te
                        } = jt;
                        if (qt === 0) {
                          te.removeAttribute("maxLength");
                          return;
                        }
                        te.setAttribute("maxLength", qt);
                        let ie = Dt.userValue;
                        !ie || ie.length <= qt || (ie = ie.slice(0, qt), te.value = Dt.userValue = ie, et.setValue(E, {
                          value: ie
                        }), (ne = this.linkService.eventBus) == null || ne.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: E,
                            name: "Keystroke",
                            value: ie,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: te.selectionStart,
                            selEnd: te.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(Kt, zt);
                  }), $.addEventListener("keydown", (zt) => {
                    var qt;
                    Dt.commitKey = 1;
                    let Kt = -1;
                    if (zt.key === "Escape" ? Kt = 0 : zt.key === "Enter" && !this.data.multiLine ? Kt = 2 : zt.key === "Tab" && (Dt.commitKey = 3), Kt === -1)
                      return;
                    const {
                      value: jt
                    } = zt.target;
                    Dt.lastCommittedValue !== jt && (Dt.lastCommittedValue = jt, Dt.userValue = jt, (qt = this.linkService.eventBus) == null || qt.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: E,
                        name: "Keystroke",
                        value: jt,
                        willCommit: !0,
                        commitKey: Kt,
                        selStart: zt.target.selectionStart,
                        selEnd: zt.target.selectionEnd
                      }
                    }));
                  });
                  const Gt = Qt;
                  Qt = null, $.addEventListener("blur", (zt) => {
                    var jt;
                    if (!Dt.focused || !zt.relatedTarget)
                      return;
                    Dt.focused = !1;
                    const {
                      value: Kt
                    } = zt.target;
                    Dt.userValue = Kt, Dt.lastCommittedValue !== Kt && ((jt = this.linkService.eventBus) == null || jt.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: E,
                        name: "Keystroke",
                        value: Kt,
                        willCommit: !0,
                        commitKey: Dt.commitKey,
                        selStart: zt.target.selectionStart,
                        selEnd: zt.target.selectionEnd
                      }
                    })), Gt(zt);
                  }), (ht = this.data.actions) != null && ht.Keystroke && $.addEventListener("beforeinput", (zt) => {
                    var le;
                    Dt.lastCommittedValue = null;
                    const {
                      data: Kt,
                      target: jt
                    } = zt, {
                      value: qt,
                      selectionStart: te,
                      selectionEnd: ie
                    } = jt;
                    let ne = te, re = ie;
                    switch (zt.inputType) {
                      case "deleteWordBackward": {
                        const ce = qt.substring(0, te).match(/\w*[^\w]*$/);
                        ce && (ne -= ce[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const ce = qt.substring(te).match(/^[^\w]*\w*/);
                        ce && (re += ce[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        te === ie && (ne -= 1);
                        break;
                      case "deleteContentForward":
                        te === ie && (re += 1);
                        break;
                    }
                    zt.preventDefault(), (le = this.linkService.eventBus) == null || le.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: E,
                        name: "Keystroke",
                        value: qt,
                        change: Kt || "",
                        willCommit: !1,
                        selStart: ne,
                        selEnd: re
                      }
                    });
                  }), this._setEventListeners($, Dt, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (zt) => zt.target.value);
                }
                if (Qt && $.addEventListener("blur", Qt), this.data.comb) {
                  const zt = (this.data.rect[2] - this.data.rect[0]) / Ft;
                  $.classList.add("comb"), $.style.letterSpacing = `calc(${zt}px * var(--scale-factor) - 1ch)`;
                }
              } else
                $ = document.createElement("div"), $.textContent = this.data.fieldValue, $.style.verticalAlign = "middle", $.style.display = "table-cell";
              return this._setTextStyle($), this._setBackgroundColor($), this._setDefaultPropertiesFromJS($), this.container.append($), this.container;
            }
          }
          class p extends u {
            constructor(et) {
              super(et, {
                isRenderable: !!et.data.hasOwnCanvas
              });
            }
          }
          class C extends u {
            constructor(et) {
              super(et, {
                isRenderable: et.renderForms
              });
            }
            render() {
              const et = this.annotationStorage, E = this.data, $ = E.id;
              let tt = et.getValue($, {
                value: E.exportValue === E.fieldValue
              }).value;
              typeof tt == "string" && (tt = tt !== "Off", et.setValue($, {
                value: tt
              })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
              const ht = document.createElement("input");
              return I.add(ht), ht.setAttribute("data-element-id", $), ht.disabled = E.readOnly, this._setRequired(ht, this.data.required), ht.type = "checkbox", ht.name = E.fieldName, tt && ht.setAttribute("checked", !0), ht.setAttribute("exportValue", E.exportValue), ht.tabIndex = c, ht.addEventListener("change", (mt) => {
                const {
                  name: Pt,
                  checked: Ft
                } = mt.target;
                for (const Vt of this._getElementsByName(Pt, $)) {
                  const Dt = Ft && Vt.exportValue === E.exportValue;
                  Vt.domElement && (Vt.domElement.checked = Dt), et.setValue(Vt.id, {
                    value: Dt
                  });
                }
                et.setValue($, {
                  value: Ft
                });
              }), ht.addEventListener("resetform", (mt) => {
                const Pt = E.defaultFieldValue || "Off";
                mt.target.checked = Pt === E.exportValue;
              }), this.enableScripting && this.hasJSActions && (ht.addEventListener("updatefromsandbox", (mt) => {
                const Pt = {
                  value(Ft) {
                    Ft.target.checked = Ft.detail.value !== "Off", et.setValue($, {
                      value: Ft.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(Pt, mt);
              }), this._setEventListeners(ht, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (mt) => mt.target.checked)), this._setBackgroundColor(ht), this._setDefaultPropertiesFromJS(ht), this.container.append(ht), this.container;
            }
          }
          class r extends u {
            constructor(et) {
              super(et, {
                isRenderable: et.renderForms
              });
            }
            render() {
              this.container.classList.add("buttonWidgetAnnotation", "radioButton");
              const et = this.annotationStorage, E = this.data, $ = E.id;
              let tt = et.getValue($, {
                value: E.fieldValue === E.buttonValue
              }).value;
              typeof tt == "string" && (tt = tt !== E.buttonValue, et.setValue($, {
                value: tt
              }));
              const ht = document.createElement("input");
              if (I.add(ht), ht.setAttribute("data-element-id", $), ht.disabled = E.readOnly, this._setRequired(ht, this.data.required), ht.type = "radio", ht.name = E.fieldName, tt && ht.setAttribute("checked", !0), ht.tabIndex = c, ht.addEventListener("change", (mt) => {
                const {
                  name: Pt,
                  checked: Ft
                } = mt.target;
                for (const Vt of this._getElementsByName(Pt, $))
                  et.setValue(Vt.id, {
                    value: !1
                  });
                et.setValue($, {
                  value: Ft
                });
              }), ht.addEventListener("resetform", (mt) => {
                const Pt = E.defaultFieldValue;
                mt.target.checked = Pt != null && Pt === E.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const mt = E.buttonValue;
                ht.addEventListener("updatefromsandbox", (Pt) => {
                  const Ft = {
                    value: (Vt) => {
                      const Dt = mt === Vt.detail.value;
                      for (const Qt of this._getElementsByName(Vt.target.name)) {
                        const Gt = Dt && Qt.id === $;
                        Qt.domElement && (Qt.domElement.checked = Gt), et.setValue(Qt.id, {
                          value: Gt
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Ft, Pt);
                }), this._setEventListeners(ht, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Pt) => Pt.target.checked);
              }
              return this._setBackgroundColor(ht), this._setDefaultPropertiesFromJS(ht), this.container.append(ht), this.container;
            }
          }
          class i extends o {
            constructor(et) {
              super(et, {
                ignoreBorder: et.data.hasAppearance
              });
            }
            render() {
              const et = super.render();
              et.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (et.title = this.data.alternativeText);
              const E = et.lastChild;
              return this.enableScripting && this.hasJSActions && E && (this._setDefaultPropertiesFromJS(E), E.addEventListener("updatefromsandbox", ($) => {
                this._dispatchEventFromSandbox({}, $);
              })), et;
            }
          }
          class w extends u {
            constructor(et) {
              super(et, {
                isRenderable: et.renderForms
              });
            }
            render() {
              this.container.classList.add("choiceWidgetAnnotation");
              const et = this.annotationStorage, E = this.data.id, $ = et.getValue(E, {
                value: this.data.fieldValue
              }), tt = document.createElement("select");
              I.add(tt), tt.setAttribute("data-element-id", E), tt.disabled = this.data.readOnly, this._setRequired(tt, this.data.required), tt.name = this.data.fieldName, tt.tabIndex = c;
              let ht = this.data.combo && this.data.options.length > 0;
              this.data.combo || (tt.size = this.data.options.length, this.data.multiSelect && (tt.multiple = !0)), tt.addEventListener("resetform", (Dt) => {
                const Qt = this.data.defaultFieldValue;
                for (const Gt of tt.options)
                  Gt.selected = Gt.value === Qt;
              });
              for (const Dt of this.data.options) {
                const Qt = document.createElement("option");
                Qt.textContent = Dt.displayValue, Qt.value = Dt.exportValue, $.value.includes(Dt.exportValue) && (Qt.setAttribute("selected", !0), ht = !1), tt.append(Qt);
              }
              let mt = null;
              if (ht) {
                const Dt = document.createElement("option");
                Dt.value = " ", Dt.setAttribute("hidden", !0), Dt.setAttribute("selected", !0), tt.prepend(Dt), mt = () => {
                  Dt.remove(), tt.removeEventListener("input", mt), mt = null;
                }, tt.addEventListener("input", mt);
              }
              const Pt = (Dt) => {
                const Qt = Dt ? "value" : "textContent", {
                  options: Gt,
                  multiple: zt
                } = tt;
                return zt ? Array.prototype.filter.call(Gt, (Kt) => Kt.selected).map((Kt) => Kt[Qt]) : Gt.selectedIndex === -1 ? null : Gt[Gt.selectedIndex][Qt];
              };
              let Ft = Pt(!1);
              const Vt = (Dt) => {
                const Qt = Dt.target.options;
                return Array.prototype.map.call(Qt, (Gt) => ({
                  displayValue: Gt.textContent,
                  exportValue: Gt.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (tt.addEventListener("updatefromsandbox", (Dt) => {
                const Qt = {
                  value(Gt) {
                    mt == null || mt();
                    const zt = Gt.detail.value, Kt = new Set(Array.isArray(zt) ? zt : [zt]);
                    for (const jt of tt.options)
                      jt.selected = Kt.has(jt.value);
                    et.setValue(E, {
                      value: Pt(!0)
                    }), Ft = Pt(!1);
                  },
                  multipleSelection(Gt) {
                    tt.multiple = !0;
                  },
                  remove(Gt) {
                    const zt = tt.options, Kt = Gt.detail.remove;
                    zt[Kt].selected = !1, tt.remove(Kt), zt.length > 0 && Array.prototype.findIndex.call(zt, (qt) => qt.selected) === -1 && (zt[0].selected = !0), et.setValue(E, {
                      value: Pt(!0),
                      items: Vt(Gt)
                    }), Ft = Pt(!1);
                  },
                  clear(Gt) {
                    for (; tt.length !== 0; )
                      tt.remove(0);
                    et.setValue(E, {
                      value: null,
                      items: []
                    }), Ft = Pt(!1);
                  },
                  insert(Gt) {
                    const {
                      index: zt,
                      displayValue: Kt,
                      exportValue: jt
                    } = Gt.detail.insert, qt = tt.children[zt], te = document.createElement("option");
                    te.textContent = Kt, te.value = jt, qt ? qt.before(te) : tt.append(te), et.setValue(E, {
                      value: Pt(!0),
                      items: Vt(Gt)
                    }), Ft = Pt(!1);
                  },
                  items(Gt) {
                    const {
                      items: zt
                    } = Gt.detail;
                    for (; tt.length !== 0; )
                      tt.remove(0);
                    for (const Kt of zt) {
                      const {
                        displayValue: jt,
                        exportValue: qt
                      } = Kt, te = document.createElement("option");
                      te.textContent = jt, te.value = qt, tt.append(te);
                    }
                    tt.options.length > 0 && (tt.options[0].selected = !0), et.setValue(E, {
                      value: Pt(!0),
                      items: Vt(Gt)
                    }), Ft = Pt(!1);
                  },
                  indices(Gt) {
                    const zt = new Set(Gt.detail.indices);
                    for (const Kt of Gt.target.options)
                      Kt.selected = zt.has(Kt.index);
                    et.setValue(E, {
                      value: Pt(!0)
                    }), Ft = Pt(!1);
                  },
                  editable(Gt) {
                    Gt.target.disabled = !Gt.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(Qt, Dt);
              }), tt.addEventListener("input", (Dt) => {
                var Gt;
                const Qt = Pt(!0);
                et.setValue(E, {
                  value: Qt
                }), Dt.preventDefault(), (Gt = this.linkService.eventBus) == null || Gt.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: E,
                    name: "Keystroke",
                    value: Ft,
                    changeEx: Qt,
                    willCommit: !1,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(tt, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (Dt) => Dt.target.value)) : tt.addEventListener("input", function(Dt) {
                et.setValue(E, {
                  value: Pt(!0)
                });
              }), this.data.combo && this._setTextStyle(tt), this._setBackgroundColor(tt), this._setDefaultPropertiesFromJS(tt), this.container.append(tt), this.container;
            }
          }
          class x extends s {
            constructor(et) {
              const {
                data: E,
                elements: $
              } = et;
              super(et, {
                isRenderable: s._hasPopupData(E)
              }), this.elements = $;
            }
            render() {
              this.container.classList.add("popupAnnotation");
              const et = new b({
                container: this.container,
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText,
                rect: this.data.rect,
                parentRect: this.data.parentRect || null,
                parent: this.parent,
                elements: this.elements,
                open: this.data.open
              }), E = [];
              for (const $ of this.elements)
                $.popup = et, E.push($.data.id), $.addHighlightArea();
              return this.container.setAttribute("aria-controls", E.map(($) => `${n.AnnotationPrefix}${$}`).join(",")), this.container;
            }
          }
          class b {
            constructor(et) {
              W(this, Ut);
              W(this, $t);
              W(this, Jt);
              W(this, Zt);
              W(this, Z, null);
              W(this, pt, J(this, Ut, mi).bind(this));
              W(this, dt, J(this, Zt, An).bind(this));
              W(this, Tt, J(this, Jt, yn).bind(this));
              W(this, lt, J(this, $t, _e).bind(this));
              W(this, yt, null);
              W(this, bt, null);
              W(this, It, null);
              W(this, Ot, null);
              W(this, Mt, null);
              W(this, gt, null);
              W(this, ut, !1);
              W(this, ct, null);
              W(this, ot, null);
              W(this, vt, null);
              W(this, wt, null);
              W(this, Lt, !1);
              var Kt;
              let {
                container: E,
                color: $,
                elements: tt,
                titleObj: ht,
                modificationDate: mt,
                contentsObj: Pt,
                richText: Ft,
                parent: Vt,
                rect: Dt,
                parentRect: Qt,
                open: Gt
              } = et;
              rt(this, bt, E), rt(this, wt, ht), rt(this, It, Pt), rt(this, vt, Ft), rt(this, Mt, Vt), rt(this, yt, $), rt(this, ot, Dt), rt(this, gt, Qt), rt(this, Ot, tt);
              const zt = h.PDFDateString.toDateObject(mt);
              zt && rt(this, Z, Vt.l10n.get("annotation_date_string", {
                date: zt.toLocaleDateString(),
                time: zt.toLocaleTimeString()
              })), this.trigger = tt.flatMap((jt) => jt.getElementsToTriggerPopup());
              for (const jt of this.trigger)
                jt.addEventListener("click", e(this, lt)), jt.addEventListener("mouseenter", e(this, Tt)), jt.addEventListener("mouseleave", e(this, dt)), jt.classList.add("popupTriggerArea");
              for (const jt of tt)
                (Kt = jt.container) == null || Kt.addEventListener("keydown", e(this, pt));
              e(this, bt).hidden = !0, Gt && J(this, $t, _e).call(this);
            }
            render() {
              if (e(this, ct))
                return;
              const {
                page: {
                  view: et
                },
                viewport: {
                  rawDims: {
                    pageWidth: E,
                    pageHeight: $,
                    pageX: tt,
                    pageY: ht
                  }
                }
              } = e(this, Mt), mt = rt(this, ct, document.createElement("div"));
              if (mt.className = "popup", e(this, yt)) {
                const ne = mt.style.outlineColor = n.Util.makeHexColor(...e(this, yt));
                CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? mt.style.backgroundColor = `color-mix(in srgb, ${ne} 30%, white)` : mt.style.backgroundColor = n.Util.makeHexColor(...e(this, yt).map((le) => Math.floor(0.7 * (255 - le) + le)));
              }
              const Pt = document.createElement("span");
              Pt.className = "header";
              const Ft = document.createElement("h1");
              if (Pt.append(Ft), {
                dir: Ft.dir,
                str: Ft.textContent
              } = e(this, wt), mt.append(Pt), e(this, Z)) {
                const ne = document.createElement("span");
                ne.classList.add("popupDate"), e(this, Z).then((re) => {
                  ne.textContent = re;
                }), Pt.append(ne);
              }
              const Vt = e(this, It), Dt = e(this, vt);
              if (Dt != null && Dt.str && (!(Vt != null && Vt.str) || Vt.str === Dt.str))
                y.XfaLayer.render({
                  xfaHtml: Dt.html,
                  intent: "richText",
                  div: mt
                }), mt.lastChild.classList.add("richText", "popupContent");
              else {
                const ne = this._formatContents(Vt);
                mt.append(ne);
              }
              let Qt = !!e(this, gt), Gt = Qt ? e(this, gt) : e(this, ot);
              for (const ne of e(this, Ot))
                if (!Gt || n.Util.intersect(ne.data.rect, Gt) !== null) {
                  Gt = ne.data.rect, Qt = !0;
                  break;
                }
              const zt = n.Util.normalizeRect([Gt[0], et[3] - Gt[1] + et[1], Gt[2], et[3] - Gt[3] + et[1]]), Kt = 5, jt = Qt ? Gt[2] - Gt[0] + Kt : 0, qt = zt[0] + jt, te = zt[1], {
                style: ie
              } = e(this, bt);
              ie.left = `${100 * (qt - tt) / E}%`, ie.top = `${100 * (te - ht) / $}%`, e(this, bt).append(mt);
            }
            _formatContents(et) {
              let {
                str: E,
                dir: $
              } = et;
              const tt = document.createElement("p");
              tt.classList.add("popupContent"), tt.dir = $;
              const ht = E.split(/(?:\r\n?|\n)/);
              for (let mt = 0, Pt = ht.length; mt < Pt; ++mt) {
                const Ft = ht[mt];
                tt.append(document.createTextNode(Ft)), mt < Pt - 1 && tt.append(document.createElement("br"));
              }
              return tt;
            }
            forceHide() {
              rt(this, Lt, this.isVisible), e(this, Lt) && (e(this, bt).hidden = !0);
            }
            maybeShow() {
              e(this, Lt) && (rt(this, Lt, !1), e(this, bt).hidden = !1);
            }
            get isVisible() {
              return e(this, bt).hidden === !1;
            }
          }
          Z = new WeakMap(), pt = new WeakMap(), dt = new WeakMap(), Tt = new WeakMap(), lt = new WeakMap(), yt = new WeakMap(), bt = new WeakMap(), It = new WeakMap(), Ot = new WeakMap(), Mt = new WeakMap(), gt = new WeakMap(), ut = new WeakMap(), ct = new WeakMap(), ot = new WeakMap(), vt = new WeakMap(), wt = new WeakMap(), Lt = new WeakMap(), Ut = new WeakSet(), mi = function(et) {
            et.altKey || et.shiftKey || et.ctrlKey || et.metaKey || (et.key === "Enter" || et.key === "Escape" && e(this, ut)) && J(this, $t, _e).call(this);
          }, $t = new WeakSet(), _e = function() {
            rt(this, ut, !e(this, ut)), e(this, ut) ? (J(this, Jt, yn).call(this), e(this, bt).addEventListener("click", e(this, lt)), e(this, bt).addEventListener("keydown", e(this, pt))) : (J(this, Zt, An).call(this), e(this, bt).removeEventListener("click", e(this, lt)), e(this, bt).removeEventListener("keydown", e(this, pt)));
          }, Jt = new WeakSet(), yn = function() {
            e(this, ct) || this.render(), this.isVisible ? e(this, ut) && e(this, bt).classList.add("focused") : (e(this, bt).hidden = !1, e(this, bt).style.zIndex = parseInt(e(this, bt).style.zIndex) + 1e3);
          }, Zt = new WeakSet(), An = function() {
            e(this, bt).classList.remove("focused"), !(e(this, ut) || !this.isVisible) && (e(this, bt).hidden = !0, e(this, bt).style.zIndex = parseInt(e(this, bt).style.zIndex) - 1e3);
          };
          class F extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0
              }), this.textContent = et.data.textContent, this.textPosition = et.data.textPosition, this.annotationEditorType = n.AnnotationEditorType.FREETEXT;
            }
            render() {
              if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
                const et = document.createElement("div");
                et.classList.add("annotationTextContent"), et.setAttribute("role", "comment");
                for (const E of this.textContent) {
                  const $ = document.createElement("span");
                  $.textContent = E, et.append($);
                }
                this.container.append(et);
              }
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
            }
          }
          S.FreeTextAnnotationElement = F;
          class L extends s {
            constructor(E) {
              super(E, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              W(this, N, null);
            }
            render() {
              this.container.classList.add("lineAnnotation");
              const E = this.data, {
                width: $,
                height: tt
              } = A(E.rect), ht = this.svgFactory.create($, tt, !0), mt = rt(this, N, this.svgFactory.createElement("svg:line"));
              return mt.setAttribute("x1", E.rect[2] - E.lineCoordinates[0]), mt.setAttribute("y1", E.rect[3] - E.lineCoordinates[1]), mt.setAttribute("x2", E.rect[2] - E.lineCoordinates[2]), mt.setAttribute("y2", E.rect[3] - E.lineCoordinates[3]), mt.setAttribute("stroke-width", E.borderStyle.width || 1), mt.setAttribute("stroke", "transparent"), mt.setAttribute("fill", "transparent"), ht.append(mt), this.container.append(ht), !E.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return e(this, N);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          N = new WeakMap();
          class G extends s {
            constructor(E) {
              super(E, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              W(this, V, null);
            }
            render() {
              this.container.classList.add("squareAnnotation");
              const E = this.data, {
                width: $,
                height: tt
              } = A(E.rect), ht = this.svgFactory.create($, tt, !0), mt = E.borderStyle.width, Pt = rt(this, V, this.svgFactory.createElement("svg:rect"));
              return Pt.setAttribute("x", mt / 2), Pt.setAttribute("y", mt / 2), Pt.setAttribute("width", $ - mt), Pt.setAttribute("height", tt - mt), Pt.setAttribute("stroke-width", mt || 1), Pt.setAttribute("stroke", "transparent"), Pt.setAttribute("fill", "transparent"), ht.append(Pt), this.container.append(ht), !E.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return e(this, V);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          V = new WeakMap();
          class nt extends s {
            constructor(E) {
              super(E, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              W(this, K, null);
            }
            render() {
              this.container.classList.add("circleAnnotation");
              const E = this.data, {
                width: $,
                height: tt
              } = A(E.rect), ht = this.svgFactory.create($, tt, !0), mt = E.borderStyle.width, Pt = rt(this, K, this.svgFactory.createElement("svg:ellipse"));
              return Pt.setAttribute("cx", $ / 2), Pt.setAttribute("cy", tt / 2), Pt.setAttribute("rx", $ / 2 - mt / 2), Pt.setAttribute("ry", tt / 2 - mt / 2), Pt.setAttribute("stroke-width", mt || 1), Pt.setAttribute("stroke", "transparent"), Pt.setAttribute("fill", "transparent"), ht.append(Pt), this.container.append(ht), !E.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return e(this, K);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          K = new WeakMap();
          class D extends s {
            constructor(E) {
              super(E, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              W(this, st, null);
              this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const E = this.data, {
                width: $,
                height: tt
              } = A(E.rect), ht = this.svgFactory.create($, tt, !0);
              let mt = [];
              for (const Ft of E.vertices) {
                const Vt = Ft.x - E.rect[0], Dt = E.rect[3] - Ft.y;
                mt.push(Vt + "," + Dt);
              }
              mt = mt.join(" ");
              const Pt = rt(this, st, this.svgFactory.createElement(this.svgElementName));
              return Pt.setAttribute("points", mt), Pt.setAttribute("stroke-width", E.borderStyle.width || 1), Pt.setAttribute("stroke", "transparent"), Pt.setAttribute("fill", "transparent"), ht.append(Pt), this.container.append(ht), !E.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return e(this, st);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          st = new WeakMap();
          class X extends D {
            constructor(et) {
              super(et), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class q extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          class j extends s {
            constructor(E) {
              super(E, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              W(this, ft, []);
              this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = n.AnnotationEditorType.INK;
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const E = this.data, {
                width: $,
                height: tt
              } = A(E.rect), ht = this.svgFactory.create($, tt, !0);
              for (const mt of E.inkLists) {
                let Pt = [];
                for (const Vt of mt) {
                  const Dt = Vt.x - E.rect[0], Qt = E.rect[3] - Vt.y;
                  Pt.push(`${Dt},${Qt}`);
                }
                Pt = Pt.join(" ");
                const Ft = this.svgFactory.createElement(this.svgElementName);
                e(this, ft).push(Ft), Ft.setAttribute("points", Pt), Ft.setAttribute("stroke-width", E.borderStyle.width || 1), Ft.setAttribute("stroke", "transparent"), Ft.setAttribute("fill", "transparent"), !E.popupRef && this.hasPopupData && this._createPopup(), ht.append(Ft);
              }
              return this.container.append(ht), this.container;
            }
            getElementsToTriggerPopup() {
              return e(this, ft);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          ft = new WeakMap(), S.InkAnnotationElement = j;
          class z extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
            }
          }
          class it extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
            }
          }
          class Q extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
            }
          }
          class Et extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
            }
          }
          class Ct extends s {
            constructor(et) {
              super(et, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          S.StampAnnotationElement = Ct;
          class H extends s {
            constructor(E) {
              var ht;
              super(E, {
                isRenderable: !0
              });
              W(this, U);
              W(this, Y, null);
              const {
                filename: $,
                content: tt
              } = this.data.file;
              this.filename = (0, h.getFilenameFromUrl)($, !0), this.content = tt, (ht = this.linkService.eventBus) == null || ht.dispatch("fileattachmentannotation", {
                source: this,
                filename: $,
                content: tt
              });
            }
            render() {
              this.container.classList.add("fileAttachmentAnnotation");
              const {
                container: E,
                data: $
              } = this;
              let tt;
              $.hasAppearance || $.fillAlpha === 0 ? tt = document.createElement("div") : (tt = document.createElement("img"), tt.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test($.name) ? "paperclip" : "pushpin"}.svg`, $.fillAlpha && $.fillAlpha < 1 && (tt.style = `filter: opacity(${Math.round($.fillAlpha * 100)}%);`)), tt.addEventListener("dblclick", J(this, U, Sn).bind(this)), rt(this, Y, tt);
              const {
                isMac: ht
              } = n.FeatureTest.platform;
              return E.addEventListener("keydown", (mt) => {
                mt.key === "Enter" && (ht ? mt.metaKey : mt.ctrlKey) && J(this, U, Sn).call(this);
              }), !$.popupRef && this.hasPopupData ? this._createPopup() : tt.classList.add("popupTriggerArea"), E.append(tt), E;
            }
            getElementsToTriggerPopup() {
              return e(this, Y);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          Y = new WeakMap(), U = new WeakSet(), Sn = function() {
            var E;
            (E = this.downloadManager) == null || E.openOrDownloadData(this.container, this.content, this.filename);
          };
          class m {
            constructor(et) {
              W(this, xt);
              W(this, kt);
              W(this, St, null);
              W(this, At, null);
              W(this, Rt, /* @__PURE__ */ new Map());
              let {
                div: E,
                accessibilityManager: $,
                annotationCanvasMap: tt,
                l10n: ht,
                page: mt,
                viewport: Pt
              } = et;
              this.div = E, rt(this, St, $), rt(this, At, tt), this.l10n = ht, this.page = mt, this.viewport = Pt, this.zIndex = 0, this.l10n || (this.l10n = f.NullL10n);
            }
            async render(et) {
              const {
                annotations: E
              } = et, $ = this.div;
              (0, h.setLayerDimensions)($, this.viewport);
              const tt = /* @__PURE__ */ new Map(), ht = {
                data: null,
                layer: $,
                linkService: et.linkService,
                downloadManager: et.downloadManager,
                imageResourcesPath: et.imageResourcesPath || "",
                renderForms: et.renderForms !== !1,
                svgFactory: new h.DOMSVGFactory(),
                annotationStorage: et.annotationStorage || new T.AnnotationStorage(),
                enableScripting: et.enableScripting === !0,
                hasJSActions: et.hasJSActions,
                fieldObjects: et.fieldObjects,
                parent: this,
                elements: null
              };
              for (const mt of E) {
                if (mt.noHTML)
                  continue;
                const Pt = mt.annotationType === n.AnnotationType.POPUP;
                if (Pt) {
                  const Dt = tt.get(mt.id);
                  if (!Dt)
                    continue;
                  ht.elements = Dt;
                } else {
                  const {
                    width: Dt,
                    height: Qt
                  } = A(mt.rect);
                  if (Dt <= 0 || Qt <= 0)
                    continue;
                }
                ht.data = mt;
                const Ft = g.create(ht);
                if (!Ft.isRenderable)
                  continue;
                if (!Pt && mt.popupRef) {
                  const Dt = tt.get(mt.popupRef);
                  Dt ? Dt.push(Ft) : tt.set(mt.popupRef, [Ft]);
                }
                Ft.annotationEditorType > 0 && e(this, Rt).set(Ft.data.id, Ft);
                const Vt = Ft.render();
                mt.hidden && (Vt.style.visibility = "hidden"), J(this, xt, vi).call(this, Vt, mt.id);
              }
              J(this, kt, En).call(this), await this.l10n.translate($);
            }
            update(et) {
              let {
                viewport: E
              } = et;
              const $ = this.div;
              this.viewport = E, (0, h.setLayerDimensions)($, {
                rotation: E.rotation
              }), J(this, kt, En).call(this), $.hidden = !1;
            }
            getEditableAnnotations() {
              return Array.from(e(this, Rt).values());
            }
            getEditableAnnotation(et) {
              return e(this, Rt).get(et);
            }
          }
          St = new WeakMap(), At = new WeakMap(), Rt = new WeakMap(), xt = new WeakSet(), vi = function(et, E) {
            var tt;
            const $ = et.firstChild || et;
            $.id = `${n.AnnotationPrefix}${E}`, this.div.append(et), (tt = e(this, St)) == null || tt.moveElementInDOM(this.div, et, $, !1);
          }, kt = new WeakSet(), En = function() {
            if (!e(this, At))
              return;
            const et = this.div;
            for (const [E, $] of e(this, At)) {
              const tt = et.querySelector(`[data-annotation-id="${E}"]`);
              if (!tt)
                continue;
              const {
                firstChild: ht
              } = tt;
              ht ? ht.nodeName === "CANVAS" ? ht.replaceWith($) : ht.before($) : tt.append($);
            }
            e(this, At).clear();
          }, S.AnnotationLayer = m;
        },
        /* 199 */
        /***/
        (O, S) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.ColorConverters = void 0;
          function t(T) {
            return Math.floor(Math.max(0, Math.min(1, T)) * 255).toString(16).padStart(2, "0");
          }
          function n(T) {
            return Math.max(0, Math.min(255, 255 * T));
          }
          class h {
            static CMYK_G(P) {
              let [f, y, c, a] = P;
              return ["G", 1 - Math.min(1, 0.3 * f + 0.59 * c + 0.11 * y + a)];
            }
            static G_CMYK(P) {
              let [f] = P;
              return ["CMYK", 0, 0, 0, 1 - f];
            }
            static G_RGB(P) {
              let [f] = P;
              return ["RGB", f, f, f];
            }
            static G_rgb(P) {
              let [f] = P;
              return f = n(f), [f, f, f];
            }
            static G_HTML(P) {
              let [f] = P;
              const y = t(f);
              return `#${y}${y}${y}`;
            }
            static RGB_G(P) {
              let [f, y, c] = P;
              return ["G", 0.3 * f + 0.59 * y + 0.11 * c];
            }
            static RGB_rgb(P) {
              return P.map(n);
            }
            static RGB_HTML(P) {
              return `#${P.map(t).join("")}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static T_rgb() {
              return [null];
            }
            static CMYK_RGB(P) {
              let [f, y, c, a] = P;
              return ["RGB", 1 - Math.min(1, f + a), 1 - Math.min(1, c + a), 1 - Math.min(1, y + a)];
            }
            static CMYK_rgb(P) {
              let [f, y, c, a] = P;
              return [n(1 - Math.min(1, f + a)), n(1 - Math.min(1, c + a)), n(1 - Math.min(1, y + a))];
            }
            static CMYK_HTML(P) {
              const f = this.CMYK_RGB(P).slice(1);
              return this.RGB_HTML(f);
            }
            static RGB_CMYK(P) {
              let [f, y, c] = P;
              const a = 1 - f, I = 1 - y, A = 1 - c, g = Math.min(a, I, A);
              return ["CMYK", a, I, A, g];
            }
          }
          S.ColorConverters = h;
        },
        /* 200 */
        /***/
        (O, S) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.NullL10n = void 0, S.getL10nFallback = n;
          const t = {
            of_pages: "of {{pagesCount}}",
            page_of_pages: "({{pageNumber}} of {{pagesCount}})",
            document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
            document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
            document_properties_date_string: "{{date}}, {{time}}",
            document_properties_page_size_unit_inches: "in",
            document_properties_page_size_unit_millimeters: "mm",
            document_properties_page_size_orientation_portrait: "portrait",
            document_properties_page_size_orientation_landscape: "landscape",
            document_properties_page_size_name_a3: "A3",
            document_properties_page_size_name_a4: "A4",
            document_properties_page_size_name_letter: "Letter",
            document_properties_page_size_name_legal: "Legal",
            document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
            document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
            document_properties_linearized_yes: "Yes",
            document_properties_linearized_no: "No",
            additional_layers: "Additional Layers",
            page_landmark: "Page {{page}}",
            thumb_page_title: "Page {{page}}",
            thumb_page_canvas: "Thumbnail of Page {{page}}",
            find_reached_top: "Reached top of document, continued from bottom",
            find_reached_bottom: "Reached end of document, continued from top",
            "find_match_count[one]": "{{current}} of {{total}} match",
            "find_match_count[other]": "{{current}} of {{total}} matches",
            "find_match_count_limit[one]": "More than {{limit}} match",
            "find_match_count_limit[other]": "More than {{limit}} matches",
            find_not_found: "Phrase not found",
            page_scale_width: "Page Width",
            page_scale_fit: "Page Fit",
            page_scale_auto: "Automatic Zoom",
            page_scale_actual: "Actual Size",
            page_scale_percent: "{{scale}}%",
            loading_error: "An error occurred while loading the PDF.",
            invalid_file_error: "Invalid or corrupted PDF file.",
            missing_file_error: "Missing PDF file.",
            unexpected_response_error: "Unexpected server response.",
            rendering_error: "An error occurred while rendering the page.",
            annotation_date_string: "{{date}}, {{time}}",
            printing_not_supported: "Warning: Printing is not fully supported by this browser.",
            printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
            web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
            free_text2_default_content: "Start typing…",
            editor_free_text2_aria_label: "Text Editor",
            editor_ink2_aria_label: "Draw Editor",
            editor_ink_canvas_aria_label: "User-created image",
            editor_alt_text_button_label: "Alt text",
            editor_alt_text_edit_button_label: "Edit alt text",
            editor_alt_text_decorative_tooltip: "Marked as decorative"
          };
          t.print_progress_percent = "{{progress}}%";
          function n(P, f) {
            switch (P) {
              case "find_match_count":
                P = `find_match_count[${f.total === 1 ? "one" : "other"}]`;
                break;
              case "find_match_count_limit":
                P = `find_match_count_limit[${f.limit === 1 ? "one" : "other"}]`;
                break;
            }
            return t[P] || "";
          }
          function h(P, f) {
            return f ? P.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (y, c) => c in f ? f[c] : "{{" + c + "}}") : P;
          }
          const T = {
            async getLanguage() {
              return "en-us";
            },
            async getDirection() {
              return "ltr";
            },
            async get(P) {
              let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : n(P, f);
              return h(y, f);
            },
            async translate(P) {
            }
          };
          S.NullL10n = T;
        },
        /* 201 */
        /***/
        (O, S, t) => {
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.XfaLayer = void 0, t(89);
          var n = t(194);
          class h {
            static setupStorage(P, f, y, c, a) {
              const I = c.getValue(f, {
                value: null
              });
              switch (y.name) {
                case "textarea":
                  if (I.value !== null && (P.textContent = I.value), a === "print")
                    break;
                  P.addEventListener("input", (A) => {
                    c.setValue(f, {
                      value: A.target.value
                    });
                  });
                  break;
                case "input":
                  if (y.attributes.type === "radio" || y.attributes.type === "checkbox") {
                    if (I.value === y.attributes.xfaOn ? P.setAttribute("checked", !0) : I.value === y.attributes.xfaOff && P.removeAttribute("checked"), a === "print")
                      break;
                    P.addEventListener("change", (A) => {
                      c.setValue(f, {
                        value: A.target.checked ? A.target.getAttribute("xfaOn") : A.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (I.value !== null && P.setAttribute("value", I.value), a === "print")
                      break;
                    P.addEventListener("input", (A) => {
                      c.setValue(f, {
                        value: A.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (I.value !== null) {
                    P.setAttribute("value", I.value);
                    for (const A of y.children)
                      A.attributes.value === I.value ? A.attributes.selected = !0 : A.attributes.hasOwnProperty("selected") && delete A.attributes.selected;
                  }
                  P.addEventListener("input", (A) => {
                    const g = A.target.options, s = g.selectedIndex === -1 ? "" : g[g.selectedIndex].value;
                    c.setValue(f, {
                      value: s
                    });
                  });
                  break;
              }
            }
            static setAttributes(P) {
              let {
                html: f,
                element: y,
                storage: c = null,
                intent: a,
                linkService: I
              } = P;
              const {
                attributes: A
              } = y, g = f instanceof HTMLAnchorElement;
              A.type === "radio" && (A.name = `${A.name}-${a}`);
              for (const [s, o] of Object.entries(A))
                if (o != null)
                  switch (s) {
                    case "class":
                      o.length && f.setAttribute(s, o.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      f.setAttribute("data-element-id", o);
                      break;
                    case "style":
                      Object.assign(f.style, o);
                      break;
                    case "textContent":
                      f.textContent = o;
                      break;
                    default:
                      (!g || s !== "href" && s !== "newWindow") && f.setAttribute(s, o);
                  }
              g && I.addLinkAttributes(f, A.href, A.newWindow), c && A.dataId && this.setupStorage(f, A.dataId, y, c);
            }
            static render(P) {
              var o;
              const f = P.annotationStorage, y = P.linkService, c = P.xfaHtml, a = P.intent || "display", I = document.createElement(c.name);
              c.attributes && this.setAttributes({
                html: I,
                element: c,
                intent: a,
                linkService: y
              });
              const A = [[c, -1, I]], g = P.div;
              if (g.append(I), P.viewport) {
                const l = `matrix(${P.viewport.transform.join(",")})`;
                g.style.transform = l;
              }
              a !== "richText" && g.setAttribute("class", "xfaLayer xfaFont");
              const s = [];
              for (; A.length > 0; ) {
                const [l, u, v] = A.at(-1);
                if (u + 1 === l.children.length) {
                  A.pop();
                  continue;
                }
                const p = l.children[++A.at(-1)[1]];
                if (p === null)
                  continue;
                const {
                  name: C
                } = p;
                if (C === "#text") {
                  const i = document.createTextNode(p.value);
                  s.push(i), v.append(i);
                  continue;
                }
                const r = (o = p == null ? void 0 : p.attributes) != null && o.xmlns ? document.createElementNS(p.attributes.xmlns, C) : document.createElement(C);
                if (v.append(r), p.attributes && this.setAttributes({
                  html: r,
                  element: p,
                  storage: f,
                  intent: a,
                  linkService: y
                }), p.children && p.children.length > 0)
                  A.push([p, -1, r]);
                else if (p.value) {
                  const i = document.createTextNode(p.value);
                  n.XfaText.shouldBuildText(C) && s.push(i), r.append(i);
                }
              }
              for (const l of g.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                l.setAttribute("readOnly", !0);
              return {
                textDivs: s
              };
            }
            static update(P) {
              const f = `matrix(${P.viewport.transform.join(",")})`;
              P.div.style.transform = f, P.div.hidden = !1;
            }
          }
          S.XfaLayer = h;
        },
        /* 202 */
        /***/
        (O, S, t) => {
          var c, a, I, A, g, s, o, l, u, v, p, C, r, i, w, bi, b, yi, L, Ai, nt, Si, X, Pn, j, Ei, it, Tn, Et, Pi, H, Ti, k, xi, R, Ci, B, wi, Z, ae, dt, xn, lt, Ne, bt, Be, Ot, ge, gt, Cn, ct, Ue, vt, Ri, Lt, wn, Ht, ki, Wt, Mi, Xt, Rn, Yt, Ve, V, me;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.InkEditor = void 0, t(89), t(2);
          var n = t(1), h = t(164), T = t(198), P = t(168), f = t(165);
          const st = class st extends h.AnnotationEditor {
            constructor(U) {
              super({
                ...U,
                name: "inkEditor"
              });
              W(this, w);
              W(this, b);
              W(this, L);
              W(this, nt);
              W(this, X);
              W(this, j);
              W(this, it);
              W(this, Et);
              W(this, H);
              W(this, k);
              W(this, R);
              W(this, B);
              W(this, Z);
              W(this, dt);
              W(this, lt);
              W(this, bt);
              W(this, Ot);
              W(this, gt);
              W(this, ct);
              W(this, Wt);
              W(this, Xt);
              W(this, Yt);
              W(this, V);
              W(this, c, 0);
              W(this, a, 0);
              W(this, I, this.canvasPointermove.bind(this));
              W(this, A, this.canvasPointerleave.bind(this));
              W(this, g, this.canvasPointerup.bind(this));
              W(this, s, this.canvasPointerdown.bind(this));
              W(this, o, new Path2D());
              W(this, l, !1);
              W(this, u, !1);
              W(this, v, !1);
              W(this, p, null);
              W(this, C, 0);
              W(this, r, 0);
              W(this, i, null);
              this.color = U.color || null, this.thickness = U.thickness || null, this.opacity = U.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
            }
            static initialize(U) {
              h.AnnotationEditor.initialize(U, {
                strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
              });
            }
            static updateDefaultParams(U, at) {
              switch (U) {
                case n.AnnotationEditorParamsType.INK_THICKNESS:
                  st._defaultThickness = at;
                  break;
                case n.AnnotationEditorParamsType.INK_COLOR:
                  st._defaultColor = at;
                  break;
                case n.AnnotationEditorParamsType.INK_OPACITY:
                  st._defaultOpacity = at / 100;
                  break;
              }
            }
            updateParams(U, at) {
              switch (U) {
                case n.AnnotationEditorParamsType.INK_THICKNESS:
                  J(this, w, bi).call(this, at);
                  break;
                case n.AnnotationEditorParamsType.INK_COLOR:
                  J(this, b, yi).call(this, at);
                  break;
                case n.AnnotationEditorParamsType.INK_OPACITY:
                  J(this, L, Ai).call(this, at);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[n.AnnotationEditorParamsType.INK_THICKNESS, st._defaultThickness], [n.AnnotationEditorParamsType.INK_COLOR, st._defaultColor || h.AnnotationEditor._defaultLineColor], [n.AnnotationEditorParamsType.INK_OPACITY, Math.round(st._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[n.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || st._defaultThickness], [n.AnnotationEditorParamsType.INK_COLOR, this.color || st._defaultColor || h.AnnotationEditor._defaultLineColor], [n.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? st._defaultOpacity))]];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.canvas || (J(this, lt, Ne).call(this), J(this, bt, Be).call(this)), this.isAttachedToDOM || (this.parent.add(this), J(this, Ot, ge).call(this)), J(this, V, me).call(this)));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, e(this, p).disconnect(), rt(this, p, null), super.remove());
            }
            setParent(U) {
              !this.parent && U ? this._uiManager.removeShouldRescale(this) : this.parent && U === null && this._uiManager.addShouldRescale(this), super.setParent(U);
            }
            onScaleChanging() {
              const [U, at] = this.parentDimensions, St = this.width * U, At = this.height * at;
              this.setDimensions(St, At);
            }
            enableEditMode() {
              e(this, l) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", e(this, s)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", e(this, s)));
            }
            onceAdded() {
              this._isDraggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              e(this, l) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), rt(this, l, !0), this.div.classList.add("disabled"), J(this, V, me).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
                preventScroll: !0
              }));
            }
            focusin(U) {
              this._focusEventsAllowed && (super.focusin(U), this.enableEditMode());
            }
            canvasPointerdown(U) {
              U.button !== 0 || !this.isInEditMode() || e(this, l) || (this.setInForeground(), U.preventDefault(), U.type !== "mouse" && this.div.focus(), J(this, j, Ei).call(this, U.offsetX, U.offsetY));
            }
            canvasPointermove(U) {
              U.preventDefault(), J(this, it, Tn).call(this, U.offsetX, U.offsetY);
            }
            canvasPointerup(U) {
              U.preventDefault(), J(this, dt, xn).call(this, U);
            }
            canvasPointerleave(U) {
              J(this, dt, xn).call(this, U);
            }
            get isResizable() {
              return !this.isEmpty() && e(this, l);
            }
            render() {
              if (this.div)
                return this.div;
              let U, at;
              this.width && (U = this.x, at = this.y), super.render(), h.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((Nt) => {
                var kt;
                return (kt = this.div) == null ? void 0 : kt.setAttribute("aria-label", Nt);
              });
              const [St, At, Rt, xt] = J(this, nt, Si).call(this);
              if (this.setAt(St, At, 0, 0), this.setDims(Rt, xt), J(this, lt, Ne).call(this), this.width) {
                const [Nt, kt] = this.parentDimensions;
                this.setAspectRatio(this.width * Nt, this.height * kt), this.setAt(U * Nt, at * kt, this.width * Nt, this.height * kt), rt(this, v, !0), J(this, Ot, ge).call(this), this.setDims(this.width * Nt, this.height * kt), J(this, Z, ae).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return J(this, bt, Be).call(this), this.div;
            }
            setDimensions(U, at) {
              const St = Math.round(U), At = Math.round(at);
              if (e(this, C) === St && e(this, r) === At)
                return;
              rt(this, C, St), rt(this, r, At), this.canvas.style.visibility = "hidden";
              const [Rt, xt] = this.parentDimensions;
              this.width = U / Rt, this.height = at / xt, this.fixAndSetPosition(), e(this, l) && J(this, gt, Cn).call(this, U, at), J(this, Ot, ge).call(this), J(this, Z, ae).call(this), this.canvas.style.visibility = "visible", this.fixDims();
            }
            static deserialize(U, at, St) {
              var ht, mt, Pt;
              if (U instanceof T.InkAnnotationElement)
                return null;
              const At = super.deserialize(U, at, St);
              At.thickness = U.thickness, At.color = n.Util.makeHexColor(...U.color), At.opacity = U.opacity;
              const [Rt, xt] = At.pageDimensions, Nt = At.width * Rt, kt = At.height * xt, _t = At.parentScale, Bt = U.thickness / 2;
              rt(At, l, !0), rt(At, C, Math.round(Nt)), rt(At, r, Math.round(kt));
              const {
                paths: et,
                rect: E,
                rotation: $
              } = U;
              for (let {
                bezier: Ft
              } of et) {
                Ft = J(ht = st, Ht, ki).call(ht, Ft, E, $);
                const Vt = [];
                At.paths.push(Vt);
                let Dt = _t * (Ft[0] - Bt), Qt = _t * (Ft[1] - Bt);
                for (let zt = 2, Kt = Ft.length; zt < Kt; zt += 6) {
                  const jt = _t * (Ft[zt] - Bt), qt = _t * (Ft[zt + 1] - Bt), te = _t * (Ft[zt + 2] - Bt), ie = _t * (Ft[zt + 3] - Bt), ne = _t * (Ft[zt + 4] - Bt), re = _t * (Ft[zt + 5] - Bt);
                  Vt.push([[Dt, Qt], [jt, qt], [te, ie], [ne, re]]), Dt = ne, Qt = re;
                }
                const Gt = J(this, vt, Ri).call(this, Vt);
                At.bezierPath2D.push(Gt);
              }
              const tt = J(mt = At, Xt, Rn).call(mt);
              return rt(At, a, Math.max(h.AnnotationEditor.MIN_SIZE, tt[2] - tt[0])), rt(At, c, Math.max(h.AnnotationEditor.MIN_SIZE, tt[3] - tt[1])), J(Pt = At, gt, Cn).call(Pt, Nt, kt), At;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const U = this.getRect(0, 0), at = h.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: n.AnnotationEditorType.INK,
                color: at,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: J(this, Wt, Mi).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, U),
                pageIndex: this.pageIndex,
                rect: U,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
            }
          };
          c = new WeakMap(), a = new WeakMap(), I = new WeakMap(), A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakMap(), v = new WeakMap(), p = new WeakMap(), C = new WeakMap(), r = new WeakMap(), i = new WeakMap(), w = new WeakSet(), bi = function(U) {
            const at = this.thickness;
            this.addCommands({
              cmd: () => {
                this.thickness = U, J(this, V, me).call(this);
              },
              undo: () => {
                this.thickness = at, J(this, V, me).call(this);
              },
              mustExec: !0,
              type: n.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, b = new WeakSet(), yi = function(U) {
            const at = this.color;
            this.addCommands({
              cmd: () => {
                this.color = U, J(this, Z, ae).call(this);
              },
              undo: () => {
                this.color = at, J(this, Z, ae).call(this);
              },
              mustExec: !0,
              type: n.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, L = new WeakSet(), Ai = function(U) {
            U /= 100;
            const at = this.opacity;
            this.addCommands({
              cmd: () => {
                this.opacity = U, J(this, Z, ae).call(this);
              },
              undo: () => {
                this.opacity = at, J(this, Z, ae).call(this);
              },
              mustExec: !0,
              type: n.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, nt = new WeakSet(), Si = function() {
            const {
              parentRotation: U,
              parentDimensions: [at, St]
            } = this;
            switch (U) {
              case 90:
                return [0, St, St, at];
              case 180:
                return [at, St, at, St];
              case 270:
                return [at, 0, St, at];
              default:
                return [0, 0, at, St];
            }
          }, X = new WeakSet(), Pn = function() {
            const {
              ctx: U,
              color: at,
              opacity: St,
              thickness: At,
              parentScale: Rt,
              scaleFactor: xt
            } = this;
            U.lineWidth = At * Rt / xt, U.lineCap = "round", U.lineJoin = "round", U.miterLimit = 10, U.strokeStyle = `${at}${(0, f.opacityToHex)(St)}`;
          }, j = new WeakSet(), Ei = function(U, at) {
            this.canvas.addEventListener("contextmenu", P.noContextMenu), this.canvas.addEventListener("pointerleave", e(this, A)), this.canvas.addEventListener("pointermove", e(this, I)), this.canvas.addEventListener("pointerup", e(this, g)), this.canvas.removeEventListener("pointerdown", e(this, s)), this.isEditing = !0, e(this, v) || (rt(this, v, !0), J(this, Ot, ge).call(this), this.thickness || (this.thickness = st._defaultThickness), this.color || (this.color = st._defaultColor || h.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = st._defaultOpacity)), this.currentPath.push([U, at]), rt(this, u, !1), J(this, X, Pn).call(this), rt(this, i, () => {
              J(this, k, xi).call(this), e(this, i) && window.requestAnimationFrame(e(this, i));
            }), window.requestAnimationFrame(e(this, i));
          }, it = new WeakSet(), Tn = function(U, at) {
            const [St, At] = this.currentPath.at(-1);
            if (this.currentPath.length > 1 && U === St && at === At)
              return;
            const Rt = this.currentPath;
            let xt = e(this, o);
            if (Rt.push([U, at]), rt(this, u, !0), Rt.length <= 2) {
              xt.moveTo(...Rt[0]), xt.lineTo(U, at);
              return;
            }
            Rt.length === 3 && (rt(this, o, xt = new Path2D()), xt.moveTo(...Rt[0])), J(this, R, Ci).call(this, xt, ...Rt.at(-3), ...Rt.at(-2), U, at);
          }, Et = new WeakSet(), Pi = function() {
            if (this.currentPath.length === 0)
              return;
            const U = this.currentPath.at(-1);
            e(this, o).lineTo(...U);
          }, H = new WeakSet(), Ti = function(U, at) {
            rt(this, i, null), U = Math.min(Math.max(U, 0), this.canvas.width), at = Math.min(Math.max(at, 0), this.canvas.height), J(this, it, Tn).call(this, U, at), J(this, Et, Pi).call(this);
            let St;
            if (this.currentPath.length !== 1)
              St = J(this, B, wi).call(this);
            else {
              const kt = [U, at];
              St = [[kt, kt.slice(), kt.slice(), kt]];
            }
            const At = e(this, o), Rt = this.currentPath;
            this.currentPath = [], rt(this, o, new Path2D());
            const xt = () => {
              this.allRawPaths.push(Rt), this.paths.push(St), this.bezierPath2D.push(At), this.rebuild();
            }, Nt = () => {
              this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (J(this, lt, Ne).call(this), J(this, bt, Be).call(this)), J(this, V, me).call(this));
            };
            this.addCommands({
              cmd: xt,
              undo: Nt,
              mustExec: !0
            });
          }, k = new WeakSet(), xi = function() {
            if (!e(this, u))
              return;
            rt(this, u, !1);
            const U = Math.ceil(this.thickness * this.parentScale), at = this.currentPath.slice(-3), St = at.map((xt) => xt[0]), At = at.map((xt) => xt[1]);
            Math.min(...St) - U, Math.max(...St) + U, Math.min(...At) - U, Math.max(...At) + U;
            const {
              ctx: Rt
            } = this;
            Rt.save(), Rt.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (const xt of this.bezierPath2D)
              Rt.stroke(xt);
            Rt.stroke(e(this, o)), Rt.restore();
          }, R = new WeakSet(), Ci = function(U, at, St, At, Rt, xt, Nt) {
            const kt = (at + At) / 2, _t = (St + Rt) / 2, Bt = (At + xt) / 2, et = (Rt + Nt) / 2;
            U.bezierCurveTo(kt + 2 * (At - kt) / 3, _t + 2 * (Rt - _t) / 3, Bt + 2 * (At - Bt) / 3, et + 2 * (Rt - et) / 3, Bt, et);
          }, B = new WeakSet(), wi = function() {
            const U = this.currentPath;
            if (U.length <= 2)
              return [[U[0], U[0], U.at(-1), U.at(-1)]];
            const at = [];
            let St, [At, Rt] = U[0];
            for (St = 1; St < U.length - 2; St++) {
              const [E, $] = U[St], [tt, ht] = U[St + 1], mt = (E + tt) / 2, Pt = ($ + ht) / 2, Ft = [At + 2 * (E - At) / 3, Rt + 2 * ($ - Rt) / 3], Vt = [mt + 2 * (E - mt) / 3, Pt + 2 * ($ - Pt) / 3];
              at.push([[At, Rt], Ft, Vt, [mt, Pt]]), [At, Rt] = [mt, Pt];
            }
            const [xt, Nt] = U[St], [kt, _t] = U[St + 1], Bt = [At + 2 * (xt - At) / 3, Rt + 2 * (Nt - Rt) / 3], et = [kt + 2 * (xt - kt) / 3, _t + 2 * (Nt - _t) / 3];
            return at.push([[At, Rt], Bt, et, [kt, _t]]), at;
          }, Z = new WeakSet(), ae = function() {
            if (this.isEmpty()) {
              J(this, ct, Ue).call(this);
              return;
            }
            J(this, X, Pn).call(this);
            const {
              canvas: U,
              ctx: at
            } = this;
            at.setTransform(1, 0, 0, 1, 0, 0), at.clearRect(0, 0, U.width, U.height), J(this, ct, Ue).call(this);
            for (const St of this.bezierPath2D)
              at.stroke(St);
          }, dt = new WeakSet(), xn = function(U) {
            this.canvas.removeEventListener("pointerleave", e(this, A)), this.canvas.removeEventListener("pointermove", e(this, I)), this.canvas.removeEventListener("pointerup", e(this, g)), this.canvas.addEventListener("pointerdown", e(this, s)), setTimeout(() => {
              this.canvas.removeEventListener("contextmenu", P.noContextMenu);
            }, 10), J(this, H, Ti).call(this, U.offsetX, U.offsetY), this.addToAnnotationStorage(), this.setInBackground();
          }, lt = new WeakSet(), Ne = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", h.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((U) => {
              var at;
              return (at = this.canvas) == null ? void 0 : at.setAttribute("aria-label", U);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, bt = new WeakSet(), Be = function() {
            rt(this, p, new ResizeObserver((U) => {
              const at = U[0].contentRect;
              at.width && at.height && this.setDimensions(at.width, at.height);
            })), e(this, p).observe(this.div);
          }, Ot = new WeakSet(), ge = function() {
            if (!e(this, v))
              return;
            const [U, at] = this.parentDimensions;
            this.canvas.width = Math.ceil(this.width * U), this.canvas.height = Math.ceil(this.height * at), J(this, ct, Ue).call(this);
          }, gt = new WeakSet(), Cn = function(U, at) {
            const St = J(this, Yt, Ve).call(this), At = (U - St) / e(this, a), Rt = (at - St) / e(this, c);
            this.scaleFactor = Math.min(At, Rt);
          }, ct = new WeakSet(), Ue = function() {
            const U = J(this, Yt, Ve).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + U, this.translationY * this.scaleFactor + U);
          }, vt = new WeakSet(), Ri = function(U) {
            const at = new Path2D();
            for (let St = 0, At = U.length; St < At; St++) {
              const [Rt, xt, Nt, kt] = U[St];
              St === 0 && at.moveTo(...Rt), at.bezierCurveTo(xt[0], xt[1], Nt[0], Nt[1], kt[0], kt[1]);
            }
            return at;
          }, Lt = new WeakSet(), wn = function(U, at, St) {
            const [At, Rt, xt, Nt] = at;
            switch (St) {
              case 0:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2)
                  U[kt] += At, U[kt + 1] = Nt - U[kt + 1];
                break;
              case 90:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2) {
                  const Bt = U[kt];
                  U[kt] = U[kt + 1] + At, U[kt + 1] = Bt + Rt;
                }
                break;
              case 180:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2)
                  U[kt] = xt - U[kt], U[kt + 1] += Rt;
                break;
              case 270:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2) {
                  const Bt = U[kt];
                  U[kt] = xt - U[kt + 1], U[kt + 1] = Nt - Bt;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return U;
          }, Ht = new WeakSet(), ki = function(U, at, St) {
            const [At, Rt, xt, Nt] = at;
            switch (St) {
              case 0:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2)
                  U[kt] -= At, U[kt + 1] = Nt - U[kt + 1];
                break;
              case 90:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2) {
                  const Bt = U[kt];
                  U[kt] = U[kt + 1] - Rt, U[kt + 1] = Bt - At;
                }
                break;
              case 180:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2)
                  U[kt] = xt - U[kt], U[kt + 1] -= Rt;
                break;
              case 270:
                for (let kt = 0, _t = U.length; kt < _t; kt += 2) {
                  const Bt = U[kt];
                  U[kt] = Nt - U[kt + 1], U[kt + 1] = xt - Bt;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return U;
          }, Wt = new WeakSet(), Mi = function(U, at, St, At) {
            var _t, Bt;
            const Rt = [], xt = this.thickness / 2, Nt = U * at + xt, kt = U * St + xt;
            for (const et of this.paths) {
              const E = [], $ = [];
              for (let tt = 0, ht = et.length; tt < ht; tt++) {
                const [mt, Pt, Ft, Vt] = et[tt], Dt = U * mt[0] + Nt, Qt = U * mt[1] + kt, Gt = U * Pt[0] + Nt, zt = U * Pt[1] + kt, Kt = U * Ft[0] + Nt, jt = U * Ft[1] + kt, qt = U * Vt[0] + Nt, te = U * Vt[1] + kt;
                tt === 0 && (E.push(Dt, Qt), $.push(Dt, Qt)), E.push(Gt, zt, Kt, jt, qt, te), $.push(Gt, zt), tt === ht - 1 && $.push(qt, te);
              }
              Rt.push({
                bezier: J(_t = st, Lt, wn).call(_t, E, At, this.rotation),
                points: J(Bt = st, Lt, wn).call(Bt, $, At, this.rotation)
              });
            }
            return Rt;
          }, Xt = new WeakSet(), Rn = function() {
            let U = 1 / 0, at = -1 / 0, St = 1 / 0, At = -1 / 0;
            for (const Rt of this.paths)
              for (const [xt, Nt, kt, _t] of Rt) {
                const Bt = n.Util.bezierBoundingBox(...xt, ...Nt, ...kt, ..._t);
                U = Math.min(U, Bt[0]), St = Math.min(St, Bt[1]), at = Math.max(at, Bt[2]), At = Math.max(At, Bt[3]);
              }
            return [U, St, at, At];
          }, Yt = new WeakSet(), Ve = function() {
            return e(this, l) ? Math.ceil(this.thickness * this.parentScale) : 0;
          }, V = new WeakSet(), me = function() {
            let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            if (this.isEmpty())
              return;
            if (!e(this, l)) {
              J(this, Z, ae).call(this);
              return;
            }
            const at = J(this, Xt, Rn).call(this), St = J(this, Yt, Ve).call(this);
            rt(this, a, Math.max(h.AnnotationEditor.MIN_SIZE, at[2] - at[0])), rt(this, c, Math.max(h.AnnotationEditor.MIN_SIZE, at[3] - at[1]));
            const At = Math.ceil(St + e(this, a) * this.scaleFactor), Rt = Math.ceil(St + e(this, c) * this.scaleFactor), [xt, Nt] = this.parentDimensions;
            this.width = At / xt, this.height = Rt / Nt, this.setAspectRatio(At, Rt);
            const kt = this.translationX, _t = this.translationY;
            this.translationX = -at[0], this.translationY = -at[1], J(this, Ot, ge).call(this), J(this, Z, ae).call(this), rt(this, C, At), rt(this, r, Rt), this.setDims(At, Rt);
            const Bt = U ? St / this.scaleFactor / 2 : 0;
            this.translate(kt - this.translationX - Bt, _t - this.translationY - Bt);
          }, W(st, vt), W(st, Lt), W(st, Ht), ee(st, "_defaultColor", null), ee(st, "_defaultOpacity", 1), ee(st, "_defaultThickness", 1), ee(st, "_type", "ink");
          let y = st;
          S.InkEditor = y;
        },
        /* 203 */
        /***/
        (O, S, t) => {
          var y, c, a, I, A, g, s, o, l, u, v, Pe, C, Te, i, He, x, kn, F, Ii, G, Li, D, Mn, q, We, z, Oi;
          Object.defineProperty(S, "__esModule", {
            value: !0
          }), S.StampEditor = void 0, t(149), t(152);
          var n = t(1), h = t(164), T = t(168), P = t(198);
          const Q = class Q extends h.AnnotationEditor {
            constructor(H) {
              super({
                ...H,
                name: "stampEditor"
              });
              W(this, v);
              W(this, C);
              W(this, i);
              W(this, x);
              W(this, F);
              W(this, G);
              W(this, D);
              W(this, q);
              W(this, z);
              W(this, y, null);
              W(this, c, null);
              W(this, a, null);
              W(this, I, null);
              W(this, A, null);
              W(this, g, null);
              W(this, s, null);
              W(this, o, null);
              W(this, l, !1);
              W(this, u, !1);
              rt(this, I, H.bitmapUrl), rt(this, A, H.bitmapFile);
            }
            static initialize(H) {
              h.AnnotationEditor.initialize(H);
            }
            static get supportedTypes() {
              const H = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
              return (0, n.shadow)(this, "supportedTypes", H.map((m) => `image/${m}`));
            }
            static get supportedTypesStr() {
              return (0, n.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
            }
            static isHandlingMimeForPasting(H) {
              return this.supportedTypes.includes(H);
            }
            static paste(H, m) {
              m.pasteEditor(n.AnnotationEditorType.STAMP, {
                bitmapFile: H.getAsFile()
              });
            }
            remove() {
              var H, m;
              e(this, c) && (rt(this, y, null), this._uiManager.imageManager.deleteId(e(this, c)), (H = e(this, g)) == null || H.remove(), rt(this, g, null), (m = e(this, s)) == null || m.disconnect(), rt(this, s, null)), super.remove();
            }
            rebuild() {
              if (!this.parent) {
                e(this, c) && J(this, i, He).call(this);
                return;
              }
              super.rebuild(), this.div !== null && (e(this, c) && J(this, i, He).call(this), this.isAttachedToDOM || this.parent.add(this));
            }
            onceAdded() {
              this._isDraggable = !0, this.div.focus();
            }
            isEmpty() {
              return !(e(this, a) || e(this, y) || e(this, I) || e(this, A));
            }
            get isResizable() {
              return !0;
            }
            render() {
              if (this.div)
                return this.div;
              let H, m;
              if (this.width && (H = this.x, m = this.y), super.render(), this.div.hidden = !0, e(this, y) ? J(this, x, kn).call(this) : J(this, i, He).call(this), this.width) {
                const [k, d] = this.parentDimensions;
                this.setAt(H * k, m * d, this.width * k, this.height * d);
              }
              return this.div;
            }
            static deserialize(H, m, k) {
              if (H instanceof P.StampAnnotationElement)
                return null;
              const d = super.deserialize(H, m, k), {
                rect: R,
                bitmapUrl: M,
                bitmapId: B,
                isSvg: _,
                accessibilityData: Z
              } = H;
              B && k.imageManager.isValidId(B) ? rt(d, c, B) : rt(d, I, M), rt(d, l, _);
              const [pt, dt] = d.pageDimensions;
              return d.width = (R[2] - R[0]) / pt, d.height = (R[3] - R[1]) / dt, Z && (d.altTextData = Z), d;
            }
            serialize() {
              let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
              if (this.isEmpty())
                return null;
              const k = {
                annotationType: n.AnnotationEditorType.STAMP,
                bitmapId: e(this, c),
                pageIndex: this.pageIndex,
                rect: this.getRect(0, 0),
                rotation: this.rotation,
                isSvg: e(this, l),
                structTreeParentId: this._structTreeParentId
              };
              if (H)
                return k.bitmapUrl = J(this, q, We).call(this, !0), k.accessibilityData = this.altTextData, k;
              const {
                decorative: d,
                altText: R
              } = this.altTextData;
              if (!d && R && (k.accessibilityData = {
                type: "Figure",
                alt: R
              }), m === null)
                return k;
              m.stamps || (m.stamps = /* @__PURE__ */ new Map());
              const M = e(this, l) ? (k.rect[2] - k.rect[0]) * (k.rect[3] - k.rect[1]) : null;
              if (!m.stamps.has(e(this, c)))
                m.stamps.set(e(this, c), {
                  area: M,
                  serialized: k
                }), k.bitmap = J(this, q, We).call(this, !1);
              else if (e(this, l)) {
                const B = m.stamps.get(e(this, c));
                M > B.area && (B.area = M, B.serialized.bitmap.close(), B.serialized.bitmap = J(this, q, We).call(this, !1));
              }
              return k;
            }
          };
          y = new WeakMap(), c = new WeakMap(), a = new WeakMap(), I = new WeakMap(), A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakMap(), v = new WeakSet(), Pe = function(H) {
            let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            if (!H) {
              this.remove();
              return;
            }
            rt(this, y, H.bitmap), m || (rt(this, c, H.id), rt(this, l, H.isSvg)), J(this, x, kn).call(this);
          }, C = new WeakSet(), Te = function() {
            rt(this, a, null), this._uiManager.enableWaiting(!1), e(this, g) && this.div.focus();
          }, i = new WeakSet(), He = function() {
            if (e(this, c)) {
              this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(e(this, c)).then((m) => J(this, v, Pe).call(this, m, !0)).finally(() => J(this, C, Te).call(this));
              return;
            }
            if (e(this, I)) {
              const m = e(this, I);
              rt(this, I, null), this._uiManager.enableWaiting(!0), rt(this, a, this._uiManager.imageManager.getFromUrl(m).then((k) => J(this, v, Pe).call(this, k)).finally(() => J(this, C, Te).call(this)));
              return;
            }
            if (e(this, A)) {
              const m = e(this, A);
              rt(this, A, null), this._uiManager.enableWaiting(!0), rt(this, a, this._uiManager.imageManager.getFromFile(m).then((k) => J(this, v, Pe).call(this, k)).finally(() => J(this, C, Te).call(this)));
              return;
            }
            const H = document.createElement("input");
            H.type = "file", H.accept = Q.supportedTypesStr, rt(this, a, new Promise((m) => {
              H.addEventListener("change", async () => {
                if (!H.files || H.files.length === 0)
                  this.remove();
                else {
                  this._uiManager.enableWaiting(!0);
                  const k = await this._uiManager.imageManager.getFromFile(H.files[0]);
                  J(this, v, Pe).call(this, k);
                }
                m();
              }), H.addEventListener("cancel", () => {
                this.remove(), m();
              });
            }).finally(() => J(this, C, Te).call(this))), H.click();
          }, x = new WeakSet(), kn = function() {
            const {
              div: H
            } = this;
            let {
              width: m,
              height: k
            } = e(this, y);
            const [d, R] = this.pageDimensions, M = 0.75;
            if (this.width)
              m = this.width * d, k = this.height * R;
            else if (m > M * d || k > M * R) {
              const pt = Math.min(M * d / m, M * R / k);
              m *= pt, k *= pt;
            }
            const [B, _] = this.parentDimensions;
            this.setDims(m * B / d, k * _ / R), this._uiManager.enableWaiting(!1);
            const Z = rt(this, g, document.createElement("canvas"));
            H.append(Z), H.hidden = !1, J(this, D, Mn).call(this, m, k), J(this, z, Oi).call(this), e(this, u) || (this.parent.addUndoableEditor(this), rt(this, u, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                subtype: this.editorType,
                data: {
                  action: "inserted_image"
                }
              }
            }), this.addAltTextButton();
          }, F = new WeakSet(), Ii = function(H, m) {
            var M;
            const [k, d] = this.parentDimensions;
            this.width = H / k, this.height = m / d, this.setDims(H, m), (M = this._initialOptions) != null && M.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, e(this, o) !== null && clearTimeout(e(this, o)), rt(this, o, setTimeout(() => {
              rt(this, o, null), J(this, D, Mn).call(this, H, m);
            }, 200));
          }, G = new WeakSet(), Li = function(H, m) {
            const {
              width: k,
              height: d
            } = e(this, y);
            let R = k, M = d, B = e(this, y);
            for (; R > 2 * H || M > 2 * m; ) {
              const _ = R, Z = M;
              R > 2 * H && (R = R >= 16384 ? Math.floor(R / 2) - 1 : Math.ceil(R / 2)), M > 2 * m && (M = M >= 16384 ? Math.floor(M / 2) - 1 : Math.ceil(M / 2));
              const pt = new OffscreenCanvas(R, M);
              pt.getContext("2d").drawImage(B, 0, 0, _, Z, 0, 0, R, M), B = pt.transferToImageBitmap();
            }
            return B;
          }, D = new WeakSet(), Mn = function(H, m) {
            H = Math.ceil(H), m = Math.ceil(m);
            const k = e(this, g);
            if (!k || k.width === H && k.height === m)
              return;
            k.width = H, k.height = m;
            const d = e(this, l) ? e(this, y) : J(this, G, Li).call(this, H, m), R = k.getContext("2d");
            R.filter = this._uiManager.hcmFilter, R.drawImage(d, 0, 0, d.width, d.height, 0, 0, H, m);
          }, q = new WeakSet(), We = function(H) {
            if (H) {
              if (e(this, l)) {
                const d = this._uiManager.imageManager.getSvgUrl(e(this, c));
                if (d)
                  return d;
              }
              const m = document.createElement("canvas");
              return {
                width: m.width,
                height: m.height
              } = e(this, y), m.getContext("2d").drawImage(e(this, y), 0, 0), m.toDataURL();
            }
            if (e(this, l)) {
              const [m, k] = this.pageDimensions, d = Math.round(this.width * m * T.PixelsPerInch.PDF_TO_CSS_UNITS), R = Math.round(this.height * k * T.PixelsPerInch.PDF_TO_CSS_UNITS), M = new OffscreenCanvas(d, R);
              return M.getContext("2d").drawImage(e(this, y), 0, 0, e(this, y).width, e(this, y).height, 0, 0, d, R), M.transferToImageBitmap();
            }
            return structuredClone(e(this, y));
          }, z = new WeakSet(), Oi = function() {
            rt(this, s, new ResizeObserver((H) => {
              const m = H[0].contentRect;
              m.width && m.height && J(this, F, Ii).call(this, m.width, m.height);
            })), e(this, s).observe(this.div);
          }, ee(Q, "_type", "stamp");
          let f = Q;
          S.StampEditor = f;
        }
        /******/
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(O) {
        var S = __webpack_module_cache__[O];
        if (S !== void 0)
          return S.exports;
        var t = __webpack_module_cache__[O] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[O].call(t.exports, t, t.exports, __w_pdfjs_require__), t.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var O = __webpack_exports__;
        Object.defineProperty(O, "__esModule", {
          value: !0
        }), Object.defineProperty(O, "AbortException", {
          enumerable: !0,
          get: function() {
            return S.AbortException;
          }
        }), Object.defineProperty(O, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return T.AnnotationEditorLayer;
          }
        }), Object.defineProperty(O, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return S.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(O, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return S.AnnotationEditorType;
          }
        }), Object.defineProperty(O, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return P.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(O, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return f.AnnotationLayer;
          }
        }), Object.defineProperty(O, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return S.AnnotationMode;
          }
        }), Object.defineProperty(O, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return S.CMapCompressionType;
          }
        }), Object.defineProperty(O, "DOMSVGFactory", {
          enumerable: !0,
          get: function() {
            return n.DOMSVGFactory;
          }
        }), Object.defineProperty(O, "FeatureTest", {
          enumerable: !0,
          get: function() {
            return S.FeatureTest;
          }
        }), Object.defineProperty(O, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return y.GlobalWorkerOptions;
          }
        }), Object.defineProperty(O, "ImageKind", {
          enumerable: !0,
          get: function() {
            return S.ImageKind;
          }
        }), Object.defineProperty(O, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return S.InvalidPDFException;
          }
        }), Object.defineProperty(O, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return S.MissingPDFException;
          }
        }), Object.defineProperty(O, "OPS", {
          enumerable: !0,
          get: function() {
            return S.OPS;
          }
        }), Object.defineProperty(O, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return t.PDFDataRangeTransport;
          }
        }), Object.defineProperty(O, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return n.PDFDateString;
          }
        }), Object.defineProperty(O, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return t.PDFWorker;
          }
        }), Object.defineProperty(O, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return S.PasswordResponses;
          }
        }), Object.defineProperty(O, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return S.PermissionFlag;
          }
        }), Object.defineProperty(O, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return n.PixelsPerInch;
          }
        }), Object.defineProperty(O, "PromiseCapability", {
          enumerable: !0,
          get: function() {
            return S.PromiseCapability;
          }
        }), Object.defineProperty(O, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return n.RenderingCancelledException;
          }
        }), Object.defineProperty(O, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return t.SVGGraphics;
          }
        }), Object.defineProperty(O, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return S.UnexpectedResponseException;
          }
        }), Object.defineProperty(O, "Util", {
          enumerable: !0,
          get: function() {
            return S.Util;
          }
        }), Object.defineProperty(O, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return S.VerbosityLevel;
          }
        }), Object.defineProperty(O, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return c.XfaLayer;
          }
        }), Object.defineProperty(O, "build", {
          enumerable: !0,
          get: function() {
            return t.build;
          }
        }), Object.defineProperty(O, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return S.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(O, "getDocument", {
          enumerable: !0,
          get: function() {
            return t.getDocument;
          }
        }), Object.defineProperty(O, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return n.getFilenameFromUrl;
          }
        }), Object.defineProperty(O, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return n.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(O, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return n.getXfaPageViewport;
          }
        }), Object.defineProperty(O, "isDataScheme", {
          enumerable: !0,
          get: function() {
            return n.isDataScheme;
          }
        }), Object.defineProperty(O, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return n.isPdfFile;
          }
        }), Object.defineProperty(O, "loadScript", {
          enumerable: !0,
          get: function() {
            return n.loadScript;
          }
        }), Object.defineProperty(O, "noContextMenu", {
          enumerable: !0,
          get: function() {
            return n.noContextMenu;
          }
        }), Object.defineProperty(O, "normalizeUnicode", {
          enumerable: !0,
          get: function() {
            return S.normalizeUnicode;
          }
        }), Object.defineProperty(O, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return h.renderTextLayer;
          }
        }), Object.defineProperty(O, "setLayerDimensions", {
          enumerable: !0,
          get: function() {
            return n.setLayerDimensions;
          }
        }), Object.defineProperty(O, "shadow", {
          enumerable: !0,
          get: function() {
            return S.shadow;
          }
        }), Object.defineProperty(O, "updateTextLayer", {
          enumerable: !0,
          get: function() {
            return h.updateTextLayer;
          }
        }), Object.defineProperty(O, "version", {
          enumerable: !0,
          get: function() {
            return t.version;
          }
        });
        var S = __w_pdfjs_require__(1), t = __w_pdfjs_require__(124), n = __w_pdfjs_require__(168), h = __w_pdfjs_require__(195), T = __w_pdfjs_require__(196), P = __w_pdfjs_require__(165), f = __w_pdfjs_require__(198), y = __w_pdfjs_require__(176), c = __w_pdfjs_require__(201);
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
var pdfExports = pdf.exports;
function useVuePdfEmbed({
  onError: O,
  onPasswordRequest: S,
  onProgress: t,
  source: n
}) {
  const h = shallowRef(null), T = shallowRef(null);
  return watchEffect(async () => {
    const P = toValue(n);
    if (P) {
      if (Object.prototype.hasOwnProperty.call(P, "_pdfInfo")) {
        h.value = P;
        return;
      }
      try {
        T.value = pdfExports.getDocument(
          P
        ), S && (T.value.onPassword = (f, y) => {
          S({
            callback: f,
            isWrongPassword: y === PasswordResponses.INCORRECT_PASSWORD
          });
        }), t && (T.value.onProgress = t), h.value = await T.value.promise;
      } catch (f) {
        if (h.value = null, O)
          O(f);
        else
          throw f;
      }
    }
  }), onBeforeUnmount(() => {
    var P, f, y;
    (P = T.value) != null && P.onPassword && (T.value.onPassword = null), (f = T.value) != null && f.onProgress && (T.value.onProgress = null), (y = h.value) == null || y.destroy();
  }), {
    doc: h
  };
}
var pdf_viewer = { exports: {} };
(function(O, S) {
  (function(n, h) {
    O.exports = n.pdfjsViewer = h();
  })(globalThis, () => (
    /******/
    (() => {
      var t = [
        ,
        /* 1 */
        /***/
        (P, f, y) => {
          var q, j, z, it, Fi, Et, In, H, Ln, k, Di, R, _i, B, Ni, Z, On, dt, Bi, lt, Ui, bt, ze, Ot, xe, gt, ve, ct, Vi, vt, Fn, Lt, Dn, Ht, $e, Wt, Hi, Xt, _n, Yt, Nn, V, Ce;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFFindController = f.FindState = void 0;
          var c = y(2), a = y(3), I = y(4);
          const A = {
            FOUND: 0,
            NOT_FOUND: 1,
            WRAPPED: 2,
            PENDING: 3
          };
          f.FindState = A;
          const g = 250, s = -50, o = -400, l = {
            "‐": "-",
            "‘": "'",
            "’": "'",
            "‚": "'",
            "‛": "'",
            "“": '"',
            "”": '"',
            "„": '"',
            "‟": '"',
            "¼": "1/4",
            "½": "1/2",
            "¾": "3/4"
          }, u = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
          let v;
          const p = /\p{M}+/gu, C = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu, r = /([^\p{M}])\p{M}*$/u, i = /^\p{M}*([^\p{M}])/u, w = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g, x = /* @__PURE__ */ new Map(), b = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]", F = /* @__PURE__ */ new Map();
          let L = null, G = null;
          function nt(st) {
            const ft = [];
            let Y;
            for (; (Y = w.exec(st)) !== null; ) {
              let {
                index: et
              } = Y;
              for (const E of Y[0]) {
                let $ = x.get(E);
                $ || ($ = E.normalize("NFD").length, x.set(E, $)), ft.push([$, et++]);
              }
            }
            let U;
            if (ft.length === 0 && L)
              U = L;
            else if (ft.length > 0 && G)
              U = G;
            else {
              const et = Object.keys(l).join(""), E = (0, a.getNormalizeWithNFKC)(), ht = `([${et}])|([${E}])|((?:゙|゚)\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|((?:\\p{Ideographic}|[぀-ヿ])\\n)|(\\n)`;
              ft.length === 0 ? U = L = new RegExp(ht + "|(\\u0000)", "gum") : U = G = new RegExp(ht + `|(${b})`, "gum");
            }
            const at = [];
            for (; (Y = p.exec(st)) !== null; )
              at.push([Y[0].length, Y.index]);
            let St = st.normalize("NFD");
            const At = [[0, 0]];
            let Rt = 0, xt = 0, Nt = 0, kt = 0, _t = 0, Bt = !1;
            return St = St.replace(U, (et, E, $, tt, ht, mt, Pt, Ft, Vt, Dt) => {
              var Qt, Gt, zt;
              if (Dt -= kt, E) {
                const Kt = l[E], jt = Kt.length;
                for (let qt = 1; qt < jt; qt++)
                  At.push([Dt - Nt + qt, Nt - qt]);
                return Nt -= jt - 1, Kt;
              }
              if ($) {
                let Kt = F.get($);
                Kt || (Kt = $.normalize("NFKC"), F.set($, Kt));
                const jt = Kt.length;
                for (let qt = 1; qt < jt; qt++)
                  At.push([Dt - Nt + qt, Nt - qt]);
                return Nt -= jt - 1, Kt;
              }
              if (tt)
                return Bt = !0, Dt + _t === ((Qt = at[Rt]) == null ? void 0 : Qt[1]) ? ++Rt : (At.push([Dt - 1 - Nt + 1, Nt - 1]), Nt -= 1, kt += 1), At.push([Dt - Nt + 1, Nt]), kt += 1, _t += 1, tt.charAt(0);
              if (ht) {
                const Kt = ht.endsWith(`
`), jt = Kt ? ht.length - 2 : ht.length;
                Bt = !0;
                let qt = jt;
                Dt + _t === ((Gt = at[Rt]) == null ? void 0 : Gt[1]) && (qt -= at[Rt][0], ++Rt);
                for (let te = 1; te <= qt; te++)
                  At.push([Dt - 1 - Nt + te, Nt - te]);
                return Nt -= qt, kt += qt, Kt ? (Dt += jt - 1, At.push([Dt - Nt + 1, 1 + Nt]), Nt += 1, kt += 1, _t += 1, ht.slice(0, jt)) : ht;
              }
              if (mt) {
                const Kt = mt.length - 2;
                return At.push([Dt - Nt + Kt, 1 + Nt]), Nt += 1, kt += 1, _t += 1, mt.slice(0, -2);
              }
              if (Pt) {
                const Kt = Pt.length - 1;
                return At.push([Dt - Nt + Kt, Nt]), kt += 1, _t += 1, Pt.slice(0, -1);
              }
              if (Ft)
                return At.push([Dt - Nt + 1, Nt - 1]), Nt -= 1, kt += 1, _t += 1, " ";
              if (Dt + _t === ((zt = ft[xt]) == null ? void 0 : zt[1])) {
                const Kt = ft[xt][0] - 1;
                ++xt;
                for (let jt = 1; jt <= Kt; jt++)
                  At.push([Dt - (Nt - jt), Nt - jt]);
                Nt -= Kt, kt += Kt;
              }
              return Vt;
            }), At.push([St.length, Nt]), [St, At, Bt];
          }
          function D(st, ft, Y) {
            if (!st)
              return [ft, Y];
            const U = ft, at = ft + Y - 1;
            let St = (0, c.binarySearchFirstItem)(st, (kt) => kt[0] >= U);
            st[St][0] > U && --St;
            let At = (0, c.binarySearchFirstItem)(st, (kt) => kt[0] >= at, St);
            st[At][0] > at && --At;
            const Rt = U + st[St][1], Nt = at + st[At][1] + 1 - Rt;
            return [Rt, Nt];
          }
          class X {
            constructor({
              linkService: ft,
              eventBus: Y,
              updateMatchesCountOnProgress: U = !0
            }) {
              W(this, it);
              W(this, Et);
              W(this, H);
              W(this, k);
              W(this, R);
              W(this, B);
              W(this, Z);
              W(this, dt);
              W(this, lt);
              W(this, bt);
              W(this, Ot);
              W(this, gt);
              W(this, ct);
              W(this, vt);
              W(this, Lt);
              W(this, Ht);
              W(this, Wt);
              W(this, Xt);
              W(this, Yt);
              W(this, V);
              W(this, q, null);
              W(this, j, !0);
              W(this, z, 0);
              this._linkService = ft, this._eventBus = Y, rt(this, j, U), this.onIsPageVisible = null, J(this, Et, In).call(this), Y._on("find", J(this, it, Fi).bind(this)), Y._on("findbarclose", J(this, Wt, Hi).bind(this));
            }
            get highlightMatches() {
              return this._highlightMatches;
            }
            get pageMatches() {
              return this._pageMatches;
            }
            get pageMatchesLength() {
              return this._pageMatchesLength;
            }
            get selected() {
              return this._selected;
            }
            get state() {
              return e(this, q);
            }
            setDocument(ft) {
              this._pdfDocument && J(this, Et, In).call(this), ft && (this._pdfDocument = ft, this._firstPageCapability.resolve());
            }
            scrollMatchIntoView({
              element: ft = null,
              selectedLeft: Y = 0,
              pageIndex: U = -1,
              matchIndex: at = -1
            }) {
              if (!this._scrollMatches || !ft)
                return;
              if (at === -1 || at !== this._selected.matchIdx)
                return;
              if (U === -1 || U !== this._selected.pageIdx)
                return;
              this._scrollMatches = !1;
              const St = {
                top: s,
                left: Y + o
              };
              (0, c.scrollIntoView)(ft, St, !0);
            }
          }
          q = new WeakMap(), j = new WeakMap(), z = new WeakMap(), it = new WeakSet(), Fi = function(ft) {
            if (!ft)
              return;
            ft.phraseSearch === !1 && (console.error("The `phraseSearch`-parameter was removed, please provide an Array of strings in the `query`-parameter instead."), typeof ft.query == "string" && (ft.query = ft.query.match(/\S+/g)));
            const Y = this._pdfDocument, {
              type: U
            } = ft;
            (e(this, q) === null || J(this, k, Di).call(this, ft)) && (this._dirtyMatch = !0), rt(this, q, ft), U !== "highlightallchange" && J(this, V, Ce).call(this, A.PENDING), this._firstPageCapability.promise.then(() => {
              if (!this._pdfDocument || Y && this._pdfDocument !== Y)
                return;
              J(this, lt, Ui).call(this);
              const at = !this._highlightMatches, St = !!this._findTimeout;
              this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), U ? this._dirtyMatch ? J(this, gt, ve).call(this) : U === "again" ? (J(this, gt, ve).call(this), at && e(this, q).highlightAll && J(this, Ot, xe).call(this)) : U === "highlightallchange" ? (St ? J(this, gt, ve).call(this) : this._highlightMatches = !0, J(this, Ot, xe).call(this)) : J(this, gt, ve).call(this) : this._findTimeout = setTimeout(() => {
                J(this, gt, ve).call(this), this._findTimeout = null;
              }, g);
            });
          }, Et = new WeakSet(), In = function() {
            this._highlightMatches = !1, this._scrollMatches = !1, this._pdfDocument = null, this._pageMatches = [], this._pageMatchesLength = [], rt(this, z, 0), rt(this, q, null), this._selected = {
              pageIdx: -1,
              matchIdx: -1
            }, this._offset = {
              pageIdx: null,
              matchIdx: null,
              wrapped: !1
            }, this._extractTextPromises = [], this._pageContents = [], this._pageDiffs = [], this._hasDiacritics = [], this._matchesCountTotal = 0, this._pagesToSearch = null, this._pendingFindMatches = /* @__PURE__ */ new Set(), this._resumePageIdx = null, this._dirtyMatch = !1, clearTimeout(this._findTimeout), this._findTimeout = null, this._firstPageCapability = new I.PromiseCapability();
          }, H = new WeakSet(), Ln = function() {
            const {
              query: ft
            } = e(this, q);
            return typeof ft == "string" ? (ft !== this._rawQuery && (this._rawQuery = ft, [this._normalizedQuery] = nt(ft)), this._normalizedQuery) : (ft || []).filter((Y) => !!Y).map((Y) => nt(Y)[0]);
          }, k = new WeakSet(), Di = function(ft) {
            var At;
            const Y = ft.query, U = e(this, q).query, at = typeof Y;
            if (at !== typeof U)
              return !0;
            if (at === "string") {
              if (Y !== U)
                return !0;
            } else if (JSON.stringify(Y) !== JSON.stringify(U))
              return !0;
            switch (ft.type) {
              case "again":
                const Rt = this._selected.pageIdx + 1, xt = this._linkService;
                return Rt >= 1 && Rt <= xt.pagesCount && Rt !== xt.page && !(((At = this.onIsPageVisible) == null ? void 0 : At.call(this, Rt)) ?? !0);
              case "highlightallchange":
                return !1;
            }
            return !0;
          }, R = new WeakSet(), _i = function(ft, Y, U) {
            let at = ft.slice(0, Y).match(r);
            if (at) {
              const St = ft.charCodeAt(Y), At = at[1].charCodeAt(0);
              if ((0, a.getCharacterType)(St) === (0, a.getCharacterType)(At))
                return !1;
            }
            if (at = ft.slice(Y + U).match(i), at) {
              const St = ft.charCodeAt(Y + U - 1), At = at[1].charCodeAt(0);
              if ((0, a.getCharacterType)(St) === (0, a.getCharacterType)(At))
                return !1;
            }
            return !0;
          }, B = new WeakSet(), Ni = function(ft, Y, U, at) {
            const St = this._pageMatches[U] = [], At = this._pageMatchesLength[U] = [];
            if (!ft)
              return;
            const Rt = this._pageDiffs[U];
            let xt;
            for (; (xt = ft.exec(at)) !== null; ) {
              if (Y && !J(this, R, _i).call(this, at, xt.index, xt[0].length))
                continue;
              const [Nt, kt] = D(Rt, xt.index, xt[0].length);
              kt && (St.push(Nt), At.push(kt));
            }
          }, Z = new WeakSet(), On = function(ft, Y) {
            const {
              matchDiacritics: U
            } = e(this, q);
            let at = !1;
            ft = ft.replaceAll(C, (At, Rt, xt, Nt, kt, _t) => Rt ? `[ ]*\\${Rt}[ ]*` : xt ? `[ ]*${xt}[ ]*` : Nt ? "[ ]+" : U ? kt || _t : kt ? u.has(kt.charCodeAt(0)) ? kt : "" : Y ? (at = !0, `${_t}\\p{M}*`) : _t);
            const St = "[ ]*";
            return ft.endsWith(St) && (ft = ft.slice(0, ft.length - St.length)), U && Y && (v || (v = String.fromCharCode(...u)), at = !0, ft = `${ft}(?=[${v}]|[^\\p{M}]|$)`), [at, ft];
          }, dt = new WeakSet(), Bi = function(ft) {
            let Y = e(this, H, Ln);
            if (Y.length === 0)
              return;
            const {
              caseSensitive: U,
              entireWord: at
            } = e(this, q), St = this._pageContents[ft], At = this._hasDiacritics[ft];
            let Rt = !1;
            typeof Y == "string" ? [Rt, Y] = J(this, Z, On).call(this, Y, At) : Y = Y.sort().reverse().map((kt) => {
              const [_t, Bt] = J(this, Z, On).call(this, kt, At);
              return Rt || (Rt = _t), `(${Bt})`;
            }).join("|");
            const xt = `g${Rt ? "u" : ""}${U ? "" : "i"}`;
            Y = Y ? new RegExp(Y, xt) : null, J(this, B, Ni).call(this, Y, at, ft, St), e(this, q).highlightAll && J(this, bt, ze).call(this, ft), this._resumePageIdx === ft && (this._resumePageIdx = null, J(this, vt, Fn).call(this));
            const Nt = this._pageMatches[ft].length;
            this._matchesCountTotal += Nt, e(this, j) ? Nt > 0 && J(this, Yt, Nn).call(this) : ++ue(this, z)._ === this._linkService.pagesCount && J(this, Yt, Nn).call(this);
          }, lt = new WeakSet(), Ui = function() {
            if (this._extractTextPromises.length > 0)
              return;
            let ft = Promise.resolve();
            const Y = {
              disableNormalization: !0
            };
            for (let U = 0, at = this._linkService.pagesCount; U < at; U++) {
              const St = new I.PromiseCapability();
              this._extractTextPromises[U] = St.promise, ft = ft.then(() => this._pdfDocument.getPage(U + 1).then((At) => At.getTextContent(Y)).then((At) => {
                const Rt = [];
                for (const xt of At.items)
                  Rt.push(xt.str), xt.hasEOL && Rt.push(`
`);
                [this._pageContents[U], this._pageDiffs[U], this._hasDiacritics[U]] = nt(Rt.join("")), St.resolve();
              }, (At) => {
                console.error(`Unable to get text content for page ${U + 1}`, At), this._pageContents[U] = "", this._pageDiffs[U] = null, this._hasDiacritics[U] = !1, St.resolve();
              }));
            }
          }, bt = new WeakSet(), ze = function(ft) {
            this._scrollMatches && this._selected.pageIdx === ft && (this._linkService.page = ft + 1), this._eventBus.dispatch("updatetextlayermatches", {
              source: this,
              pageIndex: ft
            });
          }, Ot = new WeakSet(), xe = function() {
            this._eventBus.dispatch("updatetextlayermatches", {
              source: this,
              pageIndex: -1
            });
          }, gt = new WeakSet(), ve = function() {
            const ft = e(this, q).findPrevious, Y = this._linkService.page - 1, U = this._linkService.pagesCount;
            if (this._highlightMatches = !0, this._dirtyMatch) {
              this._dirtyMatch = !1, this._selected.pageIdx = this._selected.matchIdx = -1, this._offset.pageIdx = Y, this._offset.matchIdx = null, this._offset.wrapped = !1, this._resumePageIdx = null, this._pageMatches.length = 0, this._pageMatchesLength.length = 0, rt(this, z, 0), this._matchesCountTotal = 0, J(this, Ot, xe).call(this);
              for (let At = 0; At < U; At++)
                this._pendingFindMatches.has(At) || (this._pendingFindMatches.add(At), this._extractTextPromises[At].then(() => {
                  this._pendingFindMatches.delete(At), J(this, dt, Bi).call(this, At);
                }));
            }
            if (e(this, H, Ln).length === 0) {
              J(this, V, Ce).call(this, A.FOUND);
              return;
            }
            if (this._resumePageIdx)
              return;
            const St = this._offset;
            if (this._pagesToSearch = U, St.matchIdx !== null) {
              const At = this._pageMatches[St.pageIdx].length;
              if (!ft && St.matchIdx + 1 < At || ft && St.matchIdx > 0) {
                St.matchIdx = ft ? St.matchIdx - 1 : St.matchIdx + 1, J(this, Ht, $e).call(this, !0);
                return;
              }
              J(this, Lt, Dn).call(this, ft);
            }
            J(this, vt, Fn).call(this);
          }, ct = new WeakSet(), Vi = function(ft) {
            const Y = this._offset, U = ft.length, at = e(this, q).findPrevious;
            return U ? (Y.matchIdx = at ? U - 1 : 0, J(this, Ht, $e).call(this, !0), !0) : (J(this, Lt, Dn).call(this, at), Y.wrapped && (Y.matchIdx = null, this._pagesToSearch < 0) ? (J(this, Ht, $e).call(this, !1), !0) : !1);
          }, vt = new WeakSet(), Fn = function() {
            this._resumePageIdx !== null && console.error("There can only be one pending page.");
            let ft = null;
            do {
              const Y = this._offset.pageIdx;
              if (ft = this._pageMatches[Y], !ft) {
                this._resumePageIdx = Y;
                break;
              }
            } while (!J(this, ct, Vi).call(this, ft));
          }, Lt = new WeakSet(), Dn = function(ft) {
            const Y = this._offset, U = this._linkService.pagesCount;
            Y.pageIdx = ft ? Y.pageIdx - 1 : Y.pageIdx + 1, Y.matchIdx = null, this._pagesToSearch--, (Y.pageIdx >= U || Y.pageIdx < 0) && (Y.pageIdx = ft ? U - 1 : 0, Y.wrapped = !0);
          }, Ht = new WeakSet(), $e = function(ft = !1) {
            let Y = A.NOT_FOUND;
            const U = this._offset.wrapped;
            if (this._offset.wrapped = !1, ft) {
              const at = this._selected.pageIdx;
              this._selected.pageIdx = this._offset.pageIdx, this._selected.matchIdx = this._offset.matchIdx, Y = U ? A.WRAPPED : A.FOUND, at !== -1 && at !== this._selected.pageIdx && J(this, bt, ze).call(this, at);
            }
            J(this, V, Ce).call(this, Y, e(this, q).findPrevious), this._selected.pageIdx !== -1 && (this._scrollMatches = !0, J(this, bt, ze).call(this, this._selected.pageIdx));
          }, Wt = new WeakSet(), Hi = function(ft) {
            const Y = this._pdfDocument;
            this._firstPageCapability.promise.then(() => {
              !this._pdfDocument || Y && this._pdfDocument !== Y || (this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), this._resumePageIdx && (this._resumePageIdx = null, this._dirtyMatch = !0), J(this, V, Ce).call(this, A.FOUND), this._highlightMatches = !1, J(this, Ot, xe).call(this));
            });
          }, Xt = new WeakSet(), _n = function() {
            var St;
            const {
              pageIdx: ft,
              matchIdx: Y
            } = this._selected;
            let U = 0, at = this._matchesCountTotal;
            if (Y !== -1) {
              for (let At = 0; At < ft; At++)
                U += ((St = this._pageMatches[At]) == null ? void 0 : St.length) || 0;
              U += Y + 1;
            }
            return (U < 1 || U > at) && (U = at = 0), {
              current: U,
              total: at
            };
          }, Yt = new WeakSet(), Nn = function() {
            this._eventBus.dispatch("updatefindmatchescount", {
              source: this,
              matchesCount: J(this, Xt, _n).call(this)
            });
          }, V = new WeakSet(), Ce = function(ft, Y = !1) {
            var U;
            !e(this, j) && (e(this, z) !== this._linkService.pagesCount || ft === A.PENDING) || this._eventBus.dispatch("updatefindcontrolstate", {
              source: this,
              state: ft,
              previous: Y,
              matchesCount: J(this, Xt, _n).call(this),
              rawQuery: ((U = e(this, q)) == null ? void 0 : U.query) ?? null
            });
          }, f.PDFFindController = X;
        },
        /* 2 */
        /***/
        (P, f) => {
          var yt, bt, It, Ot, Mt;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.animationStarted = f.VERTICAL_PADDING = f.UNKNOWN_SCALE = f.TextLayerMode = f.SpreadMode = f.SidebarView = f.ScrollMode = f.SCROLLBAR_PADDING = f.RenderingStates = f.ProgressBar = f.PresentationModeState = f.OutputScale = f.MIN_SCALE = f.MAX_SCALE = f.MAX_AUTO_SCALE = f.DEFAULT_SCALE_VALUE = f.DEFAULT_SCALE_DELTA = f.DEFAULT_SCALE = f.CursorTool = f.AutoPrintRegExp = void 0, f.apiPageLayoutToViewerModes = pt, f.apiPageModeToSidebarView = dt, f.approximateFraction = q, f.backtrackBeforeAllVisibleElements = it, f.binarySearchFirstItem = X, f.docStyle = void 0, f.getActiveOrFocusedElement = Z, f.getPageSizeInches = z, f.getVisibleElements = Q, f.isPortraitOrientation = d, f.isValidRotation = H, f.isValidScrollMode = m, f.isValidSpreadMode = k, f.normalizeWheelEventDelta = Ct, f.normalizeWheelEventDirection = Et, f.parseQueryString = G, f.removeNullCharacters = D, f.roundToDivide = j, f.scrollIntoView = F, f.toggleCheckedBtn = Tt, f.toggleExpandedBtn = lt, f.watchScroll = L;
          const y = "auto";
          f.DEFAULT_SCALE_VALUE = y;
          const c = 1;
          f.DEFAULT_SCALE = c;
          const a = 1.1;
          f.DEFAULT_SCALE_DELTA = a;
          const I = 0.1;
          f.MIN_SCALE = I;
          const A = 10;
          f.MAX_SCALE = A;
          const g = 0;
          f.UNKNOWN_SCALE = g;
          const s = 1.25;
          f.MAX_AUTO_SCALE = s;
          const o = 40;
          f.SCROLLBAR_PADDING = o;
          const l = 5;
          f.VERTICAL_PADDING = l;
          const u = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
          };
          f.RenderingStates = u;
          const v = {
            UNKNOWN: 0,
            NORMAL: 1,
            CHANGING: 2,
            FULLSCREEN: 3
          };
          f.PresentationModeState = v;
          const p = {
            UNKNOWN: -1,
            NONE: 0,
            THUMBS: 1,
            OUTLINE: 2,
            ATTACHMENTS: 3,
            LAYERS: 4
          };
          f.SidebarView = p;
          const C = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_PERMISSIONS: 2
          };
          f.TextLayerMode = C;
          const r = {
            UNKNOWN: -1,
            VERTICAL: 0,
            HORIZONTAL: 1,
            WRAPPED: 2,
            PAGE: 3
          };
          f.ScrollMode = r;
          const i = {
            UNKNOWN: -1,
            NONE: 0,
            ODD: 1,
            EVEN: 2
          };
          f.SpreadMode = i;
          const w = {
            SELECT: 0,
            HAND: 1,
            ZOOM: 2
          };
          f.CursorTool = w;
          const x = /\bprint\s*\(/;
          f.AutoPrintRegExp = x;
          class b {
            constructor() {
              const ut = window.devicePixelRatio || 1;
              this.sx = ut, this.sy = ut;
            }
            get scaled() {
              return this.sx !== 1 || this.sy !== 1;
            }
          }
          f.OutputScale = b;
          function F(gt, ut, ct = !1) {
            let ot = gt.offsetParent;
            if (!ot) {
              console.error("offsetParent is not set -- cannot scroll");
              return;
            }
            let vt = gt.offsetTop + gt.clientTop, wt = gt.offsetLeft + gt.clientLeft;
            for (; ot.clientHeight === ot.scrollHeight && ot.clientWidth === ot.scrollWidth || ct && (ot.classList.contains("markedContent") || getComputedStyle(ot).overflow === "hidden"); )
              if (vt += ot.offsetTop, wt += ot.offsetLeft, ot = ot.offsetParent, !ot)
                return;
            ut && (ut.top !== void 0 && (vt += ut.top), ut.left !== void 0 && (wt += ut.left, ot.scrollLeft = wt)), ot.scrollTop = vt;
          }
          function L(gt, ut) {
            const ct = function(wt) {
              vt || (vt = window.requestAnimationFrame(function() {
                vt = null;
                const Ut = gt.scrollLeft, Ht = ot.lastX;
                Ut !== Ht && (ot.right = Ut > Ht), ot.lastX = Ut;
                const $t = gt.scrollTop, Wt = ot.lastY;
                $t !== Wt && (ot.down = $t > Wt), ot.lastY = $t, ut(ot);
              }));
            }, ot = {
              right: !0,
              down: !0,
              lastX: gt.scrollLeft,
              lastY: gt.scrollTop,
              _eventHandler: ct
            };
            let vt = null;
            return gt.addEventListener("scroll", ct, !0), ot;
          }
          function G(gt) {
            const ut = /* @__PURE__ */ new Map();
            for (const [ct, ot] of new URLSearchParams(gt))
              ut.set(ct.toLowerCase(), ot);
            return ut;
          }
          const nt = /[\x01-\x1F]/g;
          function D(gt, ut = !1) {
            return typeof gt != "string" ? (console.error("The argument must be a string."), gt) : (ut && (gt = gt.replaceAll(nt, " ")), gt.replaceAll("\0", ""));
          }
          function X(gt, ut, ct = 0) {
            let ot = ct, vt = gt.length - 1;
            if (vt < 0 || !ut(gt[vt]))
              return gt.length;
            if (ut(gt[ot]))
              return ot;
            for (; ot < vt; ) {
              const wt = ot + vt >> 1, Lt = gt[wt];
              ut(Lt) ? vt = wt : ot = wt + 1;
            }
            return ot;
          }
          function q(gt) {
            if (Math.floor(gt) === gt)
              return [gt, 1];
            const ut = 1 / gt, ct = 8;
            if (ut > ct)
              return [1, ct];
            if (Math.floor(ut) === ut)
              return [1, ut];
            const ot = gt > 1 ? ut : gt;
            let vt = 0, wt = 1, Lt = 1, Ut = 1;
            for (; ; ) {
              const $t = vt + Lt, Wt = wt + Ut;
              if (Wt > ct)
                break;
              ot <= $t / Wt ? (Lt = $t, Ut = Wt) : (vt = $t, wt = Wt);
            }
            let Ht;
            return ot - vt / wt < Lt / Ut - ot ? Ht = ot === gt ? [vt, wt] : [wt, vt] : Ht = ot === gt ? [Lt, Ut] : [Ut, Lt], Ht;
          }
          function j(gt, ut) {
            const ct = gt % ut;
            return ct === 0 ? gt : Math.round(gt - ct + ut);
          }
          function z({
            view: gt,
            userUnit: ut,
            rotate: ct
          }) {
            const [ot, vt, wt, Lt] = gt, Ut = ct % 180 !== 0, Ht = (wt - ot) / 72 * ut, $t = (Lt - vt) / 72 * ut;
            return {
              width: Ut ? $t : Ht,
              height: Ut ? Ht : $t
            };
          }
          function it(gt, ut, ct) {
            if (gt < 2)
              return gt;
            let ot = ut[gt].div, vt = ot.offsetTop + ot.clientTop;
            vt >= ct && (ot = ut[gt - 1].div, vt = ot.offsetTop + ot.clientTop);
            for (let wt = gt - 2; wt >= 0 && (ot = ut[wt].div, !(ot.offsetTop + ot.clientTop + ot.clientHeight <= vt)); --wt)
              gt = wt;
            return gt;
          }
          function Q({
            scrollEl: gt,
            views: ut,
            sortByVisibility: ct = !1,
            horizontal: ot = !1,
            rtl: vt = !1
          }) {
            const wt = gt.scrollTop, Lt = wt + gt.clientHeight, Ut = gt.scrollLeft, Ht = Ut + gt.clientWidth;
            function $t(st) {
              const ft = st.div;
              return ft.offsetTop + ft.clientTop + ft.clientHeight > wt;
            }
            function Wt(st) {
              const ft = st.div, Y = ft.offsetLeft + ft.clientLeft, U = Y + ft.clientWidth;
              return vt ? Y < Ht : U > Ut;
            }
            const Jt = [], Xt = /* @__PURE__ */ new Set(), Zt = ut.length;
            let Yt = X(ut, ot ? Wt : $t);
            Yt > 0 && Yt < Zt && !ot && (Yt = it(Yt, ut, wt));
            let N = ot ? Ht : -1;
            for (let st = Yt; st < Zt; st++) {
              const ft = ut[st], Y = ft.div, U = Y.offsetLeft + Y.clientLeft, at = Y.offsetTop + Y.clientTop, St = Y.clientWidth, At = Y.clientHeight, Rt = U + St, xt = at + At;
              if (N === -1)
                xt >= Lt && (N = xt);
              else if ((ot ? U : at) > N)
                break;
              if (xt <= wt || at >= Lt || Rt <= Ut || U >= Ht)
                continue;
              const Nt = Math.max(0, wt - at) + Math.max(0, xt - Lt), kt = Math.max(0, Ut - U) + Math.max(0, Rt - Ht), _t = (At - Nt) / At, Bt = (St - kt) / St, et = _t * Bt * 100 | 0;
              Jt.push({
                id: ft.id,
                x: U,
                y: at,
                view: ft,
                percent: et,
                widthPercent: Bt * 100 | 0
              }), Xt.add(ft.id);
            }
            const V = Jt[0], K = Jt.at(-1);
            return ct && Jt.sort(function(st, ft) {
              const Y = st.percent - ft.percent;
              return Math.abs(Y) > 1e-3 ? -Y : st.id - ft.id;
            }), {
              first: V,
              last: K,
              views: Jt,
              ids: Xt
            };
          }
          function Et(gt) {
            let ut = Math.hypot(gt.deltaX, gt.deltaY);
            const ct = Math.atan2(gt.deltaY, gt.deltaX);
            return -0.25 * Math.PI < ct && ct < 0.75 * Math.PI && (ut = -ut), ut;
          }
          function Ct(gt) {
            const ut = gt.deltaMode;
            let ct = Et(gt);
            const ot = 30, vt = 30;
            return ut === WheelEvent.DOM_DELTA_PIXEL ? ct /= ot * vt : ut === WheelEvent.DOM_DELTA_LINE && (ct /= vt), ct;
          }
          function H(gt) {
            return Number.isInteger(gt) && gt % 90 === 0;
          }
          function m(gt) {
            return Number.isInteger(gt) && Object.values(r).includes(gt) && gt !== r.UNKNOWN;
          }
          function k(gt) {
            return Number.isInteger(gt) && Object.values(i).includes(gt) && gt !== i.UNKNOWN;
          }
          function d(gt) {
            return gt.width <= gt.height;
          }
          const R = new Promise(function(gt) {
            window.requestAnimationFrame(gt);
          });
          f.animationStarted = R;
          const M = document.documentElement.style;
          f.docStyle = M;
          function B(gt, ut, ct) {
            return Math.min(Math.max(gt, ut), ct);
          }
          class _ {
            constructor(ut) {
              W(this, yt, null);
              W(this, bt, null);
              W(this, It, 0);
              W(this, Ot, null);
              W(this, Mt, !0);
              rt(this, yt, ut.classList), rt(this, Ot, ut.style);
            }
            get percent() {
              return e(this, It);
            }
            set percent(ut) {
              if (rt(this, It, B(ut, 0, 100)), isNaN(ut)) {
                e(this, yt).add("indeterminate");
                return;
              }
              e(this, yt).remove("indeterminate"), e(this, Ot).setProperty("--progressBar-percent", `${e(this, It)}%`);
            }
            setWidth(ut) {
              if (!ut)
                return;
              const ot = ut.parentNode.offsetWidth - ut.offsetWidth;
              ot > 0 && e(this, Ot).setProperty("--progressBar-end-offset", `${ot}px`);
            }
            setDisableAutoFetch(ut = 5e3) {
              isNaN(e(this, It)) || (e(this, bt) && clearTimeout(e(this, bt)), this.show(), rt(this, bt, setTimeout(() => {
                rt(this, bt, null), this.hide();
              }, ut)));
            }
            hide() {
              e(this, Mt) && (rt(this, Mt, !1), e(this, yt).add("hidden"));
            }
            show() {
              e(this, Mt) || (rt(this, Mt, !0), e(this, yt).remove("hidden"));
            }
          }
          yt = new WeakMap(), bt = new WeakMap(), It = new WeakMap(), Ot = new WeakMap(), Mt = new WeakMap(), f.ProgressBar = _;
          function Z() {
            let gt = document, ut = gt.activeElement || gt.querySelector(":focus");
            for (; ut != null && ut.shadowRoot; )
              gt = ut.shadowRoot, ut = gt.activeElement || gt.querySelector(":focus");
            return ut;
          }
          function pt(gt) {
            let ut = r.VERTICAL, ct = i.NONE;
            switch (gt) {
              case "SinglePage":
                ut = r.PAGE;
                break;
              case "OneColumn":
                break;
              case "TwoPageLeft":
                ut = r.PAGE;
              case "TwoColumnLeft":
                ct = i.ODD;
                break;
              case "TwoPageRight":
                ut = r.PAGE;
              case "TwoColumnRight":
                ct = i.EVEN;
                break;
            }
            return {
              scrollMode: ut,
              spreadMode: ct
            };
          }
          function dt(gt) {
            switch (gt) {
              case "UseNone":
                return p.NONE;
              case "UseThumbs":
                return p.THUMBS;
              case "UseOutlines":
                return p.OUTLINE;
              case "UseAttachments":
                return p.ATTACHMENTS;
              case "UseOC":
                return p.LAYERS;
            }
            return p.NONE;
          }
          function Tt(gt, ut, ct = null) {
            gt.classList.toggle("toggled", ut), gt.setAttribute("aria-checked", ut), ct == null || ct.classList.toggle("hidden", !ut);
          }
          function lt(gt, ut, ct = null) {
            gt.classList.toggle("toggled", ut), gt.setAttribute("aria-expanded", ut), ct == null || ct.classList.toggle("hidden", !ut);
          }
        },
        /* 3 */
        /***/
        (P, f) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.CharacterType = void 0, f.getCharacterType = p, f.getNormalizeWithNFKC = r;
          const y = {
            SPACE: 0,
            ALPHA_LETTER: 1,
            PUNCT: 2,
            HAN_LETTER: 3,
            KATAKANA_LETTER: 4,
            HIRAGANA_LETTER: 5,
            HALFWIDTH_KATAKANA_LETTER: 6,
            THAI_LETTER: 7
          };
          f.CharacterType = y;
          function c(i) {
            return i < 11904;
          }
          function a(i) {
            return (i & 65408) === 0;
          }
          function I(i) {
            return i >= 97 && i <= 122 || i >= 65 && i <= 90;
          }
          function A(i) {
            return i >= 48 && i <= 57;
          }
          function g(i) {
            return i === 32 || i === 9 || i === 13 || i === 10;
          }
          function s(i) {
            return i >= 13312 && i <= 40959 || i >= 63744 && i <= 64255;
          }
          function o(i) {
            return i >= 12448 && i <= 12543;
          }
          function l(i) {
            return i >= 12352 && i <= 12447;
          }
          function u(i) {
            return i >= 65376 && i <= 65439;
          }
          function v(i) {
            return (i & 65408) === 3584;
          }
          function p(i) {
            return c(i) ? a(i) ? g(i) ? y.SPACE : I(i) || A(i) || i === 95 ? y.ALPHA_LETTER : y.PUNCT : v(i) ? y.THAI_LETTER : i === 160 ? y.SPACE : y.ALPHA_LETTER : s(i) ? y.HAN_LETTER : o(i) ? y.KATAKANA_LETTER : l(i) ? y.HIRAGANA_LETTER : u(i) ? y.HALFWIDTH_KATAKANA_LETTER : y.ALPHA_LETTER;
          }
          let C;
          function r() {
            return C || (C = " ¨ª¯²-µ¸-º¼-¾Ĳ-ĳĿ-ŀŉſǄ-ǌǱ-ǳʰ-ʸ˘-˝ˠ-ˤʹͺ;΄-΅·ϐ-ϖϰ-ϲϴ-ϵϹևٵ-ٸक़-य़ড়-ঢ়য়ਲ਼ਸ਼ਖ਼-ਜ਼ਫ਼ଡ଼-ଢ଼ำຳໜ-ໝ༌གྷཌྷདྷབྷཛྷཀྵჼᴬ-ᴮᴰ-ᴺᴼ-ᵍᵏ-ᵪᵸᶛ-ᶿẚ-ẛάέήίόύώΆ᾽-῁ΈΉ῍-῏ΐΊ῝-῟ΰΎ῭-`ΌΏ´-῾ - ‑‗․-… ″-‴‶-‷‼‾⁇-⁉⁗ ⁰-ⁱ⁴-₎ₐ-ₜ₨℀-℃℅-ℇ℉-ℓℕ-№ℙ-ℝ℠-™ℤΩℨK-ℭℯ-ℱℳ-ℹ℻-⅀ⅅ-ⅉ⅐-ⅿ↉∬-∭∯-∰〈-〉①-⓪⨌⩴-⩶⫝̸ⱼ-ⱽⵯ⺟⻳⼀-⿕　〶〸-〺゛-゜ゟヿㄱ-ㆎ㆒-㆟㈀-㈞㈠-㉇㉐-㉾㊀-㏿ꚜ-ꚝꝰꟲ-ꟴꟸ-ꟹꭜ-ꭟꭩ豈-嗀塚晴凞-羽蘒諸逸-都飯-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷼︐-︙︰-﹄﹇-﹒﹔-﹦﹨-﹫ﹰ-ﹲﹴﹶ-ﻼ！-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ￠-￦"), C;
          }
        },
        /* 4 */
        /***/
        (P) => {
          P.exports = globalThis.pdfjsLib;
        },
        /* 5 */
        /***/
        (P, f, y) => {
          var o, l, Bn, v, Wi;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.SimpleLinkService = f.PDFLinkService = f.LinkTarget = void 0;
          var c = y(2);
          const a = "noopener noreferrer nofollow", I = {
            NONE: 0,
            SELF: 1,
            BLANK: 2,
            PARENT: 3,
            TOP: 4
          };
          f.LinkTarget = I;
          function A(r, {
            url: i,
            target: w,
            rel: x,
            enabled: b = !0
          } = {}) {
            if (!i || typeof i != "string")
              throw new Error('A valid "url" parameter must provided.');
            b ? r.href = r.title = i : (r.href = "", r.title = `Disabled: ${i}`, r.onclick = () => !1);
            let F = "";
            switch (w) {
              case I.NONE:
                break;
              case I.SELF:
                F = "_self";
                break;
              case I.BLANK:
                F = "_blank";
                break;
              case I.PARENT:
                F = "_parent";
                break;
              case I.TOP:
                F = "_top";
                break;
            }
            r.target = F, r.rel = typeof x == "string" ? x : a;
          }
          const C = class C {
            constructor({
              eventBus: i,
              externalLinkTarget: w = null,
              externalLinkRel: x = null,
              ignoreDestinationZoom: b = !1
            } = {}) {
              W(this, l);
              W(this, o, /* @__PURE__ */ new Map());
              this.eventBus = i, this.externalLinkTarget = w, this.externalLinkRel = x, this.externalLinkEnabled = !0, this._ignoreDestinationZoom = b, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null;
            }
            setDocument(i, w = null) {
              this.baseUrl = w, this.pdfDocument = i, e(this, o).clear();
            }
            setViewer(i) {
              this.pdfViewer = i;
            }
            setHistory(i) {
              this.pdfHistory = i;
            }
            get pagesCount() {
              return this.pdfDocument ? this.pdfDocument.numPages : 0;
            }
            get page() {
              return this.pdfViewer.currentPageNumber;
            }
            set page(i) {
              this.pdfViewer.currentPageNumber = i;
            }
            get rotation() {
              return this.pdfViewer.pagesRotation;
            }
            set rotation(i) {
              this.pdfViewer.pagesRotation = i;
            }
            get isInPresentationMode() {
              return this.pdfViewer.isInPresentationMode;
            }
            async goToDestination(i) {
              if (!this.pdfDocument)
                return;
              let w, x;
              if (typeof i == "string" ? (w = i, x = await this.pdfDocument.getDestination(i)) : (w = null, x = await i), !Array.isArray(x)) {
                console.error(`PDFLinkService.goToDestination: "${x}" is not a valid destination array, for dest="${i}".`);
                return;
              }
              J(this, l, Bn).call(this, i, w, x);
            }
            goToPage(i) {
              if (!this.pdfDocument)
                return;
              const w = typeof i == "string" && this.pdfViewer.pageLabelToPageNumber(i) || i | 0;
              if (!(Number.isInteger(w) && w > 0 && w <= this.pagesCount)) {
                console.error(`PDFLinkService.goToPage: "${i}" is not a valid page.`);
                return;
              }
              this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.pushPage(w)), this.pdfViewer.scrollPageIntoView({
                pageNumber: w
              });
            }
            addLinkAttributes(i, w, x = !1) {
              A(i, {
                url: w,
                target: x ? I.BLANK : this.externalLinkTarget,
                rel: this.externalLinkRel,
                enabled: this.externalLinkEnabled
              });
            }
            getDestinationHash(i) {
              if (typeof i == "string") {
                if (i.length > 0)
                  return this.getAnchorUrl("#" + escape(i));
              } else if (Array.isArray(i)) {
                const w = JSON.stringify(i);
                if (w.length > 0)
                  return this.getAnchorUrl("#" + escape(w));
              }
              return this.getAnchorUrl("");
            }
            getAnchorUrl(i) {
              return this.baseUrl ? this.baseUrl + i : i;
            }
            setHash(i) {
              var b;
              if (!this.pdfDocument)
                return;
              let w, x;
              if (i.includes("=")) {
                const F = (0, c.parseQueryString)(i);
                if (F.has("search")) {
                  const L = F.get("search").replaceAll('"', ""), G = F.get("phrase") === "true";
                  this.eventBus.dispatch("findfromurlhash", {
                    source: this,
                    query: G ? L : L.match(/\S+/g)
                  });
                }
                if (F.has("page") && (w = F.get("page") | 0 || 1), F.has("zoom")) {
                  const L = F.get("zoom").split(","), G = L[0], nt = parseFloat(G);
                  G.includes("Fit") ? G === "Fit" || G === "FitB" ? x = [null, {
                    name: G
                  }] : G === "FitH" || G === "FitBH" || G === "FitV" || G === "FitBV" ? x = [null, {
                    name: G
                  }, L.length > 1 ? L[1] | 0 : null] : G === "FitR" ? L.length !== 5 ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : x = [null, {
                    name: G
                  }, L[1] | 0, L[2] | 0, L[3] | 0, L[4] | 0] : console.error(`PDFLinkService.setHash: "${G}" is not a valid zoom value.`) : x = [null, {
                    name: "XYZ"
                  }, L.length > 1 ? L[1] | 0 : null, L.length > 2 ? L[2] | 0 : null, nt ? nt / 100 : G];
                }
                x ? this.pdfViewer.scrollPageIntoView({
                  pageNumber: w || this.page,
                  destArray: x,
                  allowNegativeOffset: !0
                }) : w && (this.page = w), F.has("pagemode") && this.eventBus.dispatch("pagemode", {
                  source: this,
                  mode: F.get("pagemode")
                }), F.has("nameddest") && this.goToDestination(F.get("nameddest"));
              } else {
                x = unescape(i);
                try {
                  x = JSON.parse(x), Array.isArray(x) || (x = x.toString());
                } catch {
                }
                if (typeof x == "string" || J(b = C, v, Wi).call(b, x)) {
                  this.goToDestination(x);
                  return;
                }
                console.error(`PDFLinkService.setHash: "${unescape(i)}" is not a valid destination.`);
              }
            }
            executeNamedAction(i) {
              var w, x;
              switch (i) {
                case "GoBack":
                  (w = this.pdfHistory) == null || w.back();
                  break;
                case "GoForward":
                  (x = this.pdfHistory) == null || x.forward();
                  break;
                case "NextPage":
                  this.pdfViewer.nextPage();
                  break;
                case "PrevPage":
                  this.pdfViewer.previousPage();
                  break;
                case "LastPage":
                  this.page = this.pagesCount;
                  break;
                case "FirstPage":
                  this.page = 1;
                  break;
              }
              this.eventBus.dispatch("namedaction", {
                source: this,
                action: i
              });
            }
            async executeSetOCGState(i) {
              const w = this.pdfDocument, x = await this.pdfViewer.optionalContentConfigPromise;
              if (w !== this.pdfDocument)
                return;
              let b;
              for (const F of i.state) {
                switch (F) {
                  case "ON":
                  case "OFF":
                  case "Toggle":
                    b = F;
                    continue;
                }
                switch (b) {
                  case "ON":
                    x.setVisibility(F, !0);
                    break;
                  case "OFF":
                    x.setVisibility(F, !1);
                    break;
                  case "Toggle":
                    const L = x.getGroup(F);
                    L && x.setVisibility(F, !L.visible);
                    break;
                }
              }
              this.pdfViewer.optionalContentConfigPromise = Promise.resolve(x);
            }
            cachePageRef(i, w) {
              if (!w)
                return;
              const x = w.gen === 0 ? `${w.num}R` : `${w.num}R${w.gen}`;
              e(this, o).set(x, i);
            }
            _cachedPageNumber(i) {
              if (!i)
                return null;
              const w = i.gen === 0 ? `${i.num}R` : `${i.num}R${i.gen}`;
              return e(this, o).get(w) || null;
            }
          };
          o = new WeakMap(), l = new WeakSet(), Bn = function(i, w = null, x) {
            const b = x[0];
            let F;
            if (typeof b == "object" && b !== null) {
              if (F = this._cachedPageNumber(b), !F) {
                this.pdfDocument.getPageIndex(b).then((L) => {
                  this.cachePageRef(L + 1, b), J(this, l, Bn).call(this, i, w, x);
                }).catch(() => {
                  console.error(`PDFLinkService.#goToDestinationHelper: "${b}" is not a valid page reference, for dest="${i}".`);
                });
                return;
              }
            } else if (Number.isInteger(b))
              F = b + 1;
            else {
              console.error(`PDFLinkService.#goToDestinationHelper: "${b}" is not a valid destination reference, for dest="${i}".`);
              return;
            }
            if (!F || F < 1 || F > this.pagesCount) {
              console.error(`PDFLinkService.#goToDestinationHelper: "${F}" is not a valid page number, for dest="${i}".`);
              return;
            }
            this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.push({
              namedDest: w,
              explicitDest: x,
              pageNumber: F
            })), this.pdfViewer.scrollPageIntoView({
              pageNumber: F,
              destArray: x,
              ignoreDestinationZoom: this._ignoreDestinationZoom
            });
          }, v = new WeakSet(), Wi = function(i) {
            if (!Array.isArray(i))
              return !1;
            const w = i.length;
            if (w < 2)
              return !1;
            const x = i[0];
            if (!(typeof x == "object" && Number.isInteger(x.num) && Number.isInteger(x.gen)) && !(Number.isInteger(x) && x >= 0))
              return !1;
            const b = i[1];
            if (!(typeof b == "object" && typeof b.name == "string"))
              return !1;
            let F = !0;
            switch (b.name) {
              case "XYZ":
                if (w !== 5)
                  return !1;
                break;
              case "Fit":
              case "FitB":
                return w === 2;
              case "FitH":
              case "FitBH":
              case "FitV":
              case "FitBV":
                if (w !== 3)
                  return !1;
                break;
              case "FitR":
                if (w !== 6)
                  return !1;
                F = !1;
                break;
              default:
                return !1;
            }
            for (let L = 2; L < w; L++) {
              const G = i[L];
              if (!(typeof G == "number" || F && G === null))
                return !1;
            }
            return !0;
          }, W(C, v);
          let g = C;
          f.PDFLinkService = g;
          class s {
            constructor() {
              this.externalLinkEnabled = !0;
            }
            get pagesCount() {
              return 0;
            }
            get page() {
              return 0;
            }
            set page(i) {
            }
            get rotation() {
              return 0;
            }
            set rotation(i) {
            }
            get isInPresentationMode() {
              return !1;
            }
            async goToDestination(i) {
            }
            goToPage(i) {
            }
            addLinkAttributes(i, w, x = !1) {
              A(i, {
                url: w,
                enabled: this.externalLinkEnabled
              });
            }
            getDestinationHash(i) {
              return "#";
            }
            getAnchorUrl(i) {
              return "#";
            }
            setHash(i) {
            }
            executeNamedAction(i) {
            }
            executeSetOCGState(i) {
            }
            cachePageRef(i, w) {
            }
          }
          f.SimpleLinkService = s;
        },
        /* 6 */
        /***/
        (P, f, y) => {
          var g, s, Un;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.AnnotationLayerBuilder = void 0;
          var c = y(4), a = y(7), I = y(2);
          class A {
            constructor({
              pageDiv: u,
              pdfPage: v,
              linkService: p,
              downloadManager: C,
              annotationStorage: r = null,
              imageResourcesPath: i = "",
              renderForms: w = !0,
              l10n: x = a.NullL10n,
              enableScripting: b = !1,
              hasJSActionsPromise: F = null,
              fieldObjectsPromise: L = null,
              annotationCanvasMap: G = null,
              accessibilityManager: nt = null
            }) {
              W(this, s);
              W(this, g, null);
              this.pageDiv = u, this.pdfPage = v, this.linkService = p, this.downloadManager = C, this.imageResourcesPath = i, this.renderForms = w, this.l10n = x, this.annotationStorage = r, this.enableScripting = b, this._hasJSActionsPromise = F || Promise.resolve(!1), this._fieldObjectsPromise = L || Promise.resolve(null), this._annotationCanvasMap = G, this._accessibilityManager = nt, this.annotationLayer = null, this.div = null, this._cancelled = !1, this._eventBus = p.eventBus;
            }
            async render(u, v = "display") {
              var w;
              if (this.div) {
                if (this._cancelled || !this.annotationLayer)
                  return;
                this.annotationLayer.update({
                  viewport: u.clone({
                    dontFlip: !0
                  })
                });
                return;
              }
              const [p, C, r] = await Promise.all([this.pdfPage.getAnnotations({
                intent: v
              }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
              if (this._cancelled)
                return;
              const i = this.div = document.createElement("div");
              if (i.className = "annotationLayer", this.pageDiv.append(i), p.length === 0) {
                this.hide();
                return;
              }
              this.annotationLayer = new c.AnnotationLayer({
                div: i,
                accessibilityManager: this._accessibilityManager,
                annotationCanvasMap: this._annotationCanvasMap,
                l10n: this.l10n,
                page: this.pdfPage,
                viewport: u.clone({
                  dontFlip: !0
                })
              }), await this.annotationLayer.render({
                annotations: p,
                imageResourcesPath: this.imageResourcesPath,
                renderForms: this.renderForms,
                linkService: this.linkService,
                downloadManager: this.downloadManager,
                annotationStorage: this.annotationStorage,
                enableScripting: this.enableScripting,
                hasJSActions: C,
                fieldObjects: r
              }), this.linkService.isInPresentationMode && J(this, s, Un).call(this, I.PresentationModeState.FULLSCREEN), e(this, g) || (rt(this, g, (x) => {
                J(this, s, Un).call(this, x.state);
              }), (w = this._eventBus) == null || w._on("presentationmodechanged", e(this, g)));
            }
            cancel() {
              var u;
              this._cancelled = !0, e(this, g) && ((u = this._eventBus) == null || u._off("presentationmodechanged", e(this, g)), rt(this, g, null));
            }
            hide() {
              this.div && (this.div.hidden = !0);
            }
          }
          g = new WeakMap(), s = new WeakSet(), Un = function(u) {
            if (!this.div)
              return;
            let v = !1;
            switch (u) {
              case I.PresentationModeState.FULLSCREEN:
                v = !0;
                break;
              case I.PresentationModeState.NORMAL:
                break;
              default:
                return;
            }
            for (const p of this.div.childNodes)
              p.hasAttribute("data-internal-link") || (p.inert = v);
          }, f.AnnotationLayerBuilder = A;
        },
        /* 7 */
        /***/
        (P, f) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.NullL10n = void 0, f.getL10nFallback = c;
          const y = {
            of_pages: "of {{pagesCount}}",
            page_of_pages: "({{pageNumber}} of {{pagesCount}})",
            document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
            document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
            document_properties_date_string: "{{date}}, {{time}}",
            document_properties_page_size_unit_inches: "in",
            document_properties_page_size_unit_millimeters: "mm",
            document_properties_page_size_orientation_portrait: "portrait",
            document_properties_page_size_orientation_landscape: "landscape",
            document_properties_page_size_name_a3: "A3",
            document_properties_page_size_name_a4: "A4",
            document_properties_page_size_name_letter: "Letter",
            document_properties_page_size_name_legal: "Legal",
            document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
            document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
            document_properties_linearized_yes: "Yes",
            document_properties_linearized_no: "No",
            additional_layers: "Additional Layers",
            page_landmark: "Page {{page}}",
            thumb_page_title: "Page {{page}}",
            thumb_page_canvas: "Thumbnail of Page {{page}}",
            find_reached_top: "Reached top of document, continued from bottom",
            find_reached_bottom: "Reached end of document, continued from top",
            "find_match_count[one]": "{{current}} of {{total}} match",
            "find_match_count[other]": "{{current}} of {{total}} matches",
            "find_match_count_limit[one]": "More than {{limit}} match",
            "find_match_count_limit[other]": "More than {{limit}} matches",
            find_not_found: "Phrase not found",
            page_scale_width: "Page Width",
            page_scale_fit: "Page Fit",
            page_scale_auto: "Automatic Zoom",
            page_scale_actual: "Actual Size",
            page_scale_percent: "{{scale}}%",
            loading_error: "An error occurred while loading the PDF.",
            invalid_file_error: "Invalid or corrupted PDF file.",
            missing_file_error: "Missing PDF file.",
            unexpected_response_error: "Unexpected server response.",
            rendering_error: "An error occurred while rendering the page.",
            annotation_date_string: "{{date}}, {{time}}",
            printing_not_supported: "Warning: Printing is not fully supported by this browser.",
            printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
            web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
            free_text2_default_content: "Start typing…",
            editor_free_text2_aria_label: "Text Editor",
            editor_ink2_aria_label: "Draw Editor",
            editor_ink_canvas_aria_label: "User-created image",
            editor_alt_text_button_label: "Alt text",
            editor_alt_text_edit_button_label: "Edit alt text",
            editor_alt_text_decorative_tooltip: "Marked as decorative"
          };
          y.print_progress_percent = "{{progress}}%";
          function c(A, g) {
            switch (A) {
              case "find_match_count":
                A = `find_match_count[${g.total === 1 ? "one" : "other"}]`;
                break;
              case "find_match_count_limit":
                A = `find_match_count_limit[${g.limit === 1 ? "one" : "other"}]`;
                break;
            }
            return y[A] || "";
          }
          function a(A, g) {
            return g ? A.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (s, o) => o in g ? g[o] : "{{" + o + "}}") : A;
          }
          const I = {
            async getLanguage() {
              return "en-us";
            },
            async getDirection() {
              return "ltr";
            },
            async get(A, g = null, s = c(A, g)) {
              return a(s, g);
            },
            async translate(A) {
            }
          };
          f.NullL10n = I;
        },
        /* 8 */
        /***/
        (P, f, y) => {
          var A;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.DownloadManager = void 0;
          var c = y(4);
          function a(g, s) {
            const o = document.createElement("a");
            if (!o.click)
              throw new Error('DownloadManager: "a.click()" is not supported.');
            o.href = g, o.target = "_parent", "download" in o && (o.download = s), (document.body || document.documentElement).append(o), o.click(), o.remove();
          }
          class I {
            constructor() {
              W(this, A, /* @__PURE__ */ new WeakMap());
            }
            downloadUrl(s, o, l) {
              if (!(0, c.createValidAbsoluteUrl)(s, "http://example.com")) {
                console.error(`downloadUrl - not a valid URL: ${s}`);
                return;
              }
              a(s + "#pdfjs.action=download", o);
            }
            downloadData(s, o, l) {
              const u = URL.createObjectURL(new Blob([s], {
                type: l
              }));
              a(u, o);
            }
            openOrDownloadData(s, o, l) {
              const v = (0, c.isPdfFile)(l) ? "application/pdf" : "";
              return this.downloadData(o, l, v), !1;
            }
            download(s, o, l, u) {
              const v = URL.createObjectURL(s);
              a(v, l);
            }
          }
          A = new WeakMap(), f.DownloadManager = I;
        },
        /* 9 */
        /***/
        (P, f) => {
          var A;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.WaitOnType = f.EventBus = f.AutomationEventBus = void 0, f.waitOnEventOrTimeout = c;
          const y = {
            EVENT: "event",
            TIMEOUT: "timeout"
          };
          f.WaitOnType = y;
          function c({
            target: g,
            name: s,
            delay: o = 0
          }) {
            return new Promise(function(l, u) {
              if (typeof g != "object" || !(s && typeof s == "string") || !(Number.isInteger(o) && o >= 0))
                throw new Error("waitOnEventOrTimeout - invalid parameters.");
              function v(i) {
                g instanceof a ? g._off(s, p) : g.removeEventListener(s, p), r && clearTimeout(r), l(i);
              }
              const p = v.bind(null, y.EVENT);
              g instanceof a ? g._on(s, p) : g.addEventListener(s, p);
              const C = v.bind(null, y.TIMEOUT), r = setTimeout(C, o);
            });
          }
          class a {
            constructor() {
              W(this, A, /* @__PURE__ */ Object.create(null));
            }
            on(s, o, l = null) {
              this._on(s, o, {
                external: !0,
                once: l == null ? void 0 : l.once
              });
            }
            off(s, o, l = null) {
              this._off(s, o, {
                external: !0,
                once: l == null ? void 0 : l.once
              });
            }
            dispatch(s, o) {
              const l = e(this, A)[s];
              if (!l || l.length === 0)
                return;
              let u;
              for (const {
                listener: v,
                external: p,
                once: C
              } of l.slice(0)) {
                if (C && this._off(s, v), p) {
                  (u || (u = [])).push(v);
                  continue;
                }
                v(o);
              }
              if (u) {
                for (const v of u)
                  v(o);
                u = null;
              }
            }
            _on(s, o, l = null) {
              var v;
              ((v = e(this, A))[s] || (v[s] = [])).push({
                listener: o,
                external: (l == null ? void 0 : l.external) === !0,
                once: (l == null ? void 0 : l.once) === !0
              });
            }
            _off(s, o, l = null) {
              const u = e(this, A)[s];
              if (u) {
                for (let v = 0, p = u.length; v < p; v++)
                  if (u[v].listener === o) {
                    u.splice(v, 1);
                    return;
                  }
              }
            }
          }
          A = new WeakMap(), f.EventBus = a;
          class I extends a {
            dispatch(s, o) {
              throw new Error("Not implemented: AutomationEventBus.dispatch");
            }
          }
          f.AutomationEventBus = I;
        },
        /* 10 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.GenericL10n = void 0, y(11);
          var c = y(7);
          const a = {
            en: "en-US",
            es: "es-ES",
            fy: "fy-NL",
            ga: "ga-IE",
            gu: "gu-IN",
            hi: "hi-IN",
            hy: "hy-AM",
            nb: "nb-NO",
            ne: "ne-NP",
            nn: "nn-NO",
            pa: "pa-IN",
            pt: "pt-PT",
            sv: "sv-SE",
            zh: "zh-CN"
          };
          function I(g) {
            return a[g == null ? void 0 : g.toLowerCase()] || g;
          }
          class A {
            constructor(s) {
              const {
                webL10n: o
              } = document;
              this._lang = s, this._ready = new Promise((l, u) => {
                o.setLanguage(I(s), () => {
                  l(o);
                });
              });
            }
            async getLanguage() {
              return (await this._ready).getLanguage();
            }
            async getDirection() {
              return (await this._ready).getDirection();
            }
            async get(s, o = null, l = (0, c.getL10nFallback)(s, o)) {
              return (await this._ready).get(s, o, l);
            }
            async translate(s) {
              return (await this._ready).translate(s);
            }
          }
          f.GenericL10n = A;
        },
        /* 11 */
        /***/
        () => {
          document.webL10n = function(P, f) {
            var y = {}, c = "", a = "textContent", I = "", A = {}, g = "loading", s = !0;
            function o() {
              return f.querySelectorAll('link[type="application/l10n"]');
            }
            function l() {
              var D = f.querySelector('script[type="application/l10n"]');
              return D ? JSON.parse(D.innerHTML) : null;
            }
            function u(D) {
              return D ? D.querySelectorAll("*[data-l10n-id]") : [];
            }
            function v(D) {
              if (!D)
                return {};
              var X = D.getAttribute("data-l10n-id"), q = D.getAttribute("data-l10n-args"), j = {};
              if (q)
                try {
                  j = JSON.parse(q);
                } catch {
                  console.warn("could not parse arguments for #" + X);
                }
              return {
                id: X,
                args: j
              };
            }
            function p(D, X, q) {
              X = X || function(it) {
              }, q = q || function() {
              };
              var j = new XMLHttpRequest();
              j.open("GET", D, s), j.overrideMimeType && j.overrideMimeType("text/plain; charset=utf-8"), j.onreadystatechange = function() {
                j.readyState == 4 && (j.status == 200 || j.status === 0 ? X(j.responseText) : q());
              }, j.onerror = q, j.ontimeout = q;
              try {
                j.send(null);
              } catch {
                q();
              }
            }
            function C(D, X, q, j) {
              var z = D.replace(/[^\/]*$/, "") || "./";
              function it(Et) {
                return Et.lastIndexOf("\\") < 0 ? Et : Et.replace(/\\\\/g, "\\").replace(/\\n/g, `
`).replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\{/g, "{").replace(/\\}/g, "}").replace(/\\"/g, '"').replace(/\\'/g, "'");
              }
              function Q(Et, Ct) {
                var H = {}, m = /^\s*|\s*$/, k = /^\s*#|^\s*$/, d = /^\s*\[(.*)\]\s*$/, R = /^\s*@import\s+url\((.*)\)\s*$/i, M = /^([^=\s]*)\s*=\s*(.+)$/;
                function B(Z, pt, dt) {
                  var Tt = Z.replace(m, "").split(/[\r\n]+/), lt = "*", yt = X.split("-", 1)[0], bt = !1, It = "";
                  function Ot() {
                    for (; ; ) {
                      if (!Tt.length) {
                        dt();
                        return;
                      }
                      var Mt = Tt.shift();
                      if (!k.test(Mt)) {
                        if (pt) {
                          if (It = d.exec(Mt), It) {
                            lt = It[1].toLowerCase(), bt = lt !== "*" && lt !== X && lt !== yt;
                            continue;
                          } else if (bt)
                            continue;
                          if (It = R.exec(Mt), It) {
                            _(z + It[1], Ot);
                            return;
                          }
                        }
                        var gt = Mt.match(M);
                        gt && gt.length == 3 && (H[gt[1]] = it(gt[2]));
                      }
                    }
                  }
                  Ot();
                }
                function _(Z, pt) {
                  p(Z, function(dt) {
                    B(dt, !1, pt);
                  }, function() {
                    console.warn(Z + " not found."), pt();
                  });
                }
                B(Et, !0, function() {
                  Ct(H);
                });
              }
              p(D, function(Et) {
                c += Et, Q(Et, function(Ct) {
                  for (var H in Ct) {
                    var m, k, d = H.lastIndexOf(".");
                    d > 0 ? (m = H.substring(0, d), k = H.substring(d + 1)) : (m = H, k = a), y[m] || (y[m] = {}), y[m][k] = Ct[H];
                  }
                  q && q();
                });
              }, j);
            }
            function r(D, X) {
              D && (D = D.toLowerCase()), X = X || function() {
              }, i(), I = D;
              var q = o(), j = q.length;
              if (j === 0) {
                var z = l();
                if (z && z.locales && z.default_locale) {
                  if (console.log("using the embedded JSON directory, early way out"), y = z.locales[D], !y) {
                    var it = z.default_locale.toLowerCase();
                    for (var Q in z.locales)
                      if (Q = Q.toLowerCase(), Q === D) {
                        y = z.locales[D];
                        break;
                      } else
                        Q === it && (y = z.locales[it]);
                  }
                  X();
                } else
                  console.log("no resource to load, early way out");
                g = "complete";
                return;
              }
              var Et = null, Ct = 0;
              Et = function() {
                Ct++, Ct >= j && (X(), g = "complete");
              };
              function H(d) {
                var R = d.href;
                this.load = function(M, B) {
                  C(R, M, B, function() {
                    console.warn(R + " not found."), console.warn('"' + M + '" resource not found'), I = "", B();
                  });
                };
              }
              for (var m = 0; m < j; m++) {
                var k = new H(q[m]);
                k.load(D, Et);
              }
            }
            function i() {
              y = {}, c = "", I = "";
            }
            function w(D) {
              var X = {
                af: 3,
                ak: 4,
                am: 4,
                ar: 1,
                asa: 3,
                az: 0,
                be: 11,
                bem: 3,
                bez: 3,
                bg: 3,
                bh: 4,
                bm: 0,
                bn: 3,
                bo: 0,
                br: 20,
                brx: 3,
                bs: 11,
                ca: 3,
                cgg: 3,
                chr: 3,
                cs: 12,
                cy: 17,
                da: 3,
                de: 3,
                dv: 3,
                dz: 0,
                ee: 3,
                el: 3,
                en: 3,
                eo: 3,
                es: 3,
                et: 3,
                eu: 3,
                fa: 0,
                ff: 5,
                fi: 3,
                fil: 4,
                fo: 3,
                fr: 5,
                fur: 3,
                fy: 3,
                ga: 8,
                gd: 24,
                gl: 3,
                gsw: 3,
                gu: 3,
                guw: 4,
                gv: 23,
                ha: 3,
                haw: 3,
                he: 2,
                hi: 4,
                hr: 11,
                hu: 0,
                id: 0,
                ig: 0,
                ii: 0,
                is: 3,
                it: 3,
                iu: 7,
                ja: 0,
                jmc: 3,
                jv: 0,
                ka: 0,
                kab: 5,
                kaj: 3,
                kcg: 3,
                kde: 0,
                kea: 0,
                kk: 3,
                kl: 3,
                km: 0,
                kn: 0,
                ko: 0,
                ksb: 3,
                ksh: 21,
                ku: 3,
                kw: 7,
                lag: 18,
                lb: 3,
                lg: 3,
                ln: 4,
                lo: 0,
                lt: 10,
                lv: 6,
                mas: 3,
                mg: 4,
                mk: 16,
                ml: 3,
                mn: 3,
                mo: 9,
                mr: 3,
                ms: 0,
                mt: 15,
                my: 0,
                nah: 3,
                naq: 7,
                nb: 3,
                nd: 3,
                ne: 3,
                nl: 3,
                nn: 3,
                no: 3,
                nr: 3,
                nso: 4,
                ny: 3,
                nyn: 3,
                om: 3,
                or: 3,
                pa: 3,
                pap: 3,
                pl: 13,
                ps: 3,
                pt: 3,
                rm: 3,
                ro: 9,
                rof: 3,
                ru: 11,
                rwk: 3,
                sah: 0,
                saq: 3,
                se: 7,
                seh: 3,
                ses: 0,
                sg: 0,
                sh: 11,
                shi: 19,
                sk: 12,
                sl: 14,
                sma: 7,
                smi: 7,
                smj: 7,
                smn: 7,
                sms: 7,
                sn: 3,
                so: 3,
                sq: 3,
                sr: 11,
                ss: 3,
                ssy: 3,
                st: 3,
                sv: 3,
                sw: 3,
                syr: 3,
                ta: 3,
                te: 3,
                teo: 3,
                th: 0,
                ti: 4,
                tig: 3,
                tk: 3,
                tl: 4,
                tn: 3,
                to: 0,
                tr: 0,
                ts: 3,
                tzm: 22,
                uk: 11,
                ur: 3,
                ve: 3,
                vi: 0,
                vun: 3,
                wa: 4,
                wae: 3,
                wo: 0,
                xh: 3,
                xog: 3,
                yo: 0,
                zh: 0,
                zu: 3
              };
              function q(Q, Et) {
                return Et.indexOf(Q) !== -1;
              }
              function j(Q, Et, Ct) {
                return Et <= Q && Q <= Ct;
              }
              var z = {
                0: function(Q) {
                  return "other";
                },
                1: function(Q) {
                  return j(Q % 100, 3, 10) ? "few" : Q === 0 ? "zero" : j(Q % 100, 11, 99) ? "many" : Q == 2 ? "two" : Q == 1 ? "one" : "other";
                },
                2: function(Q) {
                  return Q !== 0 && Q % 10 === 0 ? "many" : Q == 2 ? "two" : Q == 1 ? "one" : "other";
                },
                3: function(Q) {
                  return Q == 1 ? "one" : "other";
                },
                4: function(Q) {
                  return j(Q, 0, 1) ? "one" : "other";
                },
                5: function(Q) {
                  return j(Q, 0, 2) && Q != 2 ? "one" : "other";
                },
                6: function(Q) {
                  return Q === 0 ? "zero" : Q % 10 == 1 && Q % 100 != 11 ? "one" : "other";
                },
                7: function(Q) {
                  return Q == 2 ? "two" : Q == 1 ? "one" : "other";
                },
                8: function(Q) {
                  return j(Q, 3, 6) ? "few" : j(Q, 7, 10) ? "many" : Q == 2 ? "two" : Q == 1 ? "one" : "other";
                },
                9: function(Q) {
                  return Q === 0 || Q != 1 && j(Q % 100, 1, 19) ? "few" : Q == 1 ? "one" : "other";
                },
                10: function(Q) {
                  return j(Q % 10, 2, 9) && !j(Q % 100, 11, 19) ? "few" : Q % 10 == 1 && !j(Q % 100, 11, 19) ? "one" : "other";
                },
                11: function(Q) {
                  return j(Q % 10, 2, 4) && !j(Q % 100, 12, 14) ? "few" : Q % 10 === 0 || j(Q % 10, 5, 9) || j(Q % 100, 11, 14) ? "many" : Q % 10 == 1 && Q % 100 != 11 ? "one" : "other";
                },
                12: function(Q) {
                  return j(Q, 2, 4) ? "few" : Q == 1 ? "one" : "other";
                },
                13: function(Q) {
                  return j(Q % 10, 2, 4) && !j(Q % 100, 12, 14) ? "few" : Q != 1 && j(Q % 10, 0, 1) || j(Q % 10, 5, 9) || j(Q % 100, 12, 14) ? "many" : Q == 1 ? "one" : "other";
                },
                14: function(Q) {
                  return j(Q % 100, 3, 4) ? "few" : Q % 100 == 2 ? "two" : Q % 100 == 1 ? "one" : "other";
                },
                15: function(Q) {
                  return Q === 0 || j(Q % 100, 2, 10) ? "few" : j(Q % 100, 11, 19) ? "many" : Q == 1 ? "one" : "other";
                },
                16: function(Q) {
                  return Q % 10 == 1 && Q != 11 ? "one" : "other";
                },
                17: function(Q) {
                  return Q == 3 ? "few" : Q === 0 ? "zero" : Q == 6 ? "many" : Q == 2 ? "two" : Q == 1 ? "one" : "other";
                },
                18: function(Q) {
                  return Q === 0 ? "zero" : j(Q, 0, 2) && Q !== 0 && Q != 2 ? "one" : "other";
                },
                19: function(Q) {
                  return j(Q, 2, 10) ? "few" : j(Q, 0, 1) ? "one" : "other";
                },
                20: function(Q) {
                  return (j(Q % 10, 3, 4) || Q % 10 == 9) && !(j(Q % 100, 10, 19) || j(Q % 100, 70, 79) || j(Q % 100, 90, 99)) ? "few" : Q % 1e6 === 0 && Q !== 0 ? "many" : Q % 10 == 2 && !q(Q % 100, [12, 72, 92]) ? "two" : Q % 10 == 1 && !q(Q % 100, [11, 71, 91]) ? "one" : "other";
                },
                21: function(Q) {
                  return Q === 0 ? "zero" : Q == 1 ? "one" : "other";
                },
                22: function(Q) {
                  return j(Q, 0, 1) || j(Q, 11, 99) ? "one" : "other";
                },
                23: function(Q) {
                  return j(Q % 10, 1, 2) || Q % 20 === 0 ? "one" : "other";
                },
                24: function(Q) {
                  return j(Q, 3, 10) || j(Q, 13, 19) ? "few" : q(Q, [2, 12]) ? "two" : q(Q, [1, 11]) ? "one" : "other";
                }
              }, it = X[D.replace(/-.*$/, "")];
              return it in z ? z[it] : (console.warn("plural form unknown for [" + D + "]"), function() {
                return "other";
              });
            }
            A.plural = function(D, X, q, j) {
              var z = parseFloat(X);
              if (isNaN(z) || j != a)
                return D;
              A._pluralRules || (A._pluralRules = w(I));
              var it = "[" + A._pluralRules(z) + "]";
              return z === 0 && q + "[zero]" in y ? D = y[q + "[zero]"][j] : z == 1 && q + "[one]" in y ? D = y[q + "[one]"][j] : z == 2 && q + "[two]" in y ? D = y[q + "[two]"][j] : q + it in y ? D = y[q + it][j] : q + "[other]" in y && (D = y[q + "[other]"][j]), D;
            };
            function x(D, X, q) {
              var j = y[D];
              if (!j) {
                if (console.warn("#" + D + " is undefined."), !q)
                  return null;
                j = q;
              }
              var z = {};
              for (var it in j) {
                var Q = j[it];
                Q = b(Q, X, D, it), Q = F(Q, X, D), z[it] = Q;
              }
              return z;
            }
            function b(D, X, q, j) {
              var z = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/, it = z.exec(D);
              if (!it || !it.length)
                return D;
              var Q = it[1], Et = it[2], Ct;
              if (X && Et in X ? Ct = X[Et] : Et in y && (Ct = y[Et]), Q in A) {
                var H = A[Q];
                D = H(D, Ct, q, j);
              }
              return D;
            }
            function F(D, X, q) {
              var j = /\{\{\s*(.+?)\s*\}\}/g;
              return D.replace(j, function(z, it) {
                return X && it in X ? X[it] : it in y ? y[it] : (console.log("argument {{" + it + "}} for #" + q + " is undefined."), z);
              });
            }
            function L(D) {
              var X = v(D);
              if (X.id) {
                var q = x(X.id, X.args);
                if (!q) {
                  console.warn("#" + X.id + " is undefined.");
                  return;
                }
                if (q[a]) {
                  if (G(D) === 0)
                    D[a] = q[a];
                  else {
                    for (var j = D.childNodes, z = !1, it = 0, Q = j.length; it < Q; it++)
                      j[it].nodeType === 3 && /\S/.test(j[it].nodeValue) && (z ? j[it].nodeValue = "" : (j[it].nodeValue = q[a], z = !0));
                    if (!z) {
                      var Et = f.createTextNode(q[a]);
                      D.prepend(Et);
                    }
                  }
                  delete q[a];
                }
                for (var Ct in q)
                  D[Ct] = q[Ct];
              }
            }
            function G(D) {
              if (D.children)
                return D.children.length;
              if (typeof D.childElementCount < "u")
                return D.childElementCount;
              for (var X = 0, q = 0; q < D.childNodes.length; q++)
                X += D.nodeType === 1 ? 1 : 0;
              return X;
            }
            function nt(D) {
              D = D || f.documentElement;
              for (var X = u(D), q = X.length, j = 0; j < q; j++)
                L(X[j]);
              L(D);
            }
            return {
              get: function(D, X, q) {
                var j = D.lastIndexOf("."), z = a;
                j > 0 && (z = D.substring(j + 1), D = D.substring(0, j));
                var it;
                q && (it = {}, it[z] = q);
                var Q = x(D, X, it);
                return Q && z in Q ? Q[z] : "{{" + D + "}}";
              },
              getData: function() {
                return y;
              },
              getText: function() {
                return c;
              },
              getLanguage: function() {
                return I;
              },
              setLanguage: function(D, X) {
                r(D, function() {
                  X && X();
                });
              },
              getDirection: function() {
                var D = ["ar", "he", "fa", "ps", "ur"], X = I.split("-", 1)[0];
                return D.indexOf(X) >= 0 ? "rtl" : "ltr";
              },
              translate: nt,
              getReadyState: function() {
                return g;
              },
              ready: function(D) {
                if (D)
                  g == "complete" || g == "interactive" ? P.setTimeout(function() {
                    D();
                  }) : f.addEventListener && f.addEventListener("localized", function X() {
                    f.removeEventListener("localized", X), D();
                  });
                else
                  return;
              }
            };
          }(window, document);
        },
        /* 12 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFHistory = void 0, f.isDestArraysEqual = u, f.isDestHashesEqual = l;
          var c = y(2), a = y(9);
          const I = 1e3, A = 50, g = 1e3;
          function s() {
            return document.location.hash;
          }
          class o {
            constructor({
              linkService: p,
              eventBus: C
            }) {
              this.linkService = p, this.eventBus = C, this._initialized = !1, this._fingerprint = "", this.reset(), this._boundEvents = null, this.eventBus._on("pagesinit", () => {
                this._isPagesLoaded = !1, this.eventBus._on("pagesloaded", (r) => {
                  this._isPagesLoaded = !!r.pagesCount;
                }, {
                  once: !0
                });
              });
            }
            initialize({
              fingerprint: p,
              resetHistory: C = !1,
              updateUrl: r = !1
            }) {
              if (!p || typeof p != "string") {
                console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
                return;
              }
              this._initialized && this.reset();
              const i = this._fingerprint !== "" && this._fingerprint !== p;
              this._fingerprint = p, this._updateUrl = r === !0, this._initialized = !0, this._bindEvents();
              const w = window.history.state;
              if (this._popStateInProgress = !1, this._blockHashChange = 0, this._currentHash = s(), this._numPositionUpdates = 0, this._uid = this._maxUid = 0, this._destination = null, this._position = null, !this._isValidState(w, !0) || C) {
                const {
                  hash: b,
                  page: F,
                  rotation: L
                } = this._parseCurrentHash(!0);
                if (!b || i || C) {
                  this._pushOrReplaceState(null, !0);
                  return;
                }
                this._pushOrReplaceState({
                  hash: b,
                  page: F,
                  rotation: L
                }, !0);
                return;
              }
              const x = w.destination;
              this._updateInternalState(x, w.uid, !0), x.rotation !== void 0 && (this._initialRotation = x.rotation), x.dest ? (this._initialBookmark = JSON.stringify(x.dest), this._destination.page = null) : x.hash ? this._initialBookmark = x.hash : x.page && (this._initialBookmark = `page=${x.page}`);
            }
            reset() {
              this._initialized && (this._pageHide(), this._initialized = !1, this._unbindEvents()), this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._initialBookmark = null, this._initialRotation = null;
            }
            push({
              namedDest: p = null,
              explicitDest: C,
              pageNumber: r
            }) {
              if (!this._initialized)
                return;
              if (p && typeof p != "string") {
                console.error(`PDFHistory.push: "${p}" is not a valid namedDest parameter.`);
                return;
              } else if (Array.isArray(C)) {
                if (!this._isValidPage(r) && (r !== null || this._destination)) {
                  console.error(`PDFHistory.push: "${r}" is not a valid pageNumber parameter.`);
                  return;
                }
              } else {
                console.error(`PDFHistory.push: "${C}" is not a valid explicitDest parameter.`);
                return;
              }
              const i = p || JSON.stringify(C);
              if (!i)
                return;
              let w = !1;
              if (this._destination && (l(this._destination.hash, i) || u(this._destination.dest, C))) {
                if (this._destination.page)
                  return;
                w = !0;
              }
              this._popStateInProgress && !w || (this._pushOrReplaceState({
                dest: C,
                hash: i,
                page: r,
                rotation: this.linkService.rotation
              }, w), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
                this._popStateInProgress = !1;
              })));
            }
            pushPage(p) {
              var C;
              if (this._initialized) {
                if (!this._isValidPage(p)) {
                  console.error(`PDFHistory.pushPage: "${p}" is not a valid page number.`);
                  return;
                }
                ((C = this._destination) == null ? void 0 : C.page) !== p && (this._popStateInProgress || (this._pushOrReplaceState({
                  dest: null,
                  hash: `page=${p}`,
                  page: p,
                  rotation: this.linkService.rotation
                }), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
                  this._popStateInProgress = !1;
                }))));
              }
            }
            pushCurrentPosition() {
              !this._initialized || this._popStateInProgress || this._tryPushCurrentPosition();
            }
            back() {
              if (!this._initialized || this._popStateInProgress)
                return;
              const p = window.history.state;
              this._isValidState(p) && p.uid > 0 && window.history.back();
            }
            forward() {
              if (!this._initialized || this._popStateInProgress)
                return;
              const p = window.history.state;
              this._isValidState(p) && p.uid < this._maxUid && window.history.forward();
            }
            get popStateInProgress() {
              return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
            }
            get initialBookmark() {
              return this._initialized ? this._initialBookmark : null;
            }
            get initialRotation() {
              return this._initialized ? this._initialRotation : null;
            }
            _pushOrReplaceState(p, C = !1) {
              const r = C || !this._destination, i = {
                fingerprint: this._fingerprint,
                uid: r ? this._uid : this._uid + 1,
                destination: p
              };
              this._updateInternalState(p, i.uid);
              let w;
              if (this._updateUrl && (p != null && p.hash)) {
                const x = document.location.href.split("#")[0];
                x.startsWith("file://") || (w = `${x}#${p.hash}`);
              }
              r ? window.history.replaceState(i, "", w) : window.history.pushState(i, "", w);
            }
            _tryPushCurrentPosition(p = !1) {
              if (!this._position)
                return;
              let C = this._position;
              if (p && (C = Object.assign(/* @__PURE__ */ Object.create(null), this._position), C.temporary = !0), !this._destination) {
                this._pushOrReplaceState(C);
                return;
              }
              if (this._destination.temporary) {
                this._pushOrReplaceState(C, !0);
                return;
              }
              if (this._destination.hash === C.hash || !this._destination.page && this._numPositionUpdates <= A)
                return;
              let r = !1;
              if (this._destination.page >= C.first && this._destination.page <= C.page) {
                if (this._destination.dest !== void 0 || !this._destination.first)
                  return;
                r = !0;
              }
              this._pushOrReplaceState(C, r);
            }
            _isValidPage(p) {
              return Number.isInteger(p) && p > 0 && p <= this.linkService.pagesCount;
            }
            _isValidState(p, C = !1) {
              if (!p)
                return !1;
              if (p.fingerprint !== this._fingerprint)
                if (C) {
                  if (typeof p.fingerprint != "string" || p.fingerprint.length !== this._fingerprint.length)
                    return !1;
                  const [r] = performance.getEntriesByType("navigation");
                  if ((r == null ? void 0 : r.type) !== "reload")
                    return !1;
                } else
                  return !1;
              return !(!Number.isInteger(p.uid) || p.uid < 0 || p.destination === null || typeof p.destination != "object");
            }
            _updateInternalState(p, C, r = !1) {
              this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), r && (p != null && p.temporary) && delete p.temporary, this._destination = p, this._uid = C, this._maxUid = Math.max(this._maxUid, C), this._numPositionUpdates = 0;
            }
            _parseCurrentHash(p = !1) {
              const C = unescape(s()).substring(1), r = (0, c.parseQueryString)(C), i = r.get("nameddest") || "";
              let w = r.get("page") | 0;
              return (!this._isValidPage(w) || p && i.length > 0) && (w = null), {
                hash: C,
                page: w,
                rotation: this.linkService.rotation
              };
            }
            _updateViewarea({
              location: p
            }) {
              this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._position = {
                hash: p.pdfOpenParams.substring(1),
                page: this.linkService.page,
                first: p.pageNumber,
                rotation: p.rotation
              }, !this._popStateInProgress && (this._isPagesLoaded && this._destination && !this._destination.page && this._numPositionUpdates++, this._updateViewareaTimeout = setTimeout(() => {
                this._popStateInProgress || this._tryPushCurrentPosition(!0), this._updateViewareaTimeout = null;
              }, g));
            }
            _popState({
              state: p
            }) {
              const C = s(), r = this._currentHash !== C;
              if (this._currentHash = C, !p) {
                this._uid++;
                const {
                  hash: w,
                  page: x,
                  rotation: b
                } = this._parseCurrentHash();
                this._pushOrReplaceState({
                  hash: w,
                  page: x,
                  rotation: b
                }, !0);
                return;
              }
              if (!this._isValidState(p))
                return;
              this._popStateInProgress = !0, r && (this._blockHashChange++, (0, a.waitOnEventOrTimeout)({
                target: window,
                name: "hashchange",
                delay: I
              }).then(() => {
                this._blockHashChange--;
              }));
              const i = p.destination;
              this._updateInternalState(i, p.uid, !0), (0, c.isValidRotation)(i.rotation) && (this.linkService.rotation = i.rotation), i.dest ? this.linkService.goToDestination(i.dest) : i.hash ? this.linkService.setHash(i.hash) : i.page && (this.linkService.page = i.page), Promise.resolve().then(() => {
                this._popStateInProgress = !1;
              });
            }
            _pageHide() {
              (!this._destination || this._destination.temporary) && this._tryPushCurrentPosition();
            }
            _bindEvents() {
              this._boundEvents || (this._boundEvents = {
                updateViewarea: this._updateViewarea.bind(this),
                popState: this._popState.bind(this),
                pageHide: this._pageHide.bind(this)
              }, this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea), window.addEventListener("popstate", this._boundEvents.popState), window.addEventListener("pagehide", this._boundEvents.pageHide));
            }
            _unbindEvents() {
              this._boundEvents && (this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea), window.removeEventListener("popstate", this._boundEvents.popState), window.removeEventListener("pagehide", this._boundEvents.pageHide), this._boundEvents = null);
            }
          }
          f.PDFHistory = o;
          function l(v, p) {
            return typeof v != "string" || typeof p != "string" ? !1 : v === p || (0, c.parseQueryString)(v).get("nameddest") === p;
          }
          function u(v, p) {
            function C(r, i) {
              if (typeof r != typeof i || Array.isArray(r) || Array.isArray(i))
                return !1;
              if (r !== null && typeof r == "object" && i !== null) {
                if (Object.keys(r).length !== Object.keys(i).length)
                  return !1;
                for (const w in r)
                  if (!C(r[w], i[w]))
                    return !1;
                return !0;
              }
              return r === i || Number.isNaN(r) && Number.isNaN(i);
            }
            if (!(Array.isArray(v) && Array.isArray(p)) || v.length !== p.length)
              return !1;
            for (let r = 0, i = v.length; r < i; r++)
              if (!C(v[r], p[r]))
                return !1;
            return !0;
          }
        },
        /* 13 */
        /***/
        (P, f, y) => {
          var x, b, F, L, G, nt, D, X, q, j, z, Ge, Q, Vn, Ct, Hn, m, Wn, d, zn, M, zi, _, $i, pt, $n;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFPageView = void 0;
          var c = y(4), a = y(2), I = y(14), A = y(6), g = y(15), s = y(7), o = y(5), l = y(16), u = y(17), v = y(18), p = y(19), C = y(20);
          const r = g.compatibilityParams.maxCanvasPixels || 16777216, i = () => ({
            annotationEditorUIManager: null,
            annotationStorage: null,
            downloadManager: null,
            enableScripting: !1,
            fieldObjectsPromise: null,
            findController: null,
            hasJSActionsPromise: null,
            get linkService() {
              return new o.SimpleLinkService();
            }
          });
          class w {
            constructor(lt) {
              W(this, z);
              W(this, Q);
              W(this, Ct);
              W(this, m);
              W(this, d);
              W(this, M);
              W(this, _);
              W(this, pt);
              W(this, x, c.AnnotationMode.ENABLE_FORMS);
              W(this, b, !1);
              W(this, F, null);
              W(this, L, null);
              W(this, G, null);
              W(this, nt, null);
              W(this, D, a.RenderingStates.INITIAL);
              W(this, X, a.TextLayerMode.ENABLE);
              W(this, q, {
                directDrawing: !0,
                initialOptionalContent: !0,
                regularAnnotations: !0
              });
              W(this, j, /* @__PURE__ */ new WeakMap());
              var Ot;
              const yt = lt.container, bt = lt.defaultViewport;
              this.id = lt.id, this.renderingId = "page" + this.id, rt(this, F, lt.layerProperties || i), this.pdfPage = null, this.pageLabel = null, this.rotation = 0, this.scale = lt.scale || a.DEFAULT_SCALE, this.viewport = bt, this.pdfPageRotate = bt.rotation, this._optionalContentConfigPromise = lt.optionalContentConfigPromise || null, rt(this, X, lt.textLayerMode ?? a.TextLayerMode.ENABLE), rt(this, x, lt.annotationMode ?? c.AnnotationMode.ENABLE_FORMS), this.imageResourcesPath = lt.imageResourcesPath || "", this.isOffscreenCanvasSupported = lt.isOffscreenCanvasSupported ?? !0, this.maxCanvasPixels = lt.maxCanvasPixels ?? r, this.pageColors = lt.pageColors || null, this.eventBus = lt.eventBus, this.renderingQueue = lt.renderingQueue, this.l10n = lt.l10n || s.NullL10n, this.renderTask = null, this.resume = null, this._isStandalone = !((Ot = this.renderingQueue) != null && Ot.hasViewer()), this._container = yt, lt.useOnlyCssZoom && (console.error("useOnlyCssZoom was removed, please use `maxCanvasPixels = 0` instead."), this.maxCanvasPixels = 0), this._annotationCanvasMap = null, this.annotationLayer = null, this.annotationEditorLayer = null, this.textLayer = null, this.zoomLayer = null, this.xfaLayer = null, this.structTreeLayer = null;
              const It = document.createElement("div");
              if (It.className = "page", It.setAttribute("data-page-number", this.id), It.setAttribute("role", "region"), this.l10n.get("page_landmark", {
                page: this.id
              }).then((Mt) => {
                It.setAttribute("aria-label", Mt);
              }), this.div = It, J(this, z, Ge).call(this), yt == null || yt.append(It), this._isStandalone) {
                yt == null || yt.style.setProperty("--scale-factor", this.scale * c.PixelsPerInch.PDF_TO_CSS_UNITS);
                const {
                  optionalContentConfigPromise: Mt
                } = lt;
                Mt && Mt.then((gt) => {
                  Mt === this._optionalContentConfigPromise && (e(this, q).initialOptionalContent = gt.hasInitialVisibility);
                });
              }
            }
            get renderingState() {
              return e(this, D);
            }
            set renderingState(lt) {
              if (lt !== e(this, D))
                switch (rt(this, D, lt), e(this, L) && (clearTimeout(e(this, L)), rt(this, L, null)), lt) {
                  case a.RenderingStates.PAUSED:
                    this.div.classList.remove("loading");
                    break;
                  case a.RenderingStates.RUNNING:
                    this.div.classList.add("loadingIcon"), rt(this, L, setTimeout(() => {
                      this.div.classList.add("loading"), rt(this, L, null);
                    }, 0));
                    break;
                  case a.RenderingStates.INITIAL:
                  case a.RenderingStates.FINISHED:
                    this.div.classList.remove("loadingIcon", "loading");
                    break;
                }
            }
            setPdfPage(lt) {
              var bt, It, Ot;
              this._isStandalone && (((bt = this.pageColors) == null ? void 0 : bt.foreground) === "CanvasText" || ((It = this.pageColors) == null ? void 0 : It.background) === "Canvas") && ((Ot = this._container) == null || Ot.style.setProperty("--hcm-highligh-filter", lt.filterFactory.addHighlightHCMFilter("CanvasText", "Canvas", "HighlightText", "Highlight"))), this.pdfPage = lt, this.pdfPageRotate = lt.rotate;
              const yt = (this.rotation + this.pdfPageRotate) % 360;
              this.viewport = lt.getViewport({
                scale: this.scale * c.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: yt
              }), J(this, z, Ge).call(this), this.reset();
            }
            destroy() {
              var lt;
              this.reset(), (lt = this.pdfPage) == null || lt.cleanup();
            }
            get _textHighlighter() {
              return (0, c.shadow)(this, "_textHighlighter", new v.TextHighlighter({
                pageIndex: this.id - 1,
                eventBus: this.eventBus,
                findController: e(this, F).call(this).findController
              }));
            }
            _resetZoomLayer(lt = !1) {
              if (!this.zoomLayer)
                return;
              const yt = this.zoomLayer.firstChild;
              e(this, j).delete(yt), yt.width = 0, yt.height = 0, lt && this.zoomLayer.remove(), this.zoomLayer = null;
            }
            reset({
              keepZoomLayer: lt = !1,
              keepAnnotationLayer: yt = !1,
              keepAnnotationEditorLayer: bt = !1,
              keepXfaLayer: It = !1,
              keepTextLayer: Ot = !1
            } = {}) {
              var Lt, Ut, Ht, $t, Wt;
              this.cancelRendering({
                keepAnnotationLayer: yt,
                keepAnnotationEditorLayer: bt,
                keepXfaLayer: It,
                keepTextLayer: Ot
              }), this.renderingState = a.RenderingStates.INITIAL;
              const Mt = this.div, gt = Mt.childNodes, ut = lt && this.zoomLayer || null, ct = yt && ((Lt = this.annotationLayer) == null ? void 0 : Lt.div) || null, ot = bt && ((Ut = this.annotationEditorLayer) == null ? void 0 : Ut.div) || null, vt = It && ((Ht = this.xfaLayer) == null ? void 0 : Ht.div) || null, wt = Ot && (($t = this.textLayer) == null ? void 0 : $t.div) || null;
              for (let Jt = gt.length - 1; Jt >= 0; Jt--) {
                const Xt = gt[Jt];
                switch (Xt) {
                  case ut:
                  case ct:
                  case ot:
                  case vt:
                  case wt:
                    continue;
                }
                Xt.remove();
              }
              Mt.removeAttribute("data-loaded"), ct && this.annotationLayer.hide(), ot && this.annotationEditorLayer.hide(), vt && this.xfaLayer.hide(), wt && this.textLayer.hide(), (Wt = this.structTreeLayer) == null || Wt.hide(), ut || (this.canvas && (e(this, j).delete(this.canvas), this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this._resetZoomLayer());
            }
            update({
              scale: lt = 0,
              rotation: yt = null,
              optionalContentConfigPromise: bt = null,
              drawingDelay: It = -1
            }) {
              var Mt;
              this.scale = lt || this.scale, typeof yt == "number" && (this.rotation = yt), bt instanceof Promise && (this._optionalContentConfigPromise = bt, bt.then((gt) => {
                bt === this._optionalContentConfigPromise && (e(this, q).initialOptionalContent = gt.hasInitialVisibility);
              })), e(this, q).directDrawing = !0;
              const Ot = (this.rotation + this.pdfPageRotate) % 360;
              if (this.viewport = this.viewport.clone({
                scale: this.scale * c.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: Ot
              }), J(this, z, Ge).call(this), this._isStandalone && ((Mt = this._container) == null || Mt.style.setProperty("--scale-factor", this.viewport.scale)), this.canvas) {
                let gt = !1;
                if (e(this, b)) {
                  if (this.maxCanvasPixels === 0)
                    gt = !0;
                  else if (this.maxCanvasPixels > 0) {
                    const {
                      width: ct,
                      height: ot
                    } = this.viewport, {
                      sx: vt,
                      sy: wt
                    } = this.outputScale;
                    gt = (Math.floor(ct) * vt | 0) * (Math.floor(ot) * wt | 0) > this.maxCanvasPixels;
                  }
                }
                const ut = !gt && It >= 0 && It < 1e3;
                if (ut || gt) {
                  if (ut && this.renderingState !== a.RenderingStates.FINISHED && (this.cancelRendering({
                    keepZoomLayer: !0,
                    keepAnnotationLayer: !0,
                    keepAnnotationEditorLayer: !0,
                    keepXfaLayer: !0,
                    keepTextLayer: !0,
                    cancelExtraDelay: It
                  }), this.renderingState = a.RenderingStates.FINISHED, e(this, q).directDrawing = !1), this.cssTransform({
                    target: this.canvas,
                    redrawAnnotationLayer: !0,
                    redrawAnnotationEditorLayer: !0,
                    redrawXfaLayer: !0,
                    redrawTextLayer: !ut,
                    hideTextLayer: ut
                  }), ut)
                    return;
                  this.eventBus.dispatch("pagerendered", {
                    source: this,
                    pageNumber: this.id,
                    cssTransform: !0,
                    timestamp: performance.now(),
                    error: e(this, nt)
                  });
                  return;
                }
                !this.zoomLayer && !this.canvas.hidden && (this.zoomLayer = this.canvas.parentNode, this.zoomLayer.style.position = "absolute");
              }
              this.zoomLayer && this.cssTransform({
                target: this.zoomLayer.firstChild
              }), this.reset({
                keepZoomLayer: !0,
                keepAnnotationLayer: !0,
                keepAnnotationEditorLayer: !0,
                keepXfaLayer: !0,
                keepTextLayer: !0
              });
            }
            cancelRendering({
              keepAnnotationLayer: lt = !1,
              keepAnnotationEditorLayer: yt = !1,
              keepXfaLayer: bt = !1,
              keepTextLayer: It = !1,
              cancelExtraDelay: Ot = 0
            } = {}) {
              var Mt;
              this.renderTask && (this.renderTask.cancel(Ot), this.renderTask = null), this.resume = null, this.textLayer && (!It || !this.textLayer.div) && (this.textLayer.cancel(), this.textLayer = null), this.structTreeLayer && !this.textLayer && (this.structTreeLayer = null), this.annotationLayer && (!lt || !this.annotationLayer.div) && (this.annotationLayer.cancel(), this.annotationLayer = null, this._annotationCanvasMap = null), this.annotationEditorLayer && (!yt || !this.annotationEditorLayer.div) && (this.annotationEditorLayer.cancel(), this.annotationEditorLayer = null), this.xfaLayer && (!bt || !this.xfaLayer.div) && (this.xfaLayer.cancel(), this.xfaLayer = null, (Mt = this._textHighlighter) == null || Mt.disable());
            }
            cssTransform({
              target: lt,
              redrawAnnotationLayer: yt = !1,
              redrawAnnotationEditorLayer: bt = !1,
              redrawXfaLayer: It = !1,
              redrawTextLayer: Ot = !1,
              hideTextLayer: Mt = !1
            }) {
              var ut;
              if (!lt.hasAttribute("zooming")) {
                lt.setAttribute("zooming", !0);
                const {
                  style: ct
                } = lt;
                ct.width = ct.height = "";
              }
              const gt = e(this, j).get(lt);
              if (this.viewport !== gt) {
                const ct = this.viewport.rotation - gt.rotation, ot = Math.abs(ct);
                let vt = 1, wt = 1;
                if (ot === 90 || ot === 270) {
                  const {
                    width: Lt,
                    height: Ut
                  } = this.viewport;
                  vt = Ut / Lt, wt = Lt / Ut;
                }
                lt.style.transform = `rotate(${ct}deg) scale(${vt}, ${wt})`;
              }
              yt && this.annotationLayer && J(this, Q, Vn).call(this), bt && this.annotationEditorLayer && J(this, Ct, Hn).call(this), It && this.xfaLayer && J(this, m, Wn).call(this), this.textLayer && (Mt ? (this.textLayer.hide(), (ut = this.structTreeLayer) == null || ut.hide()) : Ot && J(this, d, zn).call(this));
            }
            get width() {
              return this.viewport.width;
            }
            get height() {
              return this.viewport.height;
            }
            getPagePoint(lt, yt) {
              return this.viewport.convertToPdfPoint(lt, yt);
            }
            async draw() {
              this.renderingState !== a.RenderingStates.INITIAL && (console.error("Must be in new state before drawing"), this.reset());
              const {
                div: lt,
                l10n: yt,
                pageColors: bt,
                pdfPage: It,
                viewport: Ot
              } = this;
              if (!It)
                throw this.renderingState = a.RenderingStates.FINISHED, new Error("pdfPage is not loaded");
              this.renderingState = a.RenderingStates.RUNNING;
              const Mt = document.createElement("div");
              if (Mt.classList.add("canvasWrapper"), lt.append(Mt), !this.textLayer && e(this, X) !== a.TextLayerMode.DISABLE && !It.isPureXfa && (this._accessibilityManager || (this._accessibilityManager = new u.TextAccessibilityManager()), this.textLayer = new p.TextLayerBuilder({
                highlighter: this._textHighlighter,
                accessibilityManager: this._accessibilityManager,
                isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,
                enablePermissions: e(this, X) === a.TextLayerMode.ENABLE_PERMISSIONS
              }), lt.append(this.textLayer.div)), !this.annotationLayer && e(this, x) !== c.AnnotationMode.DISABLE) {
                const {
                  annotationStorage: N,
                  downloadManager: V,
                  enableScripting: K,
                  fieldObjectsPromise: st,
                  hasJSActionsPromise: ft,
                  linkService: Y
                } = e(this, F).call(this);
                this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map()), this.annotationLayer = new A.AnnotationLayerBuilder({
                  pageDiv: lt,
                  pdfPage: It,
                  annotationStorage: N,
                  imageResourcesPath: this.imageResourcesPath,
                  renderForms: e(this, x) === c.AnnotationMode.ENABLE_FORMS,
                  linkService: Y,
                  downloadManager: V,
                  l10n: yt,
                  enableScripting: K,
                  hasJSActionsPromise: ft,
                  fieldObjectsPromise: st,
                  annotationCanvasMap: this._annotationCanvasMap,
                  accessibilityManager: this._accessibilityManager
                });
              }
              const gt = (N) => {
                if (wt == null || wt(!1), this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
                  this.renderingState = a.RenderingStates.PAUSED, this.resume = () => {
                    this.renderingState = a.RenderingStates.RUNNING, N();
                  };
                  return;
                }
                N();
              }, {
                width: ut,
                height: ct
              } = Ot, ot = document.createElement("canvas");
              ot.setAttribute("role", "presentation"), ot.hidden = !0;
              const vt = !!(bt != null && bt.background && (bt != null && bt.foreground));
              let wt = (N) => {
                (!vt || N) && (ot.hidden = !1, wt = null);
              };
              Mt.append(ot), this.canvas = ot;
              const Lt = ot.getContext("2d", {
                alpha: !1
              }), Ut = this.outputScale = new a.OutputScale();
              if (this.maxCanvasPixels === 0) {
                const N = 1 / this.scale;
                Ut.sx *= N, Ut.sy *= N, rt(this, b, !0);
              } else if (this.maxCanvasPixels > 0) {
                const N = ut * ct, V = Math.sqrt(this.maxCanvasPixels / N);
                Ut.sx > V || Ut.sy > V ? (Ut.sx = V, Ut.sy = V, rt(this, b, !0)) : rt(this, b, !1);
              }
              const Ht = (0, a.approximateFraction)(Ut.sx), $t = (0, a.approximateFraction)(Ut.sy);
              ot.width = (0, a.roundToDivide)(ut * Ut.sx, Ht[0]), ot.height = (0, a.roundToDivide)(ct * Ut.sy, $t[0]);
              const {
                style: Wt
              } = ot;
              Wt.width = (0, a.roundToDivide)(ut, Ht[1]) + "px", Wt.height = (0, a.roundToDivide)(ct, $t[1]) + "px", e(this, j).set(ot, Ot);
              const Jt = Ut.scaled ? [Ut.sx, 0, 0, Ut.sy, 0, 0] : null, Xt = {
                canvasContext: Lt,
                transform: Jt,
                viewport: Ot,
                annotationMode: e(this, x),
                optionalContentConfigPromise: this._optionalContentConfigPromise,
                annotationCanvasMap: this._annotationCanvasMap,
                pageColors: bt
              }, Zt = this.renderTask = this.pdfPage.render(Xt);
              Zt.onContinue = gt;
              const Yt = Zt.promise.then(async () => {
                var N;
                if (wt == null || wt(!0), await J(this, pt, $n).call(this, Zt), J(this, d, zn).call(this), this.annotationLayer && await J(this, Q, Vn).call(this), !this.annotationEditorLayer) {
                  const {
                    annotationEditorUIManager: V
                  } = e(this, F).call(this);
                  if (!V)
                    return;
                  this.annotationEditorLayer = new I.AnnotationEditorLayerBuilder({
                    uiManager: V,
                    pageDiv: lt,
                    pdfPage: It,
                    l10n: yt,
                    accessibilityManager: this._accessibilityManager,
                    annotationLayer: (N = this.annotationLayer) == null ? void 0 : N.annotationLayer
                  });
                }
                J(this, Ct, Hn).call(this);
              }, (N) => (N instanceof c.RenderingCancelledException || wt == null || wt(!0), J(this, pt, $n).call(this, Zt, N)));
              if (It.isPureXfa) {
                if (this.xfaLayer)
                  this.xfaLayer.div && lt.append(this.xfaLayer.div);
                else {
                  const {
                    annotationStorage: N,
                    linkService: V
                  } = e(this, F).call(this);
                  this.xfaLayer = new C.XfaLayerBuilder({
                    pageDiv: lt,
                    pdfPage: It,
                    annotationStorage: N,
                    linkService: V
                  });
                }
                J(this, m, Wn).call(this);
              }
              return lt.setAttribute("data-loaded", !0), this.eventBus.dispatch("pagerender", {
                source: this,
                pageNumber: this.id
              }), Yt;
            }
            setPageLabel(lt) {
              this.pageLabel = typeof lt == "string" ? lt : null, this.pageLabel !== null ? this.div.setAttribute("data-page-label", this.pageLabel) : this.div.removeAttribute("data-page-label");
            }
            get thumbnailCanvas() {
              const {
                directDrawing: lt,
                initialOptionalContent: yt,
                regularAnnotations: bt
              } = e(this, q);
              return lt && yt && bt ? this.canvas : null;
            }
          }
          x = new WeakMap(), b = new WeakMap(), F = new WeakMap(), L = new WeakMap(), G = new WeakMap(), nt = new WeakMap(), D = new WeakMap(), X = new WeakMap(), q = new WeakMap(), j = new WeakMap(), z = new WeakSet(), Ge = function() {
            const {
              viewport: lt
            } = this;
            if (this.pdfPage) {
              if (e(this, G) === lt.rotation)
                return;
              rt(this, G, lt.rotation);
            }
            (0, c.setLayerDimensions)(this.div, lt, !0, !1);
          }, Q = new WeakSet(), Vn = async function() {
            let lt = null;
            try {
              await this.annotationLayer.render(this.viewport, "display");
            } catch (yt) {
              console.error(`#renderAnnotationLayer: "${yt}".`), lt = yt;
            } finally {
              this.eventBus.dispatch("annotationlayerrendered", {
                source: this,
                pageNumber: this.id,
                error: lt
              });
            }
          }, Ct = new WeakSet(), Hn = async function() {
            let lt = null;
            try {
              await this.annotationEditorLayer.render(this.viewport, "display");
            } catch (yt) {
              console.error(`#renderAnnotationEditorLayer: "${yt}".`), lt = yt;
            } finally {
              this.eventBus.dispatch("annotationeditorlayerrendered", {
                source: this,
                pageNumber: this.id,
                error: lt
              });
            }
          }, m = new WeakSet(), Wn = async function() {
            let lt = null;
            try {
              const yt = await this.xfaLayer.render(this.viewport, "display");
              yt != null && yt.textDivs && this._textHighlighter && J(this, _, $i).call(this, yt.textDivs);
            } catch (yt) {
              console.error(`#renderXfaLayer: "${yt}".`), lt = yt;
            } finally {
              this.eventBus.dispatch("xfalayerrendered", {
                source: this,
                pageNumber: this.id,
                error: lt
              });
            }
          }, d = new WeakSet(), zn = async function() {
            const {
              pdfPage: lt,
              textLayer: yt,
              viewport: bt
            } = this;
            if (!yt)
              return;
            let It = null;
            try {
              if (!yt.renderingDone) {
                const Ot = lt.streamTextContent({
                  includeMarkedContent: !0,
                  disableNormalization: !0
                });
                yt.setTextContentSource(Ot);
              }
              await yt.render(bt);
            } catch (Ot) {
              if (Ot instanceof c.AbortException)
                return;
              console.error(`#renderTextLayer: "${Ot}".`), It = Ot;
            }
            this.eventBus.dispatch("textlayerrendered", {
              source: this,
              pageNumber: this.id,
              numTextDivs: yt.numTextDivs,
              error: It
            }), J(this, M, zi).call(this);
          }, M = new WeakSet(), zi = async function() {
            var bt, It, Ot;
            if (!this.textLayer)
              return;
            this.structTreeLayer || (this.structTreeLayer = new l.StructTreeLayerBuilder());
            const lt = await (this.structTreeLayer.renderingDone ? null : this.pdfPage.getStructTree()), yt = (bt = this.structTreeLayer) == null ? void 0 : bt.render(lt);
            yt && ((It = this.canvas) == null || It.append(yt)), (Ot = this.structTreeLayer) == null || Ot.show();
          }, _ = new WeakSet(), $i = async function(lt) {
            const yt = await this.pdfPage.getTextContent(), bt = [];
            for (const It of yt.items)
              bt.push(It.str);
            this._textHighlighter.setTextMapping(lt, bt), this._textHighlighter.enable();
          }, pt = new WeakSet(), $n = async function(lt, yt = null) {
            if (lt === this.renderTask && (this.renderTask = null), yt instanceof c.RenderingCancelledException) {
              rt(this, nt, null);
              return;
            }
            if (rt(this, nt, yt), this.renderingState = a.RenderingStates.FINISHED, this._resetZoomLayer(!0), e(this, q).regularAnnotations = !lt.separateAnnots, this.eventBus.dispatch("pagerendered", {
              source: this,
              pageNumber: this.id,
              cssTransform: !1,
              timestamp: performance.now(),
              error: e(this, nt)
            }), yt)
              throw yt;
          }, f.PDFPageView = w;
        },
        /* 14 */
        /***/
        (P, f, y) => {
          var A, g;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.AnnotationEditorLayerBuilder = void 0;
          var c = y(4), a = y(7);
          class I {
            constructor(o) {
              W(this, A, null);
              W(this, g, void 0);
              this.pageDiv = o.pageDiv, this.pdfPage = o.pdfPage, this.accessibilityManager = o.accessibilityManager, this.l10n = o.l10n || a.NullL10n, this.annotationEditorLayer = null, this.div = null, this._cancelled = !1, rt(this, g, o.uiManager), rt(this, A, o.annotationLayer || null);
            }
            async render(o, l = "display") {
              if (l !== "display" || this._cancelled)
                return;
              const u = o.clone({
                dontFlip: !0
              });
              if (this.div) {
                this.annotationEditorLayer.update({
                  viewport: u
                }), this.show();
                return;
              }
              const v = this.div = document.createElement("div");
              v.className = "annotationEditorLayer", v.tabIndex = 0, v.hidden = !0, v.dir = e(this, g).direction, this.pageDiv.append(v), this.annotationEditorLayer = new c.AnnotationEditorLayer({
                uiManager: e(this, g),
                div: v,
                accessibilityManager: this.accessibilityManager,
                pageIndex: this.pdfPage.pageNumber - 1,
                l10n: this.l10n,
                viewport: u,
                annotationLayer: e(this, A)
              });
              const p = {
                viewport: u,
                div: v,
                annotations: null,
                intent: l
              };
              this.annotationEditorLayer.render(p), this.show();
            }
            cancel() {
              this._cancelled = !0, this.div && (this.pageDiv = null, this.annotationEditorLayer.destroy(), this.div.remove());
            }
            hide() {
              this.div && (this.div.hidden = !0);
            }
            show() {
              !this.div || this.annotationEditorLayer.isEmpty || (this.div.hidden = !1);
            }
          }
          A = new WeakMap(), g = new WeakMap(), f.AnnotationEditorLayerBuilder = I;
        },
        /* 15 */
        /***/
        (P, f) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.compatibilityParams = f.OptionKind = f.AppOptions = void 0;
          const y = /* @__PURE__ */ Object.create(null);
          f.compatibilityParams = y;
          {
            const g = navigator.userAgent || "", s = navigator.platform || "", o = navigator.maxTouchPoints || 1, l = /Android/.test(g), u = /\b(iPad|iPhone|iPod)(?=;)/.test(g) || s === "MacIntel" && o > 1;
            (function() {
              (u || l) && (y.maxCanvasPixels = 5242880);
            })();
          }
          const c = {
            VIEWER: 2,
            API: 4,
            WORKER: 8,
            PREFERENCE: 128
          };
          f.OptionKind = c;
          const a = {
            annotationEditorMode: {
              value: 0,
              kind: c.VIEWER + c.PREFERENCE
            },
            annotationMode: {
              value: 2,
              kind: c.VIEWER + c.PREFERENCE
            },
            cursorToolOnLoad: {
              value: 0,
              kind: c.VIEWER + c.PREFERENCE
            },
            defaultZoomDelay: {
              value: 400,
              kind: c.VIEWER + c.PREFERENCE
            },
            defaultZoomValue: {
              value: "",
              kind: c.VIEWER + c.PREFERENCE
            },
            disableHistory: {
              value: !1,
              kind: c.VIEWER
            },
            disablePageLabels: {
              value: !1,
              kind: c.VIEWER + c.PREFERENCE
            },
            enablePermissions: {
              value: !1,
              kind: c.VIEWER + c.PREFERENCE
            },
            enablePrintAutoRotate: {
              value: !0,
              kind: c.VIEWER + c.PREFERENCE
            },
            enableScripting: {
              value: !0,
              kind: c.VIEWER + c.PREFERENCE
            },
            enableStampEditor: {
              value: !0,
              kind: c.VIEWER + c.PREFERENCE
            },
            externalLinkRel: {
              value: "noopener noreferrer nofollow",
              kind: c.VIEWER
            },
            externalLinkTarget: {
              value: 0,
              kind: c.VIEWER + c.PREFERENCE
            },
            historyUpdateUrl: {
              value: !1,
              kind: c.VIEWER + c.PREFERENCE
            },
            ignoreDestinationZoom: {
              value: !1,
              kind: c.VIEWER + c.PREFERENCE
            },
            imageResourcesPath: {
              value: "./images/",
              kind: c.VIEWER
            },
            maxCanvasPixels: {
              value: 16777216,
              kind: c.VIEWER
            },
            forcePageColors: {
              value: !1,
              kind: c.VIEWER + c.PREFERENCE
            },
            pageColorsBackground: {
              value: "Canvas",
              kind: c.VIEWER + c.PREFERENCE
            },
            pageColorsForeground: {
              value: "CanvasText",
              kind: c.VIEWER + c.PREFERENCE
            },
            pdfBugEnabled: {
              value: !1,
              kind: c.VIEWER + c.PREFERENCE
            },
            printResolution: {
              value: 150,
              kind: c.VIEWER
            },
            sidebarViewOnLoad: {
              value: -1,
              kind: c.VIEWER + c.PREFERENCE
            },
            scrollModeOnLoad: {
              value: -1,
              kind: c.VIEWER + c.PREFERENCE
            },
            spreadModeOnLoad: {
              value: -1,
              kind: c.VIEWER + c.PREFERENCE
            },
            textLayerMode: {
              value: 1,
              kind: c.VIEWER + c.PREFERENCE
            },
            viewerCssTheme: {
              value: 0,
              kind: c.VIEWER + c.PREFERENCE
            },
            viewOnLoad: {
              value: 0,
              kind: c.VIEWER + c.PREFERENCE
            },
            cMapPacked: {
              value: !0,
              kind: c.API
            },
            cMapUrl: {
              value: "../web/cmaps/",
              kind: c.API
            },
            disableAutoFetch: {
              value: !1,
              kind: c.API + c.PREFERENCE
            },
            disableFontFace: {
              value: !1,
              kind: c.API + c.PREFERENCE
            },
            disableRange: {
              value: !1,
              kind: c.API + c.PREFERENCE
            },
            disableStream: {
              value: !1,
              kind: c.API + c.PREFERENCE
            },
            docBaseUrl: {
              value: "",
              kind: c.API
            },
            enableXfa: {
              value: !0,
              kind: c.API + c.PREFERENCE
            },
            fontExtraProperties: {
              value: !1,
              kind: c.API
            },
            isEvalSupported: {
              value: !0,
              kind: c.API
            },
            isOffscreenCanvasSupported: {
              value: !0,
              kind: c.API
            },
            maxImageSize: {
              value: -1,
              kind: c.API
            },
            pdfBug: {
              value: !1,
              kind: c.API
            },
            standardFontDataUrl: {
              value: "../web/standard_fonts/",
              kind: c.API
            },
            verbosity: {
              value: 1,
              kind: c.API
            },
            workerPort: {
              value: null,
              kind: c.WORKER
            },
            workerSrc: {
              value: "../build/pdf.worker.js",
              kind: c.WORKER
            }
          };
          a.defaultUrl = {
            value: "compressed.tracemonkey-pldi-09.pdf",
            kind: c.VIEWER
          }, a.disablePreferences = {
            value: !1,
            kind: c.VIEWER
          }, a.locale = {
            value: navigator.language || "en-US",
            kind: c.VIEWER
          }, a.sandboxBundleSrc = {
            value: "../build/pdf.sandbox.js",
            kind: c.VIEWER
          };
          const I = /* @__PURE__ */ Object.create(null);
          class A {
            constructor() {
              throw new Error("Cannot initialize AppOptions.");
            }
            static get(s) {
              const o = I[s];
              if (o !== void 0)
                return o;
              const l = a[s];
              if (l !== void 0)
                return y[s] ?? l.value;
            }
            static getAll(s = null) {
              const o = /* @__PURE__ */ Object.create(null);
              for (const l in a) {
                const u = a[l];
                if (s) {
                  if (!(s & u.kind))
                    continue;
                  if (s === c.PREFERENCE) {
                    const p = u.value, C = typeof p;
                    if (C === "boolean" || C === "string" || C === "number" && Number.isInteger(p)) {
                      o[l] = p;
                      continue;
                    }
                    throw new Error(`Invalid type for preference: ${l}`);
                  }
                }
                const v = I[l];
                o[l] = v !== void 0 ? v : y[l] ?? u.value;
              }
              return o;
            }
            static set(s, o) {
              I[s] = o;
            }
            static setAll(s) {
              for (const o in s)
                I[o] = s[o];
            }
            static remove(s) {
              delete I[s];
            }
          }
          f.AppOptions = A, A._hasUserOptions = function() {
            return Object.keys(I).length > 0;
          };
        },
        /* 16 */
        /***/
        (P, f, y) => {
          var g, s, Gn, l, Xn;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.StructTreeLayerBuilder = void 0;
          var c = y(2);
          const a = {
            Document: null,
            DocumentFragment: null,
            Part: "group",
            Sect: "group",
            Div: "group",
            Aside: "note",
            NonStruct: "none",
            P: null,
            H: "heading",
            Title: null,
            FENote: "note",
            Sub: "group",
            Lbl: null,
            Span: null,
            Em: null,
            Strong: null,
            Link: "link",
            Annot: "note",
            Form: "form",
            Ruby: null,
            RB: null,
            RT: null,
            RP: null,
            Warichu: null,
            WT: null,
            WP: null,
            L: "list",
            LI: "listitem",
            LBody: null,
            Table: "table",
            TR: "row",
            TH: "columnheader",
            TD: "cell",
            THead: "columnheader",
            TBody: null,
            TFoot: null,
            Caption: null,
            Figure: "figure",
            Formula: null,
            Artifact: null
          }, I = /^H(\d+)$/;
          class A {
            constructor() {
              W(this, s);
              W(this, l);
              W(this, g, void 0);
            }
            get renderingDone() {
              return e(this, g) !== void 0;
            }
            render(p) {
              if (e(this, g) !== void 0)
                return e(this, g);
              const C = J(this, l, Xn).call(this, p);
              return C == null || C.classList.add("structTree"), rt(this, g, C);
            }
            hide() {
              e(this, g) && !e(this, g).hidden && (e(this, g).hidden = !0);
            }
            show() {
              var p;
              (p = e(this, g)) != null && p.hidden && (e(this, g).hidden = !1);
            }
          }
          g = new WeakMap(), s = new WeakSet(), Gn = function(p, C) {
            const {
              alt: r,
              id: i,
              lang: w
            } = p;
            r !== void 0 && C.setAttribute("aria-label", (0, c.removeNullCharacters)(r)), i !== void 0 && C.setAttribute("aria-owns", i), w !== void 0 && C.setAttribute("lang", (0, c.removeNullCharacters)(w, !0));
          }, l = new WeakSet(), Xn = function(p) {
            if (!p)
              return null;
            const C = document.createElement("span");
            if ("role" in p) {
              const {
                role: r
              } = p, i = r.match(I);
              i ? (C.setAttribute("role", "heading"), C.setAttribute("aria-level", i[1])) : a[r] && C.setAttribute("role", a[r]);
            }
            if (J(this, s, Gn).call(this, p, C), p.children)
              if (p.children.length === 1 && "id" in p.children[0])
                J(this, s, Gn).call(this, p.children[0], C);
              else
                for (const r of p.children)
                  C.append(J(this, l, Xn).call(this, r));
            return C;
          }, f.StructTreeLayerBuilder = A;
        },
        /* 17 */
        /***/
        (P, f, y) => {
          var I, A, g, s, o, Xe, u, Yn;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.TextAccessibilityManager = void 0;
          var c = y(2);
          const p = class p {
            constructor() {
              W(this, u);
              W(this, I, !1);
              W(this, A, null);
              W(this, g, /* @__PURE__ */ new Map());
              W(this, s, /* @__PURE__ */ new Map());
            }
            setTextMapping(r) {
              rt(this, A, r);
            }
            enable() {
              if (e(this, I))
                throw new Error("TextAccessibilityManager is already enabled.");
              if (!e(this, A))
                throw new Error("Text divs and strings have not been set.");
              if (rt(this, I, !0), rt(this, A, e(this, A).slice()), e(this, A).sort(J(p, o, Xe)), e(this, g).size > 0) {
                const r = e(this, A);
                for (const [i, w] of e(this, g)) {
                  if (!document.getElementById(i)) {
                    e(this, g).delete(i);
                    continue;
                  }
                  J(this, u, Yn).call(this, i, r[w]);
                }
              }
              for (const [r, i] of e(this, s))
                this.addPointerInTextLayer(r, i);
              e(this, s).clear();
            }
            disable() {
              e(this, I) && (e(this, s).clear(), rt(this, A, null), rt(this, I, !1));
            }
            removePointerInTextLayer(r) {
              if (!e(this, I)) {
                e(this, s).delete(r);
                return;
              }
              const i = e(this, A);
              if (!i || i.length === 0)
                return;
              const {
                id: w
              } = r, x = e(this, g).get(w);
              if (x === void 0)
                return;
              const b = i[x];
              e(this, g).delete(w);
              let F = b.getAttribute("aria-owns");
              F != null && F.includes(w) && (F = F.split(" ").filter((L) => L !== w).join(" "), F ? b.setAttribute("aria-owns", F) : (b.removeAttribute("aria-owns"), b.setAttribute("role", "presentation")));
            }
            addPointerInTextLayer(r, i) {
              const {
                id: w
              } = r;
              if (!w)
                return null;
              if (!e(this, I))
                return e(this, s).set(r, i), null;
              i && this.removePointerInTextLayer(r);
              const x = e(this, A);
              if (!x || x.length === 0)
                return null;
              const b = (0, c.binarySearchFirstItem)(x, (nt) => {
                var D;
                return J(D = p, o, Xe).call(D, r, nt) < 0;
              }), F = Math.max(0, b - 1), L = x[F];
              J(this, u, Yn).call(this, w, L), e(this, g).set(w, F);
              const G = L.parentNode;
              return G != null && G.classList.contains("markedContent") ? G.id : null;
            }
            moveElementInDOM(r, i, w, x) {
              const b = this.addPointerInTextLayer(w, x);
              if (!r.hasChildNodes())
                return r.append(i), b;
              const F = Array.from(r.childNodes).filter((nt) => nt !== i);
              if (F.length === 0)
                return b;
              const L = w || i, G = (0, c.binarySearchFirstItem)(F, (nt) => {
                var D;
                return J(D = p, o, Xe).call(D, L, nt) < 0;
              });
              return G === 0 ? F[0].before(i) : F[G - 1].after(i), b;
            }
          };
          I = new WeakMap(), A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakSet(), Xe = function(r, i) {
            const w = r.getBoundingClientRect(), x = i.getBoundingClientRect();
            if (w.width === 0 && w.height === 0)
              return 1;
            if (x.width === 0 && x.height === 0)
              return -1;
            const b = w.y, F = w.y + w.height, L = w.y + w.height / 2, G = x.y, nt = x.y + x.height, D = x.y + x.height / 2;
            if (L <= G && D >= F)
              return -1;
            if (D <= b && L >= nt)
              return 1;
            const X = w.x + w.width / 2, q = x.x + x.width / 2;
            return X - q;
          }, u = new WeakSet(), Yn = function(r, i) {
            const w = i.getAttribute("aria-owns");
            w != null && w.includes(r) || i.setAttribute("aria-owns", w ? `${w} ${r}` : r), i.removeAttribute("role");
          }, W(p, o);
          let a = p;
          f.TextAccessibilityManager = a;
        },
        /* 18 */
        /***/
        (P, f) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.TextHighlighter = void 0;
          class y {
            constructor({
              findController: a,
              eventBus: I,
              pageIndex: A
            }) {
              this.findController = a, this.matches = [], this.eventBus = I, this.pageIdx = A, this._onUpdateTextLayerMatches = null, this.textDivs = null, this.textContentItemsStr = null, this.enabled = !1;
            }
            setTextMapping(a, I) {
              this.textDivs = a, this.textContentItemsStr = I;
            }
            enable() {
              if (!this.textDivs || !this.textContentItemsStr)
                throw new Error("Text divs and strings have not been set.");
              if (this.enabled)
                throw new Error("TextHighlighter is already enabled.");
              this.enabled = !0, this._onUpdateTextLayerMatches || (this._onUpdateTextLayerMatches = (a) => {
                (a.pageIndex === this.pageIdx || a.pageIndex === -1) && this._updateMatches();
              }, this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches)), this._updateMatches();
            }
            disable() {
              this.enabled && (this.enabled = !1, this._onUpdateTextLayerMatches && (this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches), this._onUpdateTextLayerMatches = null), this._updateMatches(!0));
            }
            _convertMatches(a, I) {
              if (!a)
                return [];
              const {
                textContentItemsStr: A
              } = this;
              let g = 0, s = 0;
              const o = A.length - 1, l = [];
              for (let u = 0, v = a.length; u < v; u++) {
                let p = a[u];
                for (; g !== o && p >= s + A[g].length; )
                  s += A[g].length, g++;
                g === A.length && console.error("Could not find a matching mapping");
                const C = {
                  begin: {
                    divIdx: g,
                    offset: p - s
                  }
                };
                for (p += I[u]; g !== o && p > s + A[g].length; )
                  s += A[g].length, g++;
                C.end = {
                  divIdx: g,
                  offset: p - s
                }, l.push(C);
              }
              return l;
            }
            _renderMatches(a) {
              if (a.length === 0)
                return;
              const {
                findController: I,
                pageIdx: A
              } = this, {
                textContentItemsStr: g,
                textDivs: s
              } = this, o = A === I.selected.pageIdx, l = I.selected.matchIdx, u = I.state.highlightAll;
              let v = null;
              const p = {
                divIdx: -1,
                offset: void 0
              };
              function C(F, L) {
                const G = F.divIdx;
                return s[G].textContent = "", r(G, 0, F.offset, L);
              }
              function r(F, L, G, nt) {
                let D = s[F];
                if (D.nodeType === Node.TEXT_NODE) {
                  const j = document.createElement("span");
                  D.before(j), j.append(D), s[F] = j, D = j;
                }
                const X = g[F].substring(L, G), q = document.createTextNode(X);
                if (nt) {
                  const j = document.createElement("span");
                  return j.className = `${nt} appended`, j.append(q), D.append(j), nt.includes("selected") ? j.offsetLeft : 0;
                }
                return D.append(q), 0;
              }
              let i = l, w = i + 1;
              if (u)
                i = 0, w = a.length;
              else if (!o)
                return;
              let x = -1, b = -1;
              for (let F = i; F < w; F++) {
                const L = a[F], G = L.begin;
                if (G.divIdx === x && G.offset === b)
                  continue;
                x = G.divIdx, b = G.offset;
                const nt = L.end, D = o && F === l, X = D ? " selected" : "";
                let q = 0;
                if (!v || G.divIdx !== v.divIdx ? (v !== null && r(v.divIdx, v.offset, p.offset), C(G)) : r(v.divIdx, v.offset, G.offset), G.divIdx === nt.divIdx)
                  q = r(G.divIdx, G.offset, nt.offset, "highlight" + X);
                else {
                  q = r(G.divIdx, G.offset, p.offset, "highlight begin" + X);
                  for (let j = G.divIdx + 1, z = nt.divIdx; j < z; j++)
                    s[j].className = "highlight middle" + X;
                  C(nt, "highlight end" + X);
                }
                v = nt, D && I.scrollMatchIntoView({
                  element: s[G.divIdx],
                  selectedLeft: q,
                  pageIndex: A,
                  matchIndex: l
                });
              }
              v && r(v.divIdx, v.offset, p.offset);
            }
            _updateMatches(a = !1) {
              if (!this.enabled && !a)
                return;
              const {
                findController: I,
                matches: A,
                pageIdx: g
              } = this, {
                textContentItemsStr: s,
                textDivs: o
              } = this;
              let l = -1;
              for (const p of A) {
                const C = Math.max(l, p.begin.divIdx);
                for (let r = C, i = p.end.divIdx; r <= i; r++) {
                  const w = o[r];
                  w.textContent = s[r], w.className = "";
                }
                l = p.end.divIdx + 1;
              }
              if (!(I != null && I.highlightMatches) || a)
                return;
              const u = I.pageMatches[g] || null, v = I.pageMatchesLength[g] || null;
              this.matches = this._convertMatches(u, v), this._renderMatches(this.matches);
            }
          }
          f.TextHighlighter = y;
        },
        /* 19 */
        /***/
        (P, f, y) => {
          var A, g, s, o, l, Gi, v, Xi;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.TextLayerBuilder = void 0;
          var c = y(4), a = y(2);
          class I {
            constructor({
              highlighter: r = null,
              accessibilityManager: i = null,
              isOffscreenCanvasSupported: w = !0,
              enablePermissions: x = !1
            }) {
              W(this, l);
              W(this, v);
              W(this, A, !1);
              W(this, g, 0);
              W(this, s, 0);
              W(this, o, null);
              this.textContentItemsStr = [], this.renderingDone = !1, this.textDivs = [], this.textDivProperties = /* @__PURE__ */ new WeakMap(), this.textLayerRenderTask = null, this.highlighter = r, this.accessibilityManager = i, this.isOffscreenCanvasSupported = w, rt(this, A, x === !0), this.div = document.createElement("div"), this.div.className = "textLayer", this.hide();
            }
            get numTextDivs() {
              return this.textDivs.length;
            }
            async render(r) {
              var x, b, F;
              if (!e(this, o))
                throw new Error('No "textContentSource" parameter specified.');
              const i = r.scale * (globalThis.devicePixelRatio || 1), {
                rotation: w
              } = r;
              if (this.renderingDone) {
                const L = w !== e(this, g), G = i !== e(this, s);
                (L || G) && (this.hide(), (0, c.updateTextLayer)({
                  container: this.div,
                  viewport: r,
                  textDivs: this.textDivs,
                  textDivProperties: this.textDivProperties,
                  isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,
                  mustRescale: G,
                  mustRotate: L
                }), rt(this, s, i), rt(this, g, w)), this.show();
                return;
              }
              this.cancel(), (x = this.highlighter) == null || x.setTextMapping(this.textDivs, this.textContentItemsStr), (b = this.accessibilityManager) == null || b.setTextMapping(this.textDivs), this.textLayerRenderTask = (0, c.renderTextLayer)({
                textContentSource: e(this, o),
                container: this.div,
                viewport: r,
                textDivs: this.textDivs,
                textDivProperties: this.textDivProperties,
                textContentItemsStr: this.textContentItemsStr,
                isOffscreenCanvasSupported: this.isOffscreenCanvasSupported
              }), await this.textLayerRenderTask.promise, J(this, l, Gi).call(this), rt(this, s, i), rt(this, g, w), this.show(), (F = this.accessibilityManager) == null || F.enable();
            }
            hide() {
              var r;
              this.div.hidden || ((r = this.highlighter) == null || r.disable(), this.div.hidden = !0);
            }
            show() {
              var r;
              this.div.hidden && this.renderingDone && (this.div.hidden = !1, (r = this.highlighter) == null || r.enable());
            }
            cancel() {
              var r, i;
              this.textLayerRenderTask && (this.textLayerRenderTask.cancel(), this.textLayerRenderTask = null), (r = this.highlighter) == null || r.disable(), (i = this.accessibilityManager) == null || i.disable(), this.textContentItemsStr.length = 0, this.textDivs.length = 0, this.textDivProperties = /* @__PURE__ */ new WeakMap();
            }
            setTextContentSource(r) {
              this.cancel(), rt(this, o, r);
            }
          }
          A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakSet(), Gi = function() {
            this.renderingDone = !0;
            const r = document.createElement("div");
            r.className = "endOfContent", this.div.append(r), J(this, v, Xi).call(this);
          }, v = new WeakSet(), Xi = function() {
            const {
              div: r
            } = this;
            r.addEventListener("mousedown", (i) => {
              const w = r.querySelector(".endOfContent");
              if (!w)
                return;
              let x = i.target !== r;
              if (x && (x = getComputedStyle(w).getPropertyValue("-moz-user-select") !== "none"), x) {
                const b = r.getBoundingClientRect(), F = Math.max(0, (i.pageY - b.top) / b.height);
                w.style.top = (F * 100).toFixed(2) + "%";
              }
              w.classList.add("active");
            }), r.addEventListener("mouseup", () => {
              const i = r.querySelector(".endOfContent");
              i && (i.style.top = "", i.classList.remove("active"));
            }), r.addEventListener("copy", (i) => {
              if (!e(this, A)) {
                const w = document.getSelection();
                i.clipboardData.setData("text/plain", (0, a.removeNullCharacters)((0, c.normalizeUnicode)(w.toString())));
              }
              i.preventDefault(), i.stopPropagation();
            });
          }, f.TextLayerBuilder = I;
        },
        /* 20 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.XfaLayerBuilder = void 0;
          var c = y(4);
          class a {
            constructor({
              pageDiv: A,
              pdfPage: g,
              annotationStorage: s = null,
              linkService: o,
              xfaHtml: l = null
            }) {
              this.pageDiv = A, this.pdfPage = g, this.annotationStorage = s, this.linkService = o, this.xfaHtml = l, this.div = null, this._cancelled = !1;
            }
            async render(A, g = "display") {
              if (g === "print") {
                const l = {
                  viewport: A.clone({
                    dontFlip: !0
                  }),
                  div: this.div,
                  xfaHtml: this.xfaHtml,
                  annotationStorage: this.annotationStorage,
                  linkService: this.linkService,
                  intent: g
                }, u = document.createElement("div");
                return this.pageDiv.append(u), l.div = u, c.XfaLayer.render(l);
              }
              const s = await this.pdfPage.getXfa();
              if (this._cancelled || !s)
                return {
                  textDivs: []
                };
              const o = {
                viewport: A.clone({
                  dontFlip: !0
                }),
                div: this.div,
                xfaHtml: s,
                annotationStorage: this.annotationStorage,
                linkService: this.linkService,
                intent: g
              };
              return this.div ? c.XfaLayer.update(o) : (this.div = document.createElement("div"), this.pageDiv.append(this.div), o.div = this.div, c.XfaLayer.render(o));
            }
            cancel() {
              this._cancelled = !0;
            }
            hide() {
              this.div && (this.div.hidden = !0);
            }
          }
          f.XfaLayerBuilder = a;
        },
        /* 21 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFScriptingManager = void 0;
          var c = y(22), a = y(23);
          class I extends a.PDFScriptingManager {
            constructor(g) {
              g.externalServices || window.addEventListener("updatefromsandbox", (s) => {
                g.eventBus.dispatch("updatefromsandbox", {
                  source: window,
                  detail: s.detail
                });
              }), g.externalServices || (g.externalServices = {
                createScripting: ({
                  sandboxBundleSrc: s
                }) => new c.GenericScripting(s)
              }), g.docProperties || (g.docProperties = (s) => (0, c.docProperties)(s)), super(g);
            }
          }
          f.PDFScriptingManager = I;
        },
        /* 22 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.GenericScripting = void 0, f.docProperties = a;
          var c = y(4);
          async function a(A) {
            const g = "", s = g.split("#")[0];
            let {
              info: o,
              metadata: l,
              contentDispositionFilename: u,
              contentLength: v
            } = await A.getMetadata();
            if (!v) {
              const {
                length: p
              } = await A.getDownloadInfo();
              v = p;
            }
            return {
              ...o,
              baseURL: s,
              filesize: v,
              filename: u || (0, c.getPdfFilenameFromUrl)(g),
              metadata: l == null ? void 0 : l.getRaw(),
              authors: l == null ? void 0 : l.get("dc:creator"),
              numPages: A.numPages,
              URL: g
            };
          }
          class I {
            constructor(g) {
              this._ready = (0, c.loadScript)(g, !0).then(() => window.pdfjsSandbox.QuickJSSandbox());
            }
            async createSandbox(g) {
              (await this._ready).create(g);
            }
            async dispatchEventInSandbox(g) {
              const s = await this._ready;
              setTimeout(() => s.dispatchEvent(g), 0);
            }
            async destroySandbox() {
              (await this._ready).nukeSandbox();
            }
          }
          f.GenericScripting = I;
        },
        /* 23 */
        /***/
        (P, f, y) => {
          var A, g, s, o, l, u, v, p, C, r, i, w, Yi, b, Ye, L, Kn, nt, Ki, X, we;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFScriptingManager = void 0;
          var c = y(2), a = y(4);
          class I {
            constructor({
              eventBus: z,
              sandboxBundleSrc: it = null,
              externalServices: Q = null,
              docProperties: Et = null
            }) {
              W(this, w);
              W(this, b);
              W(this, L);
              W(this, nt);
              W(this, X);
              W(this, A, null);
              W(this, g, null);
              W(this, s, null);
              W(this, o, null);
              W(this, l, null);
              W(this, u, null);
              W(this, v, null);
              W(this, p, !1);
              W(this, C, null);
              W(this, r, null);
              W(this, i, null);
              rt(this, o, z), rt(this, C, it), rt(this, l, Q), rt(this, s, Et);
            }
            setViewer(z) {
              rt(this, v, z);
            }
            async setDocument(z) {
              var Ct;
              if (e(this, u) && await J(this, X, we).call(this), rt(this, u, z), !z)
                return;
              const [it, Q, Et] = await Promise.all([z.getFieldObjects(), z.getCalculationOrderIds(), z.getJSActions()]);
              if (!it && !Et) {
                await J(this, X, we).call(this);
                return;
              }
              if (z === e(this, u)) {
                try {
                  rt(this, r, J(this, nt, Ki).call(this));
                } catch (H) {
                  console.error(`setDocument: "${H.message}".`), await J(this, X, we).call(this);
                  return;
                }
                this._internalEvents.set("updatefromsandbox", (H) => {
                  (H == null ? void 0 : H.source) === window && J(this, w, Yi).call(this, H.detail);
                }), this._internalEvents.set("dispatcheventinsandbox", (H) => {
                  var m;
                  (m = e(this, r)) == null || m.dispatchEventInSandbox(H.detail);
                }), this._internalEvents.set("pagechanging", ({
                  pageNumber: H,
                  previous: m
                }) => {
                  H !== m && (J(this, L, Kn).call(this, m), J(this, b, Ye).call(this, H));
                }), this._internalEvents.set("pagerendered", ({
                  pageNumber: H
                }) => {
                  this._pageOpenPending.has(H) && H === e(this, v).currentPageNumber && J(this, b, Ye).call(this, H);
                }), this._internalEvents.set("pagesdestroy", async () => {
                  var H, m;
                  await J(this, L, Kn).call(this, e(this, v).currentPageNumber), await ((H = e(this, r)) == null ? void 0 : H.dispatchEventInSandbox({
                    id: "doc",
                    name: "WillClose"
                  })), (m = e(this, A)) == null || m.resolve();
                });
                for (const [H, m] of this._internalEvents)
                  e(this, o)._on(H, m);
                try {
                  const H = await e(this, s).call(this, z);
                  if (z !== e(this, u))
                    return;
                  await e(this, r).createSandbox({
                    objects: it,
                    calculationOrder: Q,
                    appInfo: {
                      platform: navigator.platform,
                      language: navigator.language
                    },
                    docInfo: {
                      ...H,
                      actions: Et
                    }
                  }), e(this, o).dispatch("sandboxcreated", {
                    source: this
                  });
                } catch (H) {
                  console.error(`setDocument: "${H.message}".`), await J(this, X, we).call(this);
                  return;
                }
                await ((Ct = e(this, r)) == null ? void 0 : Ct.dispatchEventInSandbox({
                  id: "doc",
                  name: "Open"
                })), await J(this, b, Ye).call(this, e(this, v).currentPageNumber, !0), Promise.resolve().then(() => {
                  z === e(this, u) && rt(this, p, !0);
                });
              }
            }
            async dispatchWillSave() {
              var z;
              return (z = e(this, r)) == null ? void 0 : z.dispatchEventInSandbox({
                id: "doc",
                name: "WillSave"
              });
            }
            async dispatchDidSave() {
              var z;
              return (z = e(this, r)) == null ? void 0 : z.dispatchEventInSandbox({
                id: "doc",
                name: "DidSave"
              });
            }
            async dispatchWillPrint() {
              var z;
              if (e(this, r)) {
                await ((z = e(this, i)) == null ? void 0 : z.promise), rt(this, i, new a.PromiseCapability());
                try {
                  await e(this, r).dispatchEventInSandbox({
                    id: "doc",
                    name: "WillPrint"
                  });
                } catch (it) {
                  throw e(this, i).resolve(), rt(this, i, null), it;
                }
                await e(this, i).promise;
              }
            }
            async dispatchDidPrint() {
              var z;
              return (z = e(this, r)) == null ? void 0 : z.dispatchEventInSandbox({
                id: "doc",
                name: "DidPrint"
              });
            }
            get destroyPromise() {
              var z;
              return ((z = e(this, g)) == null ? void 0 : z.promise) || null;
            }
            get ready() {
              return e(this, p);
            }
            get _internalEvents() {
              return (0, a.shadow)(this, "_internalEvents", /* @__PURE__ */ new Map());
            }
            get _pageOpenPending() {
              return (0, a.shadow)(this, "_pageOpenPending", /* @__PURE__ */ new Set());
            }
            get _visitedPages() {
              return (0, a.shadow)(this, "_visitedPages", /* @__PURE__ */ new Map());
            }
          }
          A = new WeakMap(), g = new WeakMap(), s = new WeakMap(), o = new WeakMap(), l = new WeakMap(), u = new WeakMap(), v = new WeakMap(), p = new WeakMap(), C = new WeakMap(), r = new WeakMap(), i = new WeakMap(), w = new WeakSet(), Yi = async function(z) {
            var d, R;
            const it = e(this, v), Q = it.isInPresentationMode || it.isChangingPresentationMode, {
              id: Et,
              siblings: Ct,
              command: H,
              value: m
            } = z;
            if (!Et) {
              switch (H) {
                case "clear":
                  console.clear();
                  break;
                case "error":
                  console.error(m);
                  break;
                case "layout":
                  if (!Q) {
                    const M = (0, c.apiPageLayoutToViewerModes)(m);
                    it.spreadMode = M.spreadMode;
                  }
                  break;
                case "page-num":
                  it.currentPageNumber = m + 1;
                  break;
                case "print":
                  await it.pagesPromise, e(this, o).dispatch("print", {
                    source: this
                  });
                  break;
                case "println":
                  console.log(m);
                  break;
                case "zoom":
                  Q || (it.currentScaleValue = m);
                  break;
                case "SaveAs":
                  e(this, o).dispatch("download", {
                    source: this
                  });
                  break;
                case "FirstPage":
                  it.currentPageNumber = 1;
                  break;
                case "LastPage":
                  it.currentPageNumber = it.pagesCount;
                  break;
                case "NextPage":
                  it.nextPage();
                  break;
                case "PrevPage":
                  it.previousPage();
                  break;
                case "ZoomViewIn":
                  Q || it.increaseScale();
                  break;
                case "ZoomViewOut":
                  Q || it.decreaseScale();
                  break;
                case "WillPrintFinished":
                  (d = e(this, i)) == null || d.resolve(), rt(this, i, null);
                  break;
              }
              return;
            }
            if (Q && z.focus)
              return;
            delete z.id, delete z.siblings;
            const k = Ct ? [Et, ...Ct] : [Et];
            for (const M of k) {
              const B = document.querySelector(`[data-element-id="${M}"]`);
              B ? B.dispatchEvent(new CustomEvent("updatefromsandbox", {
                detail: z
              })) : (R = e(this, u)) == null || R.annotationStorage.setValue(M, z);
            }
          }, b = new WeakSet(), Ye = async function(z, it = !1) {
            const Q = e(this, u), Et = this._visitedPages;
            if (it && rt(this, A, new a.PromiseCapability()), !e(this, A))
              return;
            const Ct = e(this, v).getPageView(z - 1);
            if ((Ct == null ? void 0 : Ct.renderingState) !== c.RenderingStates.FINISHED) {
              this._pageOpenPending.add(z);
              return;
            }
            this._pageOpenPending.delete(z);
            const H = (async () => {
              var k, d;
              const m = await (Et.has(z) ? null : (k = Ct.pdfPage) == null ? void 0 : k.getJSActions());
              Q === e(this, u) && await ((d = e(this, r)) == null ? void 0 : d.dispatchEventInSandbox({
                id: "page",
                name: "PageOpen",
                pageNumber: z,
                actions: m
              }));
            })();
            Et.set(z, H);
          }, L = new WeakSet(), Kn = async function(z) {
            var Ct;
            const it = e(this, u), Q = this._visitedPages;
            if (!e(this, A) || this._pageOpenPending.has(z))
              return;
            const Et = Q.get(z);
            Et && (Q.set(z, null), await Et, it === e(this, u) && await ((Ct = e(this, r)) == null ? void 0 : Ct.dispatchEventInSandbox({
              id: "page",
              name: "PageClose",
              pageNumber: z
            })));
          }, nt = new WeakSet(), Ki = function() {
            if (rt(this, g, new a.PromiseCapability()), e(this, r))
              throw new Error("#initScripting: Scripting already exists.");
            return e(this, l).createScripting({
              sandboxBundleSrc: e(this, C)
            });
          }, X = new WeakSet(), we = async function() {
            var z, it, Q;
            if (!e(this, r)) {
              rt(this, u, null), (z = e(this, g)) == null || z.resolve();
              return;
            }
            e(this, A) && (await Promise.race([e(this, A).promise, new Promise((Et) => {
              setTimeout(Et, 1e3);
            })]).catch(() => {
            }), rt(this, A, null)), rt(this, u, null);
            try {
              await e(this, r).destroySandbox();
            } catch {
            }
            (it = e(this, i)) == null || it.reject(new Error("Scripting destroyed.")), rt(this, i, null);
            for (const [Et, Ct] of this._internalEvents)
              e(this, o)._off(Et, Ct);
            this._internalEvents.clear(), this._pageOpenPending.clear(), this._visitedPages.clear(), rt(this, r, null), rt(this, p, !1), (Q = e(this, g)) == null || Q.resolve();
          }, f.PDFScriptingManager = I;
        },
        /* 24 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFSinglePageViewer = void 0;
          var c = y(2), a = y(25);
          class I extends a.PDFViewer {
            _resetView() {
              super._resetView(), this._scrollMode = c.ScrollMode.PAGE, this._spreadMode = c.SpreadMode.NONE;
            }
            set scrollMode(g) {
            }
            _updateScrollMode() {
            }
            set spreadMode(g) {
            }
            _updateSpreadMode() {
            }
          }
          f.PDFSinglePageViewer = I;
        },
        /* 25 */
        /***/
        (P, f, y) => {
          var C, r, i, jn, x, b, F, L, G, nt, D, X, q, j, z, it, Q, Et, Ct, H, m, k, ji, R, Ji, B, Qi, Z, Zi, dt, Re, lt, Ke, bt, qi, Ot, Jn, gt, tr, ct, oe, vt, Qn, Lt, er, Ht, nr, Wt, Zn, Xt, ir;
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PagesCountLimit = f.PDFViewer = f.PDFPageViewBuffer = void 0;
          var c = y(4), a = y(2), I = y(7), A = y(13), g = y(26), s = y(5);
          const o = 10, l = {
            FORCE_SCROLL_MODE_PAGE: 15e3,
            FORCE_LAZY_PAGE_INIT: 7500,
            PAUSE_EAGER_PAGE_INIT: 250
          };
          f.PagesCountLimit = l;
          function u(Yt) {
            return Object.values(c.AnnotationEditorType).includes(Yt) && Yt !== c.AnnotationEditorType.DISABLE;
          }
          class v {
            constructor(N) {
              W(this, i);
              W(this, C, /* @__PURE__ */ new Set());
              W(this, r, 0);
              rt(this, r, N);
            }
            push(N) {
              const V = e(this, C);
              V.has(N) && V.delete(N), V.add(N), V.size > e(this, r) && J(this, i, jn).call(this);
            }
            resize(N, V = null) {
              rt(this, r, N);
              const K = e(this, C);
              if (V) {
                const st = K.size;
                let ft = 1;
                for (const Y of K)
                  if (V.has(Y.id) && (K.delete(Y), K.add(Y)), ++ft > st)
                    break;
              }
              for (; K.size > e(this, r); )
                J(this, i, jn).call(this);
            }
            has(N) {
              return e(this, C).has(N);
            }
            [Symbol.iterator]() {
              return e(this, C).keys();
            }
          }
          C = new WeakMap(), r = new WeakMap(), i = new WeakSet(), jn = function() {
            const N = e(this, C).keys().next().value;
            N == null || N.destroy(), e(this, C).delete(N);
          }, f.PDFPageViewBuffer = v;
          class p {
            constructor(N) {
              W(this, k);
              W(this, R);
              W(this, B);
              W(this, Z);
              W(this, dt);
              W(this, lt);
              W(this, bt);
              W(this, Ot);
              W(this, gt);
              W(this, ct);
              W(this, vt);
              W(this, Lt);
              W(this, Ht);
              W(this, Wt);
              W(this, Xt);
              W(this, x, null);
              W(this, b, null);
              W(this, F, c.AnnotationEditorType.NONE);
              W(this, L, null);
              W(this, G, c.AnnotationMode.ENABLE_FORMS);
              W(this, nt, null);
              W(this, D, null);
              W(this, X, !1);
              W(this, q, !1);
              W(this, j, null);
              W(this, z, !1);
              W(this, it, 0);
              W(this, Q, new ResizeObserver(J(this, Xt, ir).bind(this)));
              W(this, Et, null);
              W(this, Ct, null);
              W(this, H, null);
              W(this, m, a.TextLayerMode.ENABLE);
              var K, st;
              const V = "3.11.174";
              if (c.version !== V)
                throw new Error(`The API version "${c.version}" does not match the Viewer version "${V}".`);
              if (this.container = N.container, this.viewer = N.viewer || N.container.firstElementChild, ((K = this.container) == null ? void 0 : K.tagName) !== "DIV" || ((st = this.viewer) == null ? void 0 : st.tagName) !== "DIV")
                throw new Error("Invalid `container` and/or `viewer` option.");
              if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute")
                throw new Error("The `container` must be absolutely positioned.");
              e(this, Q).observe(this.container), this.eventBus = N.eventBus, this.linkService = N.linkService || new s.SimpleLinkService(), this.downloadManager = N.downloadManager || null, this.findController = N.findController || null, rt(this, b, N.altTextManager || null), this.findController && (this.findController.onIsPageVisible = (ft) => this._getVisiblePages().ids.has(ft)), this._scriptingManager = N.scriptingManager || null, rt(this, m, N.textLayerMode ?? a.TextLayerMode.ENABLE), rt(this, G, N.annotationMode ?? c.AnnotationMode.ENABLE_FORMS), rt(this, F, N.annotationEditorMode ?? c.AnnotationEditorType.NONE), this.imageResourcesPath = N.imageResourcesPath || "", this.enablePrintAutoRotate = N.enablePrintAutoRotate || !1, this.removePageBorders = N.removePageBorders || !1, N.useOnlyCssZoom && (console.error("useOnlyCssZoom was removed, please use `maxCanvasPixels = 0` instead."), N.maxCanvasPixels = 0), this.isOffscreenCanvasSupported = N.isOffscreenCanvasSupported ?? !0, this.maxCanvasPixels = N.maxCanvasPixels, this.l10n = N.l10n || I.NullL10n, rt(this, X, N.enablePermissions || !1), this.pageColors = N.pageColors || null, this.defaultRenderingQueue = !N.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new g.PDFRenderingQueue(), this.renderingQueue.setViewer(this)) : this.renderingQueue = N.renderingQueue, this.scroll = (0, a.watchScroll)(this.container, this._scrollUpdate.bind(this)), this.presentationModeState = a.PresentationModeState.UNKNOWN, this._onBeforeDraw = this._onAfterDraw = null, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders"), J(this, Wt, Zn).call(this), this.eventBus._on("thumbnailrendered", ({
                pageNumber: ft,
                pdfPage: Y
              }) => {
                const U = this._pages[ft - 1];
                e(this, x).has(U) || Y == null || Y.cleanup();
              });
            }
            get pagesCount() {
              return this._pages.length;
            }
            getPageView(N) {
              return this._pages[N];
            }
            getCachedPageViews() {
              return new Set(e(this, x));
            }
            get pageViewsReady() {
              return this._pagesCapability.settled && this._pages.every((N) => N == null ? void 0 : N.pdfPage);
            }
            get renderForms() {
              return e(this, G) === c.AnnotationMode.ENABLE_FORMS;
            }
            get enableScripting() {
              return !!this._scriptingManager;
            }
            get currentPageNumber() {
              return this._currentPageNumber;
            }
            set currentPageNumber(N) {
              if (!Number.isInteger(N))
                throw new Error("Invalid page number.");
              this.pdfDocument && (this._setCurrentPageNumber(N, !0) || console.error(`currentPageNumber: "${N}" is not a valid page.`));
            }
            _setCurrentPageNumber(N, V = !1) {
              var st;
              if (this._currentPageNumber === N)
                return V && J(this, vt, Qn).call(this), !0;
              if (!(0 < N && N <= this.pagesCount))
                return !1;
              const K = this._currentPageNumber;
              return this._currentPageNumber = N, this.eventBus.dispatch("pagechanging", {
                source: this,
                pageNumber: N,
                pageLabel: ((st = this._pageLabels) == null ? void 0 : st[N - 1]) ?? null,
                previous: K
              }), V && J(this, vt, Qn).call(this), !0;
            }
            get currentPageLabel() {
              var N;
              return ((N = this._pageLabels) == null ? void 0 : N[this._currentPageNumber - 1]) ?? null;
            }
            set currentPageLabel(N) {
              if (!this.pdfDocument)
                return;
              let V = N | 0;
              if (this._pageLabels) {
                const K = this._pageLabels.indexOf(N);
                K >= 0 && (V = K + 1);
              }
              this._setCurrentPageNumber(V, !0) || console.error(`currentPageLabel: "${N}" is not a valid page.`);
            }
            get currentScale() {
              return this._currentScale !== a.UNKNOWN_SCALE ? this._currentScale : a.DEFAULT_SCALE;
            }
            set currentScale(N) {
              if (isNaN(N))
                throw new Error("Invalid numeric scale.");
              this.pdfDocument && J(this, ct, oe).call(this, N, {
                noScroll: !1
              });
            }
            get currentScaleValue() {
              return this._currentScaleValue;
            }
            set currentScaleValue(N) {
              this.pdfDocument && J(this, ct, oe).call(this, N, {
                noScroll: !1
              });
            }
            get pagesRotation() {
              return this._pagesRotation;
            }
            set pagesRotation(N) {
              if (!(0, a.isValidRotation)(N))
                throw new Error("Invalid pages rotation angle.");
              if (!this.pdfDocument || (N %= 360, N < 0 && (N += 360), this._pagesRotation === N))
                return;
              this._pagesRotation = N;
              const V = this._currentPageNumber;
              this.refresh(!0, {
                rotation: N
              }), this._currentScaleValue && J(this, ct, oe).call(this, this._currentScaleValue, {
                noScroll: !0
              }), this.eventBus.dispatch("rotationchanging", {
                source: this,
                pagesRotation: N,
                pageNumber: V
              }), this.defaultRenderingQueue && this.update();
            }
            get firstPagePromise() {
              return this.pdfDocument ? this._firstPageCapability.promise : null;
            }
            get onePageRendered() {
              return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
            }
            get pagesPromise() {
              return this.pdfDocument ? this._pagesCapability.promise : null;
            }
            async getAllText() {
              const N = [], V = [];
              for (let K = 1, st = this.pdfDocument.numPages; K <= st; ++K) {
                if (e(this, z))
                  return null;
                V.length = 0;
                const ft = await this.pdfDocument.getPage(K), {
                  items: Y
                } = await ft.getTextContent();
                for (const U of Y)
                  U.str && V.push(U.str), U.hasEOL && V.push(`
`);
                N.push((0, a.removeNullCharacters)(V.join("")));
              }
              return N.join(`
`);
            }
            setDocument(N) {
              var Y, U;
              if (this.pdfDocument && (this.eventBus.dispatch("pagesdestroy", {
                source: this
              }), this._cancelRendering(), this._resetView(), (Y = this.findController) == null || Y.setDocument(null), (U = this._scriptingManager) == null || U.setDocument(null), e(this, L) && (e(this, L).destroy(), rt(this, L, null))), this.pdfDocument = N, !N)
                return;
              const V = N.numPages, K = N.getPage(1), st = N.getOptionalContentConfig(), ft = e(this, X) ? N.getPermissions() : Promise.resolve();
              if (V > l.FORCE_SCROLL_MODE_PAGE) {
                console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
                const at = this._scrollMode = a.ScrollMode.PAGE;
                this.eventBus.dispatch("scrollmodechanged", {
                  source: this,
                  mode: at
                });
              }
              this._pagesCapability.promise.then(() => {
                this.eventBus.dispatch("pagesloaded", {
                  source: this,
                  pagesCount: V
                });
              }, () => {
              }), this._onBeforeDraw = (at) => {
                const St = this._pages[at.pageNumber - 1];
                St && e(this, x).push(St);
              }, this.eventBus._on("pagerender", this._onBeforeDraw), this._onAfterDraw = (at) => {
                at.cssTransform || this._onePageRenderedCapability.settled || (this._onePageRenderedCapability.resolve({
                  timestamp: at.timestamp
                }), this.eventBus._off("pagerendered", this._onAfterDraw), this._onAfterDraw = null, e(this, Ct) && (document.removeEventListener("visibilitychange", e(this, Ct)), rt(this, Ct, null)));
              }, this.eventBus._on("pagerendered", this._onAfterDraw), Promise.all([K, ft]).then(([at, St]) => {
                var E, $;
                if (N !== this.pdfDocument)
                  return;
                this._firstPageCapability.resolve(at), this._optionalContentConfigPromise = st;
                const {
                  annotationEditorMode: At,
                  annotationMode: Rt,
                  textLayerMode: xt
                } = J(this, R, Ji).call(this, St);
                if (xt !== a.TextLayerMode.DISABLE) {
                  const tt = rt(this, j, document.createElement("div"));
                  tt.id = "hiddenCopyElement", this.viewer.before(tt);
                }
                if (At !== c.AnnotationEditorType.DISABLE) {
                  const tt = At;
                  N.isPureXfa ? console.warn("Warning: XFA-editing is not implemented.") : u(tt) ? (rt(this, L, new c.AnnotationEditorUIManager(this.container, this.viewer, e(this, b), this.eventBus, N, this.pageColors)), tt !== c.AnnotationEditorType.NONE && e(this, L).updateMode(tt)) : console.error(`Invalid AnnotationEditor mode: ${tt}`);
                }
                const Nt = J(this, k, ji).bind(this), kt = this._scrollMode === a.ScrollMode.PAGE ? null : this.viewer, _t = this.currentScale, Bt = at.getViewport({
                  scale: _t * c.PixelsPerInch.PDF_TO_CSS_UNITS
                });
                this.viewer.style.setProperty("--scale-factor", Bt.scale), (((E = this.pageColors) == null ? void 0 : E.foreground) === "CanvasText" || (($ = this.pageColors) == null ? void 0 : $.background) === "Canvas") && this.viewer.style.setProperty("--hcm-highligh-filter", N.filterFactory.addHighlightHCMFilter("CanvasText", "Canvas", "HighlightText", "Highlight"));
                for (let tt = 1; tt <= V; ++tt) {
                  const ht = new A.PDFPageView({
                    container: kt,
                    eventBus: this.eventBus,
                    id: tt,
                    scale: _t,
                    defaultViewport: Bt.clone(),
                    optionalContentConfigPromise: st,
                    renderingQueue: this.renderingQueue,
                    textLayerMode: xt,
                    annotationMode: Rt,
                    imageResourcesPath: this.imageResourcesPath,
                    isOffscreenCanvasSupported: this.isOffscreenCanvasSupported,
                    maxCanvasPixels: this.maxCanvasPixels,
                    pageColors: this.pageColors,
                    l10n: this.l10n,
                    layerProperties: Nt
                  });
                  this._pages.push(ht);
                }
                const et = this._pages[0];
                et && (et.setPdfPage(at), this.linkService.cachePageRef(1, at.ref)), this._scrollMode === a.ScrollMode.PAGE ? J(this, dt, Re).call(this) : this._spreadMode !== a.SpreadMode.NONE && this._updateSpreadMode(), J(this, B, Qi).call(this).then(async () => {
                  var ht, mt;
                  if ((ht = this.findController) == null || ht.setDocument(N), (mt = this._scriptingManager) == null || mt.setDocument(N), e(this, j) && (rt(this, D, J(this, Z, Zi).bind(this, xt)), document.addEventListener("copy", e(this, D))), e(this, L) && this.eventBus.dispatch("annotationeditormodechanged", {
                    source: this,
                    mode: e(this, F)
                  }), N.loadingParams.disableAutoFetch || V > l.FORCE_LAZY_PAGE_INIT) {
                    this._pagesCapability.resolve();
                    return;
                  }
                  let tt = V - 1;
                  if (tt <= 0) {
                    this._pagesCapability.resolve();
                    return;
                  }
                  for (let Pt = 2; Pt <= V; ++Pt) {
                    const Ft = N.getPage(Pt).then((Vt) => {
                      const Dt = this._pages[Pt - 1];
                      Dt.pdfPage || Dt.setPdfPage(Vt), this.linkService.cachePageRef(Pt, Vt.ref), --tt === 0 && this._pagesCapability.resolve();
                    }, (Vt) => {
                      console.error(`Unable to get page ${Pt} to initialize viewer`, Vt), --tt === 0 && this._pagesCapability.resolve();
                    });
                    Pt % l.PAUSE_EAGER_PAGE_INIT === 0 && await Ft;
                  }
                }), this.eventBus.dispatch("pagesinit", {
                  source: this
                }), N.getMetadata().then(({
                  info: tt
                }) => {
                  N === this.pdfDocument && tt.Language && (this.viewer.lang = tt.Language);
                }), this.defaultRenderingQueue && this.update();
              }).catch((at) => {
                console.error("Unable to initialize viewer", at), this._pagesCapability.reject(at);
              });
            }
            setPageLabels(N) {
              var V;
              if (this.pdfDocument) {
                N ? Array.isArray(N) && this.pdfDocument.numPages === N.length ? this._pageLabels = N : (this._pageLabels = null, console.error("setPageLabels: Invalid page labels.")) : this._pageLabels = null;
                for (let K = 0, st = this._pages.length; K < st; K++)
                  this._pages[K].setPageLabel(((V = this._pageLabels) == null ? void 0 : V[K]) ?? null);
              }
            }
            _resetView() {
              this._pages = [], this._currentPageNumber = 1, this._currentScale = a.UNKNOWN_SCALE, this._currentScaleValue = null, this._pageLabels = null, rt(this, x, new v(o)), this._location = null, this._pagesRotation = 0, this._optionalContentConfigPromise = null, this._firstPageCapability = new c.PromiseCapability(), this._onePageRenderedCapability = new c.PromiseCapability(), this._pagesCapability = new c.PromiseCapability(), this._scrollMode = a.ScrollMode.VERTICAL, this._previousScrollMode = a.ScrollMode.UNKNOWN, this._spreadMode = a.SpreadMode.NONE, rt(this, Et, {
                previousPageNumber: 1,
                scrollDown: !0,
                pages: []
              }), this._onBeforeDraw && (this.eventBus._off("pagerender", this._onBeforeDraw), this._onBeforeDraw = null), this._onAfterDraw && (this.eventBus._off("pagerendered", this._onAfterDraw), this._onAfterDraw = null), e(this, Ct) && (document.removeEventListener("visibilitychange", e(this, Ct)), rt(this, Ct, null)), this.viewer.textContent = "", this._updateScrollMode(), this.viewer.removeAttribute("lang"), e(this, j) && (document.removeEventListener("copy", e(this, D)), rt(this, D, null), e(this, j).remove(), rt(this, j, null));
            }
            _scrollUpdate() {
              this.pagesCount !== 0 && this.update();
            }
            pageLabelToPageNumber(N) {
              if (!this._pageLabels)
                return null;
              const V = this._pageLabels.indexOf(N);
              return V < 0 ? null : V + 1;
            }
            scrollPageIntoView({
              pageNumber: N,
              destArray: V = null,
              allowNegativeOffset: K = !1,
              ignoreDestinationZoom: st = !1
            }) {
              if (!this.pdfDocument)
                return;
              const ft = Number.isInteger(N) && this._pages[N - 1];
              if (!ft) {
                console.error(`scrollPageIntoView: "${N}" is not a valid pageNumber parameter.`);
                return;
              }
              if (this.isInPresentationMode || !V) {
                this._setCurrentPageNumber(N, !0);
                return;
              }
              let Y = 0, U = 0, at = 0, St = 0, At, Rt;
              const xt = ft.rotation % 180 !== 0, Nt = (xt ? ft.height : ft.width) / ft.scale / c.PixelsPerInch.PDF_TO_CSS_UNITS, kt = (xt ? ft.width : ft.height) / ft.scale / c.PixelsPerInch.PDF_TO_CSS_UNITS;
              let _t = 0;
              switch (V[1].name) {
                case "XYZ":
                  Y = V[2], U = V[3], _t = V[4], Y = Y !== null ? Y : 0, U = U !== null ? U : kt;
                  break;
                case "Fit":
                case "FitB":
                  _t = "page-fit";
                  break;
                case "FitH":
                case "FitBH":
                  U = V[2], _t = "page-width", U === null && this._location ? (Y = this._location.left, U = this._location.top) : (typeof U != "number" || U < 0) && (U = kt);
                  break;
                case "FitV":
                case "FitBV":
                  Y = V[2], at = Nt, St = kt, _t = "page-height";
                  break;
                case "FitR":
                  Y = V[2], U = V[3], at = V[4] - Y, St = V[5] - U;
                  let $ = a.SCROLLBAR_PADDING, tt = a.VERTICAL_PADDING;
                  this.removePageBorders && ($ = tt = 0), At = (this.container.clientWidth - $) / at / c.PixelsPerInch.PDF_TO_CSS_UNITS, Rt = (this.container.clientHeight - tt) / St / c.PixelsPerInch.PDF_TO_CSS_UNITS, _t = Math.min(Math.abs(At), Math.abs(Rt));
                  break;
                default:
                  console.error(`scrollPageIntoView: "${V[1].name}" is not a valid destination type.`);
                  return;
              }
              if (st || (_t && _t !== this._currentScale ? this.currentScaleValue = _t : this._currentScale === a.UNKNOWN_SCALE && (this.currentScaleValue = a.DEFAULT_SCALE_VALUE)), _t === "page-fit" && !V[4]) {
                J(this, lt, Ke).call(this, ft);
                return;
              }
              const Bt = [ft.viewport.convertToViewportPoint(Y, U), ft.viewport.convertToViewportPoint(Y + at, U + St)];
              let et = Math.min(Bt[0][0], Bt[1][0]), E = Math.min(Bt[0][1], Bt[1][1]);
              K || (et = Math.max(et, 0), E = Math.max(E, 0)), J(this, lt, Ke).call(this, ft, {
                left: et,
                top: E
              });
            }
            _updateLocation(N) {
              const V = this._currentScale, K = this._currentScaleValue, st = parseFloat(K) === V ? Math.round(V * 1e4) / 100 : K, ft = N.id, Y = this._pages[ft - 1], U = this.container, at = Y.getPagePoint(U.scrollLeft - N.x, U.scrollTop - N.y), St = Math.round(at[0]), At = Math.round(at[1]);
              let Rt = `#page=${ft}`;
              this.isInPresentationMode || (Rt += `&zoom=${st},${St},${At}`), this._location = {
                pageNumber: ft,
                scale: st,
                top: At,
                left: St,
                rotation: this._pagesRotation,
                pdfOpenParams: Rt
              };
            }
            update() {
              const N = this._getVisiblePages(), V = N.views, K = V.length;
              if (K === 0)
                return;
              const st = Math.max(o, 2 * K + 1);
              e(this, x).resize(st, N.ids), this.renderingQueue.renderHighestPriority(N);
              const ft = this._spreadMode === a.SpreadMode.NONE && (this._scrollMode === a.ScrollMode.PAGE || this._scrollMode === a.ScrollMode.VERTICAL), Y = this._currentPageNumber;
              let U = !1;
              for (const at of V) {
                if (at.percent < 100)
                  break;
                if (at.id === Y && ft) {
                  U = !0;
                  break;
                }
              }
              this._setCurrentPageNumber(U ? Y : V[0].id), this._updateLocation(N.first), this.eventBus.dispatch("updateviewarea", {
                source: this,
                location: this._location
              });
            }
            containsElement(N) {
              return this.container.contains(N);
            }
            focus() {
              this.container.focus();
            }
            get _isContainerRtl() {
              return getComputedStyle(this.container).direction === "rtl";
            }
            get isInPresentationMode() {
              return this.presentationModeState === a.PresentationModeState.FULLSCREEN;
            }
            get isChangingPresentationMode() {
              return this.presentationModeState === a.PresentationModeState.CHANGING;
            }
            get isHorizontalScrollbarEnabled() {
              return this.isInPresentationMode ? !1 : this.container.scrollWidth > this.container.clientWidth;
            }
            get isVerticalScrollbarEnabled() {
              return this.isInPresentationMode ? !1 : this.container.scrollHeight > this.container.clientHeight;
            }
            _getVisiblePages() {
              const N = this._scrollMode === a.ScrollMode.PAGE ? e(this, Et).pages : this._pages, V = this._scrollMode === a.ScrollMode.HORIZONTAL, K = V && this._isContainerRtl;
              return (0, a.getVisibleElements)({
                scrollEl: this.container,
                views: N,
                sortByVisibility: !0,
                horizontal: V,
                rtl: K
              });
            }
            cleanup() {
              for (const N of this._pages)
                N.renderingState !== a.RenderingStates.FINISHED && N.reset();
            }
            _cancelRendering() {
              for (const N of this._pages)
                N.cancelRendering();
            }
            forceRendering(N) {
              const V = N || this._getVisiblePages(), K = J(this, Ht, nr).call(this, V), st = this._spreadMode !== a.SpreadMode.NONE && this._scrollMode !== a.ScrollMode.HORIZONTAL, ft = this.renderingQueue.getHighestPriority(V, this._pages, K, st);
              return ft ? (J(this, Lt, er).call(this, ft).then(() => {
                this.renderingQueue.renderView(ft);
              }), !0) : !1;
            }
            get hasEqualPageSizes() {
              const N = this._pages[0];
              for (let V = 1, K = this._pages.length; V < K; ++V) {
                const st = this._pages[V];
                if (st.width !== N.width || st.height !== N.height)
                  return !1;
              }
              return !0;
            }
            getPagesOverview() {
              let N;
              return this._pages.map((V) => {
                const K = V.pdfPage.getViewport({
                  scale: 1
                }), st = (0, a.isPortraitOrientation)(K);
                if (N === void 0)
                  N = st;
                else if (this.enablePrintAutoRotate && st !== N)
                  return {
                    width: K.height,
                    height: K.width,
                    rotation: (K.rotation - 90) % 360
                  };
                return {
                  width: K.width,
                  height: K.height,
                  rotation: K.rotation
                };
              });
            }
            get optionalContentConfigPromise() {
              return this.pdfDocument ? this._optionalContentConfigPromise ? this._optionalContentConfigPromise : (console.error("optionalContentConfigPromise: Not initialized yet."), this.pdfDocument.getOptionalContentConfig()) : Promise.resolve(null);
            }
            set optionalContentConfigPromise(N) {
              if (!(N instanceof Promise))
                throw new Error(`Invalid optionalContentConfigPromise: ${N}`);
              this.pdfDocument && this._optionalContentConfigPromise && (this._optionalContentConfigPromise = N, this.refresh(!1, {
                optionalContentConfigPromise: N
              }), this.eventBus.dispatch("optionalcontentconfigchanged", {
                source: this,
                promise: N
              }));
            }
            get scrollMode() {
              return this._scrollMode;
            }
            set scrollMode(N) {
              if (this._scrollMode !== N) {
                if (!(0, a.isValidScrollMode)(N))
                  throw new Error(`Invalid scroll mode: ${N}`);
                this.pagesCount > l.FORCE_SCROLL_MODE_PAGE || (this._previousScrollMode = this._scrollMode, this._scrollMode = N, this.eventBus.dispatch("scrollmodechanged", {
                  source: this,
                  mode: N
                }), this._updateScrollMode(this._currentPageNumber));
              }
            }
            _updateScrollMode(N = null) {
              const V = this._scrollMode, K = this.viewer;
              K.classList.toggle("scrollHorizontal", V === a.ScrollMode.HORIZONTAL), K.classList.toggle("scrollWrapped", V === a.ScrollMode.WRAPPED), !(!this.pdfDocument || !N) && (V === a.ScrollMode.PAGE ? J(this, dt, Re).call(this) : this._previousScrollMode === a.ScrollMode.PAGE && this._updateSpreadMode(), this._currentScaleValue && isNaN(this._currentScaleValue) && J(this, ct, oe).call(this, this._currentScaleValue, {
                noScroll: !0
              }), this._setCurrentPageNumber(N, !0), this.update());
            }
            get spreadMode() {
              return this._spreadMode;
            }
            set spreadMode(N) {
              if (this._spreadMode !== N) {
                if (!(0, a.isValidSpreadMode)(N))
                  throw new Error(`Invalid spread mode: ${N}`);
                this._spreadMode = N, this.eventBus.dispatch("spreadmodechanged", {
                  source: this,
                  mode: N
                }), this._updateSpreadMode(this._currentPageNumber);
              }
            }
            _updateSpreadMode(N = null) {
              if (!this.pdfDocument)
                return;
              const V = this.viewer, K = this._pages;
              if (this._scrollMode === a.ScrollMode.PAGE)
                J(this, dt, Re).call(this);
              else if (V.textContent = "", this._spreadMode === a.SpreadMode.NONE)
                for (const st of this._pages)
                  V.append(st.div);
              else {
                const st = this._spreadMode - 1;
                let ft = null;
                for (let Y = 0, U = K.length; Y < U; ++Y)
                  ft === null ? (ft = document.createElement("div"), ft.className = "spread", V.append(ft)) : Y % 2 === st && (ft = ft.cloneNode(!1), V.append(ft)), ft.append(K[Y].div);
              }
              N && (this._currentScaleValue && isNaN(this._currentScaleValue) && J(this, ct, oe).call(this, this._currentScaleValue, {
                noScroll: !0
              }), this._setCurrentPageNumber(N, !0), this.update());
            }
            _getPageAdvance(N, V = !1) {
              switch (this._scrollMode) {
                case a.ScrollMode.WRAPPED: {
                  const {
                    views: K
                  } = this._getVisiblePages(), st = /* @__PURE__ */ new Map();
                  for (const {
                    id: ft,
                    y: Y,
                    percent: U,
                    widthPercent: at
                  } of K) {
                    if (U === 0 || at < 100)
                      continue;
                    let St = st.get(Y);
                    St || st.set(Y, St || (St = [])), St.push(ft);
                  }
                  for (const ft of st.values()) {
                    const Y = ft.indexOf(N);
                    if (Y === -1)
                      continue;
                    const U = ft.length;
                    if (U === 1)
                      break;
                    if (V)
                      for (let at = Y - 1, St = 0; at >= St; at--) {
                        const At = ft[at], Rt = ft[at + 1] - 1;
                        if (At < Rt)
                          return N - Rt;
                      }
                    else
                      for (let at = Y + 1, St = U; at < St; at++) {
                        const At = ft[at], Rt = ft[at - 1] + 1;
                        if (At > Rt)
                          return Rt - N;
                      }
                    if (V) {
                      const at = ft[0];
                      if (at < N)
                        return N - at + 1;
                    } else {
                      const at = ft[U - 1];
                      if (at > N)
                        return at - N + 1;
                    }
                    break;
                  }
                  break;
                }
                case a.ScrollMode.HORIZONTAL:
                  break;
                case a.ScrollMode.PAGE:
                case a.ScrollMode.VERTICAL: {
                  if (this._spreadMode === a.SpreadMode.NONE)
                    break;
                  const K = this._spreadMode - 1;
                  if (V && N % 2 !== K)
                    break;
                  if (!V && N % 2 === K)
                    break;
                  const {
                    views: st
                  } = this._getVisiblePages(), ft = V ? N - 1 : N + 1;
                  for (const {
                    id: Y,
                    percent: U,
                    widthPercent: at
                  } of st)
                    if (Y === ft) {
                      if (U > 0 && at === 100)
                        return 2;
                      break;
                    }
                  break;
                }
              }
              return 1;
            }
            nextPage() {
              const N = this._currentPageNumber, V = this.pagesCount;
              if (N >= V)
                return !1;
              const K = this._getPageAdvance(N, !1) || 1;
              return this.currentPageNumber = Math.min(N + K, V), !0;
            }
            previousPage() {
              const N = this._currentPageNumber;
              if (N <= 1)
                return !1;
              const V = this._getPageAdvance(N, !0) || 1;
              return this.currentPageNumber = Math.max(N - V, 1), !0;
            }
            increaseScale({
              drawingDelay: N,
              scaleFactor: V,
              steps: K
            } = {}) {
              if (!this.pdfDocument)
                return;
              let st = this._currentScale;
              if (V > 1)
                st = Math.round(st * V * 100) / 100;
              else {
                K ?? (K = 1);
                do
                  st = Math.ceil((st * a.DEFAULT_SCALE_DELTA).toFixed(2) * 10) / 10;
                while (--K > 0 && st < a.MAX_SCALE);
              }
              J(this, ct, oe).call(this, Math.min(a.MAX_SCALE, st), {
                noScroll: !1,
                drawingDelay: N
              });
            }
            decreaseScale({
              drawingDelay: N,
              scaleFactor: V,
              steps: K
            } = {}) {
              if (!this.pdfDocument)
                return;
              let st = this._currentScale;
              if (V > 0 && V < 1)
                st = Math.round(st * V * 100) / 100;
              else {
                K ?? (K = 1);
                do
                  st = Math.floor((st / a.DEFAULT_SCALE_DELTA).toFixed(2) * 10) / 10;
                while (--K > 0 && st > a.MIN_SCALE);
              }
              J(this, ct, oe).call(this, Math.max(a.MIN_SCALE, st), {
                noScroll: !1,
                drawingDelay: N
              });
            }
            get containerTopLeft() {
              return e(this, nt) || rt(this, nt, [this.container.offsetTop, this.container.offsetLeft]);
            }
            get annotationEditorMode() {
              return e(this, L) ? e(this, F) : c.AnnotationEditorType.DISABLE;
            }
            set annotationEditorMode({
              mode: N,
              editId: V = null
            }) {
              if (!e(this, L))
                throw new Error("The AnnotationEditor is not enabled.");
              if (e(this, F) !== N) {
                if (!u(N))
                  throw new Error(`Invalid AnnotationEditor mode: ${N}`);
                this.pdfDocument && (rt(this, F, N), this.eventBus.dispatch("annotationeditormodechanged", {
                  source: this,
                  mode: N
                }), e(this, L).updateMode(N, V));
              }
            }
            set annotationEditorParams({
              type: N,
              value: V
            }) {
              if (!e(this, L))
                throw new Error("The AnnotationEditor is not enabled.");
              e(this, L).updateParams(N, V);
            }
            refresh(N = !1, V = /* @__PURE__ */ Object.create(null)) {
              if (this.pdfDocument) {
                for (const K of this._pages)
                  K.update(V);
                e(this, H) !== null && (clearTimeout(e(this, H)), rt(this, H, null)), N || this.update();
              }
            }
          }
          x = new WeakMap(), b = new WeakMap(), F = new WeakMap(), L = new WeakMap(), G = new WeakMap(), nt = new WeakMap(), D = new WeakMap(), X = new WeakMap(), q = new WeakMap(), j = new WeakMap(), z = new WeakMap(), it = new WeakMap(), Q = new WeakMap(), Et = new WeakMap(), Ct = new WeakMap(), H = new WeakMap(), m = new WeakMap(), k = new WeakSet(), ji = function() {
            const N = this;
            return {
              get annotationEditorUIManager() {
                return e(N, L);
              },
              get annotationStorage() {
                var V;
                return (V = N.pdfDocument) == null ? void 0 : V.annotationStorage;
              },
              get downloadManager() {
                return N.downloadManager;
              },
              get enableScripting() {
                return !!N._scriptingManager;
              },
              get fieldObjectsPromise() {
                var V;
                return (V = N.pdfDocument) == null ? void 0 : V.getFieldObjects();
              },
              get findController() {
                return N.findController;
              },
              get hasJSActionsPromise() {
                var V;
                return (V = N.pdfDocument) == null ? void 0 : V.hasJSActions();
              },
              get linkService() {
                return N.linkService;
              }
            };
          }, R = new WeakSet(), Ji = function(N) {
            const V = {
              annotationEditorMode: e(this, F),
              annotationMode: e(this, G),
              textLayerMode: e(this, m)
            };
            return N && (!N.includes(c.PermissionFlag.COPY) && e(this, m) === a.TextLayerMode.ENABLE && (V.textLayerMode = a.TextLayerMode.ENABLE_PERMISSIONS), N.includes(c.PermissionFlag.MODIFY_CONTENTS) || (V.annotationEditorMode = c.AnnotationEditorType.DISABLE), !N.includes(c.PermissionFlag.MODIFY_ANNOTATIONS) && !N.includes(c.PermissionFlag.FILL_INTERACTIVE_FORMS) && e(this, G) === c.AnnotationMode.ENABLE_FORMS && (V.annotationMode = c.AnnotationMode.ENABLE)), V;
          }, B = new WeakSet(), Qi = function() {
            if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0)
              return Promise.resolve();
            const N = new Promise((V) => {
              rt(this, Ct, () => {
                document.visibilityState === "hidden" && (V(), document.removeEventListener("visibilitychange", e(this, Ct)), rt(this, Ct, null));
              }), document.addEventListener("visibilitychange", e(this, Ct));
            });
            return Promise.race([this._onePageRenderedCapability.promise, N]);
          }, Z = new WeakSet(), Zi = function(N, V) {
            const K = document.getSelection(), {
              focusNode: st,
              anchorNode: ft
            } = K;
            if (ft && st && K.containsNode(e(this, j))) {
              if (e(this, q) || N === a.TextLayerMode.ENABLE_PERMISSIONS) {
                V.preventDefault(), V.stopPropagation();
                return;
              }
              rt(this, q, !0);
              const Y = this.container.style.cursor;
              this.container.style.cursor = "wait";
              const U = (at) => rt(this, z, at.key === "Escape");
              window.addEventListener("keydown", U), this.getAllText().then(async (at) => {
                at !== null && await navigator.clipboard.writeText(at);
              }).catch((at) => {
                console.warn(`Something goes wrong when extracting the text: ${at.message}`);
              }).finally(() => {
                rt(this, q, !1), rt(this, z, !1), window.removeEventListener("keydown", U), this.container.style.cursor = Y;
              }), V.preventDefault(), V.stopPropagation();
            }
          }, dt = new WeakSet(), Re = function() {
            if (this._scrollMode !== a.ScrollMode.PAGE)
              throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
            const N = this._currentPageNumber, V = e(this, Et), K = this.viewer;
            if (K.textContent = "", V.pages.length = 0, this._spreadMode === a.SpreadMode.NONE && !this.isInPresentationMode) {
              const st = this._pages[N - 1];
              K.append(st.div), V.pages.push(st);
            } else {
              const st = /* @__PURE__ */ new Set(), ft = this._spreadMode - 1;
              ft === -1 ? st.add(N - 1) : N % 2 !== ft ? (st.add(N - 1), st.add(N)) : (st.add(N - 2), st.add(N - 1));
              const Y = document.createElement("div");
              if (Y.className = "spread", this.isInPresentationMode) {
                const U = document.createElement("div");
                U.className = "dummyPage", Y.append(U);
              }
              for (const U of st) {
                const at = this._pages[U];
                at && (Y.append(at.div), V.pages.push(at));
              }
              K.append(Y);
            }
            V.scrollDown = N >= V.previousPageNumber, V.previousPageNumber = N;
          }, lt = new WeakSet(), Ke = function(N, V = null) {
            const {
              div: K,
              id: st
            } = N;
            if (this._currentPageNumber !== st && this._setCurrentPageNumber(st), this._scrollMode === a.ScrollMode.PAGE && (J(this, dt, Re).call(this), this.update()), !V && !this.isInPresentationMode) {
              const ft = K.offsetLeft + K.clientLeft, Y = ft + K.clientWidth, {
                scrollLeft: U,
                clientWidth: at
              } = this.container;
              (this._scrollMode === a.ScrollMode.HORIZONTAL || ft < U || Y > U + at) && (V = {
                left: 0,
                top: 0
              });
            }
            (0, a.scrollIntoView)(K, V), !this._currentScaleValue && this._location && (this._location = null);
          }, bt = new WeakSet(), qi = function(N) {
            return N === this._currentScale || Math.abs(N - this._currentScale) < 1e-15;
          }, Ot = new WeakSet(), Jn = function(N, V, {
            noScroll: K = !1,
            preset: st = !1,
            drawingDelay: ft = -1
          }) {
            if (this._currentScaleValue = V.toString(), J(this, bt, qi).call(this, N)) {
              st && this.eventBus.dispatch("scalechanging", {
                source: this,
                scale: N,
                presetValue: V
              });
              return;
            }
            this.viewer.style.setProperty("--scale-factor", N * c.PixelsPerInch.PDF_TO_CSS_UNITS);
            const Y = ft >= 0 && ft < 1e3;
            if (this.refresh(!0, {
              scale: N,
              drawingDelay: Y ? ft : -1
            }), Y && rt(this, H, setTimeout(() => {
              rt(this, H, null), this.refresh();
            }, ft)), this._currentScale = N, !K) {
              let U = this._currentPageNumber, at;
              this._location && !(this.isInPresentationMode || this.isChangingPresentationMode) && (U = this._location.pageNumber, at = [null, {
                name: "XYZ"
              }, this._location.left, this._location.top, null]), this.scrollPageIntoView({
                pageNumber: U,
                destArray: at,
                allowNegativeOffset: !0
              });
            }
            this.eventBus.dispatch("scalechanging", {
              source: this,
              scale: N,
              presetValue: st ? V : void 0
            }), this.defaultRenderingQueue && this.update();
          }, gt = new WeakSet(), tr = function() {
            return this._spreadMode !== a.SpreadMode.NONE && this._scrollMode !== a.ScrollMode.HORIZONTAL ? 2 : 1;
          }, ct = new WeakSet(), oe = function(N, V) {
            let K = parseFloat(N);
            if (K > 0)
              V.preset = !1, J(this, Ot, Jn).call(this, K, N, V);
            else {
              const st = this._pages[this._currentPageNumber - 1];
              if (!st)
                return;
              let ft = a.SCROLLBAR_PADDING, Y = a.VERTICAL_PADDING;
              this.isInPresentationMode ? (ft = Y = 4, this._spreadMode !== a.SpreadMode.NONE && (ft *= 2)) : this.removePageBorders ? ft = Y = 0 : this._scrollMode === a.ScrollMode.HORIZONTAL && ([ft, Y] = [Y, ft]);
              const U = (this.container.clientWidth - ft) / st.width * st.scale / e(this, gt, tr), at = (this.container.clientHeight - Y) / st.height * st.scale;
              switch (N) {
                case "page-actual":
                  K = 1;
                  break;
                case "page-width":
                  K = U;
                  break;
                case "page-height":
                  K = at;
                  break;
                case "page-fit":
                  K = Math.min(U, at);
                  break;
                case "auto":
                  const St = (0, a.isPortraitOrientation)(st) ? U : Math.min(at, U);
                  K = Math.min(a.MAX_AUTO_SCALE, St);
                  break;
                default:
                  console.error(`#setScale: "${N}" is an unknown zoom value.`);
                  return;
              }
              V.preset = !0, J(this, Ot, Jn).call(this, K, N, V);
            }
          }, vt = new WeakSet(), Qn = function() {
            const N = this._pages[this._currentPageNumber - 1];
            this.isInPresentationMode && J(this, ct, oe).call(this, this._currentScaleValue, {
              noScroll: !0
            }), J(this, lt, Ke).call(this, N);
          }, Lt = new WeakSet(), er = async function(N) {
            var V, K;
            if (N.pdfPage)
              return N.pdfPage;
            try {
              const st = await this.pdfDocument.getPage(N.id);
              return N.pdfPage || N.setPdfPage(st), (K = (V = this.linkService)._cachedPageNumber) != null && K.call(V, st.ref) || this.linkService.cachePageRef(N.id, st.ref), st;
            } catch (st) {
              return console.error("Unable to get page for page view", st), null;
            }
          }, Ht = new WeakSet(), nr = function(N) {
            var V, K;
            if (((V = N.first) == null ? void 0 : V.id) === 1)
              return !0;
            if (((K = N.last) == null ? void 0 : K.id) === this.pagesCount)
              return !1;
            switch (this._scrollMode) {
              case a.ScrollMode.PAGE:
                return e(this, Et).scrollDown;
              case a.ScrollMode.HORIZONTAL:
                return this.scroll.right;
            }
            return this.scroll.down;
          }, Wt = new WeakSet(), Zn = function(N = this.container.clientHeight) {
            N !== e(this, it) && (rt(this, it, N), a.docStyle.setProperty("--viewer-container-height", `${N}px`));
          }, Xt = new WeakSet(), ir = function(N) {
            for (const V of N)
              if (V.target === this.container) {
                J(this, Wt, Zn).call(this, Math.floor(V.borderBoxSize[0].blockSize)), rt(this, nt, null);
                break;
              }
          }, f.PDFViewer = p;
        },
        /* 26 */
        /***/
        (P, f, y) => {
          Object.defineProperty(f, "__esModule", {
            value: !0
          }), f.PDFRenderingQueue = void 0;
          var c = y(4), a = y(2);
          const I = 3e4;
          class A {
            constructor() {
              this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1, Object.defineProperty(this, "hasViewer", {
                value: () => !!this.pdfViewer
              });
            }
            setViewer(s) {
              this.pdfViewer = s;
            }
            setThumbnailViewer(s) {
              this.pdfThumbnailViewer = s;
            }
            isHighestPriority(s) {
              return this.highestPriorityPage === s.renderingId;
            }
            renderHighestPriority(s) {
              var o;
              this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), !this.pdfViewer.forceRendering(s) && (this.isThumbnailViewEnabled && ((o = this.pdfThumbnailViewer) != null && o.forceRendering()) || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), I)));
            }
            getHighestPriority(s, o, l, u = !1) {
              const v = s.views, p = v.length;
              if (p === 0)
                return null;
              for (let x = 0; x < p; x++) {
                const b = v[x].view;
                if (!this.isViewFinished(b))
                  return b;
              }
              const C = s.first.id, r = s.last.id;
              if (r - C + 1 > p) {
                const x = s.ids;
                for (let b = 1, F = r - C; b < F; b++) {
                  const L = l ? C + b : r - b;
                  if (x.has(L))
                    continue;
                  const G = o[L - 1];
                  if (!this.isViewFinished(G))
                    return G;
                }
              }
              let i = l ? r : C - 2, w = o[i];
              return w && !this.isViewFinished(w) || u && (i += l ? 1 : -1, w = o[i], w && !this.isViewFinished(w)) ? w : null;
            }
            isViewFinished(s) {
              return s.renderingState === a.RenderingStates.FINISHED;
            }
            renderView(s) {
              switch (s.renderingState) {
                case a.RenderingStates.FINISHED:
                  return !1;
                case a.RenderingStates.PAUSED:
                  this.highestPriorityPage = s.renderingId, s.resume();
                  break;
                case a.RenderingStates.RUNNING:
                  this.highestPriorityPage = s.renderingId;
                  break;
                case a.RenderingStates.INITIAL:
                  this.highestPriorityPage = s.renderingId, s.draw().finally(() => {
                    this.renderHighestPriority();
                  }).catch((o) => {
                    o instanceof c.RenderingCancelledException || console.error(`renderView: "${o}"`);
                  });
                  break;
              }
              return !0;
            }
          }
          f.PDFRenderingQueue = A;
        }
        /******/
      ], n = {};
      function h(P) {
        var f = n[P];
        if (f !== void 0)
          return f.exports;
        var y = n[P] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return t[P](y, y.exports, h), y.exports;
      }
      var T = {};
      return (() => {
        var P = T;
        Object.defineProperty(P, "__esModule", {
          value: !0
        }), Object.defineProperty(P, "AnnotationLayerBuilder", {
          enumerable: !0,
          get: function() {
            return a.AnnotationLayerBuilder;
          }
        }), Object.defineProperty(P, "DownloadManager", {
          enumerable: !0,
          get: function() {
            return I.DownloadManager;
          }
        }), Object.defineProperty(P, "EventBus", {
          enumerable: !0,
          get: function() {
            return A.EventBus;
          }
        }), Object.defineProperty(P, "FindState", {
          enumerable: !0,
          get: function() {
            return f.FindState;
          }
        }), Object.defineProperty(P, "GenericL10n", {
          enumerable: !0,
          get: function() {
            return g.GenericL10n;
          }
        }), Object.defineProperty(P, "LinkTarget", {
          enumerable: !0,
          get: function() {
            return y.LinkTarget;
          }
        }), Object.defineProperty(P, "NullL10n", {
          enumerable: !0,
          get: function() {
            return s.NullL10n;
          }
        }), Object.defineProperty(P, "PDFFindController", {
          enumerable: !0,
          get: function() {
            return f.PDFFindController;
          }
        }), Object.defineProperty(P, "PDFHistory", {
          enumerable: !0,
          get: function() {
            return o.PDFHistory;
          }
        }), Object.defineProperty(P, "PDFLinkService", {
          enumerable: !0,
          get: function() {
            return y.PDFLinkService;
          }
        }), Object.defineProperty(P, "PDFPageView", {
          enumerable: !0,
          get: function() {
            return l.PDFPageView;
          }
        }), Object.defineProperty(P, "PDFScriptingManager", {
          enumerable: !0,
          get: function() {
            return u.PDFScriptingManager;
          }
        }), Object.defineProperty(P, "PDFSinglePageViewer", {
          enumerable: !0,
          get: function() {
            return v.PDFSinglePageViewer;
          }
        }), Object.defineProperty(P, "PDFViewer", {
          enumerable: !0,
          get: function() {
            return p.PDFViewer;
          }
        }), Object.defineProperty(P, "ProgressBar", {
          enumerable: !0,
          get: function() {
            return c.ProgressBar;
          }
        }), Object.defineProperty(P, "RenderingStates", {
          enumerable: !0,
          get: function() {
            return c.RenderingStates;
          }
        }), Object.defineProperty(P, "ScrollMode", {
          enumerable: !0,
          get: function() {
            return c.ScrollMode;
          }
        }), Object.defineProperty(P, "SimpleLinkService", {
          enumerable: !0,
          get: function() {
            return y.SimpleLinkService;
          }
        }), Object.defineProperty(P, "SpreadMode", {
          enumerable: !0,
          get: function() {
            return c.SpreadMode;
          }
        }), Object.defineProperty(P, "StructTreeLayerBuilder", {
          enumerable: !0,
          get: function() {
            return C.StructTreeLayerBuilder;
          }
        }), Object.defineProperty(P, "TextLayerBuilder", {
          enumerable: !0,
          get: function() {
            return r.TextLayerBuilder;
          }
        }), Object.defineProperty(P, "XfaLayerBuilder", {
          enumerable: !0,
          get: function() {
            return i.XfaLayerBuilder;
          }
        }), Object.defineProperty(P, "parseQueryString", {
          enumerable: !0,
          get: function() {
            return c.parseQueryString;
          }
        });
        var f = h(1), y = h(5), c = h(2), a = h(6), I = h(8), A = h(9), g = h(10), s = h(7), o = h(12), l = h(13), u = h(21), v = h(24), p = h(25), C = h(16), r = h(19), i = h(20);
      })(), T;
    })()
  ));
})(pdf_viewer);
var pdf_viewerExports = pdf_viewer.exports;
function addPrintStyles(O, S, t) {
  const n = O.contentWindow.document.createElement("style");
  n.textContent = `
    @page {
      margin: 3mm;
      size: ${S}pt ${t}pt;
    }
    body {
      margin: 0;
    }
    canvas {
      width: 100%;
      page-break-after: always;
      page-break-before: avoid;
      page-break-inside: avoid;
    }
  `, O.contentWindow.document.head.appendChild(n), O.contentWindow.document.body.style.width = "100%";
}
function createPrintIframe(O) {
  return new Promise((S) => {
    const t = document.createElement("iframe");
    t.width = "0", t.height = "0", t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.border = "none", t.style.overflow = "hidden", t.onload = () => S(t), O.appendChild(t);
  });
}
function downloadPdf(O, S) {
  const t = URL.createObjectURL(
    new Blob([O], {
      type: "application/pdf"
    })
  ), n = document.createElement("a");
  n.href = t, n.download = S, n.style.display = "none", document.body.append(n), n.click(), setTimeout(() => {
    URL.revokeObjectURL(t), document.body.removeChild(n);
  }, 1e3);
}
function emptyElement(O) {
  for (; O != null && O.firstChild; )
    O.removeChild(O.firstChild);
}
function releaseChildCanvases(O) {
  O == null || O.querySelectorAll("canvas").forEach((S) => {
    var t;
    S.width = 1, S.height = 1, (t = S.getContext("2d")) == null || t.clearRect(0, 0, 1, 1);
  });
}
const _hoisted_1 = ["id"], _hoisted_2 = ["id"], _hoisted_3 = /* @__PURE__ */ createElementVNode("canvas", null, null, -1), _hoisted_4 = {
  key: 0,
  class: "textLayer"
}, _hoisted_5 = {
  key: 1,
  class: "annotationLayer"
}, _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "VuePdfEmbed",
  props: {
    annotationLayer: { type: Boolean },
    height: {},
    id: {},
    imageResourcesPath: {},
    page: {},
    rotation: { default: 0 },
    scale: { default: 1 },
    source: {},
    textLayer: { type: Boolean },
    width: {}
  },
  emits: ["internal-link-clicked", "loaded", "loading-failed", "password-requested", "progress", "rendered", "rendering-failed"],
  setup(O, { expose: S, emit: t }) {
    const n = O, h = shallowRef([]), T = shallowRef([]), P = ref([]), f = shallowRef(null), { doc: y } = useVuePdfEmbed({
      onError: (u) => {
        h.value = [], t("loading-failed", u);
      },
      onPasswordRequest({ callback: u, isWrongPassword: v }) {
        t("password-requested", { callback: u, isWrongPassword: v });
      },
      onProgress: (u) => {
        t("progress", u);
      },
      source: toRef(n, "source")
    }), c = computed(() => {
      if (!y.value || !n.annotationLayer)
        return null;
      const u = new pdf_viewerExports.PDFLinkService();
      return u.setDocument(y.value), u.setViewer({
        scrollPageIntoView: ({ pageNumber: v }) => {
          t("internal-link-clicked", v);
        }
      }), u;
    }), a = async (u) => {
      if (!y.value)
        return;
      const v = await y.value.getData(), p = await y.value.getMetadata(), C = (
        // @ts-expect-error: contentDispositionFilename is not typed
        u ?? p.contentDispositionFilename ?? ""
      );
      downloadPdf(v, C);
    }, I = (u) => {
      let v, p;
      return n.height && !n.width ? (p = n.height, v = p / u) : (v = n.width ?? f.value.clientWidth, p = v * u), [v, p];
    }, A = async (u = 300, v = "", p = !1) => {
      var b, F, L;
      if (!y.value)
        return;
      const C = u / 72, r = 96 / 72;
      let i, w, x;
      try {
        i = window.document.createElement("div"), i.style.display = "none", window.document.body.appendChild(i), w = await createPrintIframe(i);
        const G = n.page && !p ? [n.page] : [...Array(y.value.numPages + 1).keys()].slice(1);
        await Promise.all(
          G.map(async (nt, D) => {
            const X = await y.value.getPage(nt), q = X.getViewport({
              scale: 1,
              rotation: 0
            });
            if (D === 0) {
              const it = q.width * C / r, Q = q.height * C / r;
              addPrintStyles(w, it, Q);
            }
            const j = window.document.createElement("canvas");
            j.width = q.width * C, j.height = q.height * C, i.appendChild(j);
            const z = j.cloneNode();
            w.contentWindow.document.body.appendChild(z), await X.render({
              canvasContext: j.getContext("2d"),
              intent: "print",
              transform: [C, 0, 0, C, 0, 0],
              viewport: q
            }).promise, z.getContext("2d").drawImage(j, 0, 0);
          })
        ), v && (x = window.document.title, window.document.title = v), (b = w.contentWindow) == null || b.focus(), (F = w.contentWindow) == null || F.print();
      } finally {
        x && (window.document.title = x), releaseChildCanvases(i), (L = i.parentNode) == null || L.removeChild(i);
      }
    }, g = async () => {
      if (y.value)
        try {
          h.value = n.page ? [n.page] : [...Array(y.value.numPages + 1).keys()].slice(1), P.value = Array(h.value.length).fill(1), await Promise.all(
            h.value.map(async (u, v) => {
              const p = await y.value.getPage(u), C = ((n.rotation % 90 === 0 ? n.rotation : 0) + p.rotate) % 360, [r, i, w] = Array.from(T.value[v].children), x = !!(C / 90 % 2), [b, F] = I(
                x ? p.view[2] / p.view[3] : p.view[3] / p.view[2]
              ), L = `${Math.floor(b)}px`, G = `${Math.floor(F)}px`, nt = x ? p.view[3] : p.view[2], D = b / nt, X = p.getViewport({
                scale: D,
                rotation: C
              });
              P.value[v] = D, r.style.width = L, r.style.height = G, i && (i.style.width = x ? G : L, i.style.height = x ? L : G), w && (w.style.width = x ? G : L, w.style.height = x ? L : G), await s(
                p,
                X.clone({
                  scale: X.scale * window.devicePixelRatio * n.scale
                }),
                r
              ), n.textLayer && await l(
                p,
                X.clone({
                  dontFlip: !0
                }),
                i
              ), n.annotationLayer && await o(
                p,
                X.clone({
                  dontFlip: !0
                }),
                w || i
              );
            })
          ), t("rendered");
        } catch (u) {
          h.value = [], P.value = [], t("rendering-failed", u);
        }
    }, s = async (u, v, p) => {
      p.width = v.width, p.height = v.height, await u.render({
        canvasContext: p.getContext("2d"),
        viewport: v
      }).promise;
    }, o = async (u, v, p) => {
      emptyElement(p), new pdfExports.AnnotationLayer({
        accessibilityManager: null,
        annotationCanvasMap: null,
        div: p,
        l10n: null,
        page: u,
        viewport: v
      }).render({
        annotations: await u.getAnnotations(),
        div: p,
        // @ts-expect-error: no downloading assumed
        downloadManager: null,
        imageResourcesPath: n.imageResourcesPath,
        linkService: c.value,
        page: u,
        renderForms: !1,
        viewport: v
      });
    }, l = async (u, v, p) => {
      emptyElement(p), await pdfExports.renderTextLayer({
        container: p,
        textContentSource: await u.getTextContent(),
        viewport: v
      }).promise;
    };
    return watch(
      y,
      () => {
        y.value && t("loaded", y.value);
      },
      { immediate: !0 }
    ), watch(
      () => n.source,
      () => {
        releaseChildCanvases(f.value);
      }
    ), watch(
      () => [
        y.value,
        n.annotationLayer,
        n.height,
        n.imageResourcesPath,
        n.page,
        n.rotation,
        n.scale,
        n.textLayer,
        n.width
      ],
      () => {
        y.value && g();
      },
      { immediate: !0 }
    ), onBeforeUnmount(() => {
      releaseChildCanvases(f.value);
    }), S({
      doc: y,
      download: a,
      print: A
    }), (u, v) => (openBlock(), createElementBlock("div", {
      id: u.id,
      ref_key: "root",
      ref: f,
      class: "vue-pdf-embed"
    }, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(h.value, (p, C) => (openBlock(), createElementBlock("div", { key: p }, [
        renderSlot(u.$slots, "before-page", { page: p }),
        createElementVNode("div", {
          id: u.id && `${u.id}-${p}`,
          ref_for: !0,
          ref_key: "pageRefs",
          ref: T,
          class: "vue-pdf-embed__page",
          style: normalizeStyle({
            "--scale-factor": P.value[C]
          })
        }, [
          _hoisted_3,
          u.textLayer ? (openBlock(), createElementBlock("div", _hoisted_4)) : createCommentVNode("", !0),
          u.annotationLayer ? (openBlock(), createElementBlock("div", _hoisted_5)) : createCommentVNode("", !0)
        ], 12, _hoisted_2),
        renderSlot(u.$slots, "after-page", { page: p })
      ]))), 128))
    ], 8, _hoisted_1));
  }
}), VuePdfEmbed_vue_vue_type_style_index_0_lang = "", GlobalWorkerOptions = pdfExports.GlobalWorkerOptions;
export {
  GlobalWorkerOptions,
  _sfc_main as default,
  useVuePdfEmbed
};
