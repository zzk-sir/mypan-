var y0 = Object.defineProperty;
var A0 = (l, e, t) => e in l ? y0(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t;
var K = (l, e, t) => (A0(l, typeof e != "symbol" ? e + "" : e, t), t), Kg = (l, e, t) => {
  if (!e.has(l))
    throw TypeError("Cannot " + t);
};
var o = (l, e, t) => (Kg(l, e, "read from private field"), t ? t.call(l) : e.get(l)), p = (l, e, t) => {
  if (e.has(l))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(l) : e.set(l, t);
}, b = (l, e, t, s) => (Kg(l, e, "write to private field"), s ? s.call(l, t) : e.set(l, t), t);
var oe = (l, e, t, s) => ({
  set _(i) {
    b(l, e, i, t);
  },
  get _() {
    return o(l, e, s);
  }
}), v = (l, e, t) => (Kg(l, e, "access private method"), t);
import { shallowRef as sf, watchEffect as E0, toValue as yb, watch as cm, onBeforeUnmount as Cy, defineComponent as w0, ref as S0, toRef as x0, computed as P0, openBlock as ll, createElementBlock as hl, Fragment as T0, renderList as C0, renderSlot as Ab, createElementVNode as Ry, normalizeStyle as R0, createCommentVNode as Eb } from "vue";
var I0 = {
  /***/
  9306: (
    /***/
    (l, e, t) => {
      var s = t(4901), i = t(6823), n = TypeError;
      l.exports = function(r) {
        if (s(r))
          return r;
        throw new n(i(r) + " is not a function");
      };
    }
  ),
  /***/
  3506: (
    /***/
    (l, e, t) => {
      var s = t(3925), i = String, n = TypeError;
      l.exports = function(r) {
        if (s(r))
          return r;
        throw new n("Can't set " + i(r) + " as a prototype");
      };
    }
  ),
  /***/
  7080: (
    /***/
    (l, e, t) => {
      var s = t(4402).has;
      l.exports = function(i) {
        return s(i), i;
      };
    }
  ),
  /***/
  679: (
    /***/
    (l, e, t) => {
      var s = t(1625), i = TypeError;
      l.exports = function(n, r) {
        if (s(r, n))
          return n;
        throw new i("Incorrect invocation");
      };
    }
  ),
  /***/
  8551: (
    /***/
    (l, e, t) => {
      var s = t(34), i = String, n = TypeError;
      l.exports = function(r) {
        if (s(r))
          return r;
        throw new n(i(r) + " is not an object");
      };
    }
  ),
  /***/
  7811: (
    /***/
    (l) => {
      l.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
    }
  ),
  /***/
  7394: (
    /***/
    (l, e, t) => {
      var s = t(6706), i = t(4576), n = TypeError;
      l.exports = s(ArrayBuffer.prototype, "byteLength", "get") || function(r) {
        if (i(r) !== "ArrayBuffer")
          throw new n("ArrayBuffer expected");
        return r.byteLength;
      };
    }
  ),
  /***/
  3238: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(7394), n = s(ArrayBuffer.prototype.slice);
      l.exports = function(r) {
        if (i(r) !== 0)
          return !1;
        try {
          return n(r, 0, 0), !1;
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  5636: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(9504), n = t(6706), r = t(7696), a = t(3238), h = t(7394), c = t(4483), d = t(1548), u = s.structuredClone, f = s.ArrayBuffer, m = s.DataView, g = s.TypeError, A = Math.min, E = f.prototype, y = m.prototype, w = i(E.slice), S = n(E, "resizable", "get"), C = n(E, "maxByteLength", "get"), P = i(y.getInt8), x = i(y.setInt8);
      l.exports = (d || c) && function(R, M, T) {
        var I = h(R), _ = M === void 0 ? I : r(M), k = !S || !S(R), F;
        if (a(R))
          throw new g("ArrayBuffer is detached");
        if (d && (R = u(R, { transfer: [R] }), I === _ && (T || k)))
          return R;
        if (I >= _ && (!T || k))
          F = w(R, 0, _);
        else {
          var V = T && !k && C ? { maxByteLength: C(R) } : void 0;
          F = new f(_, V);
          for (var $ = new m(R), L = new m(F), B = A(_, I), j = 0; j < B; j++)
            x(L, j, P($, j));
        }
        return d || c(R), F;
      };
    }
  ),
  /***/
  4644: (
    /***/
    (l, e, t) => {
      var s = t(7811), i = t(3724), n = t(4475), r = t(4901), a = t(34), h = t(9297), c = t(6955), d = t(6823), u = t(6699), f = t(6840), m = t(2106), g = t(1625), A = t(2787), E = t(2967), y = t(8227), w = t(3392), S = t(1181), C = S.enforce, P = S.get, x = n.Int8Array, R = x && x.prototype, M = n.Uint8ClampedArray, T = M && M.prototype, I = x && A(x), _ = R && A(R), k = Object.prototype, F = n.TypeError, V = y("toStringTag"), $ = w("TYPED_ARRAY_TAG"), L = "TypedArrayConstructor", B = s && !!E && c(n.opera) !== "Opera", j = !1, ot, mt, ae, lt = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, dt = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, bi = function(vt) {
        if (!a(vt))
          return !1;
        var bt = c(vt);
        return bt === "DataView" || h(lt, bt) || h(dt, bt);
      }, Pe = function(W) {
        var vt = A(W);
        if (a(vt)) {
          var bt = P(vt);
          return bt && h(bt, L) ? bt[L] : Pe(vt);
        }
      }, H = function(W) {
        if (!a(W))
          return !1;
        var vt = c(W);
        return h(lt, vt) || h(dt, vt);
      }, O = function(W) {
        if (H(W))
          return W;
        throw new F("Target is not a typed array");
      }, N = function(W) {
        if (r(W) && (!E || g(I, W)))
          return W;
        throw new F(d(W) + " is not a typed array constructor");
      }, Y = function(W, vt, bt, ts) {
        if (i) {
          if (bt)
            for (var qt in lt) {
              var Dt = n[qt];
              if (Dt && h(Dt.prototype, W))
                try {
                  delete Dt.prototype[W];
                } catch {
                  try {
                    Dt.prototype[W] = vt;
                  } catch {
                  }
                }
            }
          (!_[W] || bt) && f(_, W, bt ? vt : B && R[W] || vt, ts);
        }
      }, ut = function(W, vt, bt) {
        var ts, qt;
        if (i) {
          if (E) {
            if (bt) {
              for (ts in lt)
                if (qt = n[ts], qt && h(qt, W))
                  try {
                    delete qt[W];
                  } catch {
                  }
            }
            if (!I[W] || bt)
              try {
                return f(I, W, bt ? vt : B && I[W] || vt);
              } catch {
              }
            else
              return;
          }
          for (ts in lt)
            qt = n[ts], qt && (!qt[W] || bt) && f(qt, W, vt);
        }
      };
      for (ot in lt)
        mt = n[ot], ae = mt && mt.prototype, ae ? C(ae)[L] = mt : B = !1;
      for (ot in dt)
        mt = n[ot], ae = mt && mt.prototype, ae && (C(ae)[L] = mt);
      if ((!B || !r(I) || I === Function.prototype) && (I = function() {
        throw new F("Incorrect invocation");
      }, B))
        for (ot in lt)
          n[ot] && E(n[ot], I);
      if ((!B || !_ || _ === k) && (_ = I.prototype, B))
        for (ot in lt)
          n[ot] && E(n[ot].prototype, _);
      if (B && A(T) !== _ && E(T, _), i && !h(_, V)) {
        j = !0, m(_, V, {
          configurable: !0,
          get: function() {
            return a(this) ? this[$] : void 0;
          }
        });
        for (ot in lt)
          n[ot] && u(n[ot], $, ot);
      }
      l.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: B,
        TYPED_ARRAY_TAG: j && $,
        aTypedArray: O,
        aTypedArrayConstructor: N,
        exportTypedArrayMethod: Y,
        exportTypedArrayStaticMethod: ut,
        getTypedArrayConstructor: Pe,
        isView: bi,
        isTypedArray: H,
        TypedArray: I,
        TypedArrayPrototype: _
      };
    }
  ),
  /***/
  5370: (
    /***/
    (l, e, t) => {
      var s = t(6198);
      l.exports = function(i, n, r) {
        for (var a = 0, h = arguments.length > 2 ? r : s(n), c = new i(h); h > a; )
          c[a] = n[a++];
        return c;
      };
    }
  ),
  /***/
  9617: (
    /***/
    (l, e, t) => {
      var s = t(5397), i = t(5610), n = t(6198), r = function(a) {
        return function(h, c, d) {
          var u = s(h), f = n(u);
          if (f === 0)
            return !a && -1;
          var m = i(d, f), g;
          if (a && c !== c) {
            for (; f > m; )
              if (g = u[m++], g !== g)
                return !0;
          } else
            for (; f > m; m++)
              if ((a || m in u) && u[m] === c)
                return a || m || 0;
          return !a && -1;
        };
      };
      l.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: r(!0),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: r(!1)
      };
    }
  ),
  /***/
  4527: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(4376), n = TypeError, r = Object.getOwnPropertyDescriptor, a = s && !function() {
        if (this !== void 0)
          return !0;
        try {
          Object.defineProperty([], "length", { writable: !1 }).length = 1;
        } catch (h) {
          return h instanceof TypeError;
        }
      }();
      l.exports = a ? function(h, c) {
        if (i(h) && !r(h, "length").writable)
          throw new n("Cannot set read only .length");
        return h.length = c;
      } : function(h, c) {
        return h.length = c;
      };
    }
  ),
  /***/
  7628: (
    /***/
    (l, e, t) => {
      var s = t(6198);
      l.exports = function(i, n) {
        for (var r = s(i), a = new n(r), h = 0; h < r; h++)
          a[h] = i[r - h - 1];
        return a;
      };
    }
  ),
  /***/
  9928: (
    /***/
    (l, e, t) => {
      var s = t(6198), i = t(1291), n = RangeError;
      l.exports = function(r, a, h, c) {
        var d = s(r), u = i(h), f = u < 0 ? d + u : u;
        if (f >= d || f < 0)
          throw new n("Incorrect index");
        for (var m = new a(d), g = 0; g < d; g++)
          m[g] = g === f ? c : r[g];
        return m;
      };
    }
  ),
  /***/
  6319: (
    /***/
    (l, e, t) => {
      var s = t(8551), i = t(9539);
      l.exports = function(n, r, a, h) {
        try {
          return h ? r(s(a)[0], a[1]) : r(a);
        } catch (c) {
          i(n, "throw", c);
        }
      };
    }
  ),
  /***/
  4576: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = s({}.toString), n = s("".slice);
      l.exports = function(r) {
        return n(i(r), 8, -1);
      };
    }
  ),
  /***/
  6955: (
    /***/
    (l, e, t) => {
      var s = t(2140), i = t(4901), n = t(4576), r = t(8227), a = r("toStringTag"), h = Object, c = n(function() {
        return arguments;
      }()) === "Arguments", d = function(u, f) {
        try {
          return u[f];
        } catch {
        }
      };
      l.exports = s ? n : function(u) {
        var f, m, g;
        return u === void 0 ? "Undefined" : u === null ? "Null" : typeof (m = d(f = h(u), a)) == "string" ? m : c ? n(f) : (g = n(f)) === "Object" && i(f.callee) ? "Arguments" : g;
      };
    }
  ),
  /***/
  7740: (
    /***/
    (l, e, t) => {
      var s = t(9297), i = t(5031), n = t(7347), r = t(4913);
      l.exports = function(a, h, c) {
        for (var d = i(h), u = r.f, f = n.f, m = 0; m < d.length; m++) {
          var g = d[m];
          !s(a, g) && !(c && s(c, g)) && u(a, g, f(h, g));
        }
      };
    }
  ),
  /***/
  2211: (
    /***/
    (l, e, t) => {
      var s = t(9039);
      l.exports = !s(function() {
        function i() {
        }
        return i.prototype.constructor = null, Object.getPrototypeOf(new i()) !== i.prototype;
      });
    }
  ),
  /***/
  2529: (
    /***/
    (l) => {
      l.exports = function(e, t) {
        return { value: e, done: t };
      };
    }
  ),
  /***/
  6699: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(4913), n = t(6980);
      l.exports = s ? function(r, a, h) {
        return i.f(r, a, n(1, h));
      } : function(r, a, h) {
        return r[a] = h, r;
      };
    }
  ),
  /***/
  6980: (
    /***/
    (l) => {
      l.exports = function(e, t) {
        return {
          enumerable: !(e & 1),
          configurable: !(e & 2),
          writable: !(e & 4),
          value: t
        };
      };
    }
  ),
  /***/
  4659: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(4913), n = t(6980);
      l.exports = function(r, a, h) {
        s ? i.f(r, a, n(0, h)) : r[a] = h;
      };
    }
  ),
  /***/
  2106: (
    /***/
    (l, e, t) => {
      var s = t(283), i = t(4913);
      l.exports = function(n, r, a) {
        return a.get && s(a.get, r, { getter: !0 }), a.set && s(a.set, r, { setter: !0 }), i.f(n, r, a);
      };
    }
  ),
  /***/
  6840: (
    /***/
    (l, e, t) => {
      var s = t(4901), i = t(4913), n = t(283), r = t(9433);
      l.exports = function(a, h, c, d) {
        d || (d = {});
        var u = d.enumerable, f = d.name !== void 0 ? d.name : h;
        if (s(c) && n(c, f, d), d.global)
          u ? a[h] = c : r(h, c);
        else {
          try {
            d.unsafe ? a[h] && (u = !0) : delete a[h];
          } catch {
          }
          u ? a[h] = c : i.f(a, h, {
            value: c,
            enumerable: !1,
            configurable: !d.nonConfigurable,
            writable: !d.nonWritable
          });
        }
        return a;
      };
    }
  ),
  /***/
  6279: (
    /***/
    (l, e, t) => {
      var s = t(6840);
      l.exports = function(i, n, r) {
        for (var a in n)
          s(i, a, n[a], r);
        return i;
      };
    }
  ),
  /***/
  9433: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = Object.defineProperty;
      l.exports = function(n, r) {
        try {
          i(s, n, { value: r, configurable: !0, writable: !0 });
        } catch {
          s[n] = r;
        }
        return r;
      };
    }
  ),
  /***/
  3724: (
    /***/
    (l, e, t) => {
      var s = t(9039);
      l.exports = !s(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  ),
  /***/
  4483: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(9714), n = t(1548), r = s.structuredClone, a = s.ArrayBuffer, h = s.MessageChannel, c = !1, d, u, f, m;
      if (n)
        c = function(g) {
          r(g, { transfer: [g] });
        };
      else if (a)
        try {
          h || (d = i("worker_threads"), d && (h = d.MessageChannel)), h && (u = new h(), f = new a(2), m = function(g) {
            u.port1.postMessage(null, [g]);
          }, f.byteLength === 2 && (m(f), f.byteLength === 0 && (c = m)));
        } catch {
        }
      l.exports = c;
    }
  ),
  /***/
  4055: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(34), n = s.document, r = i(n) && i(n.createElement);
      l.exports = function(a) {
        return r ? n.createElement(a) : {};
      };
    }
  ),
  /***/
  6837: (
    /***/
    (l) => {
      var e = TypeError, t = 9007199254740991;
      l.exports = function(s) {
        if (s > t)
          throw e("Maximum allowed index exceeded");
        return s;
      };
    }
  ),
  /***/
  5002: (
    /***/
    (l) => {
      l.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  ),
  /***/
  7290: (
    /***/
    (l, e, t) => {
      var s = t(516), i = t(9088);
      l.exports = !s && !i && typeof window == "object" && typeof document == "object";
    }
  ),
  /***/
  516: (
    /***/
    (l) => {
      l.exports = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    }
  ),
  /***/
  9088: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(4576);
      l.exports = i(s.process) === "process";
    }
  ),
  /***/
  9392: (
    /***/
    (l) => {
      l.exports = typeof navigator < "u" && String(navigator.userAgent) || "";
    }
  ),
  /***/
  7388: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(9392), n = s.process, r = s.Deno, a = n && n.versions || r && r.version, h = a && a.v8, c, d;
      h && (c = h.split("."), d = c[0] > 0 && c[0] < 4 ? 1 : +(c[0] + c[1])), !d && i && (c = i.match(/Edge\/(\d+)/), (!c || c[1] >= 74) && (c = i.match(/Chrome\/(\d+)/), c && (d = +c[1]))), l.exports = d;
    }
  ),
  /***/
  8727: (
    /***/
    (l) => {
      l.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  ),
  /***/
  6193: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = Error, n = s("".replace), r = function(c) {
        return String(new i(c).stack);
      }("zxcasd"), a = /\n\s*at [^:]*:[^\n]*/, h = a.test(r);
      l.exports = function(c, d) {
        if (h && typeof c == "string" && !i.prepareStackTrace)
          for (; d--; )
            c = n(c, a, "");
        return c;
      };
    }
  ),
  /***/
  6518: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(7347).f, n = t(6699), r = t(6840), a = t(9433), h = t(7740), c = t(2796);
      l.exports = function(d, u) {
        var f = d.target, m = d.global, g = d.stat, A, E, y, w, S, C;
        if (m ? E = s : g ? E = s[f] || a(f, {}) : E = s[f] && s[f].prototype, E)
          for (y in u) {
            if (S = u[y], d.dontCallGetSet ? (C = i(E, y), w = C && C.value) : w = E[y], A = c(m ? y : f + (g ? "." : "#") + y, d.forced), !A && w !== void 0) {
              if (typeof S == typeof w)
                continue;
              h(S, w);
            }
            (d.sham || w && w.sham) && n(S, "sham", !0), r(E, y, S, d);
          }
      };
    }
  ),
  /***/
  9039: (
    /***/
    (l) => {
      l.exports = function(e) {
        try {
          return !!e();
        } catch {
          return !0;
        }
      };
    }
  ),
  /***/
  6080: (
    /***/
    (l, e, t) => {
      var s = t(7476), i = t(9306), n = t(616), r = s(s.bind);
      l.exports = function(a, h) {
        return i(a), h === void 0 ? a : n ? r(a, h) : function() {
          return a.apply(h, arguments);
        };
      };
    }
  ),
  /***/
  616: (
    /***/
    (l, e, t) => {
      var s = t(9039);
      l.exports = !s(function() {
        var i = (function() {
        }).bind();
        return typeof i != "function" || i.hasOwnProperty("prototype");
      });
    }
  ),
  /***/
  9565: (
    /***/
    (l, e, t) => {
      var s = t(616), i = Function.prototype.call;
      l.exports = s ? i.bind(i) : function() {
        return i.apply(i, arguments);
      };
    }
  ),
  /***/
  350: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9297), n = Function.prototype, r = s && Object.getOwnPropertyDescriptor, a = i(n, "name"), h = a && (function() {
      }).name === "something", c = a && (!s || s && r(n, "name").configurable);
      l.exports = {
        EXISTS: a,
        PROPER: h,
        CONFIGURABLE: c
      };
    }
  ),
  /***/
  6706: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9306);
      l.exports = function(n, r, a) {
        try {
          return s(i(Object.getOwnPropertyDescriptor(n, r)[a]));
        } catch {
        }
      };
    }
  ),
  /***/
  7476: (
    /***/
    (l, e, t) => {
      var s = t(4576), i = t(9504);
      l.exports = function(n) {
        if (s(n) === "Function")
          return i(n);
      };
    }
  ),
  /***/
  9504: (
    /***/
    (l, e, t) => {
      var s = t(616), i = Function.prototype, n = i.call, r = s && i.bind.bind(n, n);
      l.exports = s ? r : function(a) {
        return function() {
          return n.apply(a, arguments);
        };
      };
    }
  ),
  /***/
  7751: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(4901), n = function(r) {
        return i(r) ? r : void 0;
      };
      l.exports = function(r, a) {
        return arguments.length < 2 ? n(s[r]) : s[r] && s[r][a];
      };
    }
  ),
  /***/
  1767: (
    /***/
    (l) => {
      l.exports = function(e) {
        return {
          iterator: e,
          next: e.next,
          done: !1
        };
      };
    }
  ),
  /***/
  8646: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(8551), n = t(1767), r = t(851);
      l.exports = function(a, h) {
        (!h || typeof a != "string") && i(a);
        var c = r(a);
        return n(i(c !== void 0 ? s(c, a) : a));
      };
    }
  ),
  /***/
  851: (
    /***/
    (l, e, t) => {
      var s = t(6955), i = t(5966), n = t(4117), r = t(6269), a = t(8227), h = a("iterator");
      l.exports = function(c) {
        if (!n(c))
          return i(c, h) || i(c, "@@iterator") || r[s(c)];
      };
    }
  ),
  /***/
  81: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(9306), n = t(8551), r = t(6823), a = t(851), h = TypeError;
      l.exports = function(c, d) {
        var u = arguments.length < 2 ? a(c) : d;
        if (i(u))
          return n(s(u, c));
        throw new h(r(c) + " is not iterable");
      };
    }
  ),
  /***/
  5966: (
    /***/
    (l, e, t) => {
      var s = t(9306), i = t(4117);
      l.exports = function(n, r) {
        var a = n[r];
        return i(a) ? void 0 : s(a);
      };
    }
  ),
  /***/
  3789: (
    /***/
    (l, e, t) => {
      var s = t(9306), i = t(8551), n = t(9565), r = t(1291), a = t(1767), h = "Invalid size", c = RangeError, d = TypeError, u = Math.max, f = function(m, g) {
        this.set = m, this.size = u(g, 0), this.has = s(m.has), this.keys = s(m.keys);
      };
      f.prototype = {
        getIterator: function() {
          return a(i(n(this.keys, this.set)));
        },
        includes: function(m) {
          return n(this.has, this.set, m);
        }
      }, l.exports = function(m) {
        i(m);
        var g = +m.size;
        if (g !== g)
          throw new d(h);
        var A = r(g);
        if (A < 0)
          throw new c(h);
        return new f(m, A);
      };
    }
  ),
  /***/
  4475: (
    /***/
    function(l) {
      var e = function(t) {
        return t && t.Math === Math && t;
      };
      l.exports = // eslint-disable-next-line es/no-global-this -- safe
      e(typeof globalThis == "object" && globalThis) || e(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      e(typeof self == "object" && self) || e(typeof global == "object" && global) || e(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
      function() {
        return this;
      }() || Function("return this")();
    }
  ),
  /***/
  9297: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(8981), n = s({}.hasOwnProperty);
      l.exports = Object.hasOwn || function(a, h) {
        return n(i(a), h);
      };
    }
  ),
  /***/
  421: (
    /***/
    (l) => {
      l.exports = {};
    }
  ),
  /***/
  397: (
    /***/
    (l, e, t) => {
      var s = t(7751);
      l.exports = s("document", "documentElement");
    }
  ),
  /***/
  5917: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9039), n = t(4055);
      l.exports = !s && !i(function() {
        return Object.defineProperty(n("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  ),
  /***/
  7055: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9039), n = t(4576), r = Object, a = s("".split);
      l.exports = i(function() {
        return !r("z").propertyIsEnumerable(0);
      }) ? function(h) {
        return n(h) === "String" ? a(h, "") : r(h);
      } : r;
    }
  ),
  /***/
  3167: (
    /***/
    (l, e, t) => {
      var s = t(4901), i = t(34), n = t(2967);
      l.exports = function(r, a, h) {
        var c, d;
        return (
          // it can work only with native `setPrototypeOf`
          n && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          s(c = a.constructor) && c !== h && i(d = c.prototype) && d !== h.prototype && n(r, d), r
        );
      };
    }
  ),
  /***/
  3706: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(4901), n = t(7629), r = s(Function.toString);
      i(n.inspectSource) || (n.inspectSource = function(a) {
        return r(a);
      }), l.exports = n.inspectSource;
    }
  ),
  /***/
  1181: (
    /***/
    (l, e, t) => {
      var s = t(8622), i = t(4475), n = t(34), r = t(6699), a = t(9297), h = t(7629), c = t(6119), d = t(421), u = "Object already initialized", f = i.TypeError, m = i.WeakMap, g, A, E, y = function(P) {
        return E(P) ? A(P) : g(P, {});
      }, w = function(P) {
        return function(x) {
          var R;
          if (!n(x) || (R = A(x)).type !== P)
            throw new f("Incompatible receiver, " + P + " required");
          return R;
        };
      };
      if (s || h.state) {
        var S = h.state || (h.state = new m());
        S.get = S.get, S.has = S.has, S.set = S.set, g = function(P, x) {
          if (S.has(P))
            throw new f(u);
          return x.facade = P, S.set(P, x), x;
        }, A = function(P) {
          return S.get(P) || {};
        }, E = function(P) {
          return S.has(P);
        };
      } else {
        var C = c("state");
        d[C] = !0, g = function(P, x) {
          if (a(P, C))
            throw new f(u);
          return x.facade = P, r(P, C, x), x;
        }, A = function(P) {
          return a(P, C) ? P[C] : {};
        }, E = function(P) {
          return a(P, C);
        };
      }
      l.exports = {
        set: g,
        get: A,
        has: E,
        enforce: y,
        getterFor: w
      };
    }
  ),
  /***/
  4209: (
    /***/
    (l, e, t) => {
      var s = t(8227), i = t(6269), n = s("iterator"), r = Array.prototype;
      l.exports = function(a) {
        return a !== void 0 && (i.Array === a || r[n] === a);
      };
    }
  ),
  /***/
  4376: (
    /***/
    (l, e, t) => {
      var s = t(4576);
      l.exports = Array.isArray || function(n) {
        return s(n) === "Array";
      };
    }
  ),
  /***/
  1108: (
    /***/
    (l, e, t) => {
      var s = t(6955);
      l.exports = function(i) {
        var n = s(i);
        return n === "BigInt64Array" || n === "BigUint64Array";
      };
    }
  ),
  /***/
  4901: (
    /***/
    (l) => {
      var e = typeof document == "object" && document.all;
      l.exports = typeof e > "u" && e !== void 0 ? function(t) {
        return typeof t == "function" || t === e;
      } : function(t) {
        return typeof t == "function";
      };
    }
  ),
  /***/
  2796: (
    /***/
    (l, e, t) => {
      var s = t(9039), i = t(4901), n = /#|\.prototype\./, r = function(u, f) {
        var m = h[a(u)];
        return m === d ? !0 : m === c ? !1 : i(f) ? s(f) : !!f;
      }, a = r.normalize = function(u) {
        return String(u).replace(n, ".").toLowerCase();
      }, h = r.data = {}, c = r.NATIVE = "N", d = r.POLYFILL = "P";
      l.exports = r;
    }
  ),
  /***/
  4117: (
    /***/
    (l) => {
      l.exports = function(e) {
        return e == null;
      };
    }
  ),
  /***/
  34: (
    /***/
    (l, e, t) => {
      var s = t(4901);
      l.exports = function(i) {
        return typeof i == "object" ? i !== null : s(i);
      };
    }
  ),
  /***/
  3925: (
    /***/
    (l, e, t) => {
      var s = t(34);
      l.exports = function(i) {
        return s(i) || i === null;
      };
    }
  ),
  /***/
  6395: (
    /***/
    (l) => {
      l.exports = !1;
    }
  ),
  /***/
  757: (
    /***/
    (l, e, t) => {
      var s = t(7751), i = t(4901), n = t(1625), r = t(7040), a = Object;
      l.exports = r ? function(h) {
        return typeof h == "symbol";
      } : function(h) {
        var c = s("Symbol");
        return i(c) && n(c.prototype, a(h));
      };
    }
  ),
  /***/
  507: (
    /***/
    (l, e, t) => {
      var s = t(9565);
      l.exports = function(i, n, r) {
        for (var a = r ? i : i.iterator, h = i.next, c, d; !(c = s(h, a)).done; )
          if (d = n(c.value), d !== void 0)
            return d;
      };
    }
  ),
  /***/
  2652: (
    /***/
    (l, e, t) => {
      var s = t(6080), i = t(9565), n = t(8551), r = t(6823), a = t(4209), h = t(6198), c = t(1625), d = t(81), u = t(851), f = t(9539), m = TypeError, g = function(E, y) {
        this.stopped = E, this.result = y;
      }, A = g.prototype;
      l.exports = function(E, y, w) {
        var S = w && w.that, C = !!(w && w.AS_ENTRIES), P = !!(w && w.IS_RECORD), x = !!(w && w.IS_ITERATOR), R = !!(w && w.INTERRUPTED), M = s(y, S), T, I, _, k, F, V, $, L = function(j) {
          return T && f(T, "normal", j), new g(!0, j);
        }, B = function(j) {
          return C ? (n(j), R ? M(j[0], j[1], L) : M(j[0], j[1])) : R ? M(j, L) : M(j);
        };
        if (P)
          T = E.iterator;
        else if (x)
          T = E;
        else {
          if (I = u(E), !I)
            throw new m(r(E) + " is not iterable");
          if (a(I)) {
            for (_ = 0, k = h(E); k > _; _++)
              if (F = B(E[_]), F && c(A, F))
                return F;
            return new g(!1);
          }
          T = d(E, I);
        }
        for (V = P ? E.next : T.next; !($ = i(V, T)).done; ) {
          try {
            F = B($.value);
          } catch (j) {
            f(T, "throw", j);
          }
          if (typeof F == "object" && F && c(A, F))
            return F;
        }
        return new g(!1);
      };
    }
  ),
  /***/
  9539: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(8551), n = t(5966);
      l.exports = function(r, a, h) {
        var c, d;
        i(r);
        try {
          if (c = n(r, "return"), !c) {
            if (a === "throw")
              throw h;
            return h;
          }
          c = s(c, r);
        } catch (u) {
          d = !0, c = u;
        }
        if (a === "throw")
          throw h;
        if (d)
          throw c;
        return i(c), h;
      };
    }
  ),
  /***/
  9462: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(2360), n = t(6699), r = t(6279), a = t(8227), h = t(1181), c = t(5966), d = t(7657).IteratorPrototype, u = t(2529), f = t(9539), m = a("toStringTag"), g = "IteratorHelper", A = "WrapForValidIterator", E = h.set, y = function(C) {
        var P = h.getterFor(C ? A : g);
        return r(i(d), {
          next: function() {
            var R = P(this);
            if (C)
              return R.nextHandler();
            try {
              var M = R.done ? void 0 : R.nextHandler();
              return u(M, R.done);
            } catch (T) {
              throw R.done = !0, T;
            }
          },
          return: function() {
            var x = P(this), R = x.iterator;
            if (x.done = !0, C) {
              var M = c(R, "return");
              return M ? s(M, R) : u(void 0, !0);
            }
            if (x.inner)
              try {
                f(x.inner.iterator, "normal");
              } catch (T) {
                return f(R, "throw", T);
              }
            return f(R, "normal"), u(void 0, !0);
          }
        });
      }, w = y(!0), S = y(!1);
      n(S, m, "Iterator Helper"), l.exports = function(C, P) {
        var x = function(M, T) {
          T ? (T.iterator = M.iterator, T.next = M.next) : T = M, T.type = P ? A : g, T.nextHandler = C, T.counter = 0, T.done = !1, E(this, T);
        };
        return x.prototype = P ? w : S, x;
      };
    }
  ),
  /***/
  713: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(9306), n = t(8551), r = t(1767), a = t(9462), h = t(6319), c = a(function() {
        var d = this.iterator, u = n(s(this.next, d)), f = this.done = !!u.done;
        if (!f)
          return h(d, this.mapper, [u.value, this.counter++], !0);
      });
      l.exports = function(u) {
        return n(this), i(u), new c(r(this), {
          mapper: u
        });
      };
    }
  ),
  /***/
  7657: (
    /***/
    (l, e, t) => {
      var s = t(9039), i = t(4901), n = t(34), r = t(2360), a = t(2787), h = t(6840), c = t(8227), d = t(6395), u = c("iterator"), f = !1, m, g, A;
      [].keys && (A = [].keys(), "next" in A ? (g = a(a(A)), g !== Object.prototype && (m = g)) : f = !0);
      var E = !n(m) || s(function() {
        var y = {};
        return m[u].call(y) !== y;
      });
      E ? m = {} : d && (m = r(m)), i(m[u]) || h(m, u, function() {
        return this;
      }), l.exports = {
        IteratorPrototype: m,
        BUGGY_SAFARI_ITERATORS: f
      };
    }
  ),
  /***/
  6269: (
    /***/
    (l) => {
      l.exports = {};
    }
  ),
  /***/
  6198: (
    /***/
    (l, e, t) => {
      var s = t(8014);
      l.exports = function(i) {
        return s(i.length);
      };
    }
  ),
  /***/
  283: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9039), n = t(4901), r = t(9297), a = t(3724), h = t(350).CONFIGURABLE, c = t(3706), d = t(1181), u = d.enforce, f = d.get, m = String, g = Object.defineProperty, A = s("".slice), E = s("".replace), y = s([].join), w = a && !i(function() {
        return g(function() {
        }, "length", { value: 8 }).length !== 8;
      }), S = String(String).split("String"), C = l.exports = function(P, x, R) {
        A(m(x), 0, 7) === "Symbol(" && (x = "[" + E(m(x), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), R && R.getter && (x = "get " + x), R && R.setter && (x = "set " + x), (!r(P, "name") || h && P.name !== x) && (a ? g(P, "name", { value: x, configurable: !0 }) : P.name = x), w && R && r(R, "arity") && P.length !== R.arity && g(P, "length", { value: R.arity });
        try {
          R && r(R, "constructor") && R.constructor ? a && g(P, "prototype", { writable: !1 }) : P.prototype && (P.prototype = void 0);
        } catch {
        }
        var M = u(P);
        return r(M, "source") || (M.source = y(S, typeof x == "string" ? x : "")), P;
      };
      Function.prototype.toString = C(function() {
        return n(this) && f(this).source || c(this);
      }, "toString");
    }
  ),
  /***/
  741: (
    /***/
    (l) => {
      var e = Math.ceil, t = Math.floor;
      l.exports = Math.trunc || function(i) {
        var n = +i;
        return (n > 0 ? t : e)(n);
      };
    }
  ),
  /***/
  6043: (
    /***/
    (l, e, t) => {
      var s = t(9306), i = TypeError, n = function(r) {
        var a, h;
        this.promise = new r(function(c, d) {
          if (a !== void 0 || h !== void 0)
            throw new i("Bad Promise constructor");
          a = c, h = d;
        }), this.resolve = s(a), this.reject = s(h);
      };
      l.exports.f = function(r) {
        return new n(r);
      };
    }
  ),
  /***/
  2603: (
    /***/
    (l, e, t) => {
      var s = t(655);
      l.exports = function(i, n) {
        return i === void 0 ? arguments.length < 2 ? "" : n : s(i);
      };
    }
  ),
  /***/
  4149: (
    /***/
    (l) => {
      var e = RangeError;
      l.exports = function(t) {
        if (t === t)
          return t;
        throw new e("NaN is not allowed");
      };
    }
  ),
  /***/
  2360: (
    /***/
    (l, e, t) => {
      var s = t(8551), i = t(6801), n = t(8727), r = t(421), a = t(397), h = t(4055), c = t(6119), d = ">", u = "<", f = "prototype", m = "script", g = c("IE_PROTO"), A = function() {
      }, E = function(P) {
        return u + m + d + P + u + "/" + m + d;
      }, y = function(P) {
        P.write(E("")), P.close();
        var x = P.parentWindow.Object;
        return P = null, x;
      }, w = function() {
        var P = h("iframe"), x = "java" + m + ":", R;
        return P.style.display = "none", a.appendChild(P), P.src = String(x), R = P.contentWindow.document, R.open(), R.write(E("document.F=Object")), R.close(), R.F;
      }, S, C = function() {
        try {
          S = new ActiveXObject("htmlfile");
        } catch {
        }
        C = typeof document < "u" ? document.domain && S ? y(S) : w() : y(S);
        for (var P = n.length; P--; )
          delete C[f][n[P]];
        return C();
      };
      r[g] = !0, l.exports = Object.create || function(x, R) {
        var M;
        return x !== null ? (A[f] = s(x), M = new A(), A[f] = null, M[g] = x) : M = C(), R === void 0 ? M : i.f(M, R);
      };
    }
  ),
  /***/
  6801: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(8686), n = t(4913), r = t(8551), a = t(5397), h = t(1072);
      e.f = s && !i ? Object.defineProperties : function(d, u) {
        r(d);
        for (var f = a(u), m = h(u), g = m.length, A = 0, E; g > A; )
          n.f(d, E = m[A++], f[E]);
        return d;
      };
    }
  ),
  /***/
  4913: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(5917), n = t(8686), r = t(8551), a = t(6969), h = TypeError, c = Object.defineProperty, d = Object.getOwnPropertyDescriptor, u = "enumerable", f = "configurable", m = "writable";
      e.f = s ? n ? function(A, E, y) {
        if (r(A), E = a(E), r(y), typeof A == "function" && E === "prototype" && "value" in y && m in y && !y[m]) {
          var w = d(A, E);
          w && w[m] && (A[E] = y.value, y = {
            configurable: f in y ? y[f] : w[f],
            enumerable: u in y ? y[u] : w[u],
            writable: !1
          });
        }
        return c(A, E, y);
      } : c : function(A, E, y) {
        if (r(A), E = a(E), r(y), i)
          try {
            return c(A, E, y);
          } catch {
          }
        if ("get" in y || "set" in y)
          throw new h("Accessors not supported");
        return "value" in y && (A[E] = y.value), A;
      };
    }
  ),
  /***/
  7347: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9565), n = t(8773), r = t(6980), a = t(5397), h = t(6969), c = t(9297), d = t(5917), u = Object.getOwnPropertyDescriptor;
      e.f = s ? u : function(m, g) {
        if (m = a(m), g = h(g), d)
          try {
            return u(m, g);
          } catch {
          }
        if (c(m, g))
          return r(!i(n.f, m, g), m[g]);
      };
    }
  ),
  /***/
  8480: (
    /***/
    (l, e, t) => {
      var s = t(1828), i = t(8727), n = i.concat("length", "prototype");
      e.f = Object.getOwnPropertyNames || function(a) {
        return s(a, n);
      };
    }
  ),
  /***/
  3717: (
    /***/
    (l, e) => {
      e.f = Object.getOwnPropertySymbols;
    }
  ),
  /***/
  2787: (
    /***/
    (l, e, t) => {
      var s = t(9297), i = t(4901), n = t(8981), r = t(6119), a = t(2211), h = r("IE_PROTO"), c = Object, d = c.prototype;
      l.exports = a ? c.getPrototypeOf : function(u) {
        var f = n(u);
        if (s(f, h))
          return f[h];
        var m = f.constructor;
        return i(m) && f instanceof m ? m.prototype : f instanceof c ? d : null;
      };
    }
  ),
  /***/
  1625: (
    /***/
    (l, e, t) => {
      var s = t(9504);
      l.exports = s({}.isPrototypeOf);
    }
  ),
  /***/
  1828: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9297), n = t(5397), r = t(9617).indexOf, a = t(421), h = s([].push);
      l.exports = function(c, d) {
        var u = n(c), f = 0, m = [], g;
        for (g in u)
          !i(a, g) && i(u, g) && h(m, g);
        for (; d.length > f; )
          i(u, g = d[f++]) && (~r(m, g) || h(m, g));
        return m;
      };
    }
  ),
  /***/
  1072: (
    /***/
    (l, e, t) => {
      var s = t(1828), i = t(8727);
      l.exports = Object.keys || function(r) {
        return s(r, i);
      };
    }
  ),
  /***/
  8773: (
    /***/
    (l, e) => {
      var t = {}.propertyIsEnumerable, s = Object.getOwnPropertyDescriptor, i = s && !t.call({ 1: 2 }, 1);
      e.f = i ? function(r) {
        var a = s(this, r);
        return !!a && a.enumerable;
      } : t;
    }
  ),
  /***/
  2967: (
    /***/
    (l, e, t) => {
      var s = t(6706), i = t(34), n = t(7750), r = t(3506);
      l.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var a = !1, h = {}, c;
        try {
          c = s(Object.prototype, "__proto__", "set"), c(h, []), a = h instanceof Array;
        } catch {
        }
        return function(u, f) {
          return n(u), r(f), i(u) && (a ? c(u, f) : u.__proto__ = f), u;
        };
      }() : void 0);
    }
  ),
  /***/
  4270: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(4901), n = t(34), r = TypeError;
      l.exports = function(a, h) {
        var c, d;
        if (h === "string" && i(c = a.toString) && !n(d = s(c, a)) || i(c = a.valueOf) && !n(d = s(c, a)) || h !== "string" && i(c = a.toString) && !n(d = s(c, a)))
          return d;
        throw new r("Can't convert object to primitive value");
      };
    }
  ),
  /***/
  5031: (
    /***/
    (l, e, t) => {
      var s = t(7751), i = t(9504), n = t(8480), r = t(3717), a = t(8551), h = i([].concat);
      l.exports = s("Reflect", "ownKeys") || function(d) {
        var u = n.f(a(d)), f = r.f;
        return f ? h(u, f(d)) : u;
      };
    }
  ),
  /***/
  8235: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(9297), n = SyntaxError, r = parseInt, a = String.fromCharCode, h = s("".charAt), c = s("".slice), d = s(/./.exec), u = {
        '\\"': '"',
        "\\\\": "\\",
        "\\/": "/",
        "\\b": "\b",
        "\\f": "\f",
        "\\n": `
`,
        "\\r": "\r",
        "\\t": "	"
      }, f = /^[\da-f]{4}$/i, m = /^[\u0000-\u001F]$/;
      l.exports = function(g, A) {
        for (var E = !0, y = ""; A < g.length; ) {
          var w = h(g, A);
          if (w === "\\") {
            var S = c(g, A, A + 2);
            if (i(u, S))
              y += u[S], A += 2;
            else if (S === "\\u") {
              A += 2;
              var C = c(g, A, A + 4);
              if (!d(f, C))
                throw new n("Bad Unicode escape at: " + A);
              y += a(r(C, 16)), A += 4;
            } else
              throw new n('Unknown escape sequence: "' + S + '"');
          } else if (w === '"') {
            E = !1, A++;
            break;
          } else {
            if (d(m, w))
              throw new n("Bad control character in string literal at: " + A);
            y += w, A++;
          }
        }
        if (E)
          throw new n("Unterminated string at: " + A);
        return { value: y, end: A };
      };
    }
  ),
  /***/
  7750: (
    /***/
    (l, e, t) => {
      var s = t(4117), i = TypeError;
      l.exports = function(n) {
        if (s(n))
          throw new i("Can't call method on " + n);
        return n;
      };
    }
  ),
  /***/
  9286: (
    /***/
    (l, e, t) => {
      var s = t(4402), i = t(8469), n = s.Set, r = s.add;
      l.exports = function(a) {
        var h = new n();
        return i(a, function(c) {
          r(h, c);
        }), h;
      };
    }
  ),
  /***/
  3440: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402), n = t(9286), r = t(5170), a = t(3789), h = t(8469), c = t(507), d = i.has, u = i.remove;
      l.exports = function(m) {
        var g = s(this), A = a(m), E = n(g);
        return r(g) <= A.size ? h(g, function(y) {
          A.includes(y) && u(E, y);
        }) : c(A.getIterator(), function(y) {
          d(g, y) && u(E, y);
        }), E;
      };
    }
  ),
  /***/
  4402: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = Set.prototype;
      l.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: s(i.add),
        has: s(i.has),
        remove: s(i.delete),
        proto: i
      };
    }
  ),
  /***/
  8750: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402), n = t(5170), r = t(3789), a = t(8469), h = t(507), c = i.Set, d = i.add, u = i.has;
      l.exports = function(m) {
        var g = s(this), A = r(m), E = new c();
        return n(g) > A.size ? h(A.getIterator(), function(y) {
          u(g, y) && d(E, y);
        }) : a(g, function(y) {
          A.includes(y) && d(E, y);
        }), E;
      };
    }
  ),
  /***/
  4449: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402).has, n = t(5170), r = t(3789), a = t(8469), h = t(507), c = t(9539);
      l.exports = function(u) {
        var f = s(this), m = r(u);
        if (n(f) <= m.size)
          return a(f, function(A) {
            if (m.includes(A))
              return !1;
          }, !0) !== !1;
        var g = m.getIterator();
        return h(g, function(A) {
          if (i(f, A))
            return c(g, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  3838: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(5170), n = t(8469), r = t(3789);
      l.exports = function(h) {
        var c = s(this), d = r(h);
        return i(c) > d.size ? !1 : n(c, function(u) {
          if (!d.includes(u))
            return !1;
        }, !0) !== !1;
      };
    }
  ),
  /***/
  8527: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402).has, n = t(5170), r = t(3789), a = t(507), h = t(9539);
      l.exports = function(d) {
        var u = s(this), f = r(d);
        if (n(u) < f.size)
          return !1;
        var m = f.getIterator();
        return a(m, function(g) {
          if (!i(u, g))
            return h(m, "normal", !1);
        }) !== !1;
      };
    }
  ),
  /***/
  8469: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = t(507), n = t(4402), r = n.Set, a = n.proto, h = s(a.forEach), c = s(a.keys), d = c(new r()).next;
      l.exports = function(u, f, m) {
        return m ? i({ iterator: c(u), next: d }, f) : h(u, f);
      };
    }
  ),
  /***/
  4916: (
    /***/
    (l, e, t) => {
      var s = t(7751), i = function(n) {
        return {
          size: n,
          has: function() {
            return !1;
          },
          keys: function() {
            return {
              next: function() {
                return { done: !0 };
              }
            };
          }
        };
      };
      l.exports = function(n) {
        var r = s("Set");
        try {
          new r()[n](i(0));
          try {
            return new r()[n](i(-1)), !1;
          } catch {
            return !0;
          }
        } catch {
          return !1;
        }
      };
    }
  ),
  /***/
  5170: (
    /***/
    (l, e, t) => {
      var s = t(6706), i = t(4402);
      l.exports = s(i.proto, "size", "get") || function(n) {
        return n.size;
      };
    }
  ),
  /***/
  3650: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402), n = t(9286), r = t(3789), a = t(507), h = i.add, c = i.has, d = i.remove;
      l.exports = function(f) {
        var m = s(this), g = r(f).getIterator(), A = n(m);
        return a(g, function(E) {
          c(m, E) ? d(A, E) : h(A, E);
        }), A;
      };
    }
  ),
  /***/
  4204: (
    /***/
    (l, e, t) => {
      var s = t(7080), i = t(4402).add, n = t(9286), r = t(3789), a = t(507);
      l.exports = function(c) {
        var d = s(this), u = r(c).getIterator(), f = n(d);
        return a(u, function(m) {
          i(f, m);
        }), f;
      };
    }
  ),
  /***/
  6119: (
    /***/
    (l, e, t) => {
      var s = t(5745), i = t(3392), n = s("keys");
      l.exports = function(r) {
        return n[r] || (n[r] = i(r));
      };
    }
  ),
  /***/
  7629: (
    /***/
    (l, e, t) => {
      var s = t(6395), i = t(4475), n = t(9433), r = "__core-js_shared__", a = l.exports = i[r] || n(r, {});
      (a.versions || (a.versions = [])).push({
        version: "3.37.1",
        mode: s ? "pure" : "global",
        copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  ),
  /***/
  5745: (
    /***/
    (l, e, t) => {
      var s = t(7629);
      l.exports = function(i, n) {
        return s[i] || (s[i] = n || {});
      };
    }
  ),
  /***/
  1548: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(9039), n = t(7388), r = t(7290), a = t(516), h = t(9088), c = s.structuredClone;
      l.exports = !!c && !i(function() {
        if (a && n > 92 || h && n > 94 || r && n > 97)
          return !1;
        var d = new ArrayBuffer(8), u = c(d, { transfer: [d] });
        return d.byteLength !== 0 || u.byteLength !== 8;
      });
    }
  ),
  /***/
  4495: (
    /***/
    (l, e, t) => {
      var s = t(7388), i = t(9039), n = t(4475), r = n.String;
      l.exports = !!Object.getOwnPropertySymbols && !i(function() {
        var a = Symbol("symbol detection");
        return !r(a) || !(Object(a) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && s && s < 41;
      });
    }
  ),
  /***/
  5610: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = Math.max, n = Math.min;
      l.exports = function(r, a) {
        var h = s(r);
        return h < 0 ? i(h + a, 0) : n(h, a);
      };
    }
  ),
  /***/
  5854: (
    /***/
    (l, e, t) => {
      var s = t(2777), i = TypeError;
      l.exports = function(n) {
        var r = s(n, "number");
        if (typeof r == "number")
          throw new i("Can't convert number to bigint");
        return BigInt(r);
      };
    }
  ),
  /***/
  7696: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = t(8014), n = RangeError;
      l.exports = function(r) {
        if (r === void 0)
          return 0;
        var a = s(r), h = i(a);
        if (a !== h)
          throw new n("Wrong length or index");
        return h;
      };
    }
  ),
  /***/
  5397: (
    /***/
    (l, e, t) => {
      var s = t(7055), i = t(7750);
      l.exports = function(n) {
        return s(i(n));
      };
    }
  ),
  /***/
  1291: (
    /***/
    (l, e, t) => {
      var s = t(741);
      l.exports = function(i) {
        var n = +i;
        return n !== n || n === 0 ? 0 : s(n);
      };
    }
  ),
  /***/
  8014: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = Math.min;
      l.exports = function(n) {
        var r = s(n);
        return r > 0 ? i(r, 9007199254740991) : 0;
      };
    }
  ),
  /***/
  8981: (
    /***/
    (l, e, t) => {
      var s = t(7750), i = Object;
      l.exports = function(n) {
        return i(s(n));
      };
    }
  ),
  /***/
  9590: (
    /***/
    (l, e, t) => {
      var s = t(1291), i = RangeError;
      l.exports = function(n) {
        var r = s(n);
        if (r < 0)
          throw new i("The argument can't be less than 0");
        return r;
      };
    }
  ),
  /***/
  2777: (
    /***/
    (l, e, t) => {
      var s = t(9565), i = t(34), n = t(757), r = t(5966), a = t(4270), h = t(8227), c = TypeError, d = h("toPrimitive");
      l.exports = function(u, f) {
        if (!i(u) || n(u))
          return u;
        var m = r(u, d), g;
        if (m) {
          if (f === void 0 && (f = "default"), g = s(m, u, f), !i(g) || n(g))
            return g;
          throw new c("Can't convert object to primitive value");
        }
        return f === void 0 && (f = "number"), a(u, f);
      };
    }
  ),
  /***/
  6969: (
    /***/
    (l, e, t) => {
      var s = t(2777), i = t(757);
      l.exports = function(n) {
        var r = s(n, "string");
        return i(r) ? r : r + "";
      };
    }
  ),
  /***/
  2140: (
    /***/
    (l, e, t) => {
      var s = t(8227), i = s("toStringTag"), n = {};
      n[i] = "z", l.exports = String(n) === "[object z]";
    }
  ),
  /***/
  655: (
    /***/
    (l, e, t) => {
      var s = t(6955), i = String;
      l.exports = function(n) {
        if (s(n) === "Symbol")
          throw new TypeError("Cannot convert a Symbol value to a string");
        return i(n);
      };
    }
  ),
  /***/
  9714: (
    /***/
    (l, e, t) => {
      var s = t(9088);
      l.exports = function(i) {
        try {
          if (s)
            return Function('return require("' + i + '")')();
        } catch {
        }
      };
    }
  ),
  /***/
  6823: (
    /***/
    (l) => {
      var e = String;
      l.exports = function(t) {
        try {
          return e(t);
        } catch {
          return "Object";
        }
      };
    }
  ),
  /***/
  3392: (
    /***/
    (l, e, t) => {
      var s = t(9504), i = 0, n = Math.random(), r = s(1 .toString);
      l.exports = function(a) {
        return "Symbol(" + (a === void 0 ? "" : a) + ")_" + r(++i + n, 36);
      };
    }
  ),
  /***/
  7040: (
    /***/
    (l, e, t) => {
      var s = t(4495);
      l.exports = s && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  ),
  /***/
  8686: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9039);
      l.exports = s && i(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: !1
        }).prototype !== 42;
      });
    }
  ),
  /***/
  2812: (
    /***/
    (l) => {
      var e = TypeError;
      l.exports = function(t, s) {
        if (t < s)
          throw new e("Not enough arguments");
        return t;
      };
    }
  ),
  /***/
  8622: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(4901), n = s.WeakMap;
      l.exports = i(n) && /native code/.test(String(n));
    }
  ),
  /***/
  8227: (
    /***/
    (l, e, t) => {
      var s = t(4475), i = t(5745), n = t(9297), r = t(3392), a = t(4495), h = t(7040), c = s.Symbol, d = i("wks"), u = h ? c.for || c : c && c.withoutSetter || r;
      l.exports = function(f) {
        return n(d, f) || (d[f] = a && n(c, f) ? c[f] : u("Symbol." + f)), d[f];
      };
    }
  ),
  /***/
  6573: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(2106), n = t(3238), r = ArrayBuffer.prototype;
      s && !("detached" in r) && i(r, "detached", {
        configurable: !0,
        get: function() {
          return n(this);
        }
      });
    }
  ),
  /***/
  7936: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transferToFixedLength: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !1);
        }
      });
    }
  ),
  /***/
  8100: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(5636);
      i && s({ target: "ArrayBuffer", proto: !0 }, {
        transfer: function() {
          return i(this, arguments.length ? arguments[0] : void 0, !0);
        }
      });
    }
  ),
  /***/
  4114: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(8981), n = t(6198), r = t(4527), a = t(6837), h = t(9039), c = h(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      }), d = function() {
        try {
          Object.defineProperty([], "length", { writable: !1 }).push();
        } catch (f) {
          return f instanceof TypeError;
        }
      }, u = c || !d();
      s({ target: "Array", proto: !0, arity: 1, forced: u }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function(m) {
          var g = i(this), A = n(g), E = arguments.length;
          a(A + E);
          for (var y = 0; y < E; y++)
            g[A] = arguments[y], A++;
          return r(g, A), A;
        }
      });
    }
  ),
  /***/
  4628: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(6043);
      s({ target: "Promise", stat: !0 }, {
        withResolvers: function() {
          var r = i.f(this);
          return {
            promise: r.promise,
            resolve: r.resolve,
            reject: r.reject
          };
        }
      });
    }
  ),
  /***/
  7642: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3440), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("difference") }, {
        difference: i
      });
    }
  ),
  /***/
  8004: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9039), n = t(8750), r = t(4916), a = !r("intersection") || i(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      s({ target: "Set", proto: !0, real: !0, forced: a }, {
        intersection: n
      });
    }
  ),
  /***/
  3853: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4449), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isDisjointFrom") }, {
        isDisjointFrom: i
      });
    }
  ),
  /***/
  5876: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3838), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isSubsetOf") }, {
        isSubsetOf: i
      });
    }
  ),
  /***/
  2475: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(8527), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("isSupersetOf") }, {
        isSupersetOf: i
      });
    }
  ),
  /***/
  5024: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3650), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("symmetricDifference") }, {
        symmetricDifference: i
      });
    }
  ),
  /***/
  1698: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4204), n = t(4916);
      s({ target: "Set", proto: !0, real: !0, forced: !n("union") }, {
        union: i
      });
    }
  ),
  /***/
  7467: (
    /***/
    (l, e, t) => {
      var s = t(7628), i = t(4644), n = i.aTypedArray, r = i.exportTypedArrayMethod, a = i.getTypedArrayConstructor;
      r("toReversed", function() {
        return s(n(this), a(this));
      });
    }
  ),
  /***/
  4732: (
    /***/
    (l, e, t) => {
      var s = t(4644), i = t(9504), n = t(9306), r = t(5370), a = s.aTypedArray, h = s.getTypedArrayConstructor, c = s.exportTypedArrayMethod, d = i(s.TypedArrayPrototype.sort);
      c("toSorted", function(f) {
        f !== void 0 && n(f);
        var m = a(this), g = r(h(m), m);
        return d(g, f);
      });
    }
  ),
  /***/
  9577: (
    /***/
    (l, e, t) => {
      var s = t(9928), i = t(4644), n = t(1108), r = t(1291), a = t(5854), h = i.aTypedArray, c = i.getTypedArrayConstructor, d = i.exportTypedArrayMethod, u = !!function() {
        try {
          new Int8Array(1).with(2, { valueOf: function() {
            throw 8;
          } });
        } catch (f) {
          return f === 8;
        }
      }();
      d("with", function(f, m) {
        var g = h(this), A = r(f), E = n(g) ? a(m) : +m;
        return s(g, c(g), A, E);
      }, !u);
    }
  ),
  /***/
  8992: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4475), n = t(679), r = t(8551), a = t(4901), h = t(2787), c = t(2106), d = t(4659), u = t(9039), f = t(9297), m = t(8227), g = t(7657).IteratorPrototype, A = t(3724), E = t(6395), y = "constructor", w = "Iterator", S = m("toStringTag"), C = TypeError, P = i[w], x = E || !a(P) || P.prototype !== g || !u(function() {
        P({});
      }), R = function() {
        if (n(this, g), h(this) === g)
          throw new C("Abstract class Iterator not directly constructable");
      }, M = function(T, I) {
        A ? c(g, T, {
          configurable: !0,
          get: function() {
            return I;
          },
          set: function(_) {
            if (r(this), this === g)
              throw new C("You can't redefine this property");
            f(this, T) ? this[T] = _ : d(this, T, _);
          }
        }) : g[T] = I;
      };
      f(g, S) || M(S, w), (x || !f(g, y) || g[y] === Object) && M(y, R), R.prototype = g, s({ global: !0, constructor: !0, forced: x }, {
        Iterator: R
      });
    }
  ),
  /***/
  4743: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9565), n = t(8551), r = t(1767), a = t(4149), h = t(9590), c = t(9462), d = t(6395), u = c(function() {
        for (var f = this.iterator, m = this.next, g, A; this.remaining; )
          if (this.remaining--, g = n(i(m, f)), A = this.done = !!g.done, A)
            return;
        if (g = n(i(m, f)), A = this.done = !!g.done, !A)
          return g.value;
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        drop: function(m) {
          n(this);
          var g = h(a(+m));
          return new u(r(this), {
            remaining: g
          });
        }
      });
    }
  ),
  /***/
  3215: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(2652), n = t(9306), r = t(8551), a = t(1767);
      s({ target: "Iterator", proto: !0, real: !0 }, {
        every: function(c) {
          r(this), n(c);
          var d = a(this), u = 0;
          return !i(d, function(f, m) {
            if (!c(f, u++))
              return m();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  4520: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9565), n = t(9306), r = t(8551), a = t(1767), h = t(9462), c = t(6319), d = t(6395), u = h(function() {
        for (var f = this.iterator, m = this.predicate, g = this.next, A, E, y; ; ) {
          if (A = r(i(g, f)), E = this.done = !!A.done, E)
            return;
          if (y = A.value, c(f, m, [y, this.counter++], !0))
            return y;
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: d }, {
        filter: function(m) {
          return r(this), n(m), new u(a(this), {
            predicate: m
          });
        }
      });
    }
  ),
  /***/
  670: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(9565), n = t(9306), r = t(8551), a = t(1767), h = t(8646), c = t(9462), d = t(9539), u = t(6395), f = c(function() {
        for (var m = this.iterator, g = this.mapper, A, E; ; ) {
          if (E = this.inner)
            try {
              if (A = r(i(E.next, E.iterator)), !A.done)
                return A.value;
              this.inner = null;
            } catch (y) {
              d(m, "throw", y);
            }
          if (A = r(i(this.next, m)), this.done = !!A.done)
            return;
          try {
            this.inner = h(g(A.value, this.counter++), !1);
          } catch (y) {
            d(m, "throw", y);
          }
        }
      });
      s({ target: "Iterator", proto: !0, real: !0, forced: u }, {
        flatMap: function(g) {
          return r(this), n(g), new f(a(this), {
            mapper: g,
            inner: null
          });
        }
      });
    }
  ),
  /***/
  1454: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(713), n = t(6395);
      s({ target: "Iterator", proto: !0, real: !0, forced: n }, {
        map: i
      });
    }
  ),
  /***/
  7550: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(2652), n = t(9306), r = t(8551), a = t(1767);
      s({ target: "Iterator", proto: !0, real: !0 }, {
        some: function(c) {
          r(this), n(c);
          var d = a(this), u = 0;
          return i(d, function(f, m) {
            if (c(f, u++))
              return m();
          }, { IS_RECORD: !0, INTERRUPTED: !0 }).stopped;
        }
      });
    }
  ),
  /***/
  8335: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(3724), n = t(4475), r = t(7751), a = t(9504), h = t(9565), c = t(4901), d = t(34), u = t(4376), f = t(9297), m = t(655), g = t(6198), A = t(4659), E = t(9039), y = t(8235), w = t(4495), S = n.JSON, C = n.Number, P = n.SyntaxError, x = S && S.parse, R = r("Object", "keys"), M = Object.getOwnPropertyDescriptor, T = a("".charAt), I = a("".slice), _ = a(/./.exec), k = a([].push), F = /^\d$/, V = /^[1-9]$/, $ = /^(?:-|\d)$/, L = /^[\t\n\r ]$/, B = 0, j = 1, ot = function(H, O) {
        H = m(H);
        var N = new dt(H, 0), Y = N.parse(), ut = Y.value, W = N.skip(L, Y.end);
        if (W < H.length)
          throw new P('Unexpected extra character: "' + T(H, W) + '" after the parsed data at: ' + W);
        return c(O) ? mt({ "": ut }, "", O, Y) : ut;
      }, mt = function(H, O, N, Y) {
        var ut = H[O], W = Y && ut === Y.value, vt = W && typeof Y.source == "string" ? { source: Y.source } : {}, bt, ts, qt, Dt, ra;
        if (d(ut)) {
          var Xg = u(ut), au = W ? Y.nodes : Xg ? [] : {};
          if (Xg)
            for (bt = au.length, qt = g(ut), Dt = 0; Dt < qt; Dt++)
              ae(ut, Dt, mt(ut, "" + Dt, N, Dt < bt ? au[Dt] : void 0));
          else
            for (ts = R(ut), qt = g(ts), Dt = 0; Dt < qt; Dt++)
              ra = ts[Dt], ae(ut, ra, mt(ut, ra, N, f(au, ra) ? au[ra] : void 0));
        }
        return h(N, H, O, ut, vt);
      }, ae = function(H, O, N) {
        if (i) {
          var Y = M(H, O);
          if (Y && !Y.configurable)
            return;
        }
        N === void 0 ? delete H[O] : A(H, O, N);
      }, lt = function(H, O, N, Y) {
        this.value = H, this.end = O, this.source = N, this.nodes = Y;
      }, dt = function(H, O) {
        this.source = H, this.index = O;
      };
      dt.prototype = {
        fork: function(H) {
          return new dt(this.source, H);
        },
        parse: function() {
          var H = this.source, O = this.skip(L, this.index), N = this.fork(O), Y = T(H, O);
          if (_($, Y))
            return N.number();
          switch (Y) {
            case "{":
              return N.object();
            case "[":
              return N.array();
            case '"':
              return N.string();
            case "t":
              return N.keyword(!0);
            case "f":
              return N.keyword(!1);
            case "n":
              return N.keyword(null);
          }
          throw new P('Unexpected character: "' + Y + '" at: ' + O);
        },
        node: function(H, O, N, Y, ut) {
          return new lt(O, Y, H ? null : I(this.source, N, Y), ut);
        },
        object: function() {
          for (var H = this.source, O = this.index + 1, N = !1, Y = {}, ut = {}; O < H.length; ) {
            if (O = this.until(['"', "}"], O), T(H, O) === "}" && !N) {
              O++;
              break;
            }
            var W = this.fork(O).string(), vt = W.value;
            O = W.end, O = this.until([":"], O) + 1, O = this.skip(L, O), W = this.fork(O).parse(), A(ut, vt, W), A(Y, vt, W.value), O = this.until([",", "}"], W.end);
            var bt = T(H, O);
            if (bt === ",")
              N = !0, O++;
            else if (bt === "}") {
              O++;
              break;
            }
          }
          return this.node(j, Y, this.index, O, ut);
        },
        array: function() {
          for (var H = this.source, O = this.index + 1, N = !1, Y = [], ut = []; O < H.length; ) {
            if (O = this.skip(L, O), T(H, O) === "]" && !N) {
              O++;
              break;
            }
            var W = this.fork(O).parse();
            if (k(ut, W), k(Y, W.value), O = this.until([",", "]"], W.end), T(H, O) === ",")
              N = !0, O++;
            else if (T(H, O) === "]") {
              O++;
              break;
            }
          }
          return this.node(j, Y, this.index, O, ut);
        },
        string: function() {
          var H = this.index, O = y(this.source, this.index + 1);
          return this.node(B, O.value, H, O.end);
        },
        number: function() {
          var H = this.source, O = this.index, N = O;
          if (T(H, N) === "-" && N++, T(H, N) === "0")
            N++;
          else if (_(V, T(H, N)))
            N = this.skip(F, ++N);
          else
            throw new P("Failed to parse number at: " + N);
          if (T(H, N) === "." && (N = this.skip(F, ++N)), T(H, N) === "e" || T(H, N) === "E") {
            N++, (T(H, N) === "+" || T(H, N) === "-") && N++;
            var Y = N;
            if (N = this.skip(F, N), Y === N)
              throw new P("Failed to parse number's exponent value at: " + N);
          }
          return this.node(B, C(I(H, O, N)), O, N);
        },
        keyword: function(H) {
          var O = "" + H, N = this.index, Y = N + O.length;
          if (I(this.source, N, Y) !== O)
            throw new P("Failed to parse value at: " + N);
          return this.node(B, H, N, Y);
        },
        skip: function(H, O) {
          for (var N = this.source; O < N.length && _(H, T(N, O)); O++)
            ;
          return O;
        },
        until: function(H, O) {
          O = this.skip(L, O);
          for (var N = T(this.source, O), Y = 0; Y < H.length; Y++)
            if (H[Y] === N)
              return O;
          throw new P('Unexpected character: "' + N + '" at: ' + O);
        }
      };
      var bi = E(function() {
        var H = "9007199254740993", O;
        return x(H, function(N, Y, ut) {
          O = ut.source;
        }), O !== H;
      }), Pe = w && !E(function() {
        return 1 / x("-0 	") !== -1 / 0;
      });
      s({ target: "JSON", stat: !0, forced: bi }, {
        parse: function(O, N) {
          return Pe && !c(N) ? x(O) : ot(O, N);
        }
      });
    }
  ),
  /***/
  3375: (
    /***/
    (l, e, t) => {
      t(7642);
    }
  ),
  /***/
  9225: (
    /***/
    (l, e, t) => {
      t(8004);
    }
  ),
  /***/
  3972: (
    /***/
    (l, e, t) => {
      t(3853);
    }
  ),
  /***/
  9209: (
    /***/
    (l, e, t) => {
      t(5876);
    }
  ),
  /***/
  5714: (
    /***/
    (l, e, t) => {
      t(2475);
    }
  ),
  /***/
  7561: (
    /***/
    (l, e, t) => {
      t(5024);
    }
  ),
  /***/
  6197: (
    /***/
    (l, e, t) => {
      t(1698);
    }
  ),
  /***/
  4979: (
    /***/
    (l, e, t) => {
      var s = t(6518), i = t(4475), n = t(7751), r = t(6980), a = t(4913).f, h = t(9297), c = t(679), d = t(3167), u = t(2603), f = t(5002), m = t(6193), g = t(3724), A = t(6395), E = "DOMException", y = n("Error"), w = n(E), S = function() {
        c(this, C);
        var L = arguments.length, B = u(L < 1 ? void 0 : arguments[0]), j = u(L < 2 ? void 0 : arguments[1], "Error"), ot = new w(B, j), mt = new y(B);
        return mt.name = E, a(ot, "stack", r(1, m(mt.stack, 1))), d(ot, this, S), ot;
      }, C = S.prototype = w.prototype, P = "stack" in new y(E), x = "stack" in new w(1, 2), R = w && g && Object.getOwnPropertyDescriptor(i, E), M = !!R && !(R.writable && R.configurable), T = P && !M && !x;
      s({ global: !0, constructor: !0, forced: A || T }, {
        // TODO: fix export logic
        DOMException: T ? S : w
      });
      var I = n(E), _ = I.prototype;
      if (_.constructor !== I) {
        A || a(_, "constructor", r(1, I));
        for (var k in f)
          if (h(f, k)) {
            var F = f[k], V = F.s;
            h(I, V) || a(I, V, r(6, F.c));
          }
      }
    }
  ),
  /***/
  4603: (
    /***/
    (l, e, t) => {
      var s = t(6840), i = t(9504), n = t(655), r = t(2812), a = URLSearchParams, h = a.prototype, c = i(h.append), d = i(h.delete), u = i(h.forEach), f = i([].push), m = new a("a=1&a=2&b=3");
      m.delete("a", 1), m.delete("b", void 0), m + "" != "a=2" && s(h, "delete", function(g) {
        var A = arguments.length, E = A < 2 ? void 0 : arguments[1];
        if (A && E === void 0)
          return d(this, g);
        var y = [];
        u(this, function(T, I) {
          f(y, { key: I, value: T });
        }), r(A, 1);
        for (var w = n(g), S = n(E), C = 0, P = 0, x = !1, R = y.length, M; C < R; )
          M = y[C++], x || M.key === w ? (x = !0, d(this, M.key)) : P++;
        for (; P < R; )
          M = y[P++], M.key === w && M.value === S || c(this, M.key, M.value);
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  7566: (
    /***/
    (l, e, t) => {
      var s = t(6840), i = t(9504), n = t(655), r = t(2812), a = URLSearchParams, h = a.prototype, c = i(h.getAll), d = i(h.has), u = new a("a=1");
      (u.has("a", 2) || !u.has("a", void 0)) && s(h, "has", function(m) {
        var g = arguments.length, A = g < 2 ? void 0 : arguments[1];
        if (g && A === void 0)
          return d(this, m);
        var E = c(this, m);
        r(g, 1);
        for (var y = n(A), w = 0; w < E.length; )
          if (E[w++] === y)
            return !0;
        return !1;
      }, { enumerable: !0, unsafe: !0 });
    }
  ),
  /***/
  8721: (
    /***/
    (l, e, t) => {
      var s = t(3724), i = t(9504), n = t(2106), r = URLSearchParams.prototype, a = i(r.forEach);
      s && !("size" in r) && n(r, "size", {
        get: function() {
          var c = 0;
          return a(this, function() {
            c++;
          }), c;
        },
        configurable: !0,
        enumerable: !0
      });
    }
  )
  /******/
}, wb = {};
function st(l) {
  var e = wb[l];
  if (e !== void 0)
    return e.exports;
  var t = wb[l] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return I0[l].call(t.exports, t, t.exports, st), t.exports;
}
st.d = (l, e) => {
  for (var t in e)
    st.o(e, t) && !st.o(l, t) && Object.defineProperty(l, t, { enumerable: !0, get: e[t] });
};
st.o = (l, e) => Object.prototype.hasOwnProperty.call(l, e);
var G = globalThis.pdfjsLib = {};
st.d(G, {
  AbortException: () => (
    /* reexport */
    ia
  ),
  AnnotationEditorLayer: () => (
    /* reexport */
    IS
  ),
  AnnotationEditorParamsType: () => (
    /* reexport */
    X
  ),
  AnnotationEditorType: () => (
    /* reexport */
    q
  ),
  AnnotationEditorUIManager: () => (
    /* reexport */
    Vl
  ),
  AnnotationLayer: () => (
    /* reexport */
    CS
  ),
  AnnotationMode: () => (
    /* reexport */
    Ti
  ),
  CMapCompressionType: () => (
    /* reexport */
    um
  ),
  ColorPicker: () => (
    /* reexport */
    ZA
  ),
  DOMSVGFactory: () => (
    /* reexport */
    rb
  ),
  DrawLayer: () => (
    /* reexport */
    LS
  ),
  FeatureTest: () => (
    /* reexport */
    ue
  ),
  GlobalWorkerOptions: () => (
    /* reexport */
    qr
  ),
  ImageKind: () => (
    /* reexport */
    yu
  ),
  InvalidPDFException: () => (
    /* reexport */
    Ly
  ),
  MissingPDFException: () => (
    /* reexport */
    sa
  ),
  OPS: () => (
    /* reexport */
    Be
  ),
  Outliner: () => (
    /* reexport */
    ev
  ),
  PDFDataRangeTransport: () => (
    /* reexport */
    PA
  ),
  PDFDateString: () => (
    /* reexport */
    Ny
  ),
  PDFWorker: () => (
    /* reexport */
    Ru
  ),
  PasswordResponses: () => (
    /* reexport */
    O0
  ),
  PermissionFlag: () => (
    /* reexport */
    M0
  ),
  PixelsPerInch: () => (
    /* reexport */
    rl
  ),
  RenderingCancelledException: () => (
    /* reexport */
    ab
  ),
  TextLayer: () => (
    /* reexport */
    lf
  ),
  UnexpectedResponseException: () => (
    /* reexport */
    Bg
  ),
  Util: () => (
    /* reexport */
    U
  ),
  VerbosityLevel: () => (
    /* reexport */
    kg
  ),
  XfaLayer: () => (
    /* reexport */
    CA
  ),
  build: () => (
    /* reexport */
    oS
  ),
  createValidAbsoluteUrl: () => (
    /* reexport */
    N0
  ),
  fetchData: () => (
    /* reexport */
    Ug
  ),
  getDocument: () => (
    /* reexport */
    Jw
  ),
  getFilenameFromUrl: () => (
    /* reexport */
    X0
  ),
  getPdfFilenameFromUrl: () => (
    /* reexport */
    K0
  ),
  getXfaPageViewport: () => (
    /* reexport */
    Y0
  ),
  isDataScheme: () => (
    /* reexport */
    ob
  ),
  isPdfFile: () => (
    /* reexport */
    lb
  ),
  noContextMenu: () => (
    /* reexport */
    fe
  ),
  normalizeUnicode: () => (
    /* reexport */
    U0
  ),
  renderTextLayer: () => (
    /* reexport */
    Uw
  ),
  setLayerDimensions: () => (
    /* reexport */
    ta
  ),
  shadow: () => (
    /* reexport */
    et
  ),
  updateTextLayer: () => (
    /* reexport */
    zw
  ),
  version: () => (
    /* reexport */
    aS
  )
});
st(4114);
st(6573);
st(8100);
st(7936);
st(7467);
st(4732);
st(9577);
st(4603);
st(7566);
st(8721);
const Jt = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), Iy = [1, 0, 0, 1, 0, 0], dm = [1e-3, 0, 0, 1e-3, 0, 0], L0 = 1e7, Yg = 1.35, ke = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  OPLIST: 256
}, Ti = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, _0 = "pdfjs_internal_editor_", q = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, X = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
}, M0 = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, Gt = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, yu = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, Tt = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, cl = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, kg = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, um = {
  NONE: 0,
  BINARY: 1
}, Be = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
}, O0 = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let Fg = kg.WARNINGS;
function D0(l) {
  Number.isInteger(l) && (Fg = l);
}
function k0() {
  return Fg;
}
function Ng(l) {
  Fg >= kg.INFOS && console.log(`Info: ${l}`);
}
function Q(l) {
  Fg >= kg.WARNINGS && console.log(`Warning: ${l}`);
}
function at(l) {
  throw new Error(l);
}
function Ot(l, e) {
  l || at(e);
}
function F0(l) {
  switch (l == null ? void 0 : l.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function N0(l, e = null, t = null) {
  if (!l)
    return null;
  try {
    if (t && typeof l == "string") {
      if (t.addDefaultProtocol && l.startsWith("www.")) {
        const i = l.match(/\./g);
        (i == null ? void 0 : i.length) >= 2 && (l = `http://${l}`);
      }
      if (t.tryConvertEncoding)
        try {
          l = V0(l);
        } catch {
        }
    }
    const s = e ? new URL(l, e) : new URL(l);
    if (F0(s))
      return s;
  } catch {
  }
  return null;
}
function et(l, e, t, s = !1) {
  return Object.defineProperty(l, e, {
    value: t,
    enumerable: !s,
    configurable: !0,
    writable: !1
  }), t;
}
const vn = function() {
  function e(t, s) {
    this.constructor === e && at("Cannot initialize BaseException."), this.message = t, this.name = s;
  }
  return e.prototype = new Error(), e.constructor = e, e;
}();
class fm extends vn {
  constructor(e, t) {
    super(e, "PasswordException"), this.code = t;
  }
}
class pm extends vn {
  constructor(e, t) {
    super(e, "UnknownErrorException"), this.details = t;
  }
}
let Ly = class extends vn {
  constructor(e) {
    super(e, "InvalidPDFException");
  }
}, sa = class extends vn {
  constructor(e) {
    super(e, "MissingPDFException");
  }
}, Bg = class extends vn {
  constructor(e, t) {
    super(e, "UnexpectedResponseException"), this.status = t;
  }
};
class B0 extends vn {
  constructor(e) {
    super(e, "FormatError");
  }
}
let ia = class extends vn {
  constructor(e) {
    super(e, "AbortException");
  }
};
function _y(l) {
  (typeof l != "object" || (l == null ? void 0 : l.length) === void 0) && at("Invalid argument for bytesToString");
  const e = l.length, t = 8192;
  if (e < t)
    return String.fromCharCode.apply(null, l);
  const s = [];
  for (let i = 0; i < e; i += t) {
    const n = Math.min(i + t, e), r = l.subarray(i, n);
    s.push(String.fromCharCode.apply(null, r));
  }
  return s.join("");
}
function jg(l) {
  typeof l != "string" && at("Invalid argument for stringToBytes");
  const e = l.length, t = new Uint8Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = l.charCodeAt(s) & 255;
  return t;
}
function j0(l) {
  return String.fromCharCode(l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, l & 255);
}
function ib(l) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const [t, s] of l)
    e[t] = s;
  return e;
}
function H0() {
  const l = new Uint8Array(4);
  return l[0] = 1, new Uint32Array(l.buffer, 0, 1)[0] === 1;
}
function $0() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class ue {
  static get isLittleEndian() {
    return et(this, "isLittleEndian", H0());
  }
  static get isEvalSupported() {
    return et(this, "isEvalSupported", $0());
  }
  static get isOffscreenCanvasSupported() {
    return et(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? et(this, "platform", {
      isMac: navigator.platform.includes("Mac")
    }) : et(this, "platform", {
      isMac: !1
    });
  }
  static get isCSSRoundSupported() {
    var e, t;
    return et(this, "isCSSRoundSupported", (t = (e = globalThis.CSS) == null ? void 0 : e.supports) == null ? void 0 : t.call(e, "width: round(1.5px, 1px)"));
  }
}
const Qg = Array.from(Array(256).keys(), (l) => l.toString(16).padStart(2, "0"));
var ba, vu, Au, Xl, gm;
let U = (vu = class {
  static makeHexColor(e, t, s) {
    return `#${Qg[e]}${Qg[t]}${Qg[s]}`;
  }
  static scaleMinMax(e, t) {
    let s;
    e[0] ? (e[0] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[0], t[2] *= e[0], e[3] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[3], t[3] *= e[3]) : (s = t[0], t[0] = t[1], t[1] = s, s = t[2], t[2] = t[3], t[3] = s, e[1] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[1], t[3] *= e[1], e[2] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[2], t[2] *= e[2]), t[0] += e[4], t[1] += e[5], t[2] += e[4], t[3] += e[5];
  }
  static transform(e, t) {
    return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
  }
  static applyTransform(e, t) {
    const s = e[0] * t[0] + e[1] * t[2] + t[4], i = e[0] * t[1] + e[1] * t[3] + t[5];
    return [s, i];
  }
  static applyInverseTransform(e, t) {
    const s = t[0] * t[3] - t[1] * t[2], i = (e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / s, n = (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / s;
    return [i, n];
  }
  static getAxialAlignedBoundingBox(e, t) {
    const s = this.applyTransform(e, t), i = this.applyTransform(e.slice(2, 4), t), n = this.applyTransform([e[0], e[3]], t), r = this.applyTransform([e[2], e[1]], t);
    return [Math.min(s[0], i[0], n[0], r[0]), Math.min(s[1], i[1], n[1], r[1]), Math.max(s[0], i[0], n[0], r[0]), Math.max(s[1], i[1], n[1], r[1])];
  }
  static inverseTransform(e) {
    const t = e[0] * e[3] - e[1] * e[2];
    return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t];
  }
  static singularValueDecompose2dScale(e) {
    const t = [e[0], e[2], e[1], e[3]], s = e[0] * t[0] + e[1] * t[2], i = e[0] * t[1] + e[1] * t[3], n = e[2] * t[0] + e[3] * t[2], r = e[2] * t[1] + e[3] * t[3], a = (s + r) / 2, h = Math.sqrt((s + r) ** 2 - 4 * (s * r - n * i)) / 2, c = a + h || 1, d = a - h || 1;
    return [Math.sqrt(c), Math.sqrt(d)];
  }
  static normalizeRect(e) {
    const t = e.slice(0);
    return e[0] > e[2] && (t[0] = e[2], t[2] = e[0]), e[1] > e[3] && (t[1] = e[3], t[3] = e[1]), t;
  }
  static intersect(e, t) {
    const s = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])), i = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]));
    if (s > i)
      return null;
    const n = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])), r = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]));
    return n > r ? null : [s, n, i, r];
  }
  static bezierBoundingBox(e, t, s, i, n, r, a, h, c) {
    return c ? (c[0] = Math.min(c[0], e, a), c[1] = Math.min(c[1], t, h), c[2] = Math.max(c[2], e, a), c[3] = Math.max(c[3], t, h)) : c = [Math.min(e, a), Math.min(t, h), Math.max(e, a), Math.max(t, h)], v(this, Xl, gm).call(this, e, s, n, a, t, i, r, h, 3 * (-e + 3 * (s - n) + a), 6 * (e - 2 * s + n), 3 * (s - e), c), v(this, Xl, gm).call(this, e, s, n, a, t, i, r, h, 3 * (-t + 3 * (i - r) + h), 6 * (t - 2 * i + r), 3 * (i - t), c), c;
  }
}, ba = new WeakSet(), Au = function(e, t, s, i, n, r, a, h, c, d) {
  if (c <= 0 || c >= 1)
    return;
  const u = 1 - c, f = c * c, m = f * c, g = u * (u * (u * e + 3 * c * t) + 3 * f * s) + m * i, A = u * (u * (u * n + 3 * c * r) + 3 * f * a) + m * h;
  d[0] = Math.min(d[0], g), d[1] = Math.min(d[1], A), d[2] = Math.max(d[2], g), d[3] = Math.max(d[3], A);
}, Xl = new WeakSet(), gm = function(e, t, s, i, n, r, a, h, c, d, u, f) {
  if (Math.abs(c) < 1e-12) {
    Math.abs(d) >= 1e-12 && v(this, ba, Au).call(this, e, t, s, i, n, r, a, h, -u / d, f);
    return;
  }
  const m = d ** 2 - 4 * u * c;
  if (m < 0)
    return;
  const g = Math.sqrt(m), A = 2 * c;
  v(this, ba, Au).call(this, e, t, s, i, n, r, a, h, (-d + g) / A, f), v(this, ba, Au).call(this, e, t, s, i, n, r, a, h, (-d - g) / A, f);
}, p(vu, ba), p(vu, Xl), vu);
function V0(l) {
  return decodeURIComponent(escape(l));
}
let Zg = null, Sb = null;
function U0(l) {
  return Zg || (Zg = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Sb = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), l.replaceAll(Zg, (e, t, s) => t ? t.normalize("NFKC") : Sb.get(s));
}
function z0() {
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
    return crypto.randomUUID();
  const l = new Uint8Array(32);
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
    crypto.getRandomValues(l);
  else
    for (let e = 0; e < 32; e++)
      l[e] = Math.floor(Math.random() * 255);
  return _y(l);
}
const My = "pdfjs_internal_id_", Ts = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
};
st(4628);
st(1454);
st(3375);
st(9225);
st(3972);
st(9209);
st(5714);
st(7561);
st(6197);
st(4979);
st(8992);
st(4743);
st(3215);
st(7550);
st(8335);
st(4520);
class Hg {
  constructor() {
    this.constructor === Hg && at("Cannot initialize BaseFilterFactory.");
  }
  addFilter(e) {
    return "none";
  }
  addHCMFilter(e, t) {
    return "none";
  }
  addAlphaFilter(e) {
    return "none";
  }
  addLuminosityFilter(e) {
    return "none";
  }
  addHighlightHCMFilter(e, t, s, i, n) {
    return "none";
  }
  destroy(e = !1) {
  }
}
var Kl;
const gb = class gb {
  constructor({
    enableHWA: e = !1
  } = {}) {
    p(this, Kl, !1);
    this.constructor === gb && at("Cannot initialize BaseCanvasFactory."), b(this, Kl, e);
  }
  create(e, t) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid canvas size");
    const s = this._createCanvas(e, t);
    return {
      canvas: s,
      context: s.getContext("2d", {
        willReadFrequently: !o(this, Kl)
      })
    };
  }
  reset(e, t, s) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    if (t <= 0 || s <= 0)
      throw new Error("Invalid canvas size");
    e.canvas.width = t, e.canvas.height = s;
  }
  destroy(e) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null;
  }
  _createCanvas(e, t) {
    at("Abstract method `_createCanvas` called.");
  }
};
Kl = new WeakMap();
let nf = gb;
class $g {
  constructor({
    baseUrl: e = null,
    isCompressed: t = !0
  }) {
    this.constructor === $g && at("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = e, this.isCompressed = t;
  }
  async fetch({
    name: e
  }) {
    if (!this.baseUrl)
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
    if (!e)
      throw new Error("CMap name must be specified.");
    const t = this.baseUrl + e + (this.isCompressed ? ".bcmap" : ""), s = this.isCompressed ? um.BINARY : um.NONE;
    return this._fetchData(t, s).catch((i) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t}`);
    });
  }
  _fetchData(e, t) {
    at("Abstract method `_fetchData` called.");
  }
}
class Vg {
  constructor({
    baseUrl: e = null
  }) {
    this.constructor === Vg && at("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = e;
  }
  async fetch({
    filename: e
  }) {
    if (!this.baseUrl)
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
    if (!e)
      throw new Error("Font filename must be specified.");
    const t = `${this.baseUrl}${e}`;
    return this._fetchData(t).catch((s) => {
      throw new Error(`Unable to load font data at: ${t}`);
    });
  }
  _fetchData(e) {
    at("Abstract method `_fetchData` called.");
  }
}
class nb {
  constructor() {
    this.constructor === nb && at("Cannot initialize BaseSVGFactory.");
  }
  create(e, t, s = !1) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), s || (i.setAttribute("width", `${e}px`), i.setAttribute("height", `${t}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${e} ${t}`), i;
  }
  createElement(e) {
    if (typeof e != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(e);
  }
  _createSVG(e) {
    at("Abstract method `_createSVG` called.");
  }
}
const Rs = "http://www.w3.org/2000/svg";
var gi;
let rl = (gi = class {
}, K(gi, "CSS", 96), K(gi, "PDF", 72), K(gi, "PDF_TO_CSS_UNITS", gi.CSS / gi.PDF), gi);
var xn, ss, ks, he, mf, Pn, kt, Xt, Ci, aa, Ri, oa, ya, Eu, vf, Oy, Yl, mm, Ii, la, Tn, ml, Cn, vl, Ql, vm, Rn, bl;
class W0 extends Hg {
  constructor({
    docId: t,
    ownerDocument: s = globalThis.document
  } = {}) {
    super();
    p(this, kt);
    p(this, Ci);
    p(this, Ri);
    p(this, ya);
    p(this, vf);
    p(this, Yl);
    p(this, Ii);
    p(this, Tn);
    p(this, Cn);
    p(this, Ql);
    p(this, Rn);
    p(this, xn, void 0);
    p(this, ss, void 0);
    p(this, ks, void 0);
    p(this, he, void 0);
    p(this, mf, void 0);
    p(this, Pn, 0);
    b(this, ks, t), b(this, he, s);
  }
  addFilter(t) {
    if (!t)
      return "none";
    let s = o(this, kt, Xt).get(t);
    if (s)
      return s;
    const [i, n, r] = v(this, ya, Eu).call(this, t), a = t.length === 1 ? i : `${i}${n}${r}`;
    if (s = o(this, kt, Xt).get(a), s)
      return o(this, kt, Xt).set(t, s), s;
    const h = `g_${o(this, ks)}_transfer_map_${oe(this, Pn)._++}`, c = `url(#${h})`;
    o(this, kt, Xt).set(t, c), o(this, kt, Xt).set(a, c);
    const d = v(this, Ii, la).call(this, h);
    return v(this, Cn, vl).call(this, i, n, r, d), c;
  }
  addHCMFilter(t, s) {
    var g;
    const i = `${t}-${s}`, n = "base";
    let r = o(this, Ci, aa).get(n);
    if ((r == null ? void 0 : r.key) === i || (r ? ((g = r.filter) == null || g.remove(), r.key = i, r.url = "none", r.filter = null) : (r = {
      key: i,
      url: "none",
      filter: null
    }, o(this, Ci, aa).set(n, r)), !t || !s))
      return r.url;
    const a = v(this, Rn, bl).call(this, t);
    t = U.makeHexColor(...a);
    const h = v(this, Rn, bl).call(this, s);
    if (s = U.makeHexColor(...h), o(this, Ri, oa).style.color = "", t === "#000000" && s === "#ffffff" || t === s)
      return r.url;
    const c = new Array(256);
    for (let A = 0; A <= 255; A++) {
      const E = A / 255;
      c[A] = E <= 0.03928 ? E / 12.92 : ((E + 0.055) / 1.055) ** 2.4;
    }
    const d = c.join(","), u = `g_${o(this, ks)}_hcm_filter`, f = r.filter = v(this, Ii, la).call(this, u);
    v(this, Cn, vl).call(this, d, d, d, f), v(this, Yl, mm).call(this, f);
    const m = (A, E) => {
      const y = a[A] / 255, w = h[A] / 255, S = new Array(E + 1);
      for (let C = 0; C <= E; C++)
        S[C] = y + C / E * (w - y);
      return S.join(",");
    };
    return v(this, Cn, vl).call(this, m(0, 5), m(1, 5), m(2, 5), f), r.url = `url(#${u})`, r.url;
  }
  addAlphaFilter(t) {
    let s = o(this, kt, Xt).get(t);
    if (s)
      return s;
    const [i] = v(this, ya, Eu).call(this, [t]), n = `alpha_${i}`;
    if (s = o(this, kt, Xt).get(n), s)
      return o(this, kt, Xt).set(t, s), s;
    const r = `g_${o(this, ks)}_alpha_map_${oe(this, Pn)._++}`, a = `url(#${r})`;
    o(this, kt, Xt).set(t, a), o(this, kt, Xt).set(n, a);
    const h = v(this, Ii, la).call(this, r);
    return v(this, Ql, vm).call(this, i, h), a;
  }
  addLuminosityFilter(t) {
    let s = o(this, kt, Xt).get(t || "luminosity");
    if (s)
      return s;
    let i, n;
    if (t ? ([i] = v(this, ya, Eu).call(this, [t]), n = `luminosity_${i}`) : n = "luminosity", s = o(this, kt, Xt).get(n), s)
      return o(this, kt, Xt).set(t, s), s;
    const r = `g_${o(this, ks)}_luminosity_map_${oe(this, Pn)._++}`, a = `url(#${r})`;
    o(this, kt, Xt).set(t, a), o(this, kt, Xt).set(n, a);
    const h = v(this, Ii, la).call(this, r);
    return v(this, vf, Oy).call(this, h), t && v(this, Ql, vm).call(this, i, h), a;
  }
  addHighlightHCMFilter(t, s, i, n, r) {
    var w;
    const a = `${s}-${i}-${n}-${r}`;
    let h = o(this, Ci, aa).get(t);
    if ((h == null ? void 0 : h.key) === a || (h ? ((w = h.filter) == null || w.remove(), h.key = a, h.url = "none", h.filter = null) : (h = {
      key: a,
      url: "none",
      filter: null
    }, o(this, Ci, aa).set(t, h)), !s || !i))
      return h.url;
    const [c, d] = [s, i].map(v(this, Rn, bl).bind(this));
    let u = Math.round(0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2]), f = Math.round(0.2126 * d[0] + 0.7152 * d[1] + 0.0722 * d[2]), [m, g] = [n, r].map(v(this, Rn, bl).bind(this));
    f < u && ([u, f, m, g] = [f, u, g, m]), o(this, Ri, oa).style.color = "";
    const A = (S, C, P) => {
      const x = new Array(256), R = (f - u) / P, M = S / 255, T = (C - S) / (255 * P);
      let I = 0;
      for (let _ = 0; _ <= P; _++) {
        const k = Math.round(u + _ * R), F = M + _ * T;
        for (let V = I; V <= k; V++)
          x[V] = F;
        I = k + 1;
      }
      for (let _ = I; _ < 256; _++)
        x[_] = x[I - 1];
      return x.join(",");
    }, E = `g_${o(this, ks)}_hcm_${t}_filter`, y = h.filter = v(this, Ii, la).call(this, E);
    return v(this, Yl, mm).call(this, y), v(this, Cn, vl).call(this, A(m[0], g[0], 5), A(m[1], g[1], 5), A(m[2], g[2], 5), y), h.url = `url(#${E})`, h.url;
  }
  destroy(t = !1) {
    t && o(this, Ci, aa).size !== 0 || (o(this, ss) && (o(this, ss).parentNode.parentNode.remove(), b(this, ss, null)), o(this, xn) && (o(this, xn).clear(), b(this, xn, null)), b(this, Pn, 0));
  }
}
xn = new WeakMap(), ss = new WeakMap(), ks = new WeakMap(), he = new WeakMap(), mf = new WeakMap(), Pn = new WeakMap(), kt = new WeakSet(), Xt = function() {
  return o(this, xn) || b(this, xn, /* @__PURE__ */ new Map());
}, Ci = new WeakSet(), aa = function() {
  return o(this, mf) || b(this, mf, /* @__PURE__ */ new Map());
}, Ri = new WeakSet(), oa = function() {
  if (!o(this, ss)) {
    const t = o(this, he).createElement("div"), {
      style: s
    } = t;
    s.visibility = "hidden", s.contain = "strict", s.width = s.height = 0, s.position = "absolute", s.top = s.left = 0, s.zIndex = -1;
    const i = o(this, he).createElementNS(Rs, "svg");
    i.setAttribute("width", 0), i.setAttribute("height", 0), b(this, ss, o(this, he).createElementNS(Rs, "defs")), t.append(i), i.append(o(this, ss)), o(this, he).body.append(t);
  }
  return o(this, ss);
}, ya = new WeakSet(), Eu = function(t) {
  if (t.length === 1) {
    const c = t[0], d = new Array(256);
    for (let f = 0; f < 256; f++)
      d[f] = c[f] / 255;
    const u = d.join(",");
    return [u, u, u];
  }
  const [s, i, n] = t, r = new Array(256), a = new Array(256), h = new Array(256);
  for (let c = 0; c < 256; c++)
    r[c] = s[c] / 255, a[c] = i[c] / 255, h[c] = n[c] / 255;
  return [r.join(","), a.join(","), h.join(",")];
}, vf = new WeakSet(), Oy = function(t) {
  const s = o(this, he).createElementNS(Rs, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), t.append(s);
}, Yl = new WeakSet(), mm = function(t) {
  const s = o(this, he).createElementNS(Rs, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), t.append(s);
}, Ii = new WeakSet(), la = function(t) {
  const s = o(this, he).createElementNS(Rs, "filter");
  return s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("id", t), o(this, Ri, oa).append(s), s;
}, Tn = new WeakSet(), ml = function(t, s, i) {
  const n = o(this, he).createElementNS(Rs, s);
  n.setAttribute("type", "discrete"), n.setAttribute("tableValues", i), t.append(n);
}, Cn = new WeakSet(), vl = function(t, s, i, n) {
  const r = o(this, he).createElementNS(Rs, "feComponentTransfer");
  n.append(r), v(this, Tn, ml).call(this, r, "feFuncR", t), v(this, Tn, ml).call(this, r, "feFuncG", s), v(this, Tn, ml).call(this, r, "feFuncB", i);
}, Ql = new WeakSet(), vm = function(t, s) {
  const i = o(this, he).createElementNS(Rs, "feComponentTransfer");
  s.append(i), v(this, Tn, ml).call(this, i, "feFuncA", t);
}, Rn = new WeakSet(), bl = function(t) {
  return o(this, Ri, oa).style.color = t, hb(getComputedStyle(o(this, Ri, oa)).getPropertyValue("color"));
};
class G0 extends nf {
  constructor({
    ownerDocument: e = globalThis.document,
    enableHWA: t = !1
  } = {}) {
    super({
      enableHWA: t
    }), this._document = e;
  }
  _createCanvas(e, t) {
    const s = this._document.createElement("canvas");
    return s.width = e, s.height = t, s;
  }
}
async function Ug(l, e = "text") {
  if (yl(l, document.baseURI)) {
    const t = await fetch(l);
    if (!t.ok)
      throw new Error(t.statusText);
    switch (e) {
      case "arraybuffer":
        return t.arrayBuffer();
      case "blob":
        return t.blob();
      case "json":
        return t.json();
    }
    return t.text();
  }
  return new Promise((t, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", l, !0), i.responseType = e, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (e) {
            case "arraybuffer":
            case "blob":
            case "json":
              t(i.response);
              return;
          }
          t(i.responseText);
          return;
        }
        s(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
class Dy extends $g {
  _fetchData(e, t) {
    return Ug(e, this.isCompressed ? "arraybuffer" : "text").then((s) => ({
      cMapData: s instanceof ArrayBuffer ? new Uint8Array(s) : jg(s),
      compressionType: t
    }));
  }
}
class ky extends Vg {
  _fetchData(e) {
    return Ug(e, "arraybuffer").then((t) => new Uint8Array(t));
  }
}
let rb = class extends nb {
  _createSVG(e) {
    return document.createElementNS(Rs, e);
  }
};
class su {
  constructor({
    viewBox: e,
    scale: t,
    rotation: s,
    offsetX: i = 0,
    offsetY: n = 0,
    dontFlip: r = !1
  }) {
    this.viewBox = e, this.scale = t, this.rotation = s, this.offsetX = i, this.offsetY = n;
    const a = (e[2] + e[0]) / 2, h = (e[3] + e[1]) / 2;
    let c, d, u, f;
    switch (s %= 360, s < 0 && (s += 360), s) {
      case 180:
        c = -1, d = 0, u = 0, f = 1;
        break;
      case 90:
        c = 0, d = 1, u = 1, f = 0;
        break;
      case 270:
        c = 0, d = -1, u = -1, f = 0;
        break;
      case 0:
        c = 1, d = 0, u = 0, f = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    r && (u = -u, f = -f);
    let m, g, A, E;
    c === 0 ? (m = Math.abs(h - e[1]) * t + i, g = Math.abs(a - e[0]) * t + n, A = (e[3] - e[1]) * t, E = (e[2] - e[0]) * t) : (m = Math.abs(a - e[0]) * t + i, g = Math.abs(h - e[1]) * t + n, A = (e[2] - e[0]) * t, E = (e[3] - e[1]) * t), this.transform = [c * t, d * t, u * t, f * t, m - c * t * a - u * t * h, g - d * t * a - f * t * h], this.width = A, this.height = E;
  }
  get rawDims() {
    const {
      viewBox: e
    } = this;
    return et(this, "rawDims", {
      pageWidth: e[2] - e[0],
      pageHeight: e[3] - e[1],
      pageX: e[0],
      pageY: e[1]
    });
  }
  clone({
    scale: e = this.scale,
    rotation: t = this.rotation,
    offsetX: s = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: n = !1
  } = {}) {
    return new su({
      viewBox: this.viewBox.slice(),
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  convertToViewportPoint(e, t) {
    return U.applyTransform([e, t], this.transform);
  }
  convertToViewportRectangle(e) {
    const t = U.applyTransform([e[0], e[1]], this.transform), s = U.applyTransform([e[2], e[3]], this.transform);
    return [t[0], t[1], s[0], s[1]];
  }
  convertToPdfPoint(e, t) {
    return U.applyInverseTransform([e, t], this.transform);
  }
}
let ab = class extends vn {
  constructor(e, t = 0) {
    super(e, "RenderingCancelledException"), this.extraDelay = t;
  }
};
function ob(l) {
  const e = l.length;
  let t = 0;
  for (; t < e && l[t].trim() === ""; )
    t++;
  return l.substring(t, t + 5).toLowerCase() === "data:";
}
function lb(l) {
  return typeof l == "string" && /\.pdf$/i.test(l);
}
function X0(l) {
  return [l] = l.split(/[#?]/, 1), l.substring(l.lastIndexOf("/") + 1);
}
function K0(l, e = "document.pdf") {
  if (typeof l != "string")
    return e;
  if (ob(l))
    return Q('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), e;
  const t = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, s = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = t.exec(l);
  let n = s.exec(i[1]) || s.exec(i[2]) || s.exec(i[3]);
  if (n && (n = n[0], n.includes("%")))
    try {
      n = s.exec(decodeURIComponent(n))[0];
    } catch {
    }
  return n || e;
}
class xb {
  constructor() {
    K(this, "started", /* @__PURE__ */ Object.create(null));
    K(this, "times", []);
  }
  time(e) {
    e in this.started && Q(`Timer is already running for ${e}`), this.started[e] = Date.now();
  }
  timeEnd(e) {
    e in this.started || Q(`Timer has not been started for ${e}`), this.times.push({
      name: e,
      start: this.started[e],
      end: Date.now()
    }), delete this.started[e];
  }
  toString() {
    const e = [];
    let t = 0;
    for (const {
      name: s
    } of this.times)
      t = Math.max(s.length, t);
    for (const {
      name: s,
      start: i,
      end: n
    } of this.times)
      e.push(`${s.padEnd(t)} ${n - i}ms
`);
    return e.join("");
  }
}
function yl(l, e) {
  try {
    const {
      protocol: t
    } = e ? new URL(l, e) : new URL(l);
    return t === "http:" || t === "https:";
  } catch {
    return !1;
  }
}
function fe(l) {
  l.preventDefault();
}
function Fy(l) {
  console.log("Deprecated API usage: " + l);
}
let Pb, Ny = class {
  static toDateObject(e) {
    if (!e || typeof e != "string")
      return null;
    Pb || (Pb = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const t = Pb.exec(e);
    if (!t)
      return null;
    const s = parseInt(t[1], 10);
    let i = parseInt(t[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let n = parseInt(t[3], 10);
    n = n >= 1 && n <= 31 ? n : 1;
    let r = parseInt(t[4], 10);
    r = r >= 0 && r <= 23 ? r : 0;
    let a = parseInt(t[5], 10);
    a = a >= 0 && a <= 59 ? a : 0;
    let h = parseInt(t[6], 10);
    h = h >= 0 && h <= 59 ? h : 0;
    const c = t[7] || "Z";
    let d = parseInt(t[8], 10);
    d = d >= 0 && d <= 23 ? d : 0;
    let u = parseInt(t[9], 10) || 0;
    return u = u >= 0 && u <= 59 ? u : 0, c === "-" ? (r += d, a += u) : c === "+" && (r -= d, a -= u), new Date(Date.UTC(s, i, n, r, a, h));
  }
};
function Y0(l, {
  scale: e = 1,
  rotation: t = 0
}) {
  const {
    width: s,
    height: i
  } = l.attributes.style, n = [0, 0, parseInt(s), parseInt(i)];
  return new su({
    viewBox: n,
    scale: e,
    rotation: t
  });
}
function hb(l) {
  if (l.startsWith("#")) {
    const e = parseInt(l.slice(1), 16);
    return [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255];
  }
  return l.startsWith("rgb(") ? l.slice(4, -1).split(",").map((e) => parseInt(e)) : l.startsWith("rgba(") ? l.slice(5, -1).split(",").map((e) => parseInt(e)).slice(0, 3) : (Q(`Not a valid color format: "${l}"`), [0, 0, 0]);
}
function Q0(l) {
  const e = document.createElement("span");
  e.style.visibility = "hidden", document.body.append(e);
  for (const t of l.keys()) {
    e.style.color = t;
    const s = window.getComputedStyle(e).color;
    l.set(t, hb(s));
  }
  e.remove();
}
function pt(l) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: n,
    f: r
  } = l.getTransform();
  return [e, t, s, i, n, r];
}
function Cs(l) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: n,
    f: r
  } = l.getTransform().invertSelf();
  return [e, t, s, i, n, r];
}
function ta(l, e, t = !1, s = !0) {
  if (e instanceof su) {
    const {
      pageWidth: i,
      pageHeight: n
    } = e.rawDims, {
      style: r
    } = l, a = ue.isCSSRoundSupported, h = `var(--scale-factor) * ${i}px`, c = `var(--scale-factor) * ${n}px`, d = a ? `round(${h}, 1px)` : `calc(${h})`, u = a ? `round(${c}, 1px)` : `calc(${c})`;
    !t || e.rotation % 180 === 0 ? (r.width = d, r.height = u) : (r.width = u, r.height = d);
  }
  s && l.setAttribute("data-main-rotation", e.rotation);
}
var In, Ln, ge, _n, bf, By, yf, jy, Af, Hy, Aa, wu, Ef, $y, Zl, ym;
const wf = class wf {
  constructor(e) {
    p(this, yf);
    p(this, Af);
    p(this, Aa);
    p(this, Ef);
    p(this, Zl);
    p(this, In, null);
    p(this, Ln, null);
    p(this, ge, void 0);
    p(this, _n, null);
    b(this, ge, e);
  }
  render() {
    const e = b(this, In, document.createElement("div"));
    e.className = "editToolbar", e.setAttribute("role", "toolbar");
    const t = o(this, ge)._uiManager._signal;
    e.addEventListener("contextmenu", fe, {
      signal: t
    }), e.addEventListener("pointerdown", v(wf, bf, By), {
      signal: t
    });
    const s = b(this, _n, document.createElement("div"));
    s.className = "buttons", e.append(s);
    const i = o(this, ge).toolbarPosition;
    if (i) {
      const {
        style: n
      } = e, r = o(this, ge)._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      n.insetInlineEnd = `${100 * r}%`, n.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return v(this, Ef, $y).call(this), e;
  }
  hide() {
    var e;
    o(this, In).classList.add("hidden"), (e = o(this, Ln)) == null || e.hideDropdown();
  }
  show() {
    o(this, In).classList.remove("hidden");
  }
  addAltTextButton(e) {
    v(this, Aa, wu).call(this, e), o(this, _n).prepend(e, o(this, Zl, ym));
  }
  addColorPicker(e) {
    b(this, Ln, e);
    const t = e.renderButton();
    v(this, Aa, wu).call(this, t), o(this, _n).prepend(t, o(this, Zl, ym));
  }
  remove() {
    var e;
    o(this, In).remove(), (e = o(this, Ln)) == null || e.destroy(), b(this, Ln, null);
  }
};
In = new WeakMap(), Ln = new WeakMap(), ge = new WeakMap(), _n = new WeakMap(), bf = new WeakSet(), By = function(e) {
  e.stopPropagation();
}, yf = new WeakSet(), jy = function(e) {
  o(this, ge)._focusEventsAllowed = !1, e.preventDefault(), e.stopPropagation();
}, Af = new WeakSet(), Hy = function(e) {
  o(this, ge)._focusEventsAllowed = !0, e.preventDefault(), e.stopPropagation();
}, Aa = new WeakSet(), wu = function(e) {
  const t = o(this, ge)._uiManager._signal;
  e.addEventListener("focusin", v(this, yf, jy).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("focusout", v(this, Af, Hy).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("contextmenu", fe, {
    signal: t
  });
}, Ef = new WeakSet(), $y = function() {
  const e = document.createElement("button");
  e.className = "delete", e.tabIndex = 0, e.setAttribute("data-l10n-id", `pdfjs-editor-remove-${o(this, ge).editorType}-button`), v(this, Aa, wu).call(this, e), e.addEventListener("click", (t) => {
    o(this, ge)._uiManager.delete();
  }, {
    signal: o(this, ge)._uiManager._signal
  }), o(this, _n).append(e);
}, Zl = new WeakSet(), ym = function() {
  const e = document.createElement("div");
  return e.className = "divider", e;
}, p(wf, bf);
let bm = wf;
var Jl, Mn, On, Sf, Vy, xf, Uy, Pf, zy;
class Z0 {
  constructor(e) {
    p(this, Sf);
    p(this, xf);
    p(this, Pf);
    p(this, Jl, null);
    p(this, Mn, null);
    p(this, On, void 0);
    b(this, On, e);
  }
  show(e, t, s) {
    const [i, n] = v(this, xf, Uy).call(this, t, s), {
      style: r
    } = o(this, Mn) || b(this, Mn, v(this, Sf, Vy).call(this));
    e.append(o(this, Mn)), r.insetInlineEnd = `${100 * i}%`, r.top = `calc(${100 * n}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    o(this, Mn).remove();
  }
}
Jl = new WeakMap(), Mn = new WeakMap(), On = new WeakMap(), Sf = new WeakSet(), Vy = function() {
  const e = b(this, Mn, document.createElement("div"));
  e.className = "editToolbar", e.setAttribute("role", "toolbar"), e.addEventListener("contextmenu", fe, {
    signal: o(this, On)._signal
  });
  const t = b(this, Jl, document.createElement("div"));
  return t.className = "buttons", e.append(t), v(this, Pf, zy).call(this), e;
}, xf = new WeakSet(), Uy = function(e, t) {
  let s = 0, i = 0;
  for (const n of e) {
    const r = n.y + n.height;
    if (r < s)
      continue;
    const a = n.x + (t ? n.width : 0);
    if (r > s) {
      i = a, s = r;
      continue;
    }
    t ? a > i && (i = a) : a < i && (i = a);
  }
  return [t ? 1 - i : i, s];
}, Pf = new WeakSet(), zy = function() {
  const e = document.createElement("button");
  e.className = "highlightButton", e.tabIndex = 0, e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const t = document.createElement("span");
  e.append(t), t.className = "visuallyHidden", t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const s = o(this, On)._signal;
  e.addEventListener("contextmenu", fe, {
    signal: s
  }), e.addEventListener("click", () => {
    o(this, On).highlightSelection("floating_button");
  }, {
    signal: s
  }), o(this, Jl).append(e);
};
function rf(l, e, t) {
  for (const s of t)
    e.addEventListener(s, l[s].bind(l));
}
function J0(l) {
  return Math.round(Math.min(255, Math.max(1, 255 * l))).toString(16).padStart(2, "0");
}
var Tf;
class q0 {
  constructor() {
    p(this, Tf, 0);
  }
  get id() {
    return `${_0}${oe(this, Tf)._++}`;
  }
}
Tf = new WeakMap();
var ql, Cf, Ce, th, Em;
const mb = class mb {
  constructor() {
    p(this, th);
    p(this, ql, z0());
    p(this, Cf, 0);
    p(this, Ce, null);
  }
  static get _isSVGFittingCanvas() {
    const e = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = e;
    const n = i.decode().then(() => (s.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return et(this, "_isSVGFittingCanvas", n);
  }
  async getFromFile(e) {
    const {
      lastModified: t,
      name: s,
      size: i,
      type: n
    } = e;
    return v(this, th, Em).call(this, `${t}_${s}_${i}_${n}`, e);
  }
  async getFromUrl(e) {
    return v(this, th, Em).call(this, e, e);
  }
  async getFromId(e) {
    o(this, Ce) || b(this, Ce, /* @__PURE__ */ new Map());
    const t = o(this, Ce).get(e);
    return t ? t.bitmap ? (t.refCounter += 1, t) : t.file ? this.getFromFile(t.file) : this.getFromUrl(t.url) : null;
  }
  getSvgUrl(e) {
    const t = o(this, Ce).get(e);
    return t != null && t.isSvg ? t.svgUrl : null;
  }
  deleteId(e) {
    o(this, Ce) || b(this, Ce, /* @__PURE__ */ new Map());
    const t = o(this, Ce).get(e);
    t && (t.refCounter -= 1, t.refCounter === 0 && (t.bitmap = null));
  }
  isValidId(e) {
    return e.startsWith(`image_${o(this, ql)}_`);
  }
};
ql = new WeakMap(), Cf = new WeakMap(), Ce = new WeakMap(), th = new WeakSet(), Em = async function(e, t) {
  o(this, Ce) || b(this, Ce, /* @__PURE__ */ new Map());
  let s = o(this, Ce).get(e);
  if (s === null)
    return null;
  if (s != null && s.bitmap)
    return s.refCounter += 1, s;
  try {
    s || (s = {
      bitmap: null,
      id: `image_${o(this, ql)}_${oe(this, Cf)._++}`,
      refCounter: 0,
      isSvg: !1
    });
    let i;
    if (typeof t == "string" ? (s.url = t, i = await Ug(t, "blob")) : i = s.file = t, i.type === "image/svg+xml") {
      const n = mb._isSVGFittingCanvas, r = new FileReader(), a = new Image(), h = new Promise((c, d) => {
        a.onload = () => {
          s.bitmap = a, s.isSvg = !0, c();
        }, r.onload = async () => {
          const u = s.svgUrl = r.result;
          a.src = await n ? `${u}#svgView(preserveAspectRatio(none))` : u;
        }, a.onerror = r.onerror = d;
      });
      r.readAsDataURL(i), await h;
    } else
      s.bitmap = await createImageBitmap(i);
    s.refCounter = 1;
  } catch (i) {
    console.error(i), s = null;
  }
  return o(this, Ce).set(e, s), s && o(this, Ce).set(s.id, s), s;
};
let Am = mb;
var Ft, Li, eh, Nt;
class tw {
  constructor(e = 128) {
    p(this, Ft, []);
    p(this, Li, !1);
    p(this, eh, void 0);
    p(this, Nt, -1);
    b(this, eh, e);
  }
  add({
    cmd: e,
    undo: t,
    post: s,
    mustExec: i,
    type: n = NaN,
    overwriteIfSameType: r = !1,
    keepUndo: a = !1
  }) {
    if (i && e(), o(this, Li))
      return;
    const h = {
      cmd: e,
      undo: t,
      post: s,
      type: n
    };
    if (o(this, Nt) === -1) {
      o(this, Ft).length > 0 && (o(this, Ft).length = 0), b(this, Nt, 0), o(this, Ft).push(h);
      return;
    }
    if (r && o(this, Ft)[o(this, Nt)].type === n) {
      a && (h.undo = o(this, Ft)[o(this, Nt)].undo), o(this, Ft)[o(this, Nt)] = h;
      return;
    }
    const c = o(this, Nt) + 1;
    c === o(this, eh) ? o(this, Ft).splice(0, 1) : (b(this, Nt, c), c < o(this, Ft).length && o(this, Ft).splice(c)), o(this, Ft).push(h);
  }
  undo() {
    if (o(this, Nt) === -1)
      return;
    b(this, Li, !0);
    const {
      undo: e,
      post: t
    } = o(this, Ft)[o(this, Nt)];
    e(), t == null || t(), b(this, Li, !1), b(this, Nt, o(this, Nt) - 1);
  }
  redo() {
    if (o(this, Nt) < o(this, Ft).length - 1) {
      b(this, Nt, o(this, Nt) + 1), b(this, Li, !0);
      const {
        cmd: e,
        post: t
      } = o(this, Ft)[o(this, Nt)];
      e(), t == null || t(), b(this, Li, !1);
    }
  }
  hasSomethingToUndo() {
    return o(this, Nt) !== -1;
  }
  hasSomethingToRedo() {
    return o(this, Nt) < o(this, Ft).length - 1;
  }
  destroy() {
    b(this, Ft, null);
  }
}
Ft = new WeakMap(), Li = new WeakMap(), eh = new WeakMap(), Nt = new WeakMap();
var Rf, Wy;
class iu {
  constructor(e) {
    p(this, Rf);
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: t
    } = ue.platform;
    for (const [s, i, n = {}] of e)
      for (const r of s) {
        const a = r.startsWith("mac+");
        t && a ? (this.callbacks.set(r.slice(4), {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1))) : !t && !a && (this.callbacks.set(r, {
          callback: i,
          options: n
        }), this.allKeys.add(r.split("+").at(-1)));
      }
  }
  exec(e, t) {
    if (!this.allKeys.has(t.key))
      return;
    const s = this.callbacks.get(v(this, Rf, Wy).call(this, t));
    if (!s)
      return;
    const {
      callback: i,
      options: {
        bubbles: n = !1,
        args: r = [],
        checker: a = null
      }
    } = s;
    a && !a(e, t) || (i.bind(e, ...r, t)(), n || (t.stopPropagation(), t.preventDefault()));
  }
}
Rf = new WeakSet(), Wy = function(e) {
  e.altKey && this.buffer.push("alt"), e.ctrlKey && this.buffer.push("ctrl"), e.metaKey && this.buffer.push("meta"), e.shiftKey && this.buffer.push("shift"), this.buffer.push(e.key);
  const t = this.buffer.join("+");
  return this.buffer.length = 0, t;
};
const If = class If {
  get _colors() {
    const e = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return Q0(e), et(this, "_colors", e);
  }
  convert(e) {
    const t = hb(e);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return t;
    for (const [s, i] of this._colors)
      if (i.every((n, r) => n === t[r]))
        return If._colorsMapping.get(s);
    return t;
  }
  getHexCode(e) {
    const t = this._colors.get(e);
    return t ? U.makeHexColor(...t) : e;
  }
};
K(If, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
let wm = If;
var Ea, me, Ct, jt, wa, Fs, Sa, je, xa, Dn, is, He, kn, sh, ih, ns, Pa, _i, rs, Lf, Mi, nh, Fn, rh, Ta, Ht, it, Ns, Nn, ah, oh, lh, hh, ch, dh, uh, fh, ph, gh, mh, vh, bh, Oi, as, Bs, yh, gn, Ca, Su, _f, Gy, Mf, Xy, Ra, xu, Of, Ky, Df, Yy, kf, Qy, Ah, Sm, Ff, Zy, Eh, xm, wh, Pm, Nf, Jy, $t, te, os, yi, Bf, qy, jf, tA, Sh, Tm, Hf, eA, Bn, Al, xh, Cm;
let Vl = (gn = class {
  constructor(e, t, s, i, n, r, a, h, c) {
    p(this, Ca);
    p(this, _f);
    p(this, Mf);
    p(this, Ra);
    p(this, Of);
    p(this, Df);
    p(this, kf);
    p(this, Ah);
    p(this, Ff);
    p(this, Eh);
    p(this, wh);
    p(this, Nf);
    p(this, $t);
    p(this, os);
    p(this, Bf);
    p(this, jf);
    p(this, Sh);
    p(this, Hf);
    p(this, Bn);
    p(this, xh);
    p(this, Ea, new AbortController());
    p(this, me, null);
    p(this, Ct, /* @__PURE__ */ new Map());
    p(this, jt, /* @__PURE__ */ new Map());
    p(this, wa, null);
    p(this, Fs, null);
    p(this, Sa, null);
    p(this, je, new tw());
    p(this, xa, 0);
    p(this, Dn, /* @__PURE__ */ new Set());
    p(this, is, null);
    p(this, He, null);
    p(this, kn, /* @__PURE__ */ new Set());
    p(this, sh, !1);
    p(this, ih, null);
    p(this, ns, null);
    p(this, Pa, null);
    p(this, _i, !1);
    p(this, rs, null);
    p(this, Lf, new q0());
    p(this, Mi, !1);
    p(this, nh, !1);
    p(this, Fn, null);
    p(this, rh, null);
    p(this, Ta, null);
    p(this, Ht, q.NONE);
    p(this, it, /* @__PURE__ */ new Set());
    p(this, Ns, null);
    p(this, Nn, null);
    p(this, ah, null);
    p(this, oh, this.blur.bind(this));
    p(this, lh, this.focus.bind(this));
    p(this, hh, this.copy.bind(this));
    p(this, ch, this.cut.bind(this));
    p(this, dh, this.paste.bind(this));
    p(this, uh, this.keydown.bind(this));
    p(this, fh, this.keyup.bind(this));
    p(this, ph, this.onEditingAction.bind(this));
    p(this, gh, this.onPageChanging.bind(this));
    p(this, mh, this.onScaleChanging.bind(this));
    p(this, vh, this.onRotationChanging.bind(this));
    p(this, bh, {
      isEditing: !1,
      isEmpty: !0,
      hasSomethingToUndo: !1,
      hasSomethingToRedo: !1,
      hasSelectedEditor: !1,
      hasSelectedText: !1
    });
    p(this, Oi, [0, 0]);
    p(this, as, null);
    p(this, Bs, null);
    p(this, yh, null);
    this._signal = o(this, Ea).signal, b(this, Bs, e), b(this, yh, t), b(this, wa, s), this._eventBus = i, this._eventBus._on("editingaction", o(this, ph)), this._eventBus._on("pagechanging", o(this, gh)), this._eventBus._on("scalechanging", o(this, mh)), this._eventBus._on("rotationchanging", o(this, vh)), v(this, Of, Ky).call(this), v(this, Nf, Jy).call(this), v(this, Ah, Sm).call(this), b(this, Fs, n.annotationStorage), b(this, ih, n.filterFactory), b(this, Nn, r), b(this, Pa, a || null), b(this, sh, h), b(this, Ta, c || null), this.viewParameters = {
      realScale: rl.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1;
  }
  static get _keyboardManager() {
    const e = gn.prototype, t = (r) => o(r, Bs).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && r.hasSomethingToControl(), s = (r, {
      target: a
    }) => {
      if (a instanceof HTMLInputElement) {
        const {
          type: h
        } = a;
        return h !== "text" && h !== "number";
      }
      return !0;
    }, i = this.TRANSLATE_SMALL, n = this.TRANSLATE_BIG;
    return et(this, "_keyboardManager", new iu([[["ctrl+a", "mac+meta+a"], e.selectAll, {
      checker: s
    }], [["ctrl+z", "mac+meta+z"], e.undo, {
      checker: s
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e.redo, {
      checker: s
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e.delete, {
      checker: s
    }], [["Enter", "mac+Enter"], e.addNewEditorFromKeyboard, {
      checker: (r, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && o(r, Bs).contains(a) && !r.isEnterHandled
    }], [[" ", "mac+ "], e.addNewEditorFromKeyboard, {
      checker: (r, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && o(r, Bs).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], e.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e.translateSelectedEditors, {
      args: [-i, 0],
      checker: t
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e.translateSelectedEditors, {
      args: [-n, 0],
      checker: t
    }], [["ArrowRight", "mac+ArrowRight"], e.translateSelectedEditors, {
      args: [i, 0],
      checker: t
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e.translateSelectedEditors, {
      args: [n, 0],
      checker: t
    }], [["ArrowUp", "mac+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -i],
      checker: t
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -n],
      checker: t
    }], [["ArrowDown", "mac+ArrowDown"], e.translateSelectedEditors, {
      args: [0, i],
      checker: t
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e.translateSelectedEditors, {
      args: [0, n],
      checker: t
    }]]));
  }
  destroy() {
    var e, t, s;
    (e = o(this, Ea)) == null || e.abort(), b(this, Ea, null), this._signal = null, this._eventBus._off("editingaction", o(this, ph)), this._eventBus._off("pagechanging", o(this, gh)), this._eventBus._off("scalechanging", o(this, mh)), this._eventBus._off("rotationchanging", o(this, vh));
    for (const i of o(this, jt).values())
      i.destroy();
    o(this, jt).clear(), o(this, Ct).clear(), o(this, kn).clear(), b(this, me, null), o(this, it).clear(), o(this, je).destroy(), (t = o(this, wa)) == null || t.destroy(), (s = o(this, rs)) == null || s.hide(), b(this, rs, null), o(this, ns) && (clearTimeout(o(this, ns)), b(this, ns, null)), o(this, as) && (clearTimeout(o(this, as)), b(this, as, null));
  }
  async mlGuess(e) {
    var t;
    return ((t = o(this, Ta)) == null ? void 0 : t.guess(e)) || null;
  }
  get hasMLManager() {
    return !!o(this, Ta);
  }
  get hcmFilter() {
    return et(this, "hcmFilter", o(this, Nn) ? o(this, ih).addHCMFilter(o(this, Nn).foreground, o(this, Nn).background) : "none");
  }
  get direction() {
    return et(this, "direction", getComputedStyle(o(this, Bs)).direction);
  }
  get highlightColors() {
    return et(this, "highlightColors", o(this, Pa) ? new Map(o(this, Pa).split(",").map((e) => e.split("=").map((t) => t.trim()))) : null);
  }
  get highlightColorNames() {
    return et(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
  }
  setMainHighlightColorPicker(e) {
    b(this, rh, e);
  }
  editAltText(e) {
    var t;
    (t = o(this, wa)) == null || t.editAltText(this, e);
  }
  onPageChanging({
    pageNumber: e
  }) {
    b(this, xa, e - 1);
  }
  focusMainContainer() {
    o(this, Bs).focus();
  }
  findParent(e, t) {
    for (const s of o(this, jt).values()) {
      const {
        x: i,
        y: n,
        width: r,
        height: a
      } = s.div.getBoundingClientRect();
      if (e >= i && e <= i + r && t >= n && t <= n + a)
        return s;
    }
    return null;
  }
  disableUserSelect(e = !1) {
    o(this, yh).classList.toggle("noUserSelect", e);
  }
  addShouldRescale(e) {
    o(this, kn).add(e);
  }
  removeShouldRescale(e) {
    o(this, kn).delete(e);
  }
  onScaleChanging({
    scale: e
  }) {
    this.commitOrRemove(), this.viewParameters.realScale = e * rl.PDF_TO_CSS_UNITS;
    for (const t of o(this, kn))
      t.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: e
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = e;
  }
  highlightSelection(e = "") {
    const t = document.getSelection();
    if (!t || t.isCollapsed)
      return;
    const {
      anchorNode: s,
      anchorOffset: i,
      focusNode: n,
      focusOffset: r
    } = t, a = t.toString(), c = v(this, Ca, Su).call(this, t).closest(".textLayer"), d = this.getSelectionBoxes(c);
    if (d) {
      t.empty(), o(this, Ht) === q.NONE && (this._eventBus.dispatch("showannotationeditorui", {
        source: this,
        mode: q.HIGHLIGHT
      }), this.showAllEditors("highlight", !0, !0));
      for (const u of o(this, jt).values())
        if (u.hasTextLayer(c)) {
          u.createAndAddNewEditor({
            x: 0,
            y: 0
          }, !1, {
            methodOfCreation: e,
            boxes: d,
            anchorNode: s,
            anchorOffset: i,
            focusNode: n,
            focusOffset: r,
            text: a
          });
          break;
        }
    }
  }
  addToAnnotationStorage(e) {
    !e.isEmpty() && o(this, Fs) && !o(this, Fs).has(e.id) && o(this, Fs).setValue(e.id, e);
  }
  blur() {
    if (this.isShiftKeyDown = !1, o(this, _i) && (b(this, _i, !1), v(this, Ra, xu).call(this, "main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: e
    } = document;
    for (const t of o(this, it))
      if (t.div.contains(e)) {
        b(this, Fn, [t, e]), t._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!o(this, Fn))
      return;
    const [e, t] = o(this, Fn);
    b(this, Fn, null), t.addEventListener("focusin", () => {
      e._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), t.focus();
  }
  addEditListeners() {
    v(this, Ah, Sm).call(this), v(this, Eh, xm).call(this);
  }
  removeEditListeners() {
    v(this, Ff, Zy).call(this), v(this, wh, Pm).call(this);
  }
  dragOver(e) {
    for (const {
      type: t
    } of e.dataTransfer.items)
      for (const s of o(this, He))
        if (s.isHandlingMimeForPasting(t)) {
          e.dataTransfer.dropEffect = "copy", e.preventDefault();
          return;
        }
  }
  drop(e) {
    for (const t of e.dataTransfer.items)
      for (const s of o(this, He))
        if (s.isHandlingMimeForPasting(t.type)) {
          s.paste(t, this.currentLayer), e.preventDefault();
          return;
        }
  }
  copy(e) {
    var s;
    if (e.preventDefault(), (s = o(this, me)) == null || s.commitOrRemove(), !this.hasSelection)
      return;
    const t = [];
    for (const i of o(this, it)) {
      const n = i.serialize(!0);
      n && t.push(n);
    }
    t.length !== 0 && e.clipboardData.setData("application/pdfjs", JSON.stringify(t));
  }
  cut(e) {
    this.copy(e), this.delete();
  }
  paste(e) {
    e.preventDefault();
    const {
      clipboardData: t
    } = e;
    for (const n of t.items)
      for (const r of o(this, He))
        if (r.isHandlingMimeForPasting(n.type)) {
          r.paste(n, this.currentLayer);
          return;
        }
    let s = t.getData("application/pdfjs");
    if (!s)
      return;
    try {
      s = JSON.parse(s);
    } catch (n) {
      Q(`paste: "${n.message}".`);
      return;
    }
    if (!Array.isArray(s))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const n = [];
      for (const h of s) {
        const c = i.deserialize(h);
        if (!c)
          return;
        n.push(c);
      }
      const r = () => {
        for (const h of n)
          v(this, Sh, Tm).call(this, h);
        v(this, xh, Cm).call(this, n);
      }, a = () => {
        for (const h of n)
          h.remove();
      };
      this.addCommands({
        cmd: r,
        undo: a,
        mustExec: !0
      });
    } catch (n) {
      Q(`paste: "${n.message}".`);
    }
  }
  keydown(e) {
    !this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !0), o(this, Ht) !== q.NONE && !this.isEditorHandlingKeyboard && gn._keyboardManager.exec(this, e);
  }
  keyup(e) {
    this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !1, o(this, _i) && (b(this, _i, !1), v(this, Ra, xu).call(this, "main_toolbar")));
  }
  onEditingAction({
    name: e
  }) {
    switch (e) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[e]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  setEditingState(e) {
    e ? (v(this, Df, Yy).call(this), v(this, Eh, xm).call(this), v(this, $t, te).call(this, {
      isEditing: o(this, Ht) !== q.NONE,
      isEmpty: v(this, Bn, Al).call(this),
      hasSomethingToUndo: o(this, je).hasSomethingToUndo(),
      hasSomethingToRedo: o(this, je).hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (v(this, kf, Qy).call(this), v(this, wh, Pm).call(this), v(this, $t, te).call(this, {
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(e) {
    if (!o(this, He)) {
      b(this, He, e);
      for (const t of o(this, He))
        v(this, os, yi).call(this, t.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return o(this, Lf).id;
  }
  get currentLayer() {
    return o(this, jt).get(o(this, xa));
  }
  getLayer(e) {
    return o(this, jt).get(e);
  }
  get currentPageIndex() {
    return o(this, xa);
  }
  addLayer(e) {
    o(this, jt).set(e.pageIndex, e), o(this, Mi) ? e.enable() : e.disable();
  }
  removeLayer(e) {
    o(this, jt).delete(e.pageIndex);
  }
  updateMode(e, t = null, s = !1) {
    if (o(this, Ht) !== e) {
      if (b(this, Ht, e), e === q.NONE) {
        this.setEditingState(!1), v(this, jf, tA).call(this);
        return;
      }
      this.setEditingState(!0), v(this, Bf, qy).call(this), this.unselectAll();
      for (const i of o(this, jt).values())
        i.updateMode(e);
      if (!t && s) {
        this.addNewEditorFromKeyboard();
        return;
      }
      if (t) {
        for (const i of o(this, Ct).values())
          if (i.annotationElementId === t) {
            this.setSelected(i), i.enterInEditMode();
            break;
          }
      }
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(e) {
    e !== o(this, Ht) && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode: e
    });
  }
  updateParams(e, t) {
    var s;
    if (o(this, He)) {
      switch (e) {
        case X.CREATE:
          this.currentLayer.addNewEditor();
          return;
        case X.HIGHLIGHT_DEFAULT_COLOR:
          (s = o(this, rh)) == null || s.updateColor(t);
          break;
        case X.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (o(this, ah) || b(this, ah, /* @__PURE__ */ new Map())).set(e, t), this.showAllEditors("highlight", t);
          break;
      }
      for (const i of o(this, it))
        i.updateParams(e, t);
      for (const i of o(this, He))
        i.updateDefaultParams(e, t);
    }
  }
  showAllEditors(e, t, s = !1) {
    var n;
    for (const r of o(this, Ct).values())
      r.editorType === e && r.show(t);
    (((n = o(this, ah)) == null ? void 0 : n.get(X.HIGHLIGHT_SHOW_ALL)) ?? !0) !== t && v(this, os, yi).call(this, [[X.HIGHLIGHT_SHOW_ALL, t]]);
  }
  enableWaiting(e = !1) {
    if (o(this, nh) !== e) {
      b(this, nh, e);
      for (const t of o(this, jt).values())
        e ? t.disableClick() : t.enableClick(), t.div.classList.toggle("waiting", e);
    }
  }
  getEditors(e) {
    const t = [];
    for (const s of o(this, Ct).values())
      s.pageIndex === e && t.push(s);
    return t;
  }
  getEditor(e) {
    return o(this, Ct).get(e);
  }
  addEditor(e) {
    o(this, Ct).set(e.id, e);
  }
  removeEditor(e) {
    var t;
    e.div.contains(document.activeElement) && (o(this, ns) && clearTimeout(o(this, ns)), b(this, ns, setTimeout(() => {
      this.focusMainContainer(), b(this, ns, null);
    }, 0))), o(this, Ct).delete(e.id), this.unselect(e), (!e.annotationElementId || !o(this, Dn).has(e.annotationElementId)) && ((t = o(this, Fs)) == null || t.remove(e.id));
  }
  addDeletedAnnotationElement(e) {
    o(this, Dn).add(e.annotationElementId), this.addChangedExistingAnnotation(e), e.deleted = !0;
  }
  isDeletedAnnotationElement(e) {
    return o(this, Dn).has(e);
  }
  removeDeletedAnnotationElement(e) {
    o(this, Dn).delete(e.annotationElementId), this.removeChangedExistingAnnotation(e), e.deleted = !1;
  }
  setActiveEditor(e) {
    o(this, me) !== e && (b(this, me, e), e && v(this, os, yi).call(this, e.propertiesToUpdate));
  }
  updateUI(e) {
    o(this, Hf, eA) === e && v(this, os, yi).call(this, e.propertiesToUpdate);
  }
  toggleSelected(e) {
    if (o(this, it).has(e)) {
      o(this, it).delete(e), e.unselect(), v(this, $t, te).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    o(this, it).add(e), e.select(), v(this, os, yi).call(this, e.propertiesToUpdate), v(this, $t, te).call(this, {
      hasSelectedEditor: !0
    });
  }
  setSelected(e) {
    for (const t of o(this, it))
      t !== e && t.unselect();
    o(this, it).clear(), o(this, it).add(e), e.select(), v(this, os, yi).call(this, e.propertiesToUpdate), v(this, $t, te).call(this, {
      hasSelectedEditor: !0
    });
  }
  isSelected(e) {
    return o(this, it).has(e);
  }
  get firstSelectedEditor() {
    return o(this, it).values().next().value;
  }
  unselect(e) {
    e.unselect(), o(this, it).delete(e), v(this, $t, te).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return o(this, it).size !== 0;
  }
  get isEnterHandled() {
    return o(this, it).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    o(this, je).undo(), v(this, $t, te).call(this, {
      hasSomethingToUndo: o(this, je).hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: v(this, Bn, Al).call(this)
    });
  }
  redo() {
    o(this, je).redo(), v(this, $t, te).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: o(this, je).hasSomethingToRedo(),
      isEmpty: v(this, Bn, Al).call(this)
    });
  }
  addCommands(e) {
    o(this, je).add(e), v(this, $t, te).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: v(this, Bn, Al).call(this)
    });
  }
  delete() {
    if (this.commitOrRemove(), !this.hasSelection)
      return;
    const e = [...o(this, it)], t = () => {
      for (const i of e)
        i.remove();
    }, s = () => {
      for (const i of e)
        v(this, Sh, Tm).call(this, i);
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !0
    });
  }
  commitOrRemove() {
    var e;
    (e = o(this, me)) == null || e.commitOrRemove();
  }
  hasSomethingToControl() {
    return o(this, me) || this.hasSelection;
  }
  selectAll() {
    for (const e of o(this, it))
      e.commit();
    v(this, xh, Cm).call(this, o(this, Ct).values());
  }
  unselectAll() {
    if (!(o(this, me) && (o(this, me).commitOrRemove(), o(this, Ht) !== q.NONE)) && this.hasSelection) {
      for (const e of o(this, it))
        e.unselect();
      o(this, it).clear(), v(this, $t, te).call(this, {
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(e, t, s = !1) {
    if (s || this.commitOrRemove(), !this.hasSelection)
      return;
    o(this, Oi)[0] += e, o(this, Oi)[1] += t;
    const [i, n] = o(this, Oi), r = [...o(this, it)], a = 1e3;
    o(this, as) && clearTimeout(o(this, as)), b(this, as, setTimeout(() => {
      b(this, as, null), o(this, Oi)[0] = o(this, Oi)[1] = 0, this.addCommands({
        cmd: () => {
          for (const h of r)
            o(this, Ct).has(h.id) && h.translateInPage(i, n);
        },
        undo: () => {
          for (const h of r)
            o(this, Ct).has(h.id) && h.translateInPage(-i, -n);
        },
        mustExec: !1
      });
    }, a));
    for (const h of r)
      h.translateInPage(e, t);
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), b(this, is, /* @__PURE__ */ new Map());
      for (const e of o(this, it))
        o(this, is).set(e, {
          savedX: e.x,
          savedY: e.y,
          savedPageIndex: e.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!o(this, is))
      return !1;
    this.disableUserSelect(!1);
    const e = o(this, is);
    b(this, is, null);
    let t = !1;
    for (const [{
      x: i,
      y: n,
      pageIndex: r
    }, a] of e)
      a.newX = i, a.newY = n, a.newPageIndex = r, t || (t = i !== a.savedX || n !== a.savedY || r !== a.savedPageIndex);
    if (!t)
      return !1;
    const s = (i, n, r, a) => {
      if (o(this, Ct).has(i.id)) {
        const h = o(this, jt).get(a);
        h ? i._setParentAndPosition(h, n, r) : (i.pageIndex = a, i.x = n, i.y = r);
      }
    };
    return this.addCommands({
      cmd: () => {
        for (const [i, {
          newX: n,
          newY: r,
          newPageIndex: a
        }] of e)
          s(i, n, r, a);
      },
      undo: () => {
        for (const [i, {
          savedX: n,
          savedY: r,
          savedPageIndex: a
        }] of e)
          s(i, n, r, a);
      },
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(e, t) {
    if (o(this, is))
      for (const s of o(this, is).keys())
        s.drag(e, t);
  }
  rebuild(e) {
    if (e.parent === null) {
      const t = this.getLayer(e.pageIndex);
      t ? (t.changeParent(e), t.addOrRebuild(e)) : (this.addEditor(e), this.addToAnnotationStorage(e), e.rebuild());
    } else
      e.parent.addOrRebuild(e);
  }
  get isEditorHandlingKeyboard() {
    var e;
    return ((e = this.getActive()) == null ? void 0 : e.shouldGetKeyboardEvents()) || o(this, it).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(e) {
    return o(this, me) === e;
  }
  getActive() {
    return o(this, me);
  }
  getMode() {
    return o(this, Ht);
  }
  get imageManager() {
    return et(this, "imageManager", new Am());
  }
  getSelectionBoxes(e) {
    if (!e)
      return null;
    const t = document.getSelection();
    for (let c = 0, d = t.rangeCount; c < d; c++)
      if (!e.contains(t.getRangeAt(c).commonAncestorContainer))
        return null;
    const {
      x: s,
      y: i,
      width: n,
      height: r
    } = e.getBoundingClientRect();
    let a;
    switch (e.getAttribute("data-main-rotation")) {
      case "90":
        a = (c, d, u, f) => ({
          x: (d - i) / r,
          y: 1 - (c + u - s) / n,
          width: f / r,
          height: u / n
        });
        break;
      case "180":
        a = (c, d, u, f) => ({
          x: 1 - (c + u - s) / n,
          y: 1 - (d + f - i) / r,
          width: u / n,
          height: f / r
        });
        break;
      case "270":
        a = (c, d, u, f) => ({
          x: 1 - (d + f - i) / r,
          y: (c - s) / n,
          width: f / r,
          height: u / n
        });
        break;
      default:
        a = (c, d, u, f) => ({
          x: (c - s) / n,
          y: (d - i) / r,
          width: u / n,
          height: f / r
        });
        break;
    }
    const h = [];
    for (let c = 0, d = t.rangeCount; c < d; c++) {
      const u = t.getRangeAt(c);
      if (!u.collapsed)
        for (const {
          x: f,
          y: m,
          width: g,
          height: A
        } of u.getClientRects())
          g === 0 || A === 0 || h.push(a(f, m, g, A));
    }
    return h.length === 0 ? null : h;
  }
  addChangedExistingAnnotation({
    annotationElementId: e,
    id: t
  }) {
    (o(this, Sa) || b(this, Sa, /* @__PURE__ */ new Map())).set(e, t);
  }
  removeChangedExistingAnnotation({
    annotationElementId: e
  }) {
    var t;
    (t = o(this, Sa)) == null || t.delete(e);
  }
  renderAnnotationElement(e) {
    var i;
    const t = (i = o(this, Sa)) == null ? void 0 : i.get(e.data.id);
    if (!t)
      return;
    const s = o(this, Fs).getRawValue(t);
    s && (o(this, Ht) === q.NONE && !s.hasBeenModified || s.renderAnnotationElement(e));
  }
}, Ea = new WeakMap(), me = new WeakMap(), Ct = new WeakMap(), jt = new WeakMap(), wa = new WeakMap(), Fs = new WeakMap(), Sa = new WeakMap(), je = new WeakMap(), xa = new WeakMap(), Dn = new WeakMap(), is = new WeakMap(), He = new WeakMap(), kn = new WeakMap(), sh = new WeakMap(), ih = new WeakMap(), ns = new WeakMap(), Pa = new WeakMap(), _i = new WeakMap(), rs = new WeakMap(), Lf = new WeakMap(), Mi = new WeakMap(), nh = new WeakMap(), Fn = new WeakMap(), rh = new WeakMap(), Ta = new WeakMap(), Ht = new WeakMap(), it = new WeakMap(), Ns = new WeakMap(), Nn = new WeakMap(), ah = new WeakMap(), oh = new WeakMap(), lh = new WeakMap(), hh = new WeakMap(), ch = new WeakMap(), dh = new WeakMap(), uh = new WeakMap(), fh = new WeakMap(), ph = new WeakMap(), gh = new WeakMap(), mh = new WeakMap(), vh = new WeakMap(), bh = new WeakMap(), Oi = new WeakMap(), as = new WeakMap(), Bs = new WeakMap(), yh = new WeakMap(), Ca = new WeakSet(), Su = function({
  anchorNode: e
}) {
  return e.nodeType === Node.TEXT_NODE ? e.parentElement : e;
}, _f = new WeakSet(), Gy = function() {
  const e = document.getSelection();
  if (!e || e.isCollapsed)
    return;
  const s = v(this, Ca, Su).call(this, e).closest(".textLayer"), i = this.getSelectionBoxes(s);
  i && (o(this, rs) || b(this, rs, new Z0(this)), o(this, rs).show(s, i, this.direction === "ltr"));
}, Mf = new WeakSet(), Xy = function() {
  var n, r, a;
  const e = document.getSelection();
  if (!e || e.isCollapsed) {
    o(this, Ns) && ((n = o(this, rs)) == null || n.hide(), b(this, Ns, null), v(this, $t, te).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  const {
    anchorNode: t
  } = e;
  if (t === o(this, Ns))
    return;
  if (!v(this, Ca, Su).call(this, e).closest(".textLayer")) {
    o(this, Ns) && ((r = o(this, rs)) == null || r.hide(), b(this, Ns, null), v(this, $t, te).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  if ((a = o(this, rs)) == null || a.hide(), b(this, Ns, t), v(this, $t, te).call(this, {
    hasSelectedText: !0
  }), !(o(this, Ht) !== q.HIGHLIGHT && o(this, Ht) !== q.NONE) && (o(this, Ht) === q.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), b(this, _i, this.isShiftKeyDown), !this.isShiftKeyDown)) {
    const h = this._signal, c = (d) => {
      d.type === "pointerup" && d.button !== 0 || (window.removeEventListener("pointerup", c), window.removeEventListener("blur", c), d.type === "pointerup" && v(this, Ra, xu).call(this, "main_toolbar"));
    };
    window.addEventListener("pointerup", c, {
      signal: h
    }), window.addEventListener("blur", c, {
      signal: h
    });
  }
}, Ra = new WeakSet(), xu = function(e = "") {
  o(this, Ht) === q.HIGHLIGHT ? this.highlightSelection(e) : o(this, sh) && v(this, _f, Gy).call(this);
}, Of = new WeakSet(), Ky = function() {
  document.addEventListener("selectionchange", v(this, Mf, Xy).bind(this), {
    signal: this._signal
  });
}, Df = new WeakSet(), Yy = function() {
  const e = this._signal;
  window.addEventListener("focus", o(this, lh), {
    signal: e
  }), window.addEventListener("blur", o(this, oh), {
    signal: e
  });
}, kf = new WeakSet(), Qy = function() {
  window.removeEventListener("focus", o(this, lh)), window.removeEventListener("blur", o(this, oh));
}, Ah = new WeakSet(), Sm = function() {
  const e = this._signal;
  window.addEventListener("keydown", o(this, uh), {
    signal: e
  }), window.addEventListener("keyup", o(this, fh), {
    signal: e
  });
}, Ff = new WeakSet(), Zy = function() {
  window.removeEventListener("keydown", o(this, uh)), window.removeEventListener("keyup", o(this, fh));
}, Eh = new WeakSet(), xm = function() {
  const e = this._signal;
  document.addEventListener("copy", o(this, hh), {
    signal: e
  }), document.addEventListener("cut", o(this, ch), {
    signal: e
  }), document.addEventListener("paste", o(this, dh), {
    signal: e
  });
}, wh = new WeakSet(), Pm = function() {
  document.removeEventListener("copy", o(this, hh)), document.removeEventListener("cut", o(this, ch)), document.removeEventListener("paste", o(this, dh));
}, Nf = new WeakSet(), Jy = function() {
  const e = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal: e
  }), document.addEventListener("drop", this.drop.bind(this), {
    signal: e
  });
}, $t = new WeakSet(), te = function(e) {
  Object.entries(e).some(([s, i]) => o(this, bh)[s] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
    source: this,
    details: Object.assign(o(this, bh), e)
  }), o(this, Ht) === q.HIGHLIGHT && e.hasSelectedEditor === !1 && v(this, os, yi).call(this, [[X.HIGHLIGHT_FREE, !0]]));
}, os = new WeakSet(), yi = function(e) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details: e
  });
}, Bf = new WeakSet(), qy = function() {
  if (!o(this, Mi)) {
    b(this, Mi, !0);
    for (const e of o(this, jt).values())
      e.enable();
    for (const e of o(this, Ct).values())
      e.enable();
  }
}, jf = new WeakSet(), tA = function() {
  if (this.unselectAll(), o(this, Mi)) {
    b(this, Mi, !1);
    for (const e of o(this, jt).values())
      e.disable();
    for (const e of o(this, Ct).values())
      e.disable();
  }
}, Sh = new WeakSet(), Tm = function(e) {
  const t = o(this, jt).get(e.pageIndex);
  t ? t.addOrRebuild(e) : (this.addEditor(e), this.addToAnnotationStorage(e));
}, Hf = new WeakSet(), eA = function() {
  let e = null;
  for (e of o(this, it))
    ;
  return e;
}, Bn = new WeakSet(), Al = function() {
  if (o(this, Ct).size === 0)
    return !0;
  if (o(this, Ct).size === 1)
    for (const e of o(this, Ct).values())
      return e.isEmpty();
  return !1;
}, xh = new WeakSet(), Cm = function(e) {
  for (const t of o(this, it))
    t.unselect();
  o(this, it).clear();
  for (const t of e)
    t.isEmpty() || (o(this, it).add(t), t.select());
  v(this, $t, te).call(this, {
    hasSelectedEditor: this.hasSelection
  });
}, K(gn, "TRANSLATE_SMALL", 1), K(gn, "TRANSLATE_BIG", 10), gn);
var js, Hs, $e, $s, ve, Ia, Ve, Ph, Rm;
const Ls = class Ls {
  constructor(e) {
    p(this, Ph);
    p(this, js, "");
    p(this, Hs, !1);
    p(this, $e, null);
    p(this, $s, null);
    p(this, ve, null);
    p(this, Ia, !1);
    p(this, Ve, null);
    b(this, Ve, e);
  }
  static initialize(e) {
    Ls._l10nPromise || (Ls._l10nPromise = e);
  }
  async render() {
    const e = b(this, $e, document.createElement("button"));
    e.className = "altText";
    const t = await Ls._l10nPromise.get("pdfjs-editor-alt-text-button-label");
    e.textContent = t, e.setAttribute("aria-label", t), e.tabIndex = "0";
    const s = o(this, Ve)._uiManager._signal;
    e.addEventListener("contextmenu", fe, {
      signal: s
    }), e.addEventListener("pointerdown", (n) => n.stopPropagation(), {
      signal: s
    });
    const i = (n) => {
      n.preventDefault(), o(this, Ve)._uiManager.editAltText(o(this, Ve));
    };
    return e.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), e.addEventListener("keydown", (n) => {
      n.target === e && n.key === "Enter" && (b(this, Ia, !0), i(n));
    }, {
      signal: s
    }), await v(this, Ph, Rm).call(this), e;
  }
  finish() {
    o(this, $e) && (o(this, $e).focus({
      focusVisible: o(this, Ia)
    }), b(this, Ia, !1));
  }
  isEmpty() {
    return !o(this, js) && !o(this, Hs);
  }
  get data() {
    return {
      altText: o(this, js),
      decorative: o(this, Hs)
    };
  }
  set data({
    altText: e,
    decorative: t
  }) {
    o(this, js) === e && o(this, Hs) === t || (b(this, js, e), b(this, Hs, t), v(this, Ph, Rm).call(this));
  }
  toggle(e = !1) {
    o(this, $e) && (!e && o(this, ve) && (clearTimeout(o(this, ve)), b(this, ve, null)), o(this, $e).disabled = !e);
  }
  destroy() {
    var e;
    (e = o(this, $e)) == null || e.remove(), b(this, $e, null), b(this, $s, null);
  }
};
js = new WeakMap(), Hs = new WeakMap(), $e = new WeakMap(), $s = new WeakMap(), ve = new WeakMap(), Ia = new WeakMap(), Ve = new WeakMap(), Ph = new WeakSet(), Rm = async function() {
  var i;
  const e = o(this, $e);
  if (!e)
    return;
  if (!o(this, js) && !o(this, Hs)) {
    e.classList.remove("done"), (i = o(this, $s)) == null || i.remove();
    return;
  }
  e.classList.add("done"), Ls._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((n) => {
    e.setAttribute("aria-label", n);
  });
  let t = o(this, $s);
  if (!t) {
    b(this, $s, t = document.createElement("span")), t.className = "tooltip", t.setAttribute("role", "tooltip");
    const n = t.id = `alt-text-tooltip-${o(this, Ve).id}`;
    e.setAttribute("aria-describedby", n);
    const r = 100, a = o(this, Ve)._uiManager._signal;
    a.addEventListener("abort", () => {
      clearTimeout(o(this, ve)), b(this, ve, null);
    }, {
      once: !0
    }), e.addEventListener("mouseenter", () => {
      b(this, ve, setTimeout(() => {
        b(this, ve, null), o(this, $s).classList.add("show"), o(this, Ve)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, r));
    }, {
      signal: a
    }), e.addEventListener("mouseleave", () => {
      var h;
      o(this, ve) && (clearTimeout(o(this, ve)), b(this, ve, null)), (h = o(this, $s)) == null || h.classList.remove("show");
    }, {
      signal: a
    });
  }
  t.innerText = o(this, Hs) ? await Ls._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : o(this, js), t.parentNode || e.append(t);
  const s = o(this, Ve).getImageForAltText();
  s == null || s.setAttribute("aria-describedby", t.id);
}, K(Ls, "_l10nPromise", null);
let af = Ls;
var jn, Ue, Kt, La, Hn, Vt, $n, _a, Ma, Yt, Th, Vn, Di, Ch, Un, Vs, ls, Oa, Da, Re, Rh, $f, Ih, Im, Lh, Lm, _h, _m, Vf, sA, Uf, iA, Mh, Mm, Oh, Om, Dh, Dm, zf, nA, Wf, rA, Gf, aA, Xf, oA, kh, km, zn, El;
const ht = class ht {
  constructor(e) {
    p(this, Ih);
    p(this, _h);
    p(this, Vf);
    p(this, Uf);
    p(this, Mh);
    p(this, Oh);
    p(this, Dh);
    p(this, zf);
    p(this, Wf);
    p(this, Gf);
    p(this, Xf);
    p(this, kh);
    p(this, zn);
    p(this, jn, null);
    p(this, Ue, null);
    p(this, Kt, null);
    p(this, La, !1);
    p(this, Hn, !1);
    p(this, Vt, null);
    p(this, $n, null);
    p(this, _a, this.focusin.bind(this));
    p(this, Ma, this.focusout.bind(this));
    p(this, Yt, null);
    p(this, Th, "");
    p(this, Vn, !1);
    p(this, Di, null);
    p(this, Ch, !1);
    p(this, Un, !1);
    p(this, Vs, !1);
    p(this, ls, null);
    p(this, Oa, 0);
    p(this, Da, 0);
    p(this, Re, null);
    K(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    K(this, "_isVisible", !0);
    K(this, "_uiManager", null);
    K(this, "_focusEventsAllowed", !0);
    K(this, "_l10nPromise", null);
    p(this, Rh, !1);
    p(this, $f, ht._zIndex++);
    this.constructor === ht && at("Cannot initialize AnnotationEditor."), this.parent = e.parent, this.id = e.id, this.width = this.height = null, this.pageIndex = e.parent.pageIndex, this.name = e.name, this.div = null, this._uiManager = e.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = e.isCentered, this._structTreeParentId = null;
    const {
      rotation: t,
      rawDims: {
        pageWidth: s,
        pageHeight: i,
        pageX: n,
        pageY: r
      }
    } = this.parent.viewport;
    this.rotation = t, this.pageRotation = (360 + t - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, i], this.pageTranslation = [n, r];
    const [a, h] = this.parentDimensions;
    this.x = e.x / a, this.y = e.y / h, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  static get _resizerKeyboardManager() {
    const e = ht.prototype._resizeWithKeyboard, t = Vl.TRANSLATE_SMALL, s = Vl.TRANSLATE_BIG;
    return et(this, "_resizerKeyboardManager", new iu([[["ArrowLeft", "mac+ArrowLeft"], e, {
      args: [-t, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e, {
      args: [-s, 0]
    }], [["ArrowRight", "mac+ArrowRight"], e, {
      args: [t, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e, {
      args: [s, 0]
    }], [["ArrowUp", "mac+ArrowUp"], e, {
      args: [0, -t]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e, {
      args: [0, -s]
    }], [["ArrowDown", "mac+ArrowDown"], e, {
      args: [0, t]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e, {
      args: [0, s]
    }], [["Escape", "mac+Escape"], ht.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return et(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(e) {
    const t = new ew({
      id: e.parent.getNextId(),
      parent: e.parent,
      uiManager: e._uiManager
    });
    t.annotationElementId = e.annotationElementId, t.deleted = !0, t._uiManager.addToAnnotationStorage(t);
  }
  static initialize(e, t, s) {
    if (ht._l10nPromise || (ht._l10nPromise = new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((n) => [n, e.get(n.replaceAll(/([A-Z])/g, (r) => `-${r.toLowerCase()}`))]))), s != null && s.strings)
      for (const n of s.strings)
        ht._l10nPromise.set(n, e.get(n));
    if (ht._borderLineWidth !== -1)
      return;
    const i = getComputedStyle(document.documentElement);
    ht._borderLineWidth = parseFloat(i.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(e, t) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(e) {
    return !1;
  }
  static paste(e, t) {
    at("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return o(this, Rh);
  }
  set _isDraggable(e) {
    var t;
    b(this, Rh, e), (t = this.div) == null || t.classList.toggle("draggable", e);
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [e, t] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * t / (e * 2), this.y += this.width * e / (t * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * t / (e * 2), this.y -= this.width * e / (t * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(e) {
    this._uiManager.addCommands(e);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = o(this, $f);
  }
  setParent(e) {
    e !== null ? (this.pageIndex = e.pageIndex, this.pageDimensions = e.pageDimensions) : v(this, zn, El).call(this), this.parent = e;
  }
  focusin(e) {
    this._focusEventsAllowed && (o(this, Vn) ? b(this, Vn, !1) : this.parent.setSelected(this));
  }
  focusout(e) {
    var s;
    if (!this._focusEventsAllowed || !this.isAttachedToDOM)
      return;
    const t = e.relatedTarget;
    t != null && t.closest(`#${this.id}`) || (e.preventDefault(), (s = this.parent) != null && s.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(e, t, s, i) {
    const [n, r] = this.parentDimensions;
    [s, i] = this.screenToPageTranslation(s, i), this.x = (e + s) / n, this.y = (t + i) / r, this.fixAndSetPosition();
  }
  translate(e, t) {
    v(this, Ih, Im).call(this, this.parentDimensions, e, t);
  }
  translateInPage(e, t) {
    o(this, Di) || b(this, Di, [this.x, this.y]), v(this, Ih, Im).call(this, this.pageDimensions, e, t), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(e, t) {
    o(this, Di) || b(this, Di, [this.x, this.y]);
    const [s, i] = this.parentDimensions;
    if (this.x += e / s, this.y += t / i, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: c,
        y: d
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, c, d) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: n,
      y: r
    } = this;
    const [a, h] = this.getBaseTranslation();
    n += a, r += h, this.div.style.left = `${(100 * n).toFixed(2)}%`, this.div.style.top = `${(100 * r).toFixed(2)}%`, this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!o(this, Di) && (o(this, Di)[0] !== this.x || o(this, Di)[1] !== this.y);
  }
  getBaseTranslation() {
    const [e, t] = this.parentDimensions, {
      _borderLineWidth: s
    } = ht, i = s / e, n = s / t;
    switch (this.rotation) {
      case 90:
        return [-i, n];
      case 180:
        return [i, n];
      case 270:
        return [i, -n];
      default:
        return [-i, -n];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(e = this.rotation) {
    const [t, s] = this.pageDimensions;
    let {
      x: i,
      y: n,
      width: r,
      height: a
    } = this;
    if (r *= t, a *= s, i *= t, n *= s, this._mustFixPosition)
      switch (e) {
        case 0:
          i = Math.max(0, Math.min(t - r, i)), n = Math.max(0, Math.min(s - a, n));
          break;
        case 90:
          i = Math.max(0, Math.min(t - a, i)), n = Math.min(s, Math.max(r, n));
          break;
        case 180:
          i = Math.min(t, Math.max(r, i)), n = Math.min(s, Math.max(a, n));
          break;
        case 270:
          i = Math.min(t, Math.max(a, i)), n = Math.max(0, Math.min(s - r, n));
          break;
      }
    this.x = i /= t, this.y = n /= s;
    const [h, c] = this.getBaseTranslation();
    i += h, n += c;
    const {
      style: d
    } = this.div;
    d.left = `${(100 * i).toFixed(2)}%`, d.top = `${(100 * n).toFixed(2)}%`, this.moveInDOM();
  }
  screenToPageTranslation(e, t) {
    var s;
    return v(s = ht, Lh, Lm).call(s, e, t, this.parentRotation);
  }
  pageTranslationToScreen(e, t) {
    var s;
    return v(s = ht, Lh, Lm).call(s, e, t, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: e,
      pageDimensions: [t, s]
    } = this, i = t * e, n = s * e;
    return ue.isCSSRoundSupported ? [Math.round(i), Math.round(n)] : [i, n];
  }
  setDims(e, t) {
    const [s, i] = this.parentDimensions;
    this.div.style.width = `${(100 * e / s).toFixed(2)}%`, o(this, Hn) || (this.div.style.height = `${(100 * t / i).toFixed(2)}%`);
  }
  fixDims() {
    const {
      style: e
    } = this.div, {
      height: t,
      width: s
    } = e, i = s.endsWith("%"), n = !o(this, Hn) && t.endsWith("%");
    if (i && n)
      return;
    const [r, a] = this.parentDimensions;
    i || (e.width = `${(100 * parseFloat(s) / r).toFixed(2)}%`), !o(this, Hn) && !n && (e.height = `${(100 * parseFloat(t) / a).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  altTextFinish() {
    var e;
    (e = o(this, Kt)) == null || e.finish();
  }
  async addEditToolbar() {
    return o(this, Yt) || o(this, Un) ? o(this, Yt) : (b(this, Yt, new bm(this)), this.div.append(o(this, Yt).render()), o(this, Kt) && o(this, Yt).addAltTextButton(await o(this, Kt).render()), o(this, Yt));
  }
  removeEditToolbar() {
    var e;
    o(this, Yt) && (o(this, Yt).remove(), b(this, Yt, null), (e = o(this, Kt)) == null || e.destroy());
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    o(this, Kt) || (af.initialize(ht._l10nPromise), b(this, Kt, new af(this)), o(this, jn) && (o(this, Kt).data = o(this, jn), b(this, jn, null)), await this.addEditToolbar());
  }
  get altTextData() {
    var e;
    return (e = o(this, Kt)) == null ? void 0 : e.data;
  }
  set altTextData(e) {
    o(this, Kt) && (o(this, Kt).data = e);
  }
  hasAltText() {
    var e;
    return !((e = o(this, Kt)) != null && e.isEmpty());
  }
  render() {
    this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = o(this, La) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground();
    const e = this._uiManager._signal;
    this.div.addEventListener("focusin", o(this, _a), {
      signal: e
    }), this.div.addEventListener("focusout", o(this, Ma), {
      signal: e
    });
    const [t, s] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * s / t).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * t / s).toFixed(2)}%`);
    const [i, n] = this.getInitialTranslation();
    return this.translate(i, n), rf(this, this.div, ["pointerdown"]), this.div;
  }
  pointerdown(e) {
    const {
      isMac: t
    } = ue.platform;
    if (e.button !== 0 || e.ctrlKey && t) {
      e.preventDefault();
      return;
    }
    if (b(this, Vn, !0), this._isDraggable) {
      v(this, zf, nA).call(this, e);
      return;
    }
    v(this, Dh, Dm).call(this, e);
  }
  moveInDOM() {
    o(this, ls) && clearTimeout(o(this, ls)), b(this, ls, setTimeout(() => {
      var e;
      b(this, ls, null), (e = this.parent) == null || e.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(e, t, s) {
    e.changeParent(this), this.x = t, this.y = s, this.fixAndSetPosition();
  }
  getRect(e, t, s = this.rotation) {
    const i = this.parentScale, [n, r] = this.pageDimensions, [a, h] = this.pageTranslation, c = e / i, d = t / i, u = this.x * n, f = this.y * r, m = this.width * n, g = this.height * r;
    switch (s) {
      case 0:
        return [u + c + a, r - f - d - g + h, u + c + m + a, r - f - d + h];
      case 90:
        return [u + d + a, r - f + c + h, u + d + g + a, r - f + c + m + h];
      case 180:
        return [u - c - m + a, r - f + d + h, u - c + a, r - f + d + g + h];
      case 270:
        return [u - d - g + a, r - f - c - m + h, u - d + a, r - f - c + h];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(e, t) {
    const [s, i, n, r] = e, a = n - s, h = r - i;
    switch (this.rotation) {
      case 0:
        return [s, t - r, a, h];
      case 90:
        return [s, t - i, h, a];
      case 180:
        return [n, t - i, a, h];
      case 270:
        return [n, t - r, h, a];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    b(this, Un, !0);
  }
  disableEditMode() {
    b(this, Un, !1);
  }
  isInEditMode() {
    return o(this, Un);
  }
  shouldGetKeyboardEvents() {
    return o(this, Vs);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    var t, s;
    const e = this._uiManager._signal;
    (t = this.div) == null || t.addEventListener("focusin", o(this, _a), {
      signal: e
    }), (s = this.div) == null || s.addEventListener("focusout", o(this, Ma), {
      signal: e
    });
  }
  rotate(e) {
  }
  serialize(e = !1, t = null) {
    at("An editor must be serializable");
  }
  static deserialize(e, t, s) {
    const i = new this.prototype.constructor({
      parent: t,
      id: t.getNextId(),
      uiManager: s
    });
    i.rotation = e.rotation, b(i, jn, e.accessibilityData);
    const [n, r] = i.pageDimensions, [a, h, c, d] = i.getRectInCurrentCoords(e.rect, r);
    return i.x = a / n, i.y = h / r, i.width = c / n, i.height = d / r, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    if (this.div.removeEventListener("focusin", o(this, _a)), this.div.removeEventListener("focusout", o(this, Ma)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), o(this, ls) && (clearTimeout(o(this, ls)), b(this, ls, null)), v(this, zn, El).call(this), this.removeEditToolbar(), o(this, Re)) {
      for (const e of o(this, Re).values())
        clearTimeout(e);
      b(this, Re, null);
    }
    this.parent = null;
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (v(this, Vf, sA).call(this), o(this, Vt).classList.remove("hidden"), rf(this, this.div, ["keydown"]));
  }
  get toolbarPosition() {
    return null;
  }
  keydown(e) {
    if (!this.isResizable || e.target !== this.div || e.key !== "Enter")
      return;
    this._uiManager.setSelected(this), b(this, $n, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const t = o(this, Vt).children;
    if (!o(this, Ue)) {
      b(this, Ue, Array.from(t));
      const r = v(this, Wf, rA).bind(this), a = v(this, Gf, aA).bind(this), h = this._uiManager._signal;
      for (const c of o(this, Ue)) {
        const d = c.getAttribute("data-resizer-name");
        c.setAttribute("role", "spinbutton"), c.addEventListener("keydown", r, {
          signal: h
        }), c.addEventListener("blur", a, {
          signal: h
        }), c.addEventListener("focus", v(this, Xf, oA).bind(this, d), {
          signal: h
        }), ht._l10nPromise.get(`pdfjs-editor-resizer-label-${d}`).then((u) => c.setAttribute("aria-label", u));
      }
    }
    const s = o(this, Ue)[0];
    let i = 0;
    for (const r of t) {
      if (r === s)
        break;
      i++;
    }
    const n = (360 - this.rotation + this.parentRotation) % 360 / 90 * (o(this, Ue).length / 4);
    if (n !== i) {
      if (n < i)
        for (let a = 0; a < i - n; a++)
          o(this, Vt).append(o(this, Vt).firstChild);
      else if (n > i)
        for (let a = 0; a < n - i; a++)
          o(this, Vt).firstChild.before(o(this, Vt).lastChild);
      let r = 0;
      for (const a of t) {
        const c = o(this, Ue)[r++].getAttribute("data-resizer-name");
        ht._l10nPromise.get(`pdfjs-editor-resizer-label-${c}`).then((d) => a.setAttribute("aria-label", d));
      }
    }
    v(this, kh, km).call(this, 0), b(this, Vs, !0), o(this, Vt).firstChild.focus({
      focusVisible: !0
    }), e.preventDefault(), e.stopImmediatePropagation();
  }
  _resizeWithKeyboard(e, t) {
    o(this, Vs) && v(this, Oh, Om).call(this, o(this, Th), {
      movementX: e,
      movementY: t
    });
  }
  _stopResizingWithKeyboard() {
    v(this, zn, El).call(this), this.div.focus();
  }
  select() {
    var e, t;
    if (this.makeResizable(), (e = this.div) == null || e.classList.add("selectedEditor"), !o(this, Yt)) {
      this.addEditToolbar().then(() => {
        var s, i;
        (s = this.div) != null && s.classList.contains("selectedEditor") && ((i = o(this, Yt)) == null || i.show());
      });
      return;
    }
    (t = o(this, Yt)) == null || t.show();
  }
  unselect() {
    var e, t, s, i;
    (e = o(this, Vt)) == null || e.classList.add("hidden"), (t = this.div) == null || t.classList.remove("selectedEditor"), (s = this.div) != null && s.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), (i = o(this, Yt)) == null || i.hide();
  }
  updateParams(e, t) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return o(this, Ch);
  }
  set isEditing(e) {
    b(this, Ch, e), this.parent && (e ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  setAspectRatio(e, t) {
    b(this, Hn, !0);
    const s = e / t, {
      style: i
    } = this.div;
    i.aspectRatio = s, i.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(e, t = !1) {
    if (t) {
      o(this, Re) || b(this, Re, /* @__PURE__ */ new Map());
      const {
        action: s
      } = e;
      let i = o(this, Re).get(s);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(e), o(this, Re).delete(s), o(this, Re).size === 0 && b(this, Re, null);
      }, ht._telemetryTimeout), o(this, Re).set(s, i);
      return;
    }
    e.type || (e.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: e
      }
    });
  }
  show(e = this._isVisible) {
    this.div.classList.toggle("hidden", !e), this._isVisible = e;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), b(this, La, !1);
  }
  disable() {
    this.div && (this.div.tabIndex = -1), b(this, La, !0);
  }
  renderAnnotationElement(e) {
    let t = e.container.querySelector(".annotationContent");
    if (!t)
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e.container.prepend(t);
    else if (t.nodeName === "CANVAS") {
      const s = t;
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), s.before(t);
    }
    return t;
  }
  resetAnnotationElement(e) {
    const {
      firstChild: t
    } = e.container;
    t.nodeName === "DIV" && t.classList.contains("annotationContent") && t.remove();
  }
};
jn = new WeakMap(), Ue = new WeakMap(), Kt = new WeakMap(), La = new WeakMap(), Hn = new WeakMap(), Vt = new WeakMap(), $n = new WeakMap(), _a = new WeakMap(), Ma = new WeakMap(), Yt = new WeakMap(), Th = new WeakMap(), Vn = new WeakMap(), Di = new WeakMap(), Ch = new WeakMap(), Un = new WeakMap(), Vs = new WeakMap(), ls = new WeakMap(), Oa = new WeakMap(), Da = new WeakMap(), Re = new WeakMap(), Rh = new WeakMap(), $f = new WeakMap(), Ih = new WeakSet(), Im = function([e, t], s, i) {
  [s, i] = this.screenToPageTranslation(s, i), this.x += s / e, this.y += i / t, this.fixAndSetPosition();
}, Lh = new WeakSet(), Lm = function(e, t, s) {
  switch (s) {
    case 90:
      return [t, -e];
    case 180:
      return [-e, -t];
    case 270:
      return [-t, e];
    default:
      return [e, t];
  }
}, _h = new WeakSet(), _m = function(e) {
  switch (e) {
    case 90: {
      const [t, s] = this.pageDimensions;
      return [0, -t / s, s / t, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [t, s] = this.pageDimensions;
      return [0, t / s, -s / t, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
}, Vf = new WeakSet(), sA = function() {
  if (o(this, Vt))
    return;
  b(this, Vt, document.createElement("div")), o(this, Vt).classList.add("resizers");
  const e = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t = this._uiManager._signal;
  for (const s of e) {
    const i = document.createElement("div");
    o(this, Vt).append(i), i.classList.add("resizer", s), i.setAttribute("data-resizer-name", s), i.addEventListener("pointerdown", v(this, Uf, iA).bind(this, s), {
      signal: t
    }), i.addEventListener("contextmenu", fe, {
      signal: t
    }), i.tabIndex = -1;
  }
  this.div.prepend(o(this, Vt));
}, Uf = new WeakSet(), iA = function(e, t) {
  var A;
  t.preventDefault();
  const {
    isMac: s
  } = ue.platform;
  if (t.button !== 0 || t.ctrlKey && s)
    return;
  (A = o(this, Kt)) == null || A.toggle(!1);
  const i = v(this, Oh, Om).bind(this, e), n = this._isDraggable;
  this._isDraggable = !1;
  const r = this._uiManager._signal, a = {
    passive: !0,
    capture: !0,
    signal: r
  };
  this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", i, a), window.addEventListener("contextmenu", fe, {
    signal: r
  });
  const h = this.x, c = this.y, d = this.width, u = this.height, f = this.parent.div.style.cursor, m = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t.target).cursor;
  const g = () => {
    var E;
    this.parent.togglePointerEvents(!0), (E = o(this, Kt)) == null || E.toggle(!0), this._isDraggable = n, window.removeEventListener("pointerup", g), window.removeEventListener("blur", g), window.removeEventListener("pointermove", i, a), window.removeEventListener("contextmenu", fe), this.parent.div.style.cursor = f, this.div.style.cursor = m, v(this, Mh, Mm).call(this, h, c, d, u);
  };
  window.addEventListener("pointerup", g, {
    signal: r
  }), window.addEventListener("blur", g, {
    signal: r
  });
}, Mh = new WeakSet(), Mm = function(e, t, s, i) {
  const n = this.x, r = this.y, a = this.width, h = this.height;
  n === e && r === t && a === s && h === i || this.addCommands({
    cmd: () => {
      this.width = a, this.height = h, this.x = n, this.y = r;
      const [c, d] = this.parentDimensions;
      this.setDims(c * a, d * h), this.fixAndSetPosition();
    },
    undo: () => {
      this.width = s, this.height = i, this.x = e, this.y = t;
      const [c, d] = this.parentDimensions;
      this.setDims(c * s, d * i), this.fixAndSetPosition();
    },
    mustExec: !0
  });
}, Oh = new WeakSet(), Om = function(e, t) {
  const [s, i] = this.parentDimensions, n = this.x, r = this.y, a = this.width, h = this.height, c = ht.MIN_SIZE / s, d = ht.MIN_SIZE / i, u = (B) => Math.round(B * 1e4) / 1e4, f = v(this, _h, _m).call(this, this.rotation), m = (B, j) => [f[0] * B + f[2] * j, f[1] * B + f[3] * j], g = v(this, _h, _m).call(this, 360 - this.rotation), A = (B, j) => [g[0] * B + g[2] * j, g[1] * B + g[3] * j];
  let E, y, w = !1, S = !1;
  switch (e) {
    case "topLeft":
      w = !0, E = (B, j) => [0, 0], y = (B, j) => [B, j];
      break;
    case "topMiddle":
      E = (B, j) => [B / 2, 0], y = (B, j) => [B / 2, j];
      break;
    case "topRight":
      w = !0, E = (B, j) => [B, 0], y = (B, j) => [0, j];
      break;
    case "middleRight":
      S = !0, E = (B, j) => [B, j / 2], y = (B, j) => [0, j / 2];
      break;
    case "bottomRight":
      w = !0, E = (B, j) => [B, j], y = (B, j) => [0, 0];
      break;
    case "bottomMiddle":
      E = (B, j) => [B / 2, j], y = (B, j) => [B / 2, 0];
      break;
    case "bottomLeft":
      w = !0, E = (B, j) => [0, j], y = (B, j) => [B, 0];
      break;
    case "middleLeft":
      S = !0, E = (B, j) => [0, j / 2], y = (B, j) => [B, j / 2];
      break;
  }
  const C = E(a, h), P = y(a, h);
  let x = m(...P);
  const R = u(n + x[0]), M = u(r + x[1]);
  let T = 1, I = 1, [_, k] = this.screenToPageTranslation(t.movementX, t.movementY);
  if ([_, k] = A(_ / s, k / i), w) {
    const B = Math.hypot(a, h);
    T = I = Math.max(Math.min(Math.hypot(P[0] - C[0] - _, P[1] - C[1] - k) / B, 1 / a, 1 / h), c / a, d / h);
  } else
    S ? T = Math.max(c, Math.min(1, Math.abs(P[0] - C[0] - _))) / a : I = Math.max(d, Math.min(1, Math.abs(P[1] - C[1] - k))) / h;
  const F = u(a * T), V = u(h * I);
  x = m(...y(F, V));
  const $ = R - x[0], L = M - x[1];
  this.width = F, this.height = V, this.x = $, this.y = L, this.setDims(s * F, i * V), this.fixAndSetPosition();
}, Dh = new WeakSet(), Dm = function(e) {
  const {
    isMac: t
  } = ue.platform;
  e.ctrlKey && !t || e.shiftKey || e.metaKey && t ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
}, zf = new WeakSet(), nA = function(e) {
  const t = this._uiManager.isSelected(this);
  this._uiManager.setUpDragSession();
  let s, i;
  const n = this._uiManager._signal;
  t && (this.div.classList.add("moving"), s = {
    passive: !0,
    capture: !0,
    signal: n
  }, b(this, Oa, e.clientX), b(this, Da, e.clientY), i = (a) => {
    const {
      clientX: h,
      clientY: c
    } = a, [d, u] = this.screenToPageTranslation(h - o(this, Oa), c - o(this, Da));
    b(this, Oa, h), b(this, Da, c), this._uiManager.dragSelectedEditors(d, u);
  }, window.addEventListener("pointermove", i, s));
  const r = () => {
    window.removeEventListener("pointerup", r), window.removeEventListener("blur", r), t && (this.div.classList.remove("moving"), window.removeEventListener("pointermove", i, s)), b(this, Vn, !1), this._uiManager.endDragSession() || v(this, Dh, Dm).call(this, e);
  };
  window.addEventListener("pointerup", r, {
    signal: n
  }), window.addEventListener("blur", r, {
    signal: n
  });
}, Wf = new WeakSet(), rA = function(e) {
  ht._resizerKeyboardManager.exec(this, e);
}, Gf = new WeakSet(), aA = function(e) {
  var t;
  o(this, Vs) && ((t = e.relatedTarget) == null ? void 0 : t.parentNode) !== o(this, Vt) && v(this, zn, El).call(this);
}, Xf = new WeakSet(), oA = function(e) {
  b(this, Th, o(this, Vs) ? e : "");
}, kh = new WeakSet(), km = function(e) {
  if (o(this, Ue))
    for (const t of o(this, Ue))
      t.tabIndex = e;
}, zn = new WeakSet(), El = function() {
  if (b(this, Vs, !1), v(this, kh, km).call(this, -1), o(this, $n)) {
    const {
      savedX: e,
      savedY: t,
      savedWidth: s,
      savedHeight: i
    } = o(this, $n);
    v(this, Mh, Mm).call(this, e, t, s, i), b(this, $n, null);
  }
}, p(ht, Lh), K(ht, "_borderLineWidth", -1), K(ht, "_colorManager", new wm()), K(ht, "_zIndex", 1), K(ht, "_telemetryTimeout", 1e3);
let nt = ht;
class ew extends nt {
  constructor(e) {
    super(e), this.annotationElementId = e.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex
    };
  }
}
const Tb = 3285377520, Te = 4294901760, es = 65535;
class lA {
  constructor(e) {
    this.h1 = e ? e & 4294967295 : Tb, this.h2 = e ? e & 4294967295 : Tb;
  }
  update(e) {
    let t, s;
    if (typeof e == "string") {
      t = new Uint8Array(e.length * 2), s = 0;
      for (let A = 0, E = e.length; A < E; A++) {
        const y = e.charCodeAt(A);
        y <= 255 ? t[s++] = y : (t[s++] = y >>> 8, t[s++] = y & 255);
      }
    } else if (ArrayBuffer.isView(e))
      t = e.slice(), s = t.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = s >> 2, n = s - i * 4, r = new Uint32Array(t.buffer, 0, i);
    let a = 0, h = 0, c = this.h1, d = this.h2;
    const u = 3432918353, f = 461845907, m = u & es, g = f & es;
    for (let A = 0; A < i; A++)
      A & 1 ? (a = r[A], a = a * u & Te | a * m & es, a = a << 15 | a >>> 17, a = a * f & Te | a * g & es, c ^= a, c = c << 13 | c >>> 19, c = c * 5 + 3864292196) : (h = r[A], h = h * u & Te | h * m & es, h = h << 15 | h >>> 17, h = h * f & Te | h * g & es, d ^= h, d = d << 13 | d >>> 19, d = d * 5 + 3864292196);
    switch (a = 0, n) {
      case 3:
        a ^= t[i * 4 + 2] << 16;
      case 2:
        a ^= t[i * 4 + 1] << 8;
      case 1:
        a ^= t[i * 4], a = a * u & Te | a * m & es, a = a << 15 | a >>> 17, a = a * f & Te | a * g & es, i & 1 ? c ^= a : d ^= a;
    }
    this.h1 = c, this.h2 = d;
  }
  hexdigest() {
    let e = this.h1, t = this.h2;
    return e ^= t >>> 1, e = e * 3981806797 & Te | e * 36045 & es, t = t * 4283543511 & Te | ((t << 16 | e >>> 16) * 2950163797 & Te) >>> 16, e ^= t >>> 1, e = e * 444984403 & Te | e * 60499 & es, t = t * 3301882366 & Te | ((t << 16 | e >>> 16) * 3120437893 & Te) >>> 16, e ^= t >>> 1, (e >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
  }
}
const Fm = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var Wn, Ut, Kf, hA;
class cb {
  constructor() {
    p(this, Kf);
    p(this, Wn, !1);
    p(this, Ut, /* @__PURE__ */ new Map());
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(e, t) {
    const s = o(this, Ut).get(e);
    return s === void 0 ? t : Object.assign(t, s);
  }
  getRawValue(e) {
    return o(this, Ut).get(e);
  }
  remove(e) {
    if (o(this, Ut).delete(e), o(this, Ut).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
      for (const t of o(this, Ut).values())
        if (t instanceof nt)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(e, t) {
    const s = o(this, Ut).get(e);
    let i = !1;
    if (s !== void 0)
      for (const [n, r] of Object.entries(t))
        s[n] !== r && (i = !0, s[n] = r);
    else
      i = !0, o(this, Ut).set(e, t);
    i && v(this, Kf, hA).call(this), t instanceof nt && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(t.constructor._type);
  }
  has(e) {
    return o(this, Ut).has(e);
  }
  getAll() {
    return o(this, Ut).size > 0 ? ib(o(this, Ut)) : null;
  }
  setAll(e) {
    for (const [t, s] of Object.entries(e))
      this.setValue(t, s);
  }
  get size() {
    return o(this, Ut).size;
  }
  resetModified() {
    o(this, Wn) && (b(this, Wn, !1), typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new cA(this);
  }
  get serializable() {
    if (o(this, Ut).size === 0)
      return Fm;
    const e = /* @__PURE__ */ new Map(), t = new lA(), s = [], i = /* @__PURE__ */ Object.create(null);
    let n = !1;
    for (const [r, a] of o(this, Ut)) {
      const h = a instanceof nt ? a.serialize(!1, i) : a;
      h && (e.set(r, h), t.update(`${r}:${JSON.stringify(h)}`), n || (n = !!h.bitmap));
    }
    if (n)
      for (const r of e.values())
        r.bitmap && s.push(r.bitmap);
    return e.size > 0 ? {
      map: e,
      hash: t.hexdigest(),
      transfer: s
    } : Fm;
  }
  get editorStats() {
    let e = null;
    const t = /* @__PURE__ */ new Map();
    for (const s of o(this, Ut).values()) {
      if (!(s instanceof nt))
        continue;
      const i = s.telemetryFinalData;
      if (!i)
        continue;
      const {
        type: n
      } = i;
      t.has(n) || t.set(n, Object.getPrototypeOf(s).constructor), e || (e = /* @__PURE__ */ Object.create(null));
      const r = e[n] || (e[n] = /* @__PURE__ */ new Map());
      for (const [a, h] of Object.entries(i)) {
        if (a === "type")
          continue;
        let c = r.get(a);
        c || (c = /* @__PURE__ */ new Map(), r.set(a, c));
        const d = c.get(h) ?? 0;
        c.set(h, d + 1);
      }
    }
    for (const [s, i] of t)
      e[s] = i.computeTelemetryFinalData(e[s]);
    return e;
  }
}
Wn = new WeakMap(), Ut = new WeakMap(), Kf = new WeakSet(), hA = function() {
  o(this, Wn) || (b(this, Wn, !0), typeof this.onSetModified == "function" && this.onSetModified());
};
var Fh;
class cA extends cb {
  constructor(t) {
    super();
    p(this, Fh, void 0);
    const {
      map: s,
      hash: i,
      transfer: n
    } = t.serializable, r = structuredClone(s, n ? {
      transfer: n
    } : null);
    b(this, Fh, {
      map: r,
      hash: i,
      transfer: n
    });
  }
  get print() {
    at("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return o(this, Fh);
  }
}
Fh = new WeakMap();
var ka;
class sw {
  constructor({
    ownerDocument: e = globalThis.document,
    styleElement: t = null
  }) {
    p(this, ka, /* @__PURE__ */ new Set());
    this._document = e, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(e) {
    this.nativeFontFaces.add(e), this._document.fonts.add(e);
  }
  removeNativeFontFace(e) {
    this.nativeFontFaces.delete(e), this._document.fonts.delete(e);
  }
  insertRule(e) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const t = this.styleElement.sheet;
    t.insertRule(e, t.cssRules.length);
  }
  clear() {
    for (const e of this.nativeFontFaces)
      this._document.fonts.delete(e);
    this.nativeFontFaces.clear(), o(this, ka).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: e,
    _inspectFont: t
  }) {
    if (!(!e || o(this, ka).has(e.loadedName))) {
      if (Ot(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: s,
          src: i,
          style: n
        } = e, r = new FontFace(s, i, n);
        this.addNativeFontFace(r);
        try {
          await r.load(), o(this, ka).add(s), t == null || t(e);
        } catch {
          Q(`Cannot load system font: ${e.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(r);
        }
        return;
      }
      at("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(e) {
    if (e.attached || e.missingFile && !e.systemFontInfo)
      return;
    if (e.attached = !0, e.systemFontInfo) {
      await this.loadSystemFont(e);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const s = e.createNativeFontFace();
      if (s) {
        this.addNativeFontFace(s);
        try {
          await s.loaded;
        } catch (i) {
          throw Q(`Failed to load font '${s.family}': '${i}'.`), e.disableFontFace = !0, i;
        }
      }
      return;
    }
    const t = e.createFontFaceRule();
    if (t) {
      if (this.insertRule(t), this.isSyncFontLoadingSupported)
        return;
      await new Promise((s) => {
        const i = this._queueLoadingCallback(s);
        this._prepareFontLoadEvent(e, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var t;
    const e = !!((t = this._document) != null && t.fonts);
    return et(this, "isFontLoadingAPISupported", e);
  }
  get isSyncFontLoadingSupported() {
    let e = !1;
    return (Jt || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (e = !0), et(this, "isSyncFontLoadingSupported", e);
  }
  _queueLoadingCallback(e) {
    function t() {
      for (Ot(!i.done, "completeRequest() cannot be called twice."), i.done = !0; s.length > 0 && s[0].done; ) {
        const n = s.shift();
        setTimeout(n.callback, 0);
      }
    }
    const {
      loadingRequests: s
    } = this, i = {
      done: !1,
      complete: t,
      callback: e
    };
    return s.push(i), i;
  }
  get _loadTestFont() {
    const e = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return et(this, "_loadTestFont", e);
  }
  _prepareFontLoadEvent(e, t) {
    function s(C, P) {
      return C.charCodeAt(P) << 24 | C.charCodeAt(P + 1) << 16 | C.charCodeAt(P + 2) << 8 | C.charCodeAt(P + 3) & 255;
    }
    function i(C, P, x, R) {
      const M = C.substring(0, P), T = C.substring(P + x);
      return M + R + T;
    }
    let n, r;
    const a = this._document.createElement("canvas");
    a.width = 1, a.height = 1;
    const h = a.getContext("2d");
    let c = 0;
    function d(C, P) {
      if (++c > 30) {
        Q("Load test font never loaded."), P();
        return;
      }
      if (h.font = "30px " + C, h.fillText(".", 0, 20), h.getImageData(0, 0, 1, 1).data[3] > 0) {
        P();
        return;
      }
      setTimeout(d.bind(null, C, P));
    }
    const u = `lt${Date.now()}${this.loadTestFontId++}`;
    let f = this._loadTestFont;
    f = i(f, 976, u.length, u);
    const g = 16, A = 1482184792;
    let E = s(f, g);
    for (n = 0, r = u.length - 3; n < r; n += 4)
      E = E - A + s(u, n) | 0;
    n < u.length && (E = E - A + s(u + "XXX", n) | 0), f = i(f, g, 4, j0(E));
    const y = `url(data:font/opentype;base64,${btoa(f)});`, w = `@font-face {font-family:"${u}";src:${y}}`;
    this.insertRule(w);
    const S = this._document.createElement("div");
    S.style.visibility = "hidden", S.style.width = S.style.height = "10px", S.style.position = "absolute", S.style.top = S.style.left = "0px";
    for (const C of [e.loadedName, u]) {
      const P = this._document.createElement("span");
      P.textContent = "Hi", P.style.fontFamily = C, S.append(P);
    }
    this._document.body.append(S), d(u, () => {
      S.remove(), t.complete();
    });
  }
}
ka = new WeakMap();
class iw {
  constructor(e, {
    disableFontFace: t = !1,
    inspectFont: s = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i in e)
      this[i] = e[i];
    this.disableFontFace = t === !0, this._inspectFont = s;
  }
  createNativeFontFace() {
    var t;
    if (!this.data || this.disableFontFace)
      return null;
    let e;
    if (!this.cssFontInfo)
      e = new FontFace(this.loadedName, this.data, {});
    else {
      const s = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (s.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e = new FontFace(this.cssFontInfo.fontFamily, this.data, s);
    }
    return (t = this._inspectFont) == null || t.call(this, this), e;
  }
  createFontFaceRule() {
    var i;
    if (!this.data || this.disableFontFace)
      return null;
    const e = _y(this.data), t = `url(data:${this.mimetype};base64,${btoa(e)});`;
    let s;
    if (!this.cssFontInfo)
      s = `@font-face {font-family:"${this.loadedName}";src:${t}}`;
    else {
      let n = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (n += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), s = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${n}src:${t}}`;
    }
    return (i = this._inspectFont) == null || i.call(this, this, t), s;
  }
  getPathGenerator(e, t) {
    if (this.compiledGlyphs[t] !== void 0)
      return this.compiledGlyphs[t];
    let s;
    try {
      s = e.get(this.loadedName + "_path_" + t);
    } catch (n) {
      Q(`getPathGenerator - ignoring character: "${n}".`);
    }
    if (!Array.isArray(s) || s.length === 0)
      return this.compiledGlyphs[t] = function(n, r) {
      };
    const i = [];
    for (let n = 0, r = s.length; n < r; )
      switch (s[n++]) {
        case Ts.BEZIER_CURVE_TO:
          {
            const [a, h, c, d, u, f] = s.slice(n, n + 6);
            i.push((m) => m.bezierCurveTo(a, h, c, d, u, f)), n += 6;
          }
          break;
        case Ts.MOVE_TO:
          {
            const [a, h] = s.slice(n, n + 2);
            i.push((c) => c.moveTo(a, h)), n += 2;
          }
          break;
        case Ts.LINE_TO:
          {
            const [a, h] = s.slice(n, n + 2);
            i.push((c) => c.lineTo(a, h)), n += 2;
          }
          break;
        case Ts.QUADRATIC_CURVE_TO:
          {
            const [a, h, c, d] = s.slice(n, n + 4);
            i.push((u) => u.quadraticCurveTo(a, h, c, d)), n += 4;
          }
          break;
        case Ts.RESTORE:
          i.push((a) => a.restore());
          break;
        case Ts.SAVE:
          i.push((a) => a.save());
          break;
        case Ts.SCALE:
          Ot(i.length === 2, "Scale command is only valid at the third position.");
          break;
        case Ts.TRANSFORM:
          {
            const [a, h, c, d, u, f] = s.slice(n, n + 6);
            i.push((m) => m.transform(a, h, c, d, u, f)), n += 6;
          }
          break;
        case Ts.TRANSLATE:
          {
            const [a, h] = s.slice(n, n + 2);
            i.push((c) => c.translate(a, h)), n += 2;
          }
          break;
      }
    return this.compiledGlyphs[t] = function(r, a) {
      i[0](r), i[1](r), r.scale(a, -a);
      for (let h = 2, c = i.length; h < c; h++)
        i[h](r);
    };
  }
}
if (Jt) {
  var Nm = Promise.withResolvers(), Bl = null;
  (async () => {
    const e = await Promise.resolve().then(() => pl), t = await Promise.resolve().then(() => pl), s = await Promise.resolve().then(() => pl), i = await Promise.resolve().then(() => pl);
    let n, r;
    try {
      n = await Promise.resolve().then(() => pl);
    } catch {
    }
    try {
      r = await Promise.resolve().then(() => lT);
    } catch {
    }
    return new Map(Object.entries({
      fs: e,
      http: t,
      https: s,
      url: i,
      canvas: n,
      path2d: r
    }));
  })().then((e) => {
    var t, s, i, n;
    if (Bl = e, Nm.resolve(), !globalThis.DOMMatrix) {
      const r = (t = e.get("canvas")) == null ? void 0 : t.DOMMatrix;
      r ? globalThis.DOMMatrix = r : Q("Cannot polyfill `DOMMatrix`, rendering may be broken.");
    }
    if (!globalThis.Path2D) {
      const r = (s = e.get("canvas")) == null ? void 0 : s.CanvasRenderingContext2D, a = (i = e.get("path2d")) == null ? void 0 : i.applyPath2DToCanvasRenderingContext, h = (n = e.get("path2d")) == null ? void 0 : n.Path2D;
      r && a && h ? (a(r), globalThis.Path2D = h) : Q("Cannot polyfill `Path2D`, rendering may be broken.");
    }
  }, (e) => {
    Q(`loadPackages: ${e}`), Bl = /* @__PURE__ */ new Map(), Nm.resolve();
  });
}
class Ps {
  static get promise() {
    return Nm.promise;
  }
  static get(e) {
    return Bl == null ? void 0 : Bl.get(e);
  }
}
const dA = function(l) {
  return Ps.get("fs").promises.readFile(l).then((t) => new Uint8Array(t));
};
class nw extends Hg {
}
class rw extends nf {
  _createCanvas(e, t) {
    return Ps.get("canvas").createCanvas(e, t);
  }
}
class aw extends $g {
  _fetchData(e, t) {
    return dA(e).then((s) => ({
      cMapData: s,
      compressionType: t
    }));
  }
}
class ow extends Vg {
  _fetchData(e) {
    return dA(e);
  }
}
const re = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function Bm(l, e) {
  if (!e)
    return;
  const t = e[2] - e[0], s = e[3] - e[1], i = new Path2D();
  i.rect(e[0], e[1], t, s), l.clip(i);
}
class nu {
  constructor() {
    this.constructor === nu && at("Cannot initialize BaseShadingPattern.");
  }
  getPattern() {
    at("Abstract method `getPattern` called.");
  }
}
class lw extends nu {
  constructor(e) {
    super(), this._type = e[1], this._bbox = e[2], this._colorStops = e[3], this._p0 = e[4], this._p1 = e[5], this._r0 = e[6], this._r1 = e[7], this.matrix = null;
  }
  _createGradient(e) {
    let t;
    this._type === "axial" ? t = e.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (t = e.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const s of this._colorStops)
      t.addColorStop(s[0], s[1]);
    return t;
  }
  getPattern(e, t, s, i) {
    let n;
    if (i === re.STROKE || i === re.FILL) {
      const r = t.current.getClippedPathBoundingBox(i, pt(e)) || [0, 0, 0, 0], a = Math.ceil(r[2] - r[0]) || 1, h = Math.ceil(r[3] - r[1]) || 1, c = t.cachedCanvases.getCanvas("pattern", a, h, !0), d = c.context;
      d.clearRect(0, 0, d.canvas.width, d.canvas.height), d.beginPath(), d.rect(0, 0, d.canvas.width, d.canvas.height), d.translate(-r[0], -r[1]), s = U.transform(s, [1, 0, 0, 1, r[0], r[1]]), d.transform(...t.baseTransform), this.matrix && d.transform(...this.matrix), Bm(d, this._bbox), d.fillStyle = this._createGradient(d), d.fill(), n = e.createPattern(c.canvas, "no-repeat");
      const u = new DOMMatrix(s);
      n.setTransform(u);
    } else
      Bm(e, this._bbox), n = this._createGradient(e);
    return n;
  }
}
function Jg(l, e, t, s, i, n, r, a) {
  const h = e.coords, c = e.colors, d = l.data, u = l.width * 4;
  let f;
  h[t + 1] > h[s + 1] && (f = t, t = s, s = f, f = n, n = r, r = f), h[s + 1] > h[i + 1] && (f = s, s = i, i = f, f = r, r = a, a = f), h[t + 1] > h[s + 1] && (f = t, t = s, s = f, f = n, n = r, r = f);
  const m = (h[t] + e.offsetX) * e.scaleX, g = (h[t + 1] + e.offsetY) * e.scaleY, A = (h[s] + e.offsetX) * e.scaleX, E = (h[s + 1] + e.offsetY) * e.scaleY, y = (h[i] + e.offsetX) * e.scaleX, w = (h[i + 1] + e.offsetY) * e.scaleY;
  if (g >= w)
    return;
  const S = c[n], C = c[n + 1], P = c[n + 2], x = c[r], R = c[r + 1], M = c[r + 2], T = c[a], I = c[a + 1], _ = c[a + 2], k = Math.round(g), F = Math.round(w);
  let V, $, L, B, j, ot, mt, ae;
  for (let lt = k; lt <= F; lt++) {
    if (lt < E) {
      const O = lt < g ? 0 : (g - lt) / (g - E);
      V = m - (m - A) * O, $ = S - (S - x) * O, L = C - (C - R) * O, B = P - (P - M) * O;
    } else {
      let O;
      lt > w ? O = 1 : E === w ? O = 0 : O = (E - lt) / (E - w), V = A - (A - y) * O, $ = x - (x - T) * O, L = R - (R - I) * O, B = M - (M - _) * O;
    }
    let dt;
    lt < g ? dt = 0 : lt > w ? dt = 1 : dt = (g - lt) / (g - w), j = m - (m - y) * dt, ot = S - (S - T) * dt, mt = C - (C - I) * dt, ae = P - (P - _) * dt;
    const bi = Math.round(Math.min(V, j)), Pe = Math.round(Math.max(V, j));
    let H = u * lt + bi * 4;
    for (let O = bi; O <= Pe; O++)
      dt = (V - O) / (V - j), dt < 0 ? dt = 0 : dt > 1 && (dt = 1), d[H++] = $ - ($ - ot) * dt | 0, d[H++] = L - (L - mt) * dt | 0, d[H++] = B - (B - ae) * dt | 0, d[H++] = 255;
  }
}
function hw(l, e, t) {
  const s = e.coords, i = e.colors;
  let n, r;
  switch (e.type) {
    case "lattice":
      const a = e.verticesPerRow, h = Math.floor(s.length / a) - 1, c = a - 1;
      for (n = 0; n < h; n++) {
        let d = n * a;
        for (let u = 0; u < c; u++, d++)
          Jg(l, t, s[d], s[d + 1], s[d + a], i[d], i[d + 1], i[d + a]), Jg(l, t, s[d + a + 1], s[d + 1], s[d + a], i[d + a + 1], i[d + 1], i[d + a]);
      }
      break;
    case "triangles":
      for (n = 0, r = s.length; n < r; n += 3)
        Jg(l, t, s[n], s[n + 1], s[n + 2], i[n], i[n + 1], i[n + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class cw extends nu {
  constructor(e) {
    super(), this._coords = e[2], this._colors = e[3], this._figures = e[4], this._bounds = e[5], this._bbox = e[7], this._background = e[8], this.matrix = null;
  }
  _createMeshCanvas(e, t, s) {
    const a = Math.floor(this._bounds[0]), h = Math.floor(this._bounds[1]), c = Math.ceil(this._bounds[2]) - a, d = Math.ceil(this._bounds[3]) - h, u = Math.min(Math.ceil(Math.abs(c * e[0] * 1.1)), 3e3), f = Math.min(Math.ceil(Math.abs(d * e[1] * 1.1)), 3e3), m = c / u, g = d / f, A = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -a,
      offsetY: -h,
      scaleX: 1 / m,
      scaleY: 1 / g
    }, E = u + 2 * 2, y = f + 2 * 2, w = s.getCanvas("mesh", E, y, !1), S = w.context, C = S.createImageData(u, f);
    if (t) {
      const x = C.data;
      for (let R = 0, M = x.length; R < M; R += 4)
        x[R] = t[0], x[R + 1] = t[1], x[R + 2] = t[2], x[R + 3] = 255;
    }
    for (const x of this._figures)
      hw(C, x, A);
    return S.putImageData(C, 2, 2), {
      canvas: w.canvas,
      offsetX: a - 2 * m,
      offsetY: h - 2 * g,
      scaleX: m,
      scaleY: g
    };
  }
  getPattern(e, t, s, i) {
    Bm(e, this._bbox);
    let n;
    if (i === re.SHADING)
      n = U.singularValueDecompose2dScale(pt(e));
    else if (n = U.singularValueDecompose2dScale(t.baseTransform), this.matrix) {
      const a = U.singularValueDecompose2dScale(this.matrix);
      n = [n[0] * a[0], n[1] * a[1]];
    }
    const r = this._createMeshCanvas(n, i === re.SHADING ? null : this._background, t.cachedCanvases);
    return i !== re.SHADING && (e.setTransform(...t.baseTransform), this.matrix && e.transform(...this.matrix)), e.translate(r.offsetX, r.offsetY), e.scale(r.scaleX, r.scaleY), e.createPattern(r.canvas, "no-repeat");
  }
}
class dw extends nu {
  getPattern() {
    return "hotpink";
  }
}
function uw(l) {
  switch (l[0]) {
    case "RadialAxial":
      return new lw(l);
    case "Mesh":
      return new cw(l);
    case "Dummy":
      return new dw();
  }
  throw new Error(`Unknown IR type: ${l[0]}`);
}
const Cb = {
  COLORED: 1,
  UNCOLORED: 2
}, Yf = class Yf {
  constructor(e, t, s, i, n) {
    this.operatorList = e[2], this.matrix = e[3], this.bbox = e[4], this.xstep = e[5], this.ystep = e[6], this.paintType = e[7], this.tilingType = e[8], this.color = t, this.ctx = s, this.canvasGraphicsFactory = i, this.baseTransform = n;
  }
  createPatternCanvas(e) {
    const t = this.operatorList, s = this.bbox, i = this.xstep, n = this.ystep, r = this.paintType, a = this.tilingType, h = this.color, c = this.canvasGraphicsFactory;
    Ng("TilingType: " + a);
    const d = s[0], u = s[1], f = s[2], m = s[3], g = U.singularValueDecompose2dScale(this.matrix), A = U.singularValueDecompose2dScale(this.baseTransform), E = [g[0] * A[0], g[1] * A[1]], y = this.getSizeAndScale(i, this.ctx.canvas.width, E[0]), w = this.getSizeAndScale(n, this.ctx.canvas.height, E[1]), S = e.cachedCanvases.getCanvas("pattern", y.size, w.size, !0), C = S.context, P = c.createCanvasGraphics(C);
    P.groupLevel = e.groupLevel, this.setFillAndStrokeStyleToContext(P, r, h);
    let x = d, R = u, M = f, T = m;
    return d < 0 && (x = 0, M += Math.abs(d)), u < 0 && (R = 0, T += Math.abs(u)), C.translate(-(y.scale * x), -(w.scale * R)), P.transform(y.scale, 0, 0, w.scale, 0, 0), C.save(), this.clipBbox(P, x, R, M, T), P.baseTransform = pt(P.ctx), P.executeOperatorList(t), P.endDrawing(), {
      canvas: S.canvas,
      scaleX: y.scale,
      scaleY: w.scale,
      offsetX: x,
      offsetY: R
    };
  }
  getSizeAndScale(e, t, s) {
    e = Math.abs(e);
    const i = Math.max(Yf.MAX_PATTERN_SIZE, t);
    let n = Math.ceil(e * s);
    return n >= i ? n = i : s = n / e, {
      scale: s,
      size: n
    };
  }
  clipBbox(e, t, s, i, n) {
    const r = i - t, a = n - s;
    e.ctx.rect(t, s, r, a), e.current.updateRectMinMax(pt(e.ctx), [t, s, i, n]), e.clip(), e.endPath();
  }
  setFillAndStrokeStyleToContext(e, t, s) {
    const i = e.ctx, n = e.current;
    switch (t) {
      case Cb.COLORED:
        const r = this.ctx;
        i.fillStyle = r.fillStyle, i.strokeStyle = r.strokeStyle, n.fillColor = r.fillStyle, n.strokeColor = r.strokeStyle;
        break;
      case Cb.UNCOLORED:
        const a = U.makeHexColor(s[0], s[1], s[2]);
        i.fillStyle = a, i.strokeStyle = a, n.fillColor = a, n.strokeColor = a;
        break;
      default:
        throw new B0(`Unsupported paint type: ${t}`);
    }
  }
  getPattern(e, t, s, i) {
    let n = s;
    i !== re.SHADING && (n = U.transform(n, t.baseTransform), this.matrix && (n = U.transform(n, this.matrix)));
    const r = this.createPatternCanvas(t);
    let a = new DOMMatrix(n);
    a = a.translate(r.offsetX, r.offsetY), a = a.scale(1 / r.scaleX, 1 / r.scaleY);
    const h = e.createPattern(r.canvas, "repeat");
    return h.setTransform(a), h;
  }
};
K(Yf, "MAX_PATTERN_SIZE", 3e3);
let jm = Yf;
function fw({
  src: l,
  srcPos: e = 0,
  dest: t,
  width: s,
  height: i,
  nonBlackColor: n = 4294967295,
  inverseDecode: r = !1
}) {
  const a = ue.isLittleEndian ? 4278190080 : 255, [h, c] = r ? [n, a] : [a, n], d = s >> 3, u = s & 7, f = l.length;
  t = new Uint32Array(t.buffer);
  let m = 0;
  for (let g = 0; g < i; g++) {
    for (const E = e + d; e < E; e++) {
      const y = e < f ? l[e] : 255;
      t[m++] = y & 128 ? c : h, t[m++] = y & 64 ? c : h, t[m++] = y & 32 ? c : h, t[m++] = y & 16 ? c : h, t[m++] = y & 8 ? c : h, t[m++] = y & 4 ? c : h, t[m++] = y & 2 ? c : h, t[m++] = y & 1 ? c : h;
    }
    if (u === 0)
      continue;
    const A = e < f ? l[e++] : 255;
    for (let E = 0; E < u; E++)
      t[m++] = A & 1 << 7 - E ? c : h;
  }
  return {
    srcPos: e,
    destPos: m
  };
}
const Rb = 16, Ib = 100, pw = 15, Lb = 10, _b = 1e3, de = 16;
function gw(l, e) {
  if (l._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  l.__originalSave = l.save, l.__originalRestore = l.restore, l.__originalRotate = l.rotate, l.__originalScale = l.scale, l.__originalTranslate = l.translate, l.__originalTransform = l.transform, l.__originalSetTransform = l.setTransform, l.__originalResetTransform = l.resetTransform, l.__originalClip = l.clip, l.__originalMoveTo = l.moveTo, l.__originalLineTo = l.lineTo, l.__originalBezierCurveTo = l.bezierCurveTo, l.__originalRect = l.rect, l.__originalClosePath = l.closePath, l.__originalBeginPath = l.beginPath, l._removeMirroring = () => {
    l.save = l.__originalSave, l.restore = l.__originalRestore, l.rotate = l.__originalRotate, l.scale = l.__originalScale, l.translate = l.__originalTranslate, l.transform = l.__originalTransform, l.setTransform = l.__originalSetTransform, l.resetTransform = l.__originalResetTransform, l.clip = l.__originalClip, l.moveTo = l.__originalMoveTo, l.lineTo = l.__originalLineTo, l.bezierCurveTo = l.__originalBezierCurveTo, l.rect = l.__originalRect, l.closePath = l.__originalClosePath, l.beginPath = l.__originalBeginPath, delete l._removeMirroring;
  }, l.save = function() {
    e.save(), this.__originalSave();
  }, l.restore = function() {
    e.restore(), this.__originalRestore();
  }, l.translate = function(s, i) {
    e.translate(s, i), this.__originalTranslate(s, i);
  }, l.scale = function(s, i) {
    e.scale(s, i), this.__originalScale(s, i);
  }, l.transform = function(s, i, n, r, a, h) {
    e.transform(s, i, n, r, a, h), this.__originalTransform(s, i, n, r, a, h);
  }, l.setTransform = function(s, i, n, r, a, h) {
    e.setTransform(s, i, n, r, a, h), this.__originalSetTransform(s, i, n, r, a, h);
  }, l.resetTransform = function() {
    e.resetTransform(), this.__originalResetTransform();
  }, l.rotate = function(s) {
    e.rotate(s), this.__originalRotate(s);
  }, l.clip = function(s) {
    e.clip(s), this.__originalClip(s);
  }, l.moveTo = function(t, s) {
    e.moveTo(t, s), this.__originalMoveTo(t, s);
  }, l.lineTo = function(t, s) {
    e.lineTo(t, s), this.__originalLineTo(t, s);
  }, l.bezierCurveTo = function(t, s, i, n, r, a) {
    e.bezierCurveTo(t, s, i, n, r, a), this.__originalBezierCurveTo(t, s, i, n, r, a);
  }, l.rect = function(t, s, i, n) {
    e.rect(t, s, i, n), this.__originalRect(t, s, i, n);
  }, l.closePath = function() {
    e.closePath(), this.__originalClosePath();
  }, l.beginPath = function() {
    e.beginPath(), this.__originalBeginPath();
  };
}
class mw {
  constructor(e) {
    this.canvasFactory = e, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(e, t, s) {
    let i;
    return this.cache[e] !== void 0 ? (i = this.cache[e], this.canvasFactory.reset(i, t, s)) : (i = this.canvasFactory.create(t, s), this.cache[e] = i), i;
  }
  delete(e) {
    delete this.cache[e];
  }
  clear() {
    for (const e in this.cache) {
      const t = this.cache[e];
      this.canvasFactory.destroy(t), delete this.cache[e];
    }
  }
}
function ou(l, e, t, s, i, n, r, a, h, c) {
  const [d, u, f, m, g, A] = pt(l);
  if (u === 0 && f === 0) {
    const w = r * d + g, S = Math.round(w), C = a * m + A, P = Math.round(C), x = (r + h) * d + g, R = Math.abs(Math.round(x) - S) || 1, M = (a + c) * m + A, T = Math.abs(Math.round(M) - P) || 1;
    return l.setTransform(Math.sign(d), 0, 0, Math.sign(m), S, P), l.drawImage(e, t, s, i, n, 0, 0, R, T), l.setTransform(d, u, f, m, g, A), [R, T];
  }
  if (d === 0 && m === 0) {
    const w = a * f + g, S = Math.round(w), C = r * u + A, P = Math.round(C), x = (a + c) * f + g, R = Math.abs(Math.round(x) - S) || 1, M = (r + h) * u + A, T = Math.abs(Math.round(M) - P) || 1;
    return l.setTransform(0, Math.sign(u), Math.sign(f), 0, S, P), l.drawImage(e, t, s, i, n, 0, 0, T, R), l.setTransform(d, u, f, m, g, A), [T, R];
  }
  l.drawImage(e, t, s, i, n, r, a, h, c);
  const E = Math.hypot(d, u), y = Math.hypot(f, m);
  return [E * h, y * c];
}
function vw(l) {
  const {
    width: e,
    height: t
  } = l;
  if (e > _b || t > _b)
    return null;
  const s = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), n = e + 1;
  let r = new Uint8Array(n * (t + 1)), a, h, c;
  const d = e + 7 & -8;
  let u = new Uint8Array(d * t), f = 0;
  for (const y of l.data) {
    let w = 128;
    for (; w > 0; )
      u[f++] = y & w ? 0 : 255, w >>= 1;
  }
  let m = 0;
  for (f = 0, u[f] !== 0 && (r[0] = 1, ++m), h = 1; h < e; h++)
    u[f] !== u[f + 1] && (r[h] = u[f] ? 2 : 1, ++m), f++;
  for (u[f] !== 0 && (r[h] = 2, ++m), a = 1; a < t; a++) {
    f = a * d, c = a * n, u[f - d] !== u[f] && (r[c] = u[f] ? 1 : 8, ++m);
    let y = (u[f] ? 4 : 0) + (u[f - d] ? 8 : 0);
    for (h = 1; h < e; h++)
      y = (y >> 2) + (u[f + 1] ? 4 : 0) + (u[f - d + 1] ? 8 : 0), i[y] && (r[c + h] = i[y], ++m), f++;
    if (u[f - d] !== u[f] && (r[c + h] = u[f] ? 2 : 4, ++m), m > s)
      return null;
  }
  for (f = d * (t - 1), c = a * n, u[f] !== 0 && (r[c] = 8, ++m), h = 1; h < e; h++)
    u[f] !== u[f + 1] && (r[c + h] = u[f] ? 4 : 8, ++m), f++;
  if (u[f] !== 0 && (r[c + h] = 4, ++m), m > s)
    return null;
  const g = new Int32Array([0, n, -1, 0, -n, 0, 0, 0, 1]), A = new Path2D();
  for (a = 0; m && a <= t; a++) {
    let y = a * n;
    const w = y + e;
    for (; y < w && !r[y]; )
      y++;
    if (y === w)
      continue;
    A.moveTo(y % n, a);
    const S = y;
    let C = r[y];
    do {
      const P = g[C];
      do
        y += P;
      while (!r[y]);
      const x = r[y];
      x !== 5 && x !== 10 ? (C = x, r[y] = 0) : (C = x & 51 * C >> 4, r[y] &= C >> 2 | C << 2), A.lineTo(y % n, y / n | 0), r[y] || --m;
    } while (S !== y);
    --a;
  }
  return u = null, r = null, function(y) {
    y.save(), y.scale(1 / e, -1 / t), y.translate(0, -t), y.fill(A), y.beginPath(), y.restore();
  };
}
class Mb {
  constructor(e, t) {
    this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = Iy, this.textMatrixScale = 1, this.fontMatrix = dm, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = Gt.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, e, t]);
  }
  clone() {
    const e = Object.create(this);
    return e.clipBox = this.clipBox.slice(), e;
  }
  setCurrentPoint(e, t) {
    this.x = e, this.y = t;
  }
  updatePathMinMax(e, t, s) {
    [t, s] = U.applyTransform([t, s], e), this.minX = Math.min(this.minX, t), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, t), this.maxY = Math.max(this.maxY, s);
  }
  updateRectMinMax(e, t) {
    const s = U.applyTransform(t, e), i = U.applyTransform(t.slice(2), e), n = U.applyTransform([t[0], t[3]], e), r = U.applyTransform([t[2], t[1]], e);
    this.minX = Math.min(this.minX, s[0], i[0], n[0], r[0]), this.minY = Math.min(this.minY, s[1], i[1], n[1], r[1]), this.maxX = Math.max(this.maxX, s[0], i[0], n[0], r[0]), this.maxY = Math.max(this.maxY, s[1], i[1], n[1], r[1]);
  }
  updateScalingPathMinMax(e, t) {
    U.scaleMinMax(e, t), this.minX = Math.min(this.minX, t[0]), this.minY = Math.min(this.minY, t[1]), this.maxX = Math.max(this.maxX, t[2]), this.maxY = Math.max(this.maxY, t[3]);
  }
  updateCurvePathMinMax(e, t, s, i, n, r, a, h, c, d) {
    const u = U.bezierBoundingBox(t, s, i, n, r, a, h, c, d);
    d || this.updateRectMinMax(e, u);
  }
  getPathBoundingBox(e = re.FILL, t = null) {
    const s = [this.minX, this.minY, this.maxX, this.maxY];
    if (e === re.STROKE) {
      t || at("Stroke bounding box must include transform.");
      const i = U.singularValueDecompose2dScale(t), n = i[0] * this.lineWidth / 2, r = i[1] * this.lineWidth / 2;
      s[0] -= n, s[1] -= r, s[2] += n, s[3] += r;
    }
    return s;
  }
  updateClipFromPath() {
    const e = U.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(e || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === 1 / 0;
  }
  startNewPathAndClipBox(e) {
    this.clipBox = e, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
  }
  getClippedPathBoundingBox(e = re.FILL, t = null) {
    return U.intersect(this.clipBox, this.getPathBoundingBox(e, t));
  }
}
function Ob(l, e) {
  if (typeof ImageData < "u" && e instanceof ImageData) {
    l.putImageData(e, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % de, n = (t - i) / de, r = i === 0 ? n : n + 1, a = l.createImageData(s, de);
  let h = 0, c;
  const d = e.data, u = a.data;
  let f, m, g, A;
  if (e.kind === yu.GRAYSCALE_1BPP) {
    const E = d.byteLength, y = new Uint32Array(u.buffer, 0, u.byteLength >> 2), w = y.length, S = s + 7 >> 3, C = 4294967295, P = ue.isLittleEndian ? 4278190080 : 255;
    for (f = 0; f < r; f++) {
      for (g = f < n ? de : i, c = 0, m = 0; m < g; m++) {
        const x = E - h;
        let R = 0;
        const M = x > S ? s : x * 8 - 7, T = M & -8;
        let I = 0, _ = 0;
        for (; R < T; R += 8)
          _ = d[h++], y[c++] = _ & 128 ? C : P, y[c++] = _ & 64 ? C : P, y[c++] = _ & 32 ? C : P, y[c++] = _ & 16 ? C : P, y[c++] = _ & 8 ? C : P, y[c++] = _ & 4 ? C : P, y[c++] = _ & 2 ? C : P, y[c++] = _ & 1 ? C : P;
        for (; R < M; R++)
          I === 0 && (_ = d[h++], I = 128), y[c++] = _ & I ? C : P, I >>= 1;
      }
      for (; c < w; )
        y[c++] = 0;
      l.putImageData(a, 0, f * de);
    }
  } else if (e.kind === yu.RGBA_32BPP) {
    for (m = 0, A = s * de * 4, f = 0; f < n; f++)
      u.set(d.subarray(h, h + A)), h += A, l.putImageData(a, 0, m), m += de;
    f < r && (A = s * i * 4, u.set(d.subarray(h, h + A)), l.putImageData(a, 0, m));
  } else if (e.kind === yu.RGB_24BPP)
    for (g = de, A = s * g, f = 0; f < r; f++) {
      for (f >= n && (g = i, A = s * g), c = 0, m = A; m--; )
        u[c++] = d[h++], u[c++] = d[h++], u[c++] = d[h++], u[c++] = 255;
      l.putImageData(a, 0, f * de);
    }
  else
    throw new Error(`bad image kind: ${e.kind}`);
}
function Db(l, e) {
  if (e.bitmap) {
    l.drawImage(e.bitmap, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % de, n = (t - i) / de, r = i === 0 ? n : n + 1, a = l.createImageData(s, de);
  let h = 0;
  const c = e.data, d = a.data;
  for (let u = 0; u < r; u++) {
    const f = u < n ? de : i;
    ({
      srcPos: h
    } = fw({
      src: c,
      srcPos: h,
      dest: d,
      width: s,
      height: f,
      nonBlackColor: 0
    })), l.putImageData(a, 0, u * de);
  }
}
function dl(l, e) {
  const t = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s of t)
    l[s] !== void 0 && (e[s] = l[s]);
  l.setLineDash !== void 0 && (e.setLineDash(l.getLineDash()), e.lineDashOffset = l.lineDashOffset);
}
function lu(l) {
  if (l.strokeStyle = l.fillStyle = "#000000", l.fillRule = "nonzero", l.globalAlpha = 1, l.lineWidth = 1, l.lineCap = "butt", l.lineJoin = "miter", l.miterLimit = 10, l.globalCompositeOperation = "source-over", l.font = "10px sans-serif", l.setLineDash !== void 0 && (l.setLineDash([]), l.lineDashOffset = 0), !Jt) {
    const {
      filter: e
    } = l;
    e !== "none" && e !== "" && (l.filter = "none");
  }
}
function kb(l, e) {
  if (e)
    return !0;
  const t = U.singularValueDecompose2dScale(l);
  t[0] = Math.fround(t[0]), t[1] = Math.fround(t[1]);
  const s = Math.fround((globalThis.devicePixelRatio || 1) * rl.PDF_TO_CSS_UNITS);
  return t[0] <= s && t[1] <= s;
}
const bw = ["butt", "round", "square"], yw = ["miter", "round", "bevel"], Aw = {}, Fb = {};
var Nh, Hm, Bh, $m;
const vb = class vb {
  constructor(e, t, s, i, n, {
    optionalContentConfig: r,
    markedContentStack: a = null
  }, h, c) {
    p(this, Nh);
    p(this, Bh);
    this.ctx = e, this.current = new Mb(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = s, this.canvasFactory = i, this.filterFactory = n, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = a || [], this.optionalContentConfig = r, this.cachedCanvases = new mw(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = h, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = c, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(e, t = null) {
    return typeof e == "string" ? e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e) : t;
  }
  beginDrawing({
    transform: e,
    viewport: t,
    transparency: s = !1,
    background: i = null
  }) {
    const n = this.ctx.canvas.width, r = this.ctx.canvas.height, a = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, n, r), this.ctx.fillStyle = a, s) {
      const h = this.cachedCanvases.getCanvas("transparent", n, r);
      this.compositeCtx = this.ctx, this.transparentCanvas = h.canvas, this.ctx = h.context, this.ctx.save(), this.ctx.transform(...pt(this.compositeCtx));
    }
    this.ctx.save(), lu(this.ctx), e && (this.ctx.transform(...e), this.outputScaleX = e[0], this.outputScaleY = e[0]), this.ctx.transform(...t.transform), this.viewportScale = t.scale, this.baseTransform = pt(this.ctx);
  }
  executeOperatorList(e, t, s, i) {
    const n = e.argsArray, r = e.fnArray;
    let a = t || 0;
    const h = n.length;
    if (h === a)
      return a;
    const c = h - a > Lb && typeof s == "function", d = c ? Date.now() + pw : 0;
    let u = 0;
    const f = this.commonObjs, m = this.objs;
    let g;
    for (; ; ) {
      if (i !== void 0 && a === i.nextBreakPoint)
        return i.breakIt(a, s), a;
      if (g = r[a], g !== Be.dependency)
        this[g].apply(this, n[a]);
      else
        for (const A of n[a]) {
          const E = A.startsWith("g_") ? f : m;
          if (!E.has(A))
            return E.get(A, s), a;
        }
      if (a++, a === h)
        return a;
      if (c && ++u > Lb) {
        if (Date.now() > d)
          return s(), a;
        u = 0;
      }
    }
  }
  endDrawing() {
    v(this, Nh, Hm).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const e of this._cachedBitmapsMap.values()) {
      for (const t of e.values())
        typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && (t.width = t.height = 0);
      e.clear();
    }
    this._cachedBitmapsMap.clear(), v(this, Bh, $m).call(this);
  }
  _scaleImage(e, t) {
    const s = e.width, i = e.height;
    let n = Math.max(Math.hypot(t[0], t[1]), 1), r = Math.max(Math.hypot(t[2], t[3]), 1), a = s, h = i, c = "prescale1", d, u;
    for (; n > 2 && a > 1 || r > 2 && h > 1; ) {
      let f = a, m = h;
      n > 2 && a > 1 && (f = a >= 16384 ? Math.floor(a / 2) - 1 || 1 : Math.ceil(a / 2), n /= a / f), r > 2 && h > 1 && (m = h >= 16384 ? Math.floor(h / 2) - 1 || 1 : Math.ceil(h) / 2, r /= h / m), d = this.cachedCanvases.getCanvas(c, f, m), u = d.context, u.clearRect(0, 0, f, m), u.drawImage(e, 0, 0, a, h, 0, 0, f, m), e = d.canvas, a = f, h = m, c = c === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: e,
      paintWidth: a,
      paintHeight: h
    };
  }
  _createMaskCanvas(e) {
    const t = this.ctx, {
      width: s,
      height: i
    } = e, n = this.current.fillColor, r = this.current.patternFill, a = pt(t);
    let h, c, d, u;
    if ((e.bitmap || e.data) && e.count > 1) {
      const M = e.bitmap || e.data.buffer;
      c = JSON.stringify(r ? a : [a.slice(0, 4), n]), h = this._cachedBitmapsMap.get(M), h || (h = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(M, h));
      const T = h.get(c);
      if (T && !r) {
        const I = Math.round(Math.min(a[0], a[2]) + a[4]), _ = Math.round(Math.min(a[1], a[3]) + a[5]);
        return {
          canvas: T,
          offsetX: I,
          offsetY: _
        };
      }
      d = T;
    }
    d || (u = this.cachedCanvases.getCanvas("maskCanvas", s, i), Db(u.context, e));
    let f = U.transform(a, [1 / s, 0, 0, -1 / i, 0, 0]);
    f = U.transform(f, [1, 0, 0, 1, 0, -i]);
    const [m, g, A, E] = U.getAxialAlignedBoundingBox([0, 0, s, i], f), y = Math.round(A - m) || 1, w = Math.round(E - g) || 1, S = this.cachedCanvases.getCanvas("fillCanvas", y, w), C = S.context, P = m, x = g;
    C.translate(-P, -x), C.transform(...f), d || (d = this._scaleImage(u.canvas, Cs(C)), d = d.img, h && r && h.set(c, d)), C.imageSmoothingEnabled = kb(pt(C), e.interpolate), ou(C, d, 0, 0, d.width, d.height, 0, 0, s, i), C.globalCompositeOperation = "source-in";
    const R = U.transform(Cs(C), [1, 0, 0, 1, -P, -x]);
    return C.fillStyle = r ? n.getPattern(t, this, R, re.FILL) : n, C.fillRect(0, 0, s, i), h && !r && (this.cachedCanvases.delete("fillCanvas"), h.set(c, S.canvas)), {
      canvas: S.canvas,
      offsetX: Math.round(P),
      offsetY: Math.round(x)
    };
  }
  setLineWidth(e) {
    e !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e, this.ctx.lineWidth = e;
  }
  setLineCap(e) {
    this.ctx.lineCap = bw[e];
  }
  setLineJoin(e) {
    this.ctx.lineJoin = yw[e];
  }
  setMiterLimit(e) {
    this.ctx.miterLimit = e;
  }
  setDash(e, t) {
    const s = this.ctx;
    s.setLineDash !== void 0 && (s.setLineDash(e), s.lineDashOffset = t);
  }
  setRenderingIntent(e) {
  }
  setFlatness(e) {
  }
  setGState(e) {
    for (const [t, s] of e)
      switch (t) {
        case "LW":
          this.setLineWidth(s);
          break;
        case "LC":
          this.setLineCap(s);
          break;
        case "LJ":
          this.setLineJoin(s);
          break;
        case "ML":
          this.setMiterLimit(s);
          break;
        case "D":
          this.setDash(s[0], s[1]);
          break;
        case "RI":
          this.setRenderingIntent(s);
          break;
        case "FL":
          this.setFlatness(s);
          break;
        case "Font":
          this.setFont(s[0], s[1]);
          break;
        case "CA":
          this.current.strokeAlpha = s;
          break;
        case "ca":
          this.current.fillAlpha = s, this.ctx.globalAlpha = s;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = s;
          break;
        case "SMask":
          this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const e = this.inSMaskMode;
    this.current.activeSMask && !e ? this.beginSMaskMode() : !this.current.activeSMask && e && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const e = this.ctx.canvas.width, t = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, i = this.cachedCanvases.getCanvas(s, e, t);
    this.suspendedCtx = this.ctx, this.ctx = i.context;
    const n = this.ctx;
    n.setTransform(...pt(this.suspendedCtx)), dl(this.suspendedCtx, n), gw(n, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), dl(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(e) {
    if (!this.current.activeSMask)
      return;
    e ? (e[0] = Math.floor(e[0]), e[1] = Math.floor(e[1]), e[2] = Math.ceil(e[2]), e[3] = Math.ceil(e[3])) : e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const t = this.current.activeSMask, s = this.suspendedCtx;
    this.composeSMask(s, t, this.ctx, e), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(e, t, s, i) {
    const n = i[0], r = i[1], a = i[2] - n, h = i[3] - r;
    a === 0 || h === 0 || (this.genericComposeSMask(t.context, s, a, h, t.subtype, t.backdrop, t.transferMap, n, r, t.offsetX, t.offsetY), e.save(), e.globalAlpha = 1, e.globalCompositeOperation = "source-over", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s.canvas, 0, 0), e.restore());
  }
  genericComposeSMask(e, t, s, i, n, r, a, h, c, d, u) {
    let f = e.canvas, m = h - d, g = c - u;
    if (r) {
      if (m < 0 || g < 0 || m + s > f.width || g + i > f.height) {
        const E = this.cachedCanvases.getCanvas("maskExtension", s, i), y = E.context;
        y.drawImage(f, -m, -g), r.some((w) => w !== 0) && (y.globalCompositeOperation = "destination-atop", y.fillStyle = U.makeHexColor(...r), y.fillRect(0, 0, s, i), y.globalCompositeOperation = "source-over"), f = E.canvas, m = g = 0;
      } else if (r.some((E) => E !== 0)) {
        e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0);
        const E = new Path2D();
        E.rect(m, g, s, i), e.clip(E), e.globalCompositeOperation = "destination-atop", e.fillStyle = U.makeHexColor(...r), e.fillRect(m, g, s, i), e.restore();
      }
    }
    t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0), n === "Alpha" && a ? t.filter = this.filterFactory.addAlphaFilter(a) : n === "Luminosity" && (t.filter = this.filterFactory.addLuminosityFilter(a));
    const A = new Path2D();
    A.rect(h, c, s, i), t.clip(A), t.globalCompositeOperation = "destination-in", t.drawImage(f, m, g, s, i, h, c, s, i), t.restore();
  }
  save() {
    this.inSMaskMode ? (dl(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
    const e = this.current;
    this.stateStack.push(e), this.current = e.clone();
  }
  restore() {
    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), dl(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
  }
  transform(e, t, s, i, n, r) {
    this.ctx.transform(e, t, s, i, n, r), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(e, t, s) {
    const i = this.ctx, n = this.current;
    let r = n.x, a = n.y, h, c;
    const d = pt(i), u = d[0] === 0 && d[3] === 0 || d[1] === 0 && d[2] === 0, f = u ? s.slice(0) : null;
    for (let m = 0, g = 0, A = e.length; m < A; m++)
      switch (e[m] | 0) {
        case Be.rectangle:
          r = t[g++], a = t[g++];
          const E = t[g++], y = t[g++], w = r + E, S = a + y;
          i.moveTo(r, a), E === 0 || y === 0 ? i.lineTo(w, S) : (i.lineTo(w, a), i.lineTo(w, S), i.lineTo(r, S)), u || n.updateRectMinMax(d, [r, a, w, S]), i.closePath();
          break;
        case Be.moveTo:
          r = t[g++], a = t[g++], i.moveTo(r, a), u || n.updatePathMinMax(d, r, a);
          break;
        case Be.lineTo:
          r = t[g++], a = t[g++], i.lineTo(r, a), u || n.updatePathMinMax(d, r, a);
          break;
        case Be.curveTo:
          h = r, c = a, r = t[g + 4], a = t[g + 5], i.bezierCurveTo(t[g], t[g + 1], t[g + 2], t[g + 3], r, a), n.updateCurvePathMinMax(d, h, c, t[g], t[g + 1], t[g + 2], t[g + 3], r, a, f), g += 6;
          break;
        case Be.curveTo2:
          h = r, c = a, i.bezierCurveTo(r, a, t[g], t[g + 1], t[g + 2], t[g + 3]), n.updateCurvePathMinMax(d, h, c, r, a, t[g], t[g + 1], t[g + 2], t[g + 3], f), r = t[g + 2], a = t[g + 3], g += 4;
          break;
        case Be.curveTo3:
          h = r, c = a, r = t[g + 2], a = t[g + 3], i.bezierCurveTo(t[g], t[g + 1], r, a, r, a), n.updateCurvePathMinMax(d, h, c, t[g], t[g + 1], r, a, r, a, f), g += 4;
          break;
        case Be.closePath:
          i.closePath();
          break;
      }
    u && n.updateScalingPathMinMax(d, f), n.setCurrentPoint(r, a);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(e = !0) {
    const t = this.ctx, s = this.current.strokeColor;
    t.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (t.save(), t.strokeStyle = s.getPattern(t, this, Cs(t), re.STROKE), this.rescaleAndStroke(!1), t.restore()) : this.rescaleAndStroke(!0)), e && this.consumePath(this.current.getClippedPathBoundingBox()), t.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath(), this.stroke();
  }
  fill(e = !0) {
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    let n = !1;
    i && (t.save(), t.fillStyle = s.getPattern(t, this, Cs(t), re.FILL), n = !0);
    const r = this.current.getClippedPathBoundingBox();
    this.contentVisible && r !== null && (this.pendingEOFill ? (t.fill("evenodd"), this.pendingEOFill = !1) : t.fill()), n && t.restore(), e && this.consumePath(r);
  }
  eoFill() {
    this.pendingEOFill = !0, this.fill();
  }
  fillStroke() {
    this.fill(!1), this.stroke(!1), this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = !0, this.fillStroke();
  }
  closeFillStroke() {
    this.closePath(), this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = !0, this.closePath(), this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = Aw;
  }
  eoClip() {
    this.pendingClip = Fb;
  }
  beginText() {
    this.current.textMatrix = Iy, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  endText() {
    const e = this.pendingTextPaths, t = this.ctx;
    if (e === void 0) {
      t.beginPath();
      return;
    }
    t.save(), t.beginPath();
    for (const s of e)
      t.setTransform(...s.transform), t.translate(s.x, s.y), s.addToPath(t, s.fontSize);
    t.restore(), t.clip(), t.beginPath(), delete this.pendingTextPaths;
  }
  setCharSpacing(e) {
    this.current.charSpacing = e;
  }
  setWordSpacing(e) {
    this.current.wordSpacing = e;
  }
  setHScale(e) {
    this.current.textHScale = e / 100;
  }
  setLeading(e) {
    this.current.leading = -e;
  }
  setFont(e, t) {
    var d;
    const s = this.commonObjs.get(e), i = this.current;
    if (!s)
      throw new Error(`Can't find font for ${e}`);
    if (i.fontMatrix = s.fontMatrix || dm, (i.fontMatrix[0] === 0 || i.fontMatrix[3] === 0) && Q("Invalid font matrix for font " + e), t < 0 ? (t = -t, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = s, this.current.fontSize = t, s.isType3Font)
      return;
    const n = s.loadedName || "sans-serif", r = ((d = s.systemFontInfo) == null ? void 0 : d.css) || `"${n}", ${s.fallbackName}`;
    let a = "normal";
    s.black ? a = "900" : s.bold && (a = "bold");
    const h = s.italic ? "italic" : "normal";
    let c = t;
    t < Rb ? c = Rb : t > Ib && (c = Ib), this.current.fontSizeScale = t / c, this.ctx.font = `${h} ${a} ${c}px ${r}`;
  }
  setTextRenderingMode(e) {
    this.current.textRenderingMode = e;
  }
  setTextRise(e) {
    this.current.textRise = e;
  }
  moveText(e, t) {
    this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += t;
  }
  setLeadingMoveText(e, t) {
    this.setLeading(-t), this.moveText(e, t);
  }
  setTextMatrix(e, t, s, i, n, r) {
    this.current.textMatrix = [e, t, s, i, n, r], this.current.textMatrixScale = Math.hypot(e, t), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(e, t, s, i) {
    const n = this.ctx, r = this.current, a = r.font, h = r.textRenderingMode, c = r.fontSize / r.fontSizeScale, d = h & Gt.FILL_STROKE_MASK, u = !!(h & Gt.ADD_TO_PATH_FLAG), f = r.patternFill && !a.missingFile;
    let m;
    (a.disableFontFace || u || f) && (m = a.getPathGenerator(this.commonObjs, e)), a.disableFontFace || f ? (n.save(), n.translate(t, s), n.beginPath(), m(n, c), i && n.setTransform(...i), (d === Gt.FILL || d === Gt.FILL_STROKE) && n.fill(), (d === Gt.STROKE || d === Gt.FILL_STROKE) && n.stroke(), n.restore()) : ((d === Gt.FILL || d === Gt.FILL_STROKE) && n.fillText(e, t, s), (d === Gt.STROKE || d === Gt.FILL_STROKE) && n.strokeText(e, t, s)), u && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
      transform: pt(n),
      x: t,
      y: s,
      fontSize: c,
      addToPath: m
    });
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: e
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    e.scale(1.5, 1), e.fillText("I", 0, 10);
    const t = e.getImageData(0, 0, 10, 10).data;
    let s = !1;
    for (let i = 3; i < t.length; i += 4)
      if (t[i] > 0 && t[i] < 255) {
        s = !0;
        break;
      }
    return et(this, "isFontSubpixelAAEnabled", s);
  }
  showText(e) {
    const t = this.current, s = t.font;
    if (s.isType3Font)
      return this.showType3Text(e);
    const i = t.fontSize;
    if (i === 0)
      return;
    const n = this.ctx, r = t.fontSizeScale, a = t.charSpacing, h = t.wordSpacing, c = t.fontDirection, d = t.textHScale * c, u = e.length, f = s.vertical, m = f ? 1 : -1, g = s.defaultVMetrics, A = i * t.fontMatrix[0], E = t.textRenderingMode === Gt.FILL && !s.disableFontFace && !t.patternFill;
    n.save(), n.transform(...t.textMatrix), n.translate(t.x, t.y + t.textRise), c > 0 ? n.scale(d, -1) : n.scale(d, 1);
    let y;
    if (t.patternFill) {
      n.save();
      const x = t.fillColor.getPattern(n, this, Cs(n), re.FILL);
      y = pt(n), n.restore(), n.fillStyle = x;
    }
    let w = t.lineWidth;
    const S = t.textMatrixScale;
    if (S === 0 || w === 0) {
      const x = t.textRenderingMode & Gt.FILL_STROKE_MASK;
      (x === Gt.STROKE || x === Gt.FILL_STROKE) && (w = this.getSinglePixelWidth());
    } else
      w /= S;
    if (r !== 1 && (n.scale(r, r), w /= r), n.lineWidth = w, s.isInvalidPDFjsFont) {
      const x = [];
      let R = 0;
      for (const M of e)
        x.push(M.unicode), R += M.width;
      n.fillText(x.join(""), 0, 0), t.x += R * A * d, n.restore(), this.compose();
      return;
    }
    let C = 0, P;
    for (P = 0; P < u; ++P) {
      const x = e[P];
      if (typeof x == "number") {
        C += m * x * i / 1e3;
        continue;
      }
      let R = !1;
      const M = (x.isSpace ? h : 0) + a, T = x.fontChar, I = x.accent;
      let _, k, F = x.width;
      if (f) {
        const $ = x.vmetric || g, L = -(x.vmetric ? $[1] : F * 0.5) * A, B = $[2] * A;
        F = $ ? -$[0] : F, _ = L / r, k = (C + B) / r;
      } else
        _ = C / r, k = 0;
      if (s.remeasure && F > 0) {
        const $ = n.measureText(T).width * 1e3 / i * r;
        if (F < $ && this.isFontSubpixelAAEnabled) {
          const L = F / $;
          R = !0, n.save(), n.scale(L, 1), _ /= L;
        } else
          F !== $ && (_ += (F - $) / 2e3 * i / r);
      }
      if (this.contentVisible && (x.isInFont || s.missingFile)) {
        if (E && !I)
          n.fillText(T, _, k);
        else if (this.paintChar(T, _, k, y), I) {
          const $ = _ + i * I.offset.x / r, L = k - i * I.offset.y / r;
          this.paintChar(I.fontChar, $, L, y);
        }
      }
      const V = f ? F * A - M * c : F * A + M * c;
      C += V, R && n.restore();
    }
    f ? t.y -= C : t.x += C * d, n.restore(), this.compose();
  }
  showType3Text(e) {
    const t = this.ctx, s = this.current, i = s.font, n = s.fontSize, r = s.fontDirection, a = i.vertical ? 1 : -1, h = s.charSpacing, c = s.wordSpacing, d = s.textHScale * r, u = s.fontMatrix || dm, f = e.length, m = s.textRenderingMode === Gt.INVISIBLE;
    let g, A, E, y;
    if (!(m || n === 0)) {
      for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, t.save(), t.transform(...s.textMatrix), t.translate(s.x, s.y), t.scale(d, r), g = 0; g < f; ++g) {
        if (A = e[g], typeof A == "number") {
          y = a * A * n / 1e3, this.ctx.translate(y, 0), s.x += y * d;
          continue;
        }
        const w = (A.isSpace ? c : 0) + h, S = i.charProcOperatorList[A.operatorListId];
        if (!S) {
          Q(`Type3 character "${A.operatorListId}" is not available.`);
          continue;
        }
        this.contentVisible && (this.processingType3 = A, this.save(), t.scale(n, n), t.transform(...u), this.executeOperatorList(S), this.restore()), E = U.applyTransform([A.width, 0], u)[0] * n + w, t.translate(E, 0), s.x += E * d;
      }
      t.restore(), this.processingType3 = null;
    }
  }
  setCharWidth(e, t) {
  }
  setCharWidthAndBounds(e, t, s, i, n, r) {
    this.ctx.rect(s, i, n - s, r - i), this.ctx.clip(), this.endPath();
  }
  getColorN_Pattern(e) {
    let t;
    if (e[0] === "TilingPattern") {
      const s = e[1], i = this.baseTransform || pt(this.ctx), n = {
        createCanvasGraphics: (r) => new vb(r, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      t = new jm(e, s, this.ctx, n, i);
    } else
      t = this._getPattern(e[1], e[2]);
    return t;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
  }
  setStrokeRGBColor(e, t, s) {
    const i = U.makeHexColor(e, t, s);
    this.ctx.strokeStyle = i, this.current.strokeColor = i;
  }
  setFillRGBColor(e, t, s) {
    const i = U.makeHexColor(e, t, s);
    this.ctx.fillStyle = i, this.current.fillColor = i, this.current.patternFill = !1;
  }
  _getPattern(e, t = null) {
    let s;
    return this.cachedPatterns.has(e) ? s = this.cachedPatterns.get(e) : (s = uw(this.getObject(e)), this.cachedPatterns.set(e, s)), t && (s.matrix = t), s;
  }
  shadingFill(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx;
    this.save();
    const s = this._getPattern(e);
    t.fillStyle = s.getPattern(t, this, Cs(t), re.SHADING);
    const i = Cs(t);
    if (i) {
      const {
        width: n,
        height: r
      } = t.canvas, [a, h, c, d] = U.getAxialAlignedBoundingBox([0, 0, n, r], i);
      this.ctx.fillRect(a, h, c - a, d - h);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox()), this.restore();
  }
  beginInlineImage() {
    at("Should not call beginInlineImage");
  }
  beginImageData() {
    at("Should not call beginImageData");
  }
  paintFormXObjectBegin(e, t) {
    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), e && this.transform(...e), this.baseTransform = pt(this.ctx), t)) {
      const s = t[2] - t[0], i = t[3] - t[1];
      this.ctx.rect(t[0], t[1], s, i), this.current.updateRectMinMax(pt(this.ctx), t), this.clip(), this.endPath();
    }
  }
  paintFormXObjectEnd() {
    this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(e) {
    if (!this.contentVisible)
      return;
    this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const t = this.ctx;
    e.isolated || Ng("TODO: Support non-isolated groups."), e.knockout && Q("Knockout groups not supported.");
    const s = pt(t);
    if (e.matrix && t.transform(...e.matrix), !e.bbox)
      throw new Error("Bounding box is required.");
    let i = U.getAxialAlignedBoundingBox(e.bbox, pt(t));
    const n = [0, 0, t.canvas.width, t.canvas.height];
    i = U.intersect(i, n) || [0, 0, 0, 0];
    const r = Math.floor(i[0]), a = Math.floor(i[1]), h = Math.max(Math.ceil(i[2]) - r, 1), c = Math.max(Math.ceil(i[3]) - a, 1);
    this.current.startNewPathAndClipBox([0, 0, h, c]);
    let d = "groupAt" + this.groupLevel;
    e.smask && (d += "_smask_" + this.smaskCounter++ % 2);
    const u = this.cachedCanvases.getCanvas(d, h, c), f = u.context;
    f.translate(-r, -a), f.transform(...s), e.smask ? this.smaskStack.push({
      canvas: u.canvas,
      context: f,
      offsetX: r,
      offsetY: a,
      subtype: e.smask.subtype,
      backdrop: e.smask.backdrop,
      transferMap: e.smask.transferMap || null,
      startTransformInverse: null
    }) : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(r, a), t.save()), dl(t, f), this.ctx = f, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(t), this.groupLevel++;
  }
  endGroup(e) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const t = this.ctx, s = this.groupStack.pop();
    if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, e.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore();
    else {
      this.ctx.restore();
      const i = pt(this.ctx);
      this.restore(), this.ctx.save(), this.ctx.setTransform(...i);
      const n = U.getAxialAlignedBoundingBox([0, 0, t.canvas.width, t.canvas.height], i);
      this.ctx.drawImage(t.canvas, 0, 0), this.ctx.restore(), this.compose(n);
    }
  }
  beginAnnotation(e, t, s, i, n) {
    if (v(this, Nh, Hm).call(this), lu(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), t) {
      const r = t[2] - t[0], a = t[3] - t[1];
      if (n && this.annotationCanvasMap) {
        s = s.slice(), s[4] -= t[0], s[5] -= t[1], t = t.slice(), t[0] = t[1] = 0, t[2] = r, t[3] = a;
        const [h, c] = U.singularValueDecompose2dScale(pt(this.ctx)), {
          viewportScale: d
        } = this, u = Math.ceil(r * this.outputScaleX * d), f = Math.ceil(a * this.outputScaleY * d);
        this.annotationCanvas = this.canvasFactory.create(u, f);
        const {
          canvas: m,
          context: g
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(e, m), this.annotationCanvas.savedCtx = this.ctx, this.ctx = g, this.ctx.save(), this.ctx.setTransform(h, 0, 0, -c, 0, a * c), lu(this.ctx);
      } else
        lu(this.ctx), this.ctx.rect(t[0], t[1], r, a), this.ctx.clip(), this.endPath();
    }
    this.current = new Mb(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...i);
  }
  endAnnotation() {
    this.annotationCanvas && (this.ctx.restore(), v(this, Bh, $m).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.count;
    e = this.getObject(e.data, e), e.count = t;
    const s = this.ctx, i = this.processingType3;
    if (i && (i.compiled === void 0 && (i.compiled = vw(e)), i.compiled)) {
      i.compiled(s);
      return;
    }
    const n = this._createMaskCanvas(e), r = n.canvas;
    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(r, n.offsetX, n.offsetY), s.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(e, t, s = 0, i = 0, n, r) {
    if (!this.contentVisible)
      return;
    e = this.getObject(e.data, e);
    const a = this.ctx;
    a.save();
    const h = pt(a);
    a.transform(t, s, i, n, 0, 0);
    const c = this._createMaskCanvas(e);
    a.setTransform(1, 0, 0, 1, c.offsetX - h[4], c.offsetY - h[5]);
    for (let d = 0, u = r.length; d < u; d += 2) {
      const f = U.transform(h, [t, s, i, n, r[d], r[d + 1]]), [m, g] = U.applyTransform([0, 0], f);
      a.drawImage(c.canvas, m, g);
    }
    a.restore(), this.compose();
  }
  paintImageMaskXObjectGroup(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    for (const n of e) {
      const {
        data: r,
        width: a,
        height: h,
        transform: c
      } = n, d = this.cachedCanvases.getCanvas("maskCanvas", a, h), u = d.context;
      u.save();
      const f = this.getObject(r, n);
      Db(u, f), u.globalCompositeOperation = "source-in", u.fillStyle = i ? s.getPattern(u, this, Cs(t), re.FILL) : s, u.fillRect(0, 0, a, h), u.restore(), t.save(), t.transform(...c), t.scale(1, -1), ou(t, d.canvas, 0, 0, a, h, 0, -1, 1, 1), t.restore();
    }
    this.compose();
  }
  paintImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = this.getObject(e);
    if (!t) {
      Q("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(t);
  }
  paintImageXObjectRepeat(e, t, s, i) {
    if (!this.contentVisible)
      return;
    const n = this.getObject(e);
    if (!n) {
      Q("Dependent image isn't ready yet");
      return;
    }
    const r = n.width, a = n.height, h = [];
    for (let c = 0, d = i.length; c < d; c += 2)
      h.push({
        transform: [t, 0, 0, s, i[c], i[c + 1]],
        x: 0,
        y: 0,
        w: r,
        h: a
      });
    this.paintInlineImageXObjectGroup(n, h);
  }
  applyTransferMapsToCanvas(e) {
    return this.current.transferMaps !== "none" && (e.filter = this.current.transferMaps, e.drawImage(e.canvas, 0, 0), e.filter = "none"), e.canvas;
  }
  applyTransferMapsToBitmap(e) {
    if (this.current.transferMaps === "none")
      return e.bitmap;
    const {
      bitmap: t,
      width: s,
      height: i
    } = e, n = this.cachedCanvases.getCanvas("inlineImage", s, i), r = n.context;
    return r.filter = this.current.transferMaps, r.drawImage(t, 0, 0), r.filter = "none", n.canvas;
  }
  paintInlineImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.width, s = e.height, i = this.ctx;
    if (this.save(), !Jt) {
      const {
        filter: a
      } = i;
      a !== "none" && a !== "" && (i.filter = "none");
    }
    i.scale(1 / t, -1 / s);
    let n;
    if (e.bitmap)
      n = this.applyTransferMapsToBitmap(e);
    else if (typeof HTMLElement == "function" && e instanceof HTMLElement || !e.data)
      n = e;
    else {
      const h = this.cachedCanvases.getCanvas("inlineImage", t, s).context;
      Ob(h, e), n = this.applyTransferMapsToCanvas(h);
    }
    const r = this._scaleImage(n, Cs(i));
    i.imageSmoothingEnabled = kb(pt(i), e.interpolate), ou(i, r.img, 0, 0, r.paintWidth, r.paintHeight, 0, -s, t, s), this.compose(), this.restore();
  }
  paintInlineImageXObjectGroup(e, t) {
    if (!this.contentVisible)
      return;
    const s = this.ctx;
    let i;
    if (e.bitmap)
      i = e.bitmap;
    else {
      const n = e.width, r = e.height, h = this.cachedCanvases.getCanvas("inlineImage", n, r).context;
      Ob(h, e), i = this.applyTransferMapsToCanvas(h);
    }
    for (const n of t)
      s.save(), s.transform(...n.transform), s.scale(1, -1), ou(s, i, n.x, n.y, n.w, n.h, 0, -1, 1, 1), s.restore();
    this.compose();
  }
  paintSolidColorImageMask() {
    this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(e) {
  }
  markPointProps(e, t) {
  }
  beginMarkedContent(e) {
    this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(e, t) {
    e === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(t)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(e) {
    const t = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(e);
    const s = this.ctx;
    this.pendingClip && (t || (this.pendingClip === Fb ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const e = pt(this.ctx);
      if (e[1] === 0 && e[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e[0]), Math.abs(e[3]));
      else {
        const t = Math.abs(e[0] * e[3] - e[2] * e[1]), s = Math.hypot(e[0], e[2]), i = Math.hypot(e[1], e[3]);
        this._cachedGetSinglePixelWidth = Math.max(s, i) / t;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: e
      } = this.current, {
        a: t,
        b: s,
        c: i,
        d: n
      } = this.ctx.getTransform();
      let r, a;
      if (s === 0 && i === 0) {
        const h = Math.abs(t), c = Math.abs(n);
        if (h === c)
          if (e === 0)
            r = a = 1 / h;
          else {
            const d = h * e;
            r = a = d < 1 ? 1 / d : 1;
          }
        else if (e === 0)
          r = 1 / h, a = 1 / c;
        else {
          const d = h * e, u = c * e;
          r = d < 1 ? 1 / d : 1, a = u < 1 ? 1 / u : 1;
        }
      } else {
        const h = Math.abs(t * n - s * i), c = Math.hypot(t, s), d = Math.hypot(i, n);
        if (e === 0)
          r = d / h, a = c / h;
        else {
          const u = e * h;
          r = d > u ? d / u : 1, a = c > u ? c / u : 1;
        }
      }
      this._cachedScaleForStroking[0] = r, this._cachedScaleForStroking[1] = a;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(e) {
    const {
      ctx: t
    } = this, {
      lineWidth: s
    } = this.current, [i, n] = this.getScaleForStroking();
    if (t.lineWidth = s || 1, i === 1 && n === 1) {
      t.stroke();
      return;
    }
    const r = t.getLineDash();
    if (e && t.save(), t.scale(i, n), r.length > 0) {
      const a = Math.max(i, n);
      t.setLineDash(r.map((h) => h / a)), t.lineDashOffset /= a;
    }
    t.stroke(), e && t.restore();
  }
  isContentVisible() {
    for (let e = this.markedContentStack.length - 1; e >= 0; e--)
      if (!this.markedContentStack[e].visible)
        return !1;
    return !0;
  }
};
Nh = new WeakSet(), Hm = function() {
  for (; this.stateStack.length || this.inSMaskMode; )
    this.restore();
  this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
}, Bh = new WeakSet(), $m = function() {
  if (this.pageColors) {
    const e = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (e !== "none") {
      const t = this.ctx.filter;
      this.ctx.filter = e, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t;
    }
  }
};
let ma = vb;
for (const l in Be)
  ma.prototype[l] !== void 0 && (ma.prototype[Be[l]] = ma.prototype[l]);
var bu, jh, Hh;
let qr = (bu = class {
  static get workerPort() {
    return o(this, jh);
  }
  static set workerPort(e) {
    if (!(typeof Worker < "u" && e instanceof Worker) && e !== null)
      throw new Error("Invalid `workerPort` type.");
    b(this, jh, e);
  }
  static get workerSrc() {
    return o(this, Hh);
  }
  static set workerSrc(e) {
    if (typeof e != "string")
      throw new Error("Invalid `workerSrc` type.");
    b(this, Hh, e);
  }
}, jh = new WeakMap(), Hh = new WeakMap(), p(bu, jh, null), p(bu, Hh, ""), bu);
const hu = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
}, St = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function pe(l) {
  switch (l instanceof Error || typeof l == "object" && l !== null || at('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), l.name) {
    case "AbortException":
      return new ia(l.message);
    case "MissingPDFException":
      return new sa(l.message);
    case "PasswordException":
      return new fm(l.message, l.code);
    case "UnexpectedResponseException":
      return new Bg(l.message, l.status);
    case "UnknownErrorException":
      return new pm(l.message, l.details);
    default:
      return new pm(l.message, l.toString());
  }
}
var Qf, uA, Zf, fA, Fa, Pu;
class wl {
  constructor(e, t, s) {
    p(this, Qf);
    p(this, Zf);
    p(this, Fa);
    this.sourceName = e, this.targetName = t, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (i) => {
      const n = i.data;
      if (n.targetName !== this.sourceName)
        return;
      if (n.stream) {
        v(this, Zf, fA).call(this, n);
        return;
      }
      if (n.callback) {
        const a = n.callbackId, h = this.callbackCapabilities[a];
        if (!h)
          throw new Error(`Cannot resolve callback ${a}`);
        if (delete this.callbackCapabilities[a], n.callback === hu.DATA)
          h.resolve(n.data);
        else if (n.callback === hu.ERROR)
          h.reject(pe(n.reason));
        else
          throw new Error("Unexpected callback case");
        return;
      }
      const r = this.actionHandler[n.action];
      if (!r)
        throw new Error(`Unknown action from worker: ${n.action}`);
      if (n.callbackId) {
        const a = this.sourceName, h = n.sourceName;
        new Promise(function(c) {
          c(r(n.data));
        }).then(function(c) {
          s.postMessage({
            sourceName: a,
            targetName: h,
            callback: hu.DATA,
            callbackId: n.callbackId,
            data: c
          });
        }, function(c) {
          s.postMessage({
            sourceName: a,
            targetName: h,
            callback: hu.ERROR,
            callbackId: n.callbackId,
            reason: pe(c)
          });
        });
        return;
      }
      if (n.streamId) {
        v(this, Qf, uA).call(this, n);
        return;
      }
      r(n.data);
    }, s.addEventListener("message", this._onComObjOnMessage);
  }
  on(e, t) {
    const s = this.actionHandler;
    if (s[e])
      throw new Error(`There is already an actionName called "${e}"`);
    s[e] = t;
  }
  send(e, t, s) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: e,
      data: t
    }, s);
  }
  sendWithPromise(e, t, s) {
    const i = this.callbackId++, n = Promise.withResolvers();
    this.callbackCapabilities[i] = n;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: e,
        callbackId: i,
        data: t
      }, s);
    } catch (r) {
      n.reject(r);
    }
    return n.promise;
  }
  sendWithStream(e, t, s, i) {
    const n = this.streamId++, r = this.sourceName, a = this.targetName, h = this.comObj;
    return new ReadableStream({
      start: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[n] = {
          controller: c,
          startCall: d,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, h.postMessage({
          sourceName: r,
          targetName: a,
          action: e,
          streamId: n,
          data: t,
          desiredSize: c.desiredSize
        }, i), d.promise;
      },
      pull: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[n].pullCall = d, h.postMessage({
          sourceName: r,
          targetName: a,
          stream: St.PULL,
          streamId: n,
          desiredSize: c.desiredSize
        }), d.promise;
      },
      cancel: (c) => {
        Ot(c instanceof Error, "cancel must have a valid reason");
        const d = Promise.withResolvers();
        return this.streamControllers[n].cancelCall = d, this.streamControllers[n].isClosed = !0, h.postMessage({
          sourceName: r,
          targetName: a,
          stream: St.CANCEL,
          streamId: n,
          reason: pe(c)
        }), d.promise;
      }
    }, s);
  }
  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }
}
Qf = new WeakSet(), uA = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, n = this.comObj, r = this, a = this.actionHandler[e.action], h = {
    enqueue(c, d = 1, u) {
      if (this.isCancelled)
        return;
      const f = this.desiredSize;
      this.desiredSize -= d, f > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), n.postMessage({
        sourceName: s,
        targetName: i,
        stream: St.ENQUEUE,
        streamId: t,
        chunk: c
      }, u);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: St.CLOSE,
        streamId: t
      }), delete r.streamSinks[t]);
    },
    error(c) {
      Ot(c instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, n.postMessage({
        sourceName: s,
        targetName: i,
        stream: St.ERROR,
        streamId: t,
        reason: pe(c)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: e.desiredSize,
    ready: null
  };
  h.sinkCapability.resolve(), h.ready = h.sinkCapability.promise, this.streamSinks[t] = h, new Promise(function(c) {
    c(a(e.data, h));
  }).then(function() {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: St.START_COMPLETE,
      streamId: t,
      success: !0
    });
  }, function(c) {
    n.postMessage({
      sourceName: s,
      targetName: i,
      stream: St.START_COMPLETE,
      streamId: t,
      reason: pe(c)
    });
  });
}, Zf = new WeakSet(), fA = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, n = this.comObj, r = this.streamControllers[t], a = this.streamSinks[t];
  switch (e.stream) {
    case St.START_COMPLETE:
      e.success ? r.startCall.resolve() : r.startCall.reject(pe(e.reason));
      break;
    case St.PULL_COMPLETE:
      e.success ? r.pullCall.resolve() : r.pullCall.reject(pe(e.reason));
      break;
    case St.PULL:
      if (!a) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: St.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
        break;
      }
      a.desiredSize <= 0 && e.desiredSize > 0 && a.sinkCapability.resolve(), a.desiredSize = e.desiredSize, new Promise(function(h) {
        var c;
        h((c = a.onPull) == null ? void 0 : c.call(a));
      }).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: St.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(h) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: St.PULL_COMPLETE,
          streamId: t,
          reason: pe(h)
        });
      });
      break;
    case St.ENQUEUE:
      if (Ot(r, "enqueue should have stream controller"), r.isClosed)
        break;
      r.controller.enqueue(e.chunk);
      break;
    case St.CLOSE:
      if (Ot(r, "close should have stream controller"), r.isClosed)
        break;
      r.isClosed = !0, r.controller.close(), v(this, Fa, Pu).call(this, r, t);
      break;
    case St.ERROR:
      Ot(r, "error should have stream controller"), r.controller.error(pe(e.reason)), v(this, Fa, Pu).call(this, r, t);
      break;
    case St.CANCEL_COMPLETE:
      e.success ? r.cancelCall.resolve() : r.cancelCall.reject(pe(e.reason)), v(this, Fa, Pu).call(this, r, t);
      break;
    case St.CANCEL:
      if (!a)
        break;
      new Promise(function(h) {
        var c;
        h((c = a.onCancel) == null ? void 0 : c.call(a, pe(e.reason)));
      }).then(function() {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: St.CANCEL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(h) {
        n.postMessage({
          sourceName: s,
          targetName: i,
          stream: St.CANCEL_COMPLETE,
          streamId: t,
          reason: pe(h)
        });
      }), a.sinkCapability.reject(pe(e.reason)), a.isCancelled = !0, delete this.streamSinks[t];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, Fa = new WeakSet(), Pu = async function(e, t) {
  var s, i, n;
  await Promise.allSettled([(s = e.startCall) == null ? void 0 : s.promise, (i = e.pullCall) == null ? void 0 : i.promise, (n = e.cancelCall) == null ? void 0 : n.promise]), delete this.streamControllers[t];
};
var Gn, $h;
class Ew {
  constructor({
    parsedData: e,
    rawData: t
  }) {
    p(this, Gn, void 0);
    p(this, $h, void 0);
    b(this, Gn, e), b(this, $h, t);
  }
  getRaw() {
    return o(this, $h);
  }
  get(e) {
    return o(this, Gn).get(e) ?? null;
  }
  getAll() {
    return ib(o(this, Gn));
  }
  has(e) {
    return o(this, Gn).has(e);
  }
}
Gn = new WeakMap(), $h = new WeakMap();
const Ai = Symbol("INTERNAL");
var Vh, Uh, zh, Na;
class ww {
  constructor(e, {
    name: t,
    intent: s,
    usage: i
  }) {
    p(this, Vh, !1);
    p(this, Uh, !1);
    p(this, zh, !1);
    p(this, Na, !0);
    b(this, Vh, !!(e & ke.DISPLAY)), b(this, Uh, !!(e & ke.PRINT)), this.name = t, this.intent = s, this.usage = i;
  }
  get visible() {
    if (o(this, zh))
      return o(this, Na);
    if (!o(this, Na))
      return !1;
    const {
      print: e,
      view: t
    } = this.usage;
    return o(this, Vh) ? (t == null ? void 0 : t.viewState) !== "OFF" : o(this, Uh) ? (e == null ? void 0 : e.printState) !== "OFF" : !0;
  }
  _setVisible(e, t, s = !1) {
    e !== Ai && at("Internal method `_setVisible` called."), b(this, zh, s), b(this, Na, t);
  }
}
Vh = new WeakMap(), Uh = new WeakMap(), zh = new WeakMap(), Na = new WeakMap();
var ki, rt, Ba, ja, Wh, Vm;
class Sw {
  constructor(e, t = ke.DISPLAY) {
    p(this, Wh);
    p(this, ki, null);
    p(this, rt, /* @__PURE__ */ new Map());
    p(this, Ba, null);
    p(this, ja, null);
    if (this.renderingIntent = t, this.name = null, this.creator = null, e !== null) {
      this.name = e.name, this.creator = e.creator, b(this, ja, e.order);
      for (const s of e.groups)
        o(this, rt).set(s.id, new ww(t, s));
      if (e.baseState === "OFF")
        for (const s of o(this, rt).values())
          s._setVisible(Ai, !1);
      for (const s of e.on)
        o(this, rt).get(s)._setVisible(Ai, !0);
      for (const s of e.off)
        o(this, rt).get(s)._setVisible(Ai, !1);
      b(this, Ba, this.getHash());
    }
  }
  isVisible(e) {
    if (o(this, rt).size === 0)
      return !0;
    if (!e)
      return Ng("Optional content group not defined."), !0;
    if (e.type === "OCG")
      return o(this, rt).has(e.id) ? o(this, rt).get(e.id).visible : (Q(`Optional content group not found: ${e.id}`), !0);
    if (e.type === "OCMD") {
      if (e.expression)
        return v(this, Wh, Vm).call(this, e.expression);
      if (!e.policy || e.policy === "AnyOn") {
        for (const t of e.ids) {
          if (!o(this, rt).has(t))
            return Q(`Optional content group not found: ${t}`), !0;
          if (o(this, rt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOn") {
        for (const t of e.ids) {
          if (!o(this, rt).has(t))
            return Q(`Optional content group not found: ${t}`), !0;
          if (!o(this, rt).get(t).visible)
            return !1;
        }
        return !0;
      } else if (e.policy === "AnyOff") {
        for (const t of e.ids) {
          if (!o(this, rt).has(t))
            return Q(`Optional content group not found: ${t}`), !0;
          if (!o(this, rt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOff") {
        for (const t of e.ids) {
          if (!o(this, rt).has(t))
            return Q(`Optional content group not found: ${t}`), !0;
          if (o(this, rt).get(t).visible)
            return !1;
        }
        return !0;
      }
      return Q(`Unknown optional content policy ${e.policy}.`), !0;
    }
    return Q(`Unknown group type ${e.type}.`), !0;
  }
  setVisibility(e, t = !0) {
    const s = o(this, rt).get(e);
    if (!s) {
      Q(`Optional content group not found: ${e}`);
      return;
    }
    s._setVisible(Ai, !!t, !0), b(this, ki, null);
  }
  setOCGState({
    state: e,
    preserveRB: t
  }) {
    let s;
    for (const i of e) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          s = i;
          continue;
      }
      const n = o(this, rt).get(i);
      if (n)
        switch (s) {
          case "ON":
            n._setVisible(Ai, !0);
            break;
          case "OFF":
            n._setVisible(Ai, !1);
            break;
          case "Toggle":
            n._setVisible(Ai, !n.visible);
            break;
        }
    }
    b(this, ki, null);
  }
  get hasInitialVisibility() {
    return o(this, Ba) === null || this.getHash() === o(this, Ba);
  }
  getOrder() {
    return o(this, rt).size ? o(this, ja) ? o(this, ja).slice() : [...o(this, rt).keys()] : null;
  }
  getGroups() {
    return o(this, rt).size > 0 ? ib(o(this, rt)) : null;
  }
  getGroup(e) {
    return o(this, rt).get(e) || null;
  }
  getHash() {
    if (o(this, ki) !== null)
      return o(this, ki);
    const e = new lA();
    for (const [t, s] of o(this, rt))
      e.update(`${t}:${s.visible}`);
    return b(this, ki, e.hexdigest());
  }
}
ki = new WeakMap(), rt = new WeakMap(), Ba = new WeakMap(), ja = new WeakMap(), Wh = new WeakSet(), Vm = function(e) {
  const t = e.length;
  if (t < 2)
    return !0;
  const s = e[0];
  for (let i = 1; i < t; i++) {
    const n = e[i];
    let r;
    if (Array.isArray(n))
      r = v(this, Wh, Vm).call(this, n);
    else if (o(this, rt).has(n))
      r = o(this, rt).get(n).visible;
    else
      return Q(`Optional content group not found: ${n}`), !0;
    switch (s) {
      case "And":
        if (!r)
          return !1;
        break;
      case "Or":
        if (r)
          return !0;
        break;
      case "Not":
        return !r;
      default:
        return !0;
    }
  }
  return s === "And";
};
class xw {
  constructor(e, {
    disableRange: t = !1,
    disableStream: s = !1
  }) {
    Ot(e, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: n,
      progressiveDone: r,
      contentDispositionFilename: a
    } = e;
    if (this._queuedChunks = [], this._progressiveDone = r, this._contentDispositionFilename = a, (n == null ? void 0 : n.length) > 0) {
      const h = n instanceof Uint8Array && n.byteLength === n.buffer.byteLength ? n.buffer : new Uint8Array(n).buffer;
      this._queuedChunks.push(h);
    }
    this._pdfDataRangeTransport = e, this._isStreamingSupported = !s, this._isRangeSupported = !t, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], e.addRangeListener((h, c) => {
      this._onReceiveData({
        begin: h,
        chunk: c
      });
    }), e.addProgressListener((h, c) => {
      this._onProgress({
        loaded: h,
        total: c
      });
    }), e.addProgressiveReadListener((h) => {
      this._onReceiveData({
        chunk: h
      });
    }), e.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), e.transportReady();
  }
  _onReceiveData({
    begin: e,
    chunk: t
  }) {
    const s = t instanceof Uint8Array && t.byteLength === t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
    if (e === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
    else {
      const i = this._rangeReaders.some(function(n) {
        return n._begin !== e ? !1 : (n._enqueue(s), !0);
      });
      Ot(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  _onProgress(e) {
    var t, s, i, n;
    e.total === void 0 ? (s = (t = this._rangeReaders[0]) == null ? void 0 : t.onProgress) == null || s.call(t, {
      loaded: e.loaded
    }) : (n = (i = this._fullRequestReader) == null ? void 0 : i.onProgress) == null || n.call(i, {
      loaded: e.loaded,
      total: e.total
    });
  }
  _onProgressiveDone() {
    var e;
    (e = this._fullRequestReader) == null || e.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(e) {
    const t = this._rangeReaders.indexOf(e);
    t >= 0 && this._rangeReaders.splice(t, 1);
  }
  getFullReader() {
    Ot(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const e = this._queuedChunks;
    return this._queuedChunks = null, new Pw(this, e, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new Tw(this, e, t);
    return this._pdfDataRangeTransport.requestDataRange(e, t), this._rangeReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeReaders.slice(0))
      s.cancel(e);
    this._pdfDataRangeTransport.abort();
  }
}
class Pw {
  constructor(e, t, s = !1, i = null) {
    this._stream = e, this._done = s || !1, this._filename = lb(i) ? i : null, this._queuedChunks = t || [], this._loaded = 0;
    for (const n of this._queuedChunks)
      this._loaded += n.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), e._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(e) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunks.push(e), this._loaded += e.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
}
class Tw {
  constructor(e, t, s) {
    this._stream = e, this._begin = t, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(e) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = e;
      else {
        this._requests.shift().resolve({
          value: e,
          done: !1
        });
        for (const s of this._requests)
          s.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function Cw(l) {
  let e = !0, t = s("filename\\*", "i").exec(l);
  if (t) {
    t = t[1];
    let d = a(t);
    return d = unescape(d), d = h(d), d = c(d), n(d);
  }
  if (t = r(l), t) {
    const d = c(t);
    return n(d);
  }
  if (t = s("filename", "i").exec(l), t) {
    t = t[1];
    let d = a(t);
    return d = c(d), n(d);
  }
  function s(d, u) {
    return new RegExp("(?:^|;)\\s*" + d + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
  }
  function i(d, u) {
    if (d) {
      if (!/^[\x00-\xFF]+$/.test(u))
        return u;
      try {
        const f = new TextDecoder(d, {
          fatal: !0
        }), m = jg(u);
        u = f.decode(m), e = !1;
      } catch {
      }
    }
    return u;
  }
  function n(d) {
    return e && /[\x80-\xff]/.test(d) && (d = i("utf-8", d), e && (d = i("iso-8859-1", d))), d;
  }
  function r(d) {
    const u = [];
    let f;
    const m = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (f = m.exec(d)) !== null; ) {
      let [, A, E, y] = f;
      if (A = parseInt(A, 10), A in u) {
        if (A === 0)
          break;
        continue;
      }
      u[A] = [E, y];
    }
    const g = [];
    for (let A = 0; A < u.length && A in u; ++A) {
      let [E, y] = u[A];
      y = a(y), E && (y = unescape(y), A === 0 && (y = h(y))), g.push(y);
    }
    return g.join("");
  }
  function a(d) {
    if (d.startsWith('"')) {
      const u = d.slice(1).split('\\"');
      for (let f = 0; f < u.length; ++f) {
        const m = u[f].indexOf('"');
        m !== -1 && (u[f] = u[f].slice(0, m), u.length = f + 1), u[f] = u[f].replaceAll(/\\(.)/g, "$1");
      }
      d = u.join('"');
    }
    return d;
  }
  function h(d) {
    const u = d.indexOf("'");
    if (u === -1)
      return d;
    const f = d.slice(0, u), g = d.slice(u + 1).replace(/^[^']*'/, "");
    return i(f, g);
  }
  function c(d) {
    return !d.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(d) ? d : d.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, f, m, g) {
      if (m === "q" || m === "Q")
        return g = g.replaceAll("_", " "), g = g.replaceAll(/=([0-9a-fA-F]{2})/g, function(A, E) {
          return String.fromCharCode(parseInt(E, 16));
        }), i(f, g);
      try {
        g = atob(g);
      } catch {
      }
      return i(f, g);
    });
  }
  return "";
}
function db({
  getResponseHeader: l,
  isHttp: e,
  rangeChunkSize: t,
  disableRange: s
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, n = parseInt(l("Content-Length"), 10);
  return !Number.isInteger(n) || (i.suggestedLength = n, n <= 2 * t) || s || !e || l("Accept-Ranges") !== "bytes" || (l("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
function ub(l) {
  const e = l("Content-Disposition");
  if (e) {
    let t = Cw(e);
    if (t.includes("%"))
      try {
        t = decodeURIComponent(t);
      } catch {
      }
    if (lb(t))
      return t;
  }
  return null;
}
function zg(l, e) {
  return l === 404 || l === 0 && e.startsWith("file:") ? new sa('Missing PDF "' + e + '".') : new Bg(`Unexpected server response (${l}) while retrieving PDF "${e}".`, l);
}
function pA(l) {
  return l === 200 || l === 206;
}
function gA(l, e, t) {
  return {
    method: "GET",
    headers: l,
    signal: t.signal,
    mode: "cors",
    credentials: e ? "include" : "same-origin",
    redirect: "follow"
  };
}
function mA(l) {
  const e = new Headers();
  for (const t in l) {
    const s = l[t];
    s !== void 0 && e.append(t, s);
  }
  return e;
}
function vA(l) {
  return l instanceof Uint8Array ? l.buffer : l instanceof ArrayBuffer ? l : (Q(`getArrayBuffer - unexpected data format: ${l}`), new Uint8Array(l).buffer);
}
class Nb {
  constructor(e) {
    this.source = e, this.isHttp = /^https?:/i.test(e.url), this.httpHeaders = this.isHttp && e.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return Ot(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new Rw(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new Iw(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class Rw {
  constructor(e) {
    this._stream = e, this._reader = null, this._loaded = 0, this._filename = null;
    const t = e.source;
    this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._headers = mA(this._stream.httpHeaders);
    const s = t.url;
    fetch(s, gA(this._headers, this._withCredentials, this._abortController)).then((i) => {
      if (!pA(i.status))
        throw zg(i.status, s);
      this._reader = i.body.getReader(), this._headersCapability.resolve();
      const n = (h) => i.headers.get(h), {
        allowRangeRequests: r,
        suggestedLength: a
      } = db({
        getResponseHeader: n,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = r, this._contentLength = a || this._contentLength, this._filename = ub(n), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new ia("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._headersCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: vA(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
class Iw {
  constructor(e, t, s) {
    this._stream = e, this._reader = null, this._loaded = 0;
    const i = e.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController(), this._headers = mA(this._stream.httpHeaders), this._headers.append("Range", `bytes=${t}-${s - 1}`);
    const n = i.url;
    fetch(n, gA(this._headers, this._withCredentials, this._abortController)).then((r) => {
      if (!pA(r.status))
        throw zg(r.status, n);
      this._readCapability.resolve(), this._reader = r.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._readCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: vA(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
const qg = 200, tm = 206;
function Lw(l) {
  const e = l.response;
  return typeof e != "string" ? e : jg(e).buffer;
}
class _w {
  constructor(e, t = {}) {
    this.url = e, this.isHttp = /^https?:/i.test(e), this.httpHeaders = this.isHttp && t.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = t.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  requestRange(e, t, s) {
    const i = {
      begin: e,
      end: t
    };
    for (const n in s)
      i[n] = s[n];
    return this.request(i);
  }
  requestFull(e) {
    return this.request(e);
  }
  request(e) {
    const t = new XMLHttpRequest(), s = this.currXhrId++, i = this.pendingRequests[s] = {
      xhr: t
    };
    t.open("GET", this.url), t.withCredentials = this.withCredentials;
    for (const n in this.httpHeaders) {
      const r = this.httpHeaders[n];
      r !== void 0 && t.setRequestHeader(n, r);
    }
    return this.isHttp && "begin" in e && "end" in e ? (t.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), i.expectedStatus = tm) : i.expectedStatus = qg, t.responseType = "arraybuffer", e.onError && (t.onerror = function(n) {
      e.onError(t.status);
    }), t.onreadystatechange = this.onStateChange.bind(this, s), t.onprogress = this.onProgress.bind(this, s), i.onHeadersReceived = e.onHeadersReceived, i.onDone = e.onDone, i.onError = e.onError, i.onProgress = e.onProgress, t.send(null), s;
  }
  onProgress(e, t) {
    var i;
    const s = this.pendingRequests[e];
    s && ((i = s.onProgress) == null || i.call(s, t));
  }
  onStateChange(e, t) {
    var h, c, d;
    const s = this.pendingRequests[e];
    if (!s)
      return;
    const i = s.xhr;
    if (i.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), i.readyState !== 4 || !(e in this.pendingRequests))
      return;
    if (delete this.pendingRequests[e], i.status === 0 && this.isHttp) {
      (h = s.onError) == null || h.call(s, i.status);
      return;
    }
    const n = i.status || qg;
    if (!(n === qg && s.expectedStatus === tm) && n !== s.expectedStatus) {
      (c = s.onError) == null || c.call(s, i.status);
      return;
    }
    const a = Lw(i);
    if (n === tm) {
      const u = i.getResponseHeader("Content-Range"), f = /bytes (\d+)-(\d+)\/(\d+)/.exec(u);
      s.onDone({
        begin: parseInt(f[1], 10),
        chunk: a
      });
    } else
      a ? s.onDone({
        begin: 0,
        chunk: a
      }) : (d = s.onError) == null || d.call(s, i.status);
  }
  getRequestXhr(e) {
    return this.pendingRequests[e].xhr;
  }
  isPendingRequest(e) {
    return e in this.pendingRequests;
  }
  abortRequest(e) {
    const t = this.pendingRequests[e].xhr;
    delete this.pendingRequests[e], t.abort();
  }
}
class Mw {
  constructor(e) {
    this._source = e, this._manager = new _w(e.url, {
      httpHeaders: e.httpHeaders,
      withCredentials: e.withCredentials
    }), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(e) {
    const t = this._rangeRequestReaders.indexOf(e);
    t >= 0 && this._rangeRequestReaders.splice(t, 1);
  }
  getFullReader() {
    return Ot(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new Ow(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    const s = new Dw(this._manager, e, t);
    return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class Ow {
  constructor(e, t) {
    this._manager = e;
    const s = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = t.url, this._fullRequestId = e.requestFull(s), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const e = this._fullRequestId, t = this._manager.getRequestXhr(e), s = (r) => t.getResponseHeader(r), {
      allowRangeRequests: i,
      suggestedLength: n
    } = db({
      getResponseHeader: s,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    i && (this._isRangeSupported = !0), this._contentLength = n || this._contentLength, this._filename = ub(s), this._isRangeSupported && this._manager.abortRequest(e), this._headersReceivedCapability.resolve();
  }
  _onDone(e) {
    if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e.chunk,
      done: !1
    }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const t of this._requests)
        t.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(e) {
    this._storedError = zg(e, this._url), this._headersReceivedCapability.reject(this._storedError);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(e) {
    var t;
    (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded,
      total: e.lengthComputable ? e.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersReceivedCapability.promise;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0, this._headersReceivedCapability.reject(e);
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class Dw {
  constructor(e, t, s) {
    this._manager = e;
    const i = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = e.url, this._requestId = e.requestRange(t, s, i), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _close() {
    var e;
    (e = this.onClosed) == null || e.call(this, this);
  }
  _onDone(e) {
    const t = e.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunk = t, this._done = !0;
    for (const s of this._requests)
      s.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(e) {
    this._storedError = zg(e, this._url);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(e) {
    var t;
    this.isStreamingSupported || (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const bA = /^file:\/\/\/[a-zA-Z]:\//;
function kw(l) {
  const e = Ps.get("url"), t = e.parse(l);
  return t.protocol === "file:" || t.host ? t : /^[a-z]:[/\\]/i.test(l) ? e.parse(`file:///${l}`) : (t.host || (t.protocol = "file:"), t);
}
class Fw {
  constructor(e) {
    this.source = e, this.url = kw(e.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && e.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return Ot(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new jw(this) : new Nw(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = this.isFsUrl ? new Hw(this, e, t) : new Bw(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class yA {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const t = e.source;
    this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new ia("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class AA {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const t = e.source;
    this._isStreamingSupported = !t.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
function of(l, e) {
  return {
    protocol: l.protocol,
    auth: l.auth,
    host: l.hostname,
    port: l.port,
    path: l.path,
    method: "GET",
    headers: e
  };
}
class Nw extends yA {
  constructor(e) {
    super(e);
    const t = (s) => {
      if (s.statusCode === 404) {
        const a = new sa(`Missing PDF "${this._url}".`);
        this._storedError = a, this._headersCapability.reject(a);
        return;
      }
      this._headersCapability.resolve(), this._setReadableStream(s);
      const i = (a) => this._readableStream.headers[a.toLowerCase()], {
        allowRangeRequests: n,
        suggestedLength: r
      } = db({
        getResponseHeader: i,
        isHttp: e.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = n, this._contentLength = r || this._contentLength, this._filename = ub(i);
    };
    if (this._request = null, this._url.protocol === "http:") {
      const s = Ps.get("http");
      this._request = s.request(of(this._url, e.httpHeaders), t);
    } else {
      const s = Ps.get("https");
      this._request = s.request(of(this._url, e.httpHeaders), t);
    }
    this._request.on("error", (s) => {
      this._storedError = s, this._headersCapability.reject(s);
    }), this._request.end();
  }
}
class Bw extends AA {
  constructor(e, t, s) {
    super(e), this._httpHeaders = {};
    for (const n in e.httpHeaders) {
      const r = e.httpHeaders[n];
      r !== void 0 && (this._httpHeaders[n] = r);
    }
    this._httpHeaders.Range = `bytes=${t}-${s - 1}`;
    const i = (n) => {
      if (n.statusCode === 404) {
        const r = new sa(`Missing PDF "${this._url}".`);
        this._storedError = r;
        return;
      }
      this._setReadableStream(n);
    };
    if (this._request = null, this._url.protocol === "http:") {
      const n = Ps.get("http");
      this._request = n.request(of(this._url, this._httpHeaders), i);
    } else {
      const n = Ps.get("https");
      this._request = n.request(of(this._url, this._httpHeaders), i);
    }
    this._request.on("error", (n) => {
      this._storedError = n;
    }), this._request.end();
  }
}
class jw extends yA {
  constructor(e) {
    super(e);
    let t = decodeURIComponent(this._url.path);
    bA.test(this._url.href) && (t = t.replace(/^\//, ""));
    const s = Ps.get("fs");
    s.promises.lstat(t).then((i) => {
      this._contentLength = i.size, this._setReadableStream(s.createReadStream(t)), this._headersCapability.resolve();
    }, (i) => {
      i.code === "ENOENT" && (i = new sa(`Missing PDF "${t}".`)), this._storedError = i, this._headersCapability.reject(i);
    });
  }
}
class Hw extends AA {
  constructor(e, t, s) {
    super(e);
    let i = decodeURIComponent(this._url.path);
    bA.test(this._url.href) && (i = i.replace(/^\//, ""));
    const n = Ps.get("fs");
    this._setReadableStream(n.createReadStream(i, {
      start: t,
      end: s - 1
    }));
  }
}
const $w = 1e5, le = 30, Vw = 0.8;
var xy, Fi, ce, Gh, Xh, Xn, Us, Kh, Yh, Kn, Ha, $a, Ni, Va, Qh, Ua, Yn, Zh, Jh, xt, Qn, Zn, Bi, za, Jf, EA, qf, wA, qh, Um, Wa, Tu, tp, SA, ep, xA;
let lf = (xt = class {
  constructor({
    textContentSource: e,
    container: t,
    viewport: s
  }) {
    p(this, Jf);
    p(this, qf);
    p(this, qh);
    p(this, Fi, Promise.withResolvers());
    p(this, ce, null);
    p(this, Gh, !1);
    p(this, Xh, !!((xy = globalThis.FontInspector) != null && xy.enabled));
    p(this, Xn, null);
    p(this, Us, null);
    p(this, Kh, 0);
    p(this, Yh, 0);
    p(this, Kn, null);
    p(this, Ha, null);
    p(this, $a, 0);
    p(this, Ni, 0);
    p(this, Va, /* @__PURE__ */ Object.create(null));
    p(this, Qh, []);
    p(this, Ua, null);
    p(this, Yn, []);
    p(this, Zh, /* @__PURE__ */ new WeakMap());
    p(this, Jh, null);
    var h;
    if (e instanceof ReadableStream)
      b(this, Ua, e);
    else if (typeof e == "object")
      b(this, Ua, new ReadableStream({
        start(c) {
          c.enqueue(e), c.close();
        }
      }));
    else
      throw new Error('No "textContentSource" parameter specified.');
    b(this, ce, b(this, Ha, t)), b(this, Ni, s.scale * (globalThis.devicePixelRatio || 1)), b(this, $a, s.rotation), b(this, Us, {
      prevFontSize: null,
      prevFontFamily: null,
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth: i,
      pageHeight: n,
      pageX: r,
      pageY: a
    } = s.rawDims;
    b(this, Jh, [1, 0, 0, -1, -r, a + n]), b(this, Yh, i), b(this, Kh, n), v(h = xt, tp, SA).call(h), ta(t, s), o(this, Fi).promise.catch(() => {
    }).then(() => {
      o(xt, za).delete(this), b(this, Us, null), b(this, Va, null);
    });
  }
  render() {
    const e = () => {
      o(this, Kn).read().then(({
        value: t,
        done: s
      }) => {
        if (s) {
          o(this, Fi).resolve();
          return;
        }
        o(this, Xn) ?? b(this, Xn, t.lang), Object.assign(o(this, Va), t.styles), v(this, Jf, EA).call(this, t.items), e();
      }, o(this, Fi).reject);
    };
    return b(this, Kn, o(this, Ua).getReader()), o(xt, za).add(this), e(), o(this, Fi).promise;
  }
  update({
    viewport: e,
    onBefore: t = null
  }) {
    var n;
    const s = e.scale * (globalThis.devicePixelRatio || 1), i = e.rotation;
    if (i !== o(this, $a) && (t == null || t(), b(this, $a, i), ta(o(this, Ha), {
      rotation: i
    })), s !== o(this, Ni)) {
      t == null || t(), b(this, Ni, s);
      const r = {
        prevFontSize: null,
        prevFontFamily: null,
        div: null,
        properties: null,
        ctx: v(n = xt, Wa, Tu).call(n, o(this, Xn))
      };
      for (const a of o(this, Yn))
        r.properties = o(this, Zh).get(a), r.div = a, v(this, qh, Um).call(this, r);
    }
  }
  cancel() {
    var t;
    const e = new ia("TextLayer task cancelled.");
    (t = o(this, Kn)) == null || t.cancel(e).catch(() => {
    }), b(this, Kn, null), o(this, Fi).reject(e);
  }
  get textDivs() {
    return o(this, Yn);
  }
  get textContentItemsStr() {
    return o(this, Qh);
  }
  static cleanup() {
    if (!(o(this, za).size > 0)) {
      o(this, Qn).clear();
      for (const {
        canvas: e
      } of o(this, Zn).values())
        e.remove();
      o(this, Zn).clear();
    }
  }
}, Fi = new WeakMap(), ce = new WeakMap(), Gh = new WeakMap(), Xh = new WeakMap(), Xn = new WeakMap(), Us = new WeakMap(), Kh = new WeakMap(), Yh = new WeakMap(), Kn = new WeakMap(), Ha = new WeakMap(), $a = new WeakMap(), Ni = new WeakMap(), Va = new WeakMap(), Qh = new WeakMap(), Ua = new WeakMap(), Yn = new WeakMap(), Zh = new WeakMap(), Jh = new WeakMap(), Qn = new WeakMap(), Zn = new WeakMap(), Bi = new WeakMap(), za = new WeakMap(), Jf = new WeakSet(), EA = function(e) {
  var i, n;
  if (o(this, Gh))
    return;
  (n = o(this, Us)).ctx ?? (n.ctx = v(i = xt, Wa, Tu).call(i, o(this, Xn)));
  const t = o(this, Yn), s = o(this, Qh);
  for (const r of e) {
    if (t.length > $w) {
      Q("Ignoring additional textDivs for performance reasons."), b(this, Gh, !0);
      return;
    }
    if (r.str === void 0) {
      if (r.type === "beginMarkedContentProps" || r.type === "beginMarkedContent") {
        const a = o(this, ce);
        b(this, ce, document.createElement("span")), o(this, ce).classList.add("markedContent"), r.id !== null && o(this, ce).setAttribute("id", `${r.id}`), a.append(o(this, ce));
      } else
        r.type === "endMarkedContent" && b(this, ce, o(this, ce).parentNode);
      continue;
    }
    s.push(r.str), v(this, qf, wA).call(this, r);
  }
}, qf = new WeakSet(), wA = function(e) {
  var A;
  const t = document.createElement("span"), s = {
    angle: 0,
    canvasWidth: 0,
    hasText: e.str !== "",
    hasEOL: e.hasEOL,
    fontSize: 0
  };
  o(this, Yn).push(t);
  const i = U.transform(o(this, Jh), e.transform);
  let n = Math.atan2(i[1], i[0]);
  const r = o(this, Va)[e.fontName];
  r.vertical && (n += Math.PI / 2);
  const a = o(this, Xh) && r.fontSubstitution || r.fontFamily, h = Math.hypot(i[2], i[3]), c = h * v(A = xt, ep, xA).call(A, a, o(this, Xn));
  let d, u;
  n === 0 ? (d = i[4], u = i[5] - c) : (d = i[4] + c * Math.sin(n), u = i[5] - c * Math.cos(n));
  const f = "calc(var(--scale-factor)*", m = t.style;
  o(this, ce) === o(this, Ha) ? (m.left = `${(100 * d / o(this, Yh)).toFixed(2)}%`, m.top = `${(100 * u / o(this, Kh)).toFixed(2)}%`) : (m.left = `${f}${d.toFixed(2)}px)`, m.top = `${f}${u.toFixed(2)}px)`), m.fontSize = `${f}${(o(xt, Bi) * h).toFixed(2)}px)`, m.fontFamily = a, s.fontSize = h, t.setAttribute("role", "presentation"), t.textContent = e.str, t.dir = e.dir, o(this, Xh) && (t.dataset.fontName = r.fontSubstitutionLoadedName || e.fontName), n !== 0 && (s.angle = n * (180 / Math.PI));
  let g = !1;
  if (e.str.length > 1)
    g = !0;
  else if (e.str !== " " && e.transform[0] !== e.transform[3]) {
    const E = Math.abs(e.transform[0]), y = Math.abs(e.transform[3]);
    E !== y && Math.max(E, y) / Math.min(E, y) > 1.5 && (g = !0);
  }
  if (g && (s.canvasWidth = r.vertical ? e.height : e.width), o(this, Zh).set(t, s), o(this, Us).div = t, o(this, Us).properties = s, v(this, qh, Um).call(this, o(this, Us)), s.hasText && o(this, ce).append(t), s.hasEOL) {
    const E = document.createElement("br");
    E.setAttribute("role", "presentation"), o(this, ce).append(E);
  }
}, qh = new WeakSet(), Um = function(e) {
  const {
    div: t,
    properties: s,
    ctx: i,
    prevFontSize: n,
    prevFontFamily: r
  } = e, {
    style: a
  } = t;
  let h = "";
  if (o(xt, Bi) > 1 && (h = `scale(${1 / o(xt, Bi)})`), s.canvasWidth !== 0 && s.hasText) {
    const {
      fontFamily: c
    } = a, {
      canvasWidth: d,
      fontSize: u
    } = s;
    (n !== u || r !== c) && (i.font = `${u * o(this, Ni)}px ${c}`, e.prevFontSize = u, e.prevFontFamily = c);
    const {
      width: f
    } = i.measureText(t.textContent);
    f > 0 && (h = `scaleX(${d * o(this, Ni) / f}) ${h}`);
  }
  s.angle !== 0 && (h = `rotate(${s.angle}deg) ${h}`), h.length > 0 && (a.transform = h);
}, Wa = new WeakSet(), Tu = function(e = null) {
  let t = o(this, Zn).get(e || (e = ""));
  if (!t) {
    const s = document.createElement("canvas");
    s.className = "hiddenCanvasElement", s.lang = e, document.body.append(s), t = s.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    }), o(this, Zn).set(e, t);
  }
  return t;
}, tp = new WeakSet(), SA = function() {
  if (o(this, Bi) !== null)
    return;
  const e = document.createElement("div");
  e.style.opacity = 0, e.style.lineHeight = 1, e.style.fontSize = "1px", e.textContent = "X", document.body.append(e), b(this, Bi, e.getBoundingClientRect().height), e.remove();
}, ep = new WeakSet(), xA = function(e, t) {
  const s = o(this, Qn).get(e);
  if (s)
    return s;
  const i = v(this, Wa, Tu).call(this, t), n = i.font;
  i.canvas.width = i.canvas.height = le, i.font = `${le}px ${e}`;
  const r = i.measureText("");
  let a = r.fontBoundingBoxAscent, h = Math.abs(r.fontBoundingBoxDescent);
  if (a) {
    const u = a / (a + h);
    return o(this, Qn).set(e, u), i.canvas.width = i.canvas.height = 0, i.font = n, u;
  }
  i.strokeStyle = "red", i.clearRect(0, 0, le, le), i.strokeText("g", 0, 0);
  let c = i.getImageData(0, 0, le, le).data;
  h = 0;
  for (let u = c.length - 1 - 3; u >= 0; u -= 4)
    if (c[u] > 0) {
      h = Math.ceil(u / 4 / le);
      break;
    }
  i.clearRect(0, 0, le, le), i.strokeText("A", 0, le), c = i.getImageData(0, 0, le, le).data, a = 0;
  for (let u = 0, f = c.length; u < f; u += 4)
    if (c[u] > 0) {
      a = le - Math.floor(u / 4 / le);
      break;
    }
  i.canvas.width = i.canvas.height = 0, i.font = n;
  const d = a ? a / (a + h) : Vw;
  return o(this, Qn).set(e, d), d;
}, p(xt, Wa), p(xt, tp), p(xt, ep), p(xt, Qn, /* @__PURE__ */ new Map()), p(xt, Zn, /* @__PURE__ */ new Map()), p(xt, Bi, null), p(xt, za, /* @__PURE__ */ new Set()), xt);
function Uw() {
  Fy("`renderTextLayer`, please use `TextLayer` instead.");
  const {
    textContentSource: l,
    container: e,
    viewport: t,
    ...s
  } = arguments[0], i = Object.keys(s);
  i.length > 0 && Q("Ignoring `renderTextLayer` parameters: " + i.join(", "));
  const n = new lf({
    textContentSource: l,
    container: e,
    viewport: t
  }), {
    textDivs: r,
    textContentItemsStr: a
  } = n;
  return {
    promise: n.render(),
    textDivs: r,
    textContentItemsStr: a
  };
}
function zw() {
  Fy("`updateTextLayer`, please use `TextLayer` instead.");
}
class Ul {
  static textContent(e) {
    const t = [], s = {
      items: t,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(n) {
      var h;
      if (!n)
        return;
      let r = null;
      const a = n.name;
      if (a === "#text")
        r = n.value;
      else if (Ul.shouldBuildText(a))
        (h = n == null ? void 0 : n.attributes) != null && h.textContent ? r = n.attributes.textContent : n.value && (r = n.value);
      else
        return;
      if (r !== null && t.push({
        str: r
      }), !!n.children)
        for (const c of n.children)
          i(c);
    }
    return i(e), s;
  }
  static shouldBuildText(e) {
    return !(e === "textarea" || e === "input" || e === "option" || e === "select");
  }
}
const Ww = 65536, Gw = 100, Xw = 5e3, Kw = Jt ? rw : G0, Yw = Jt ? aw : Dy, Qw = Jt ? nw : W0, Zw = Jt ? ow : ky;
function Jw(l = {}) {
  typeof l == "string" || l instanceof URL ? l = {
    url: l
  } : (l instanceof ArrayBuffer || ArrayBuffer.isView(l)) && (l = {
    data: l
  });
  const e = new zm(), {
    docId: t
  } = e, s = l.url ? qw(l.url) : null, i = l.data ? tS(l.data) : null, n = l.httpHeaders || null, r = l.withCredentials === !0, a = l.password ?? null, h = l.range instanceof PA ? l.range : null, c = Number.isInteger(l.rangeChunkSize) && l.rangeChunkSize > 0 ? l.rangeChunkSize : Ww;
  let d = l.worker instanceof Ru ? l.worker : null;
  const u = l.verbosity, f = typeof l.docBaseUrl == "string" && !ob(l.docBaseUrl) ? l.docBaseUrl : null, m = typeof l.cMapUrl == "string" ? l.cMapUrl : null, g = l.cMapPacked !== !1, A = l.CMapReaderFactory || Yw, E = typeof l.standardFontDataUrl == "string" ? l.standardFontDataUrl : null, y = l.StandardFontDataFactory || Zw, w = l.stopAtErrors !== !0, S = Number.isInteger(l.maxImageSize) && l.maxImageSize > -1 ? l.maxImageSize : -1, C = l.isEvalSupported !== !1, P = typeof l.isOffscreenCanvasSupported == "boolean" ? l.isOffscreenCanvasSupported : !Jt, x = Number.isInteger(l.canvasMaxAreaInBytes) ? l.canvasMaxAreaInBytes : -1, R = typeof l.disableFontFace == "boolean" ? l.disableFontFace : Jt, M = l.fontExtraProperties === !0, T = l.enableXfa === !0, I = l.ownerDocument || globalThis.document, _ = l.disableRange === !0, k = l.disableStream === !0, F = l.disableAutoFetch === !0, V = l.pdfBug === !0, $ = l.enableHWA === !0, L = h ? h.length : l.length ?? NaN, B = typeof l.useSystemFonts == "boolean" ? l.useSystemFonts : !Jt && !R, j = typeof l.useWorkerFetch == "boolean" ? l.useWorkerFetch : A === Dy && y === ky && m && E && yl(m, document.baseURI) && yl(E, document.baseURI), ot = l.canvasFactory || new Kw({
    ownerDocument: I,
    enableHWA: $
  }), mt = l.filterFactory || new Qw({
    docId: t,
    ownerDocument: I
  }), ae = null;
  D0(u);
  const lt = {
    canvasFactory: ot,
    filterFactory: mt
  };
  if (j || (lt.cMapReaderFactory = new A({
    baseUrl: m,
    isCompressed: g
  }), lt.standardFontDataFactory = new y({
    baseUrl: E
  })), !d) {
    const Pe = {
      verbosity: u,
      port: qr.workerPort
    };
    d = Pe.port ? Ru.fromPort(Pe) : new Ru(Pe), e._worker = d;
  }
  const dt = {
    docId: t,
    apiVersion: "4.4.168",
    data: i,
    password: a,
    disableAutoFetch: F,
    rangeChunkSize: c,
    length: L,
    docBaseUrl: f,
    enableXfa: T,
    evaluatorOptions: {
      maxImageSize: S,
      disableFontFace: R,
      ignoreErrors: w,
      isEvalSupported: C,
      isOffscreenCanvasSupported: P,
      canvasMaxAreaInBytes: x,
      fontExtraProperties: M,
      useSystemFonts: B,
      cMapUrl: j ? m : null,
      standardFontDataUrl: j ? E : null
    }
  }, bi = {
    disableFontFace: R,
    fontExtraProperties: M,
    ownerDocument: I,
    pdfBug: V,
    styleElement: ae,
    loadingParams: {
      disableAutoFetch: F,
      enableXfa: T
    }
  };
  return d.promise.then(function() {
    if (e.destroyed)
      throw new Error("Loading aborted");
    if (d.destroyed)
      throw new Error("Worker was destroyed");
    const Pe = d.messageHandler.sendWithPromise("GetDocRequest", dt, i ? [i.buffer] : null);
    let H;
    if (h)
      H = new xw(h, {
        disableRange: _,
        disableStream: k
      });
    else if (!i) {
      if (!s)
        throw new Error("getDocument - no `url` parameter provided.");
      H = ((N) => Jt ? function() {
        return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype;
      }() && yl(N.url) ? new Nb(N) : new Fw(N) : yl(N.url) ? new Nb(N) : new Mw(N))({
        url: s,
        length: L,
        httpHeaders: n,
        withCredentials: r,
        rangeChunkSize: c,
        disableRange: _,
        disableStream: k
      });
    }
    return Pe.then((O) => {
      if (e.destroyed)
        throw new Error("Loading aborted");
      if (d.destroyed)
        throw new Error("Worker was destroyed");
      const N = new wl(t, O, d.port), Y = new nS(N, e, H, bi, lt);
      e._transport = Y, N.send("Ready", null);
    });
  }).catch(e._capability.reject), e;
}
function qw(l) {
  if (l instanceof URL)
    return l.href;
  try {
    return new URL(l, window.location).href;
  } catch {
    if (Jt && typeof l == "string")
      return l;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function tS(l) {
  if (Jt && typeof Buffer < "u" && l instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (l instanceof Uint8Array && l.byteLength === l.buffer.byteLength)
    return l;
  if (typeof l == "string")
    return jg(l);
  if (l instanceof ArrayBuffer || ArrayBuffer.isView(l) || typeof l == "object" && !isNaN(l == null ? void 0 : l.length))
    return new Uint8Array(l);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function Bb(l) {
  return typeof l == "object" && Number.isInteger(l == null ? void 0 : l.num) && l.num >= 0 && Number.isInteger(l == null ? void 0 : l.gen) && l.gen >= 0;
}
var sp;
const ip = class ip {
  constructor() {
    this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${oe(ip, sp)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var e, t, s;
    this.destroyed = !0;
    try {
      (e = this._worker) != null && e.port && (this._worker._pendingDestroy = !0), await ((t = this._transport) == null ? void 0 : t.destroy());
    } catch (i) {
      throw (s = this._worker) != null && s.port && delete this._worker._pendingDestroy, i;
    }
    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
  }
};
sp = new WeakMap(), p(ip, sp, 0);
let zm = ip, PA = class {
  constructor(e, t, s = !1, i = null) {
    this.length = e, this.initialData = t, this.progressiveDone = s, this.contentDispositionFilename = i, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(e) {
    this._rangeListeners.push(e);
  }
  addProgressListener(e) {
    this._progressListeners.push(e);
  }
  addProgressiveReadListener(e) {
    this._progressiveReadListeners.push(e);
  }
  addProgressiveDoneListener(e) {
    this._progressiveDoneListeners.push(e);
  }
  onDataRange(e, t) {
    for (const s of this._rangeListeners)
      s(e, t);
  }
  onDataProgress(e, t) {
    this._readyCapability.promise.then(() => {
      for (const s of this._progressListeners)
        s(e, t);
    });
  }
  onDataProgressiveRead(e) {
    this._readyCapability.promise.then(() => {
      for (const t of this._progressiveReadListeners)
        t(e);
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const e of this._progressiveDoneListeners)
        e();
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(e, t) {
    at("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
class eS {
  constructor(e, t) {
    this._pdfInfo = e, this._transport = t;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return et(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(e) {
    return this._transport.getPage(e);
  }
  getPageIndex(e) {
    return this._transport.getPageIndex(e);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(e) {
    return this._transport.getDestination(e);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getOptionalContentConfig(t);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(e = !1) {
    return this._transport.startCleanup(e || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(e) {
    return this._transport.cachedPageNumber(e);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
var ji, zs, Hi, ha, Ga, Cu;
class sS {
  constructor(e, t, s, i = !1) {
    p(this, Hi);
    p(this, Ga);
    p(this, ji, null);
    p(this, zs, !1);
    this._pageIndex = e, this._pageInfo = t, this._transport = s, this._stats = i ? new xb() : null, this._pdfBug = i, this.commonObjs = s.commonObjs, this.objs = new TA(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: e,
    rotation: t = this.rotate,
    offsetX: s = 0,
    offsetY: i = 0,
    dontFlip: n = !1
  } = {}) {
    return new su({
      viewBox: this.view,
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: n
    });
  }
  getAnnotations({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getAnnotations(this._pageIndex, t);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return et(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var e;
    return ((e = this._transport._htmlForXfa) == null ? void 0 : e.children[this._pageIndex]) || null;
  }
  render({
    canvasContext: e,
    viewport: t,
    intent: s = "display",
    annotationMode: i = Ti.ENABLE,
    transform: n = null,
    background: r = null,
    optionalContentConfigPromise: a = null,
    annotationCanvasMap: h = null,
    pageColors: c = null,
    printAnnotationStorage: d = null
  }) {
    var S, C;
    (S = this._stats) == null || S.time("Overall");
    const u = this._transport.getRenderingIntent(s, i, d), {
      renderingIntent: f,
      cacheKey: m
    } = u;
    b(this, zs, !1), v(this, Ga, Cu).call(this), a || (a = this._transport.getOptionalContentConfig(f));
    let g = this._intentStates.get(m);
    g || (g = /* @__PURE__ */ Object.create(null), this._intentStates.set(m, g)), g.streamReaderCancelTimeout && (clearTimeout(g.streamReaderCancelTimeout), g.streamReaderCancelTimeout = null);
    const A = !!(f & ke.PRINT);
    g.displayReadyCapability || (g.displayReadyCapability = Promise.withResolvers(), g.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (C = this._stats) == null || C.time("Page Request"), this._pumpOperatorList(u));
    const E = (P) => {
      var x;
      g.renderTasks.delete(y), (this._maybeCleanupAfterRender || A) && b(this, zs, !0), v(this, Hi, ha).call(this, !A), P ? (y.capability.reject(P), this._abortOperatorList({
        intentState: g,
        reason: P instanceof Error ? P : new Error(P)
      })) : y.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (x = globalThis.Stats) != null && x.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, y = new Gm({
      callback: E,
      params: {
        canvasContext: e,
        viewport: t,
        transform: n,
        background: r
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: h,
      operatorList: g.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !A,
      pdfBug: this._pdfBug,
      pageColors: c
    });
    (g.renderTasks || (g.renderTasks = /* @__PURE__ */ new Set())).add(y);
    const w = y.task;
    return Promise.all([g.displayReadyCapability.promise, a]).then(([P, x]) => {
      var R;
      if (this.destroyed) {
        E();
        return;
      }
      if ((R = this._stats) == null || R.time("Rendering"), !(x.renderingIntent & f))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      y.initializeGraphics({
        transparency: P,
        optionalContentConfig: x
      }), y.operatorListChanged();
    }).catch(E), w;
  }
  getOperatorList({
    intent: e = "display",
    annotationMode: t = Ti.ENABLE,
    printAnnotationStorage: s = null
  } = {}) {
    var h;
    function i() {
      r.operatorList.lastChunk && (r.opListReadCapability.resolve(r.operatorList), r.renderTasks.delete(a));
    }
    const n = this._transport.getRenderingIntent(e, t, s, !0);
    let r = this._intentStates.get(n.cacheKey);
    r || (r = /* @__PURE__ */ Object.create(null), this._intentStates.set(n.cacheKey, r));
    let a;
    return r.opListReadCapability || (a = /* @__PURE__ */ Object.create(null), a.operatorListChanged = i, r.opListReadCapability = Promise.withResolvers(), (r.renderTasks || (r.renderTasks = /* @__PURE__ */ new Set())).add(a), r.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (h = this._stats) == null || h.time("Page Request"), this._pumpOperatorList(n)), r.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: e = !1,
    disableNormalization: t = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: e === !0,
      disableNormalization: t === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(e = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((s) => Ul.textContent(s));
    const t = this.streamTextContent(e);
    return new Promise(function(s, i) {
      function n() {
        r.read().then(function({
          value: h,
          done: c
        }) {
          if (c) {
            s(a);
            return;
          }
          a.lang ?? (a.lang = h.lang), Object.assign(a.styles, h.styles), a.items.push(...h.items), n();
        }, i);
      }
      const r = t.getReader(), a = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      n();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const e = [];
    for (const t of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: t,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !t.opListReadCapability)
        for (const s of t.renderTasks)
          e.push(s.completed), s.cancel();
    return this.objs.clear(), b(this, zs, !1), v(this, Ga, Cu).call(this), Promise.all(e);
  }
  cleanup(e = !1) {
    b(this, zs, !0);
    const t = v(this, Hi, ha).call(this, !1);
    return e && t && this._stats && (this._stats = new xb()), t;
  }
  _startRenderPage(e, t) {
    var i, n;
    const s = this._intentStates.get(t);
    s && ((i = this._stats) == null || i.timeEnd("Page Request"), (n = s.displayReadyCapability) == null || n.resolve(e));
  }
  _renderPageChunk(e, t) {
    for (let s = 0, i = e.length; s < i; s++)
      t.operatorList.fnArray.push(e.fnArray[s]), t.operatorList.argsArray.push(e.argsArray[s]);
    t.operatorList.lastChunk = e.lastChunk, t.operatorList.separateAnnots = e.separateAnnots;
    for (const s of t.renderTasks)
      s.operatorListChanged();
    e.lastChunk && v(this, Hi, ha).call(this, !0);
  }
  _pumpOperatorList({
    renderingIntent: e,
    cacheKey: t,
    annotationStorageSerializable: s
  }) {
    const {
      map: i,
      transfer: n
    } = s, a = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: e,
      cacheKey: t,
      annotationStorage: i
    }, n).getReader(), h = this._intentStates.get(t);
    h.streamReader = a;
    const c = () => {
      a.read().then(({
        value: d,
        done: u
      }) => {
        if (u) {
          h.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(d, h), c());
      }, (d) => {
        if (h.streamReader = null, !this._transport.destroyed) {
          if (h.operatorList) {
            h.operatorList.lastChunk = !0;
            for (const u of h.renderTasks)
              u.operatorListChanged();
            v(this, Hi, ha).call(this, !0);
          }
          if (h.displayReadyCapability)
            h.displayReadyCapability.reject(d);
          else if (h.opListReadCapability)
            h.opListReadCapability.reject(d);
          else
            throw d;
        }
      });
    };
    c();
  }
  _abortOperatorList({
    intentState: e,
    reason: t,
    force: s = !1
  }) {
    if (e.streamReader) {
      if (e.streamReaderCancelTimeout && (clearTimeout(e.streamReaderCancelTimeout), e.streamReaderCancelTimeout = null), !s) {
        if (e.renderTasks.size > 0)
          return;
        if (t instanceof ab) {
          let i = Gw;
          t.extraDelay > 0 && t.extraDelay < 1e3 && (i += t.extraDelay), e.streamReaderCancelTimeout = setTimeout(() => {
            e.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: e,
              reason: t,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (e.streamReader.cancel(new ia(t.message)).catch(() => {
      }), e.streamReader = null, !this._transport.destroyed) {
        for (const [i, n] of this._intentStates)
          if (n === e) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
ji = new WeakMap(), zs = new WeakMap(), Hi = new WeakSet(), ha = function(e = !1) {
  if (v(this, Ga, Cu).call(this), !o(this, zs) || this.destroyed)
    return !1;
  if (e)
    return b(this, ji, setTimeout(() => {
      b(this, ji, null), v(this, Hi, ha).call(this, !1);
    }, Xw)), !1;
  for (const {
    renderTasks: t,
    operatorList: s
  } of this._intentStates.values())
    if (t.size > 0 || !s.lastChunk)
      return !1;
  return this._intentStates.clear(), this.objs.clear(), b(this, zs, !1), !0;
}, Ga = new WeakSet(), Cu = function() {
  o(this, ji) && (clearTimeout(o(this, ji)), b(this, ji, null));
};
var Jn, np;
class iS {
  constructor() {
    p(this, Jn, /* @__PURE__ */ new Set());
    p(this, np, Promise.resolve());
  }
  postMessage(e, t) {
    const s = {
      data: structuredClone(e, t ? {
        transfer: t
      } : null)
    };
    o(this, np).then(() => {
      for (const i of o(this, Jn))
        i.call(this, s);
    });
  }
  addEventListener(e, t) {
    o(this, Jn).add(t);
  }
  removeEventListener(e, t) {
    o(this, Jn).delete(t);
  }
  terminate() {
    o(this, Jn).clear();
  }
}
Jn = new WeakMap(), np = new WeakMap();
const Os = {
  isWorkerDisabled: !1,
  fakeWorkerId: 0
};
Jt && (Os.isWorkerDisabled = !0, qr.workerSrc || (qr.workerSrc = "./pdf.worker.mjs")), Os.isSameOrigin = function(l, e) {
  let t;
  try {
    if (t = new URL(l), !t.origin || t.origin === "null")
      return !1;
  } catch {
    return !1;
  }
  const s = new URL(e, t);
  return t.origin === s.origin;
}, Os.createCDNWrapper = function(l) {
  const e = `await import("${l}");`;
  return URL.createObjectURL(new Blob([e], {
    type: "text/javascript"
  }));
};
var ne, qn, Xa, Iu, Ka, Lu;
let Ru = (ne = class {
  constructor({
    name: e = null,
    port: t = null,
    verbosity: s = k0()
  } = {}) {
    p(this, Xa);
    var i;
    if (this.name = e, this.destroyed = !1, this.verbosity = s, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, t) {
      if ((i = o(ne, qn)) != null && i.has(t))
        throw new Error("Cannot use more than one PDFWorker per port.");
      (o(ne, qn) || b(ne, qn, /* @__PURE__ */ new WeakMap())).set(t, this), this._initializeFromPort(t);
      return;
    }
    this._initialize();
  }
  get promise() {
    return Jt ? Promise.all([Ps.promise, this._readyCapability.promise]) : this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(e) {
    this._port = e, this._messageHandler = new wl("main", "worker", e), this._messageHandler.on("ready", function() {
    }), v(this, Xa, Iu).call(this);
  }
  _initialize() {
    if (Os.isWorkerDisabled || o(ne, Ka, Lu)) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc: e
    } = ne;
    try {
      Os.isSameOrigin(window.location.href, e) || (e = Os.createCDNWrapper(new URL(e, window.location).href));
      const t = new Worker(e, {
        type: "module"
      }), s = new wl("main", "worker", t), i = () => {
        n.abort(), s.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
      }, n = new AbortController();
      t.addEventListener("error", () => {
        this._webWorker || i();
      }, {
        signal: n.signal
      }), s.on("test", (a) => {
        if (n.abort(), this.destroyed || !a) {
          i();
          return;
        }
        this._messageHandler = s, this._port = t, this._webWorker = t, v(this, Xa, Iu).call(this);
      }), s.on("ready", (a) => {
        if (n.abort(), this.destroyed) {
          i();
          return;
        }
        try {
          r();
        } catch {
          this._setupFakeWorker();
        }
      });
      const r = () => {
        const a = new Uint8Array();
        s.send("test", a, [a.buffer]);
      };
      r();
      return;
    } catch {
      Ng("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    Os.isWorkerDisabled || (Q("Setting up fake worker."), Os.isWorkerDisabled = !0), ne._setupFakeWorkerGlobal.then((e) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const t = new iS();
      this._port = t;
      const s = `fake${Os.fakeWorkerId++}`, i = new wl(s + "_worker", s, t);
      e.setup(i, t), this._messageHandler = new wl(s, s + "_worker", t), v(this, Xa, Iu).call(this);
    }).catch((e) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e.message}".`));
    });
  }
  destroy() {
    var e;
    this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (e = o(ne, qn)) == null || e.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
  }
  static fromPort(e) {
    var s;
    if (!(e != null && e.port))
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    const t = (s = o(this, qn)) == null ? void 0 : s.get(e.port);
    if (t) {
      if (t._pendingDestroy)
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return t;
    }
    return new ne(e);
  }
  static get workerSrc() {
    if (qr.workerSrc)
      return qr.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return et(this, "_setupFakeWorkerGlobal", (async () => o(this, Ka, Lu) ? o(this, Ka, Lu) : (await import(
      /*webpackIgnore: true*/
      this.workerSrc
    )).WorkerMessageHandler)());
  }
}, qn = new WeakMap(), Xa = new WeakSet(), Iu = function() {
  this._readyCapability.resolve(), this._messageHandler.send("configure", {
    verbosity: this.verbosity
  });
}, Ka = new WeakSet(), Lu = function() {
  var e;
  try {
    return ((e = globalThis.pdfjsWorker) == null ? void 0 : e.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
}, p(ne, Ka), p(ne, qn, void 0), ne);
var Ws, hs, Ya, Qa, cs, tr, Sl;
class nS {
  constructor(e, t, s, i, n) {
    p(this, tr);
    p(this, Ws, /* @__PURE__ */ new Map());
    p(this, hs, /* @__PURE__ */ new Map());
    p(this, Ya, /* @__PURE__ */ new Map());
    p(this, Qa, /* @__PURE__ */ new Map());
    p(this, cs, null);
    this.messageHandler = e, this.loadingTask = t, this.commonObjs = new TA(), this.fontLoader = new sw({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = n.canvasFactory, this.filterFactory = n.filterFactory, this.cMapReaderFactory = n.cMapReaderFactory, this.standardFontDataFactory = n.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
  }
  get annotationStorage() {
    return et(this, "annotationStorage", new cb());
  }
  getRenderingIntent(e, t = Ti.ENABLE, s = null, i = !1) {
    let n = ke.DISPLAY, r = Fm;
    switch (e) {
      case "any":
        n = ke.ANY;
        break;
      case "display":
        break;
      case "print":
        n = ke.PRINT;
        break;
      default:
        Q(`getRenderingIntent - invalid intent: ${e}`);
    }
    switch (t) {
      case Ti.DISABLE:
        n += ke.ANNOTATIONS_DISABLE;
        break;
      case Ti.ENABLE:
        break;
      case Ti.ENABLE_FORMS:
        n += ke.ANNOTATIONS_FORMS;
        break;
      case Ti.ENABLE_STORAGE:
        n += ke.ANNOTATIONS_STORAGE, r = (n & ke.PRINT && s instanceof cA ? s : this.annotationStorage).serializable;
        break;
      default:
        Q(`getRenderingIntent - invalid annotationMode: ${t}`);
    }
    return i && (n += ke.OPLIST), {
      renderingIntent: n,
      cacheKey: `${n}_${r.hash}`,
      annotationStorageSerializable: r
    };
  }
  destroy() {
    var s;
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (s = o(this, cs)) == null || s.reject(new Error("Worker was destroyed during onPassword callback"));
    const e = [];
    for (const i of o(this, hs).values())
      e.push(i._destroy());
    o(this, hs).clear(), o(this, Ya).clear(), o(this, Qa).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const t = this.messageHandler.sendWithPromise("Terminate", null);
    return e.push(t), Promise.all(e).then(() => {
      var i;
      this.commonObjs.clear(), this.fontLoader.clear(), o(this, Ws).clear(), this.filterFactory.destroy(), lf.cleanup(), (i = this._networkStream) == null || i.cancelAllRequests(new ia("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: e,
      loadingTask: t
    } = this;
    e.on("GetReader", (s, i) => {
      Ot(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (n) => {
        this._lastProgress = {
          loaded: n.loaded,
          total: n.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: n,
          done: r
        }) {
          if (r) {
            i.close();
            return;
          }
          Ot(n instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(n), 1, [n]);
        }).catch((n) => {
          i.error(n);
        });
      }, i.onCancel = (n) => {
        this._fullReader.cancel(n), i.ready.catch((r) => {
          if (!this.destroyed)
            throw r;
        });
      };
    }), e.on("ReaderHeadersReady", (s) => {
      const i = Promise.withResolvers(), n = this._fullReader;
      return n.headersReady.then(() => {
        var r;
        (!n.isStreamingSupported || !n.isRangeSupported) && (this._lastProgress && ((r = t.onProgress) == null || r.call(t, this._lastProgress)), n.onProgress = (a) => {
          var h;
          (h = t.onProgress) == null || h.call(t, {
            loaded: a.loaded,
            total: a.total
          });
        }), i.resolve({
          isStreamingSupported: n.isStreamingSupported,
          isRangeSupported: n.isRangeSupported,
          contentLength: n.contentLength
        });
      }, i.reject), i.promise;
    }), e.on("GetRangeReader", (s, i) => {
      Ot(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const n = this._networkStream.getRangeReader(s.begin, s.end);
      if (!n) {
        i.close();
        return;
      }
      i.onPull = () => {
        n.read().then(function({
          value: r,
          done: a
        }) {
          if (a) {
            i.close();
            return;
          }
          Ot(r instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(r), 1, [r]);
        }).catch((r) => {
          i.error(r);
        });
      }, i.onCancel = (r) => {
        n.cancel(r), i.ready.catch((a) => {
          if (!this.destroyed)
            throw a;
        });
      };
    }), e.on("GetDoc", ({
      pdfInfo: s
    }) => {
      this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, t._capability.resolve(new eS(s, this));
    }), e.on("DocException", function(s) {
      let i;
      switch (s.name) {
        case "PasswordException":
          i = new fm(s.message, s.code);
          break;
        case "InvalidPDFException":
          i = new Ly(s.message);
          break;
        case "MissingPDFException":
          i = new sa(s.message);
          break;
        case "UnexpectedResponseException":
          i = new Bg(s.message, s.status);
          break;
        case "UnknownErrorException":
          i = new pm(s.message, s.details);
          break;
        default:
          at("DocException - expected a valid Error.");
      }
      t._capability.reject(i);
    }), e.on("PasswordRequest", (s) => {
      if (b(this, cs, Promise.withResolvers()), t.onPassword) {
        const i = (n) => {
          n instanceof Error ? o(this, cs).reject(n) : o(this, cs).resolve({
            password: n
          });
        };
        try {
          t.onPassword(i, s.code);
        } catch (n) {
          o(this, cs).reject(n);
        }
      } else
        o(this, cs).reject(new fm(s.message, s.code));
      return o(this, cs).promise;
    }), e.on("DataLoaded", (s) => {
      var i;
      (i = t.onProgress) == null || i.call(t, {
        loaded: s.length,
        total: s.length
      }), this.downloadInfoCapability.resolve(s);
    }), e.on("StartRenderPage", (s) => {
      if (this.destroyed)
        return;
      o(this, hs).get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
    }), e.on("commonobj", ([s, i, n]) => {
      var r;
      if (this.destroyed || this.commonObjs.has(s))
        return null;
      switch (i) {
        case "Font":
          const {
            disableFontFace: a,
            fontExtraProperties: h,
            pdfBug: c
          } = this._params;
          if ("error" in n) {
            const m = n.error;
            Q(`Error during font loading: ${m}`), this.commonObjs.resolve(s, m);
            break;
          }
          const d = c && ((r = globalThis.FontInspector) != null && r.enabled) ? (m, g) => globalThis.FontInspector.fontAdded(m, g) : null, u = new iw(n, {
            disableFontFace: a,
            inspectFont: d
          });
          this.fontLoader.bind(u).catch(() => e.sendWithPromise("FontFallback", {
            id: s
          })).finally(() => {
            !h && u.data && (u.data = null), this.commonObjs.resolve(s, u);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: f
          } = n;
          Ot(f, "The imageRef must be defined.");
          for (const m of o(this, hs).values())
            for (const [, g] of m.objs)
              if ((g == null ? void 0 : g.ref) === f)
                return g.dataLen ? (this.commonObjs.resolve(s, structuredClone(g)), g.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(s, n);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), e.on("obj", ([s, i, n, r]) => {
      var h;
      if (this.destroyed)
        return;
      const a = o(this, hs).get(i);
      if (!a.objs.has(s)) {
        if (a._intentStates.size === 0) {
          (h = r == null ? void 0 : r.bitmap) == null || h.close();
          return;
        }
        switch (n) {
          case "Image":
            a.objs.resolve(s, r), (r == null ? void 0 : r.dataLen) > L0 && (a._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            a.objs.resolve(s, r);
            break;
          default:
            throw new Error(`Got unknown object type ${n}`);
        }
      }
    }), e.on("DocProgress", (s) => {
      var i;
      this.destroyed || (i = t.onProgress) == null || i.call(t, {
        loaded: s.loaded,
        total: s.total
      });
    }), e.on("FetchBuiltInCMap", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(s) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), e.on("FetchStandardFontData", (s) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(s) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var s;
    this.annotationStorage.size <= 0 && Q("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: e,
      transfer: t
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: e,
      filename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null
    }, t).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(e) {
    if (!Number.isInteger(e) || e <= 0 || e > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const t = e - 1, s = o(this, Ya).get(t);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: t
    }).then((n) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      n.refStr && o(this, Qa).set(n.refStr, e);
      const r = new sS(t, n, this, this._params.pdfBug);
      return o(this, hs).set(t, r), r;
    });
    return o(this, Ya).set(t, i), i;
  }
  getPageIndex(e) {
    return Bb(e) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: e.num,
      gen: e.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(e, t) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: e,
      intent: t
    });
  }
  getFieldObjects() {
    return v(this, tr, Sl).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return v(this, tr, Sl).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(e) {
    return typeof e != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: e
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return v(this, tr, Sl).call(this, "GetDocJSActions");
  }
  getPageJSActions(e) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: e
    });
  }
  getStructTree(e) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: e
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(e) {
    return v(this, tr, Sl).call(this, "GetOptionalContentConfig").then((t) => new Sw(t, e));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const e = "GetMetadata", t = o(this, Ws).get(e);
    if (t)
      return t;
    const s = this.messageHandler.sendWithPromise(e, null).then((i) => {
      var n, r;
      return {
        info: i[0],
        metadata: i[1] ? new Ew(i[1]) : null,
        contentDispositionFilename: ((n = this._fullReader) == null ? void 0 : n.filename) ?? null,
        contentLength: ((r = this._fullReader) == null ? void 0 : r.contentLength) ?? null
      };
    });
    return o(this, Ws).set(e, s), s;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(e = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const t of o(this, hs).values())
        if (!t.cleanup())
          throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), e || this.fontLoader.clear(), o(this, Ws).clear(), this.filterFactory.destroy(!0), lf.cleanup();
    }
  }
  cachedPageNumber(e) {
    if (!Bb(e))
      return null;
    const t = e.gen === 0 ? `${e.num}R` : `${e.num}R${e.gen}`;
    return o(this, Qa).get(t) ?? null;
  }
}
Ws = new WeakMap(), hs = new WeakMap(), Ya = new WeakMap(), Qa = new WeakMap(), cs = new WeakMap(), tr = new WeakSet(), Sl = function(e, t = null) {
  const s = o(this, Ws).get(e);
  if (s)
    return s;
  const i = this.messageHandler.sendWithPromise(e, t);
  return o(this, Ws).set(e, i), i;
};
const cu = Symbol("INITIAL_DATA");
var ze, tc, Wm;
class TA {
  constructor() {
    p(this, tc);
    p(this, ze, /* @__PURE__ */ Object.create(null));
  }
  get(e, t = null) {
    if (t) {
      const i = v(this, tc, Wm).call(this, e);
      return i.promise.then(() => t(i.data)), null;
    }
    const s = o(this, ze)[e];
    if (!s || s.data === cu)
      throw new Error(`Requesting object that isn't resolved yet ${e}.`);
    return s.data;
  }
  has(e) {
    const t = o(this, ze)[e];
    return !!t && t.data !== cu;
  }
  resolve(e, t = null) {
    const s = v(this, tc, Wm).call(this, e);
    s.data = t, s.resolve();
  }
  clear() {
    var e;
    for (const t in o(this, ze)) {
      const {
        data: s
      } = o(this, ze)[t];
      (e = s == null ? void 0 : s.bitmap) == null || e.close();
    }
    b(this, ze, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const e in o(this, ze)) {
      const {
        data: t
      } = o(this, ze)[e];
      t !== cu && (yield [e, t]);
    }
  }
}
ze = new WeakMap(), tc = new WeakSet(), Wm = function(e) {
  var t;
  return (t = o(this, ze))[e] || (t[e] = {
    ...Promise.withResolvers(),
    data: cu
  });
};
var $i;
class rS {
  constructor(e) {
    p(this, $i, null);
    b(this, $i, e), this.onContinue = null;
  }
  get promise() {
    return o(this, $i).capability.promise;
  }
  cancel(e = 0) {
    o(this, $i).cancel(null, e);
  }
  get separateAnnots() {
    const {
      separateAnnots: e
    } = o(this, $i).operatorList;
    if (!e)
      return !1;
    const {
      annotationCanvasMap: t
    } = o(this, $i);
    return e.form || e.canvas && (t == null ? void 0 : t.size) > 0;
  }
}
$i = new WeakMap();
var Vi, er;
const Sn = class Sn {
  constructor({
    callback: e,
    params: t,
    objs: s,
    commonObjs: i,
    annotationCanvasMap: n,
    operatorList: r,
    pageIndex: a,
    canvasFactory: h,
    filterFactory: c,
    useRequestAnimationFrame: d = !1,
    pdfBug: u = !1,
    pageColors: f = null
  }) {
    p(this, Vi, null);
    this.callback = e, this.params = t, this.objs = s, this.commonObjs = i, this.annotationCanvasMap = n, this.operatorListIdx = null, this.operatorList = r, this._pageIndex = a, this.canvasFactory = h, this.filterFactory = c, this._pdfBug = u, this.pageColors = f, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = d === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new rS(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: e = !1,
    optionalContentConfig: t
  }) {
    var a, h;
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (o(Sn, er).has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      o(Sn, er).add(this._canvas);
    }
    this._pdfBug && ((a = globalThis.StepperManager) != null && a.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      canvasContext: s,
      viewport: i,
      transform: n,
      background: r
    } = this.params;
    this.gfx = new ma(s, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: t
    }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
      transform: n,
      viewport: i,
      transparency: e,
      background: r
    }), this.operatorListIdx = 0, this.graphicsReady = !0, (h = this.graphicsReadyCallback) == null || h.call(this);
  }
  cancel(e = null, t = 0) {
    var s;
    this.running = !1, this.cancelled = !0, (s = this.gfx) == null || s.endDrawing(), o(this, Vi) && (window.cancelAnimationFrame(o(this, Vi)), b(this, Vi, null)), o(Sn, er).delete(this._canvas), this.callback(e || new ab(`Rendering cancelled, page ${this._pageIndex + 1}`, t));
  }
  operatorListChanged() {
    var e;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (e = this.stepper) == null || e.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? b(this, Vi, window.requestAnimationFrame(() => {
      b(this, Vi, null), this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), o(Sn, er).delete(this._canvas), this.callback())));
  }
};
Vi = new WeakMap(), er = new WeakMap(), p(Sn, er, /* @__PURE__ */ new WeakSet());
let Gm = Sn;
const aS = "4.4.168", oS = "19fbc8998";
st(670);
function jb(l) {
  return Math.floor(Math.max(0, Math.min(1, l)) * 255).toString(16).padStart(2, "0");
}
function ul(l) {
  return Math.max(0, Math.min(255, 255 * l));
}
class Hb {
  static CMYK_G([e, t, s, i]) {
    return ["G", 1 - Math.min(1, 0.3 * e + 0.59 * s + 0.11 * t + i)];
  }
  static G_CMYK([e]) {
    return ["CMYK", 0, 0, 0, 1 - e];
  }
  static G_RGB([e]) {
    return ["RGB", e, e, e];
  }
  static G_rgb([e]) {
    return e = ul(e), [e, e, e];
  }
  static G_HTML([e]) {
    const t = jb(e);
    return `#${t}${t}${t}`;
  }
  static RGB_G([e, t, s]) {
    return ["G", 0.3 * e + 0.59 * t + 0.11 * s];
  }
  static RGB_rgb(e) {
    return e.map(ul);
  }
  static RGB_HTML(e) {
    return `#${e.map(jb).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([e, t, s, i]) {
    return ["RGB", 1 - Math.min(1, e + i), 1 - Math.min(1, s + i), 1 - Math.min(1, t + i)];
  }
  static CMYK_rgb([e, t, s, i]) {
    return [ul(1 - Math.min(1, e + i)), ul(1 - Math.min(1, s + i)), ul(1 - Math.min(1, t + i))];
  }
  static CMYK_HTML(e) {
    const t = this.CMYK_RGB(e).slice(1);
    return this.RGB_HTML(t);
  }
  static RGB_CMYK([e, t, s]) {
    const i = 1 - e, n = 1 - t, r = 1 - s, a = Math.min(i, n, r);
    return ["CMYK", i, n, r, a];
  }
}
let CA = class {
  static setupStorage(e, t, s, i, n) {
    const r = i.getValue(t, {
      value: null
    });
    switch (s.name) {
      case "textarea":
        if (r.value !== null && (e.textContent = r.value), n === "print")
          break;
        e.addEventListener("input", (a) => {
          i.setValue(t, {
            value: a.target.value
          });
        });
        break;
      case "input":
        if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
          if (r.value === s.attributes.xfaOn ? e.setAttribute("checked", !0) : r.value === s.attributes.xfaOff && e.removeAttribute("checked"), n === "print")
            break;
          e.addEventListener("change", (a) => {
            i.setValue(t, {
              value: a.target.checked ? a.target.getAttribute("xfaOn") : a.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (r.value !== null && e.setAttribute("value", r.value), n === "print")
            break;
          e.addEventListener("input", (a) => {
            i.setValue(t, {
              value: a.target.value
            });
          });
        }
        break;
      case "select":
        if (r.value !== null) {
          e.setAttribute("value", r.value);
          for (const a of s.children)
            a.attributes.value === r.value ? a.attributes.selected = !0 : a.attributes.hasOwnProperty("selected") && delete a.attributes.selected;
        }
        e.addEventListener("input", (a) => {
          const h = a.target.options, c = h.selectedIndex === -1 ? "" : h[h.selectedIndex].value;
          i.setValue(t, {
            value: c
          });
        });
        break;
    }
  }
  static setAttributes({
    html: e,
    element: t,
    storage: s = null,
    intent: i,
    linkService: n
  }) {
    const {
      attributes: r
    } = t, a = e instanceof HTMLAnchorElement;
    r.type === "radio" && (r.name = `${r.name}-${i}`);
    for (const [h, c] of Object.entries(r))
      if (c != null)
        switch (h) {
          case "class":
            c.length && e.setAttribute(h, c.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            e.setAttribute("data-element-id", c);
            break;
          case "style":
            Object.assign(e.style, c);
            break;
          case "textContent":
            e.textContent = c;
            break;
          default:
            (!a || h !== "href" && h !== "newWindow") && e.setAttribute(h, c);
        }
    a && n.addLinkAttributes(e, r.href, r.newWindow), s && r.dataId && this.setupStorage(e, r.dataId, t, s);
  }
  static render(e) {
    var u, f;
    const t = e.annotationStorage, s = e.linkService, i = e.xfaHtml, n = e.intent || "display", r = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: r,
      element: i,
      intent: n,
      linkService: s
    });
    const a = n !== "richText", h = e.div;
    if (h.append(r), e.viewport) {
      const m = `matrix(${e.viewport.transform.join(",")})`;
      h.style.transform = m;
    }
    a && h.setAttribute("class", "xfaLayer xfaFont");
    const c = [];
    if (i.children.length === 0) {
      if (i.value) {
        const m = document.createTextNode(i.value);
        r.append(m), a && Ul.shouldBuildText(i.name) && c.push(m);
      }
      return {
        textDivs: c
      };
    }
    const d = [[i, -1, r]];
    for (; d.length > 0; ) {
      const [m, g, A] = d.at(-1);
      if (g + 1 === m.children.length) {
        d.pop();
        continue;
      }
      const E = m.children[++d.at(-1)[1]];
      if (E === null)
        continue;
      const {
        name: y
      } = E;
      if (y === "#text") {
        const S = document.createTextNode(E.value);
        c.push(S), A.append(S);
        continue;
      }
      const w = (u = E == null ? void 0 : E.attributes) != null && u.xmlns ? document.createElementNS(E.attributes.xmlns, y) : document.createElement(y);
      if (A.append(w), E.attributes && this.setAttributes({
        html: w,
        element: E,
        storage: t,
        intent: n,
        linkService: s
      }), ((f = E.children) == null ? void 0 : f.length) > 0)
        d.push([E, -1, w]);
      else if (E.value) {
        const S = document.createTextNode(E.value);
        a && Ul.shouldBuildText(y) && c.push(S), w.append(S);
      }
    }
    for (const m of h.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      m.setAttribute("readOnly", !0);
    return {
      textDivs: c
    };
  }
  static update(e) {
    const t = `matrix(${e.viewport.transform.join(",")})`;
    e.div.style.transform = t, e.div.hidden = !1;
  }
};
const ru = 1e3, lS = 9, ea = /* @__PURE__ */ new WeakSet();
function mi(l) {
  return {
    width: l[2] - l[0],
    height: l[3] - l[1]
  };
}
class hS {
  static create(e) {
    switch (e.data.annotationType) {
      case Tt.LINK:
        return new RA(e);
      case Tt.TEXT:
        return new cS(e);
      case Tt.WIDGET:
        switch (e.data.fieldType) {
          case "Tx":
            return new dS(e);
          case "Btn":
            return e.data.radioButton ? new _A(e) : e.data.checkBox ? new fS(e) : new pS(e);
          case "Ch":
            return new gS(e);
          case "Sig":
            return new uS(e);
        }
        return new na(e);
      case Tt.POPUP:
        return new Km(e);
      case Tt.FREETEXT:
        return new FA(e);
      case Tt.LINE:
        return new vS(e);
      case Tt.SQUARE:
        return new bS(e);
      case Tt.CIRCLE:
        return new yS(e);
      case Tt.POLYLINE:
        return new NA(e);
      case Tt.CARET:
        return new ES(e);
      case Tt.INK:
        return new BA(e);
      case Tt.POLYGON:
        return new AS(e);
      case Tt.HIGHLIGHT:
        return new wS(e);
      case Tt.UNDERLINE:
        return new SS(e);
      case Tt.SQUIGGLY:
        return new xS(e);
      case Tt.STRIKEOUT:
        return new PS(e);
      case Tt.STAMP:
        return new jA(e);
      case Tt.FILEATTACHMENT:
        return new TS(e);
      default:
        return new wt(e);
    }
  }
}
var sr, Za, Ja, ec, Xm;
const bb = class bb {
  constructor(e, {
    isRenderable: t = !1,
    ignoreBorder: s = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    p(this, ec);
    p(this, sr, null);
    p(this, Za, !1);
    p(this, Ja, null);
    this.isRenderable = t, this.data = e.data, this.layer = e.layer, this.linkService = e.linkService, this.downloadManager = e.downloadManager, this.imageResourcesPath = e.imageResourcesPath, this.renderForms = e.renderForms, this.svgFactory = e.svgFactory, this.annotationStorage = e.annotationStorage, this.enableScripting = e.enableScripting, this.hasJSActions = e.hasJSActions, this._fieldObjects = e.fieldObjects, this.parent = e.parent, t && (this.container = this._createContainer(s)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    titleObj: e,
    contentsObj: t,
    richText: s
  }) {
    return !!(e != null && e.str || t != null && t.str || s != null && s.str);
  }
  get hasPopupData() {
    return bb._hasPopupData(this.data);
  }
  updateEdited(e) {
    var s;
    if (!this.container)
      return;
    o(this, sr) || b(this, sr, {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: t
    } = e;
    t && v(this, ec, Xm).call(this, t), (s = o(this, Ja)) == null || s.popup.updateEdited(e);
  }
  resetEdited() {
    var e;
    o(this, sr) && (v(this, ec, Xm).call(this, o(this, sr).rect), (e = o(this, Ja)) == null || e.popup.resetEdited(), b(this, sr, null));
  }
  _createContainer(e) {
    const {
      data: t,
      parent: {
        page: s,
        viewport: i
      }
    } = this, n = document.createElement("section");
    n.setAttribute("data-annotation-id", t.id), this instanceof na || (n.tabIndex = ru);
    const {
      style: r
    } = n;
    if (r.zIndex = this.parent.zIndex++, t.popupRef && n.setAttribute("aria-haspopup", "dialog"), t.alternativeText && (n.title = t.alternativeText), t.noRotate && n.classList.add("norotate"), !t.rect || this instanceof Km) {
      const {
        rotation: A
      } = t;
      return !t.hasOwnCanvas && A !== 0 && this.setRotation(A, n), n;
    }
    const {
      width: a,
      height: h
    } = mi(t.rect);
    if (!e && t.borderStyle.width > 0) {
      r.borderWidth = `${t.borderStyle.width}px`;
      const A = t.borderStyle.horizontalCornerRadius, E = t.borderStyle.verticalCornerRadius;
      if (A > 0 || E > 0) {
        const w = `calc(${A}px * var(--scale-factor)) / calc(${E}px * var(--scale-factor))`;
        r.borderRadius = w;
      } else if (this instanceof _A) {
        const w = `calc(${a}px * var(--scale-factor)) / calc(${h}px * var(--scale-factor))`;
        r.borderRadius = w;
      }
      switch (t.borderStyle.style) {
        case cl.SOLID:
          r.borderStyle = "solid";
          break;
        case cl.DASHED:
          r.borderStyle = "dashed";
          break;
        case cl.BEVELED:
          Q("Unimplemented border style: beveled");
          break;
        case cl.INSET:
          Q("Unimplemented border style: inset");
          break;
        case cl.UNDERLINE:
          r.borderBottomStyle = "solid";
          break;
      }
      const y = t.borderColor || null;
      y ? (b(this, Za, !0), r.borderColor = U.makeHexColor(y[0] | 0, y[1] | 0, y[2] | 0)) : r.borderWidth = 0;
    }
    const c = U.normalizeRect([t.rect[0], s.view[3] - t.rect[1] + s.view[1], t.rect[2], s.view[3] - t.rect[3] + s.view[1]]), {
      pageWidth: d,
      pageHeight: u,
      pageX: f,
      pageY: m
    } = i.rawDims;
    r.left = `${100 * (c[0] - f) / d}%`, r.top = `${100 * (c[1] - m) / u}%`;
    const {
      rotation: g
    } = t;
    return t.hasOwnCanvas || g === 0 ? (r.width = `${100 * a / d}%`, r.height = `${100 * h / u}%`) : this.setRotation(g, n), n;
  }
  setRotation(e, t = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: s,
      pageHeight: i
    } = this.parent.viewport.rawDims, {
      width: n,
      height: r
    } = mi(this.data.rect);
    let a, h;
    e % 180 === 0 ? (a = 100 * n / s, h = 100 * r / i) : (a = 100 * r / s, h = 100 * n / i), t.style.width = `${a}%`, t.style.height = `${h}%`, t.setAttribute("data-main-rotation", (360 - e) % 360);
  }
  get _commonActions() {
    const e = (t, s, i) => {
      const n = i.detail[t], r = n[0], a = n.slice(1);
      i.target.style[s] = Hb[`${r}_HTML`](a), this.annotationStorage.setValue(this.data.id, {
        [s]: Hb[`${r}_rgb`](a)
      });
    };
    return et(this, "_commonActions", {
      display: (t) => {
        const {
          display: s
        } = t.detail, i = s % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: s === 1 || s === 2
        });
      },
      print: (t) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !t.detail.print
        });
      },
      hidden: (t) => {
        const {
          hidden: s
        } = t.detail;
        this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: s,
          noView: s
        });
      },
      focus: (t) => {
        setTimeout(() => t.target.focus({
          preventScroll: !1
        }), 0);
      },
      userName: (t) => {
        t.target.title = t.detail.userName;
      },
      readonly: (t) => {
        t.target.disabled = t.detail.readonly;
      },
      required: (t) => {
        this._setRequired(t.target, t.detail.required);
      },
      bgColor: (t) => {
        e("bgColor", "backgroundColor", t);
      },
      fillColor: (t) => {
        e("fillColor", "backgroundColor", t);
      },
      fgColor: (t) => {
        e("fgColor", "color", t);
      },
      textColor: (t) => {
        e("textColor", "color", t);
      },
      borderColor: (t) => {
        e("borderColor", "borderColor", t);
      },
      strokeColor: (t) => {
        e("strokeColor", "borderColor", t);
      },
      rotation: (t) => {
        const s = t.detail.rotation;
        this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
          rotation: s
        });
      }
    });
  }
  _dispatchEventFromSandbox(e, t) {
    const s = this._commonActions;
    for (const i of Object.keys(t.detail)) {
      const n = e[i] || s[i];
      n == null || n(t);
    }
  }
  _setDefaultPropertiesFromJS(e) {
    if (!this.enableScripting)
      return;
    const t = this.annotationStorage.getRawValue(this.data.id);
    if (!t)
      return;
    const s = this._commonActions;
    for (const [i, n] of Object.entries(t)) {
      const r = s[i];
      if (r) {
        const a = {
          detail: {
            [i]: n
          },
          target: e
        };
        r(a), delete t[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: e
    } = this.data;
    if (!e)
      return;
    const [t, s, i, n] = this.data.rect.map((A) => Math.fround(A));
    if (e.length === 8) {
      const [A, E, y, w] = e.subarray(2, 6);
      if (i === A && n === E && t === y && s === w)
        return;
    }
    const {
      style: r
    } = this.container;
    let a;
    if (o(this, Za)) {
      const {
        borderColor: A,
        borderWidth: E
      } = r;
      r.borderWidth = 0, a = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${A}" stroke-width="${E}">`], this.container.classList.add("hasBorder");
    }
    const h = i - t, c = n - s, {
      svgFactory: d
    } = this, u = d.createElement("svg");
    u.classList.add("quadrilateralsContainer"), u.setAttribute("width", 0), u.setAttribute("height", 0);
    const f = d.createElement("defs");
    u.append(f);
    const m = d.createElement("clipPath"), g = `clippath_${this.data.id}`;
    m.setAttribute("id", g), m.setAttribute("clipPathUnits", "objectBoundingBox"), f.append(m);
    for (let A = 2, E = e.length; A < E; A += 8) {
      const y = e[A], w = e[A + 1], S = e[A + 2], C = e[A + 3], P = d.createElement("rect"), x = (S - t) / h, R = (n - w) / c, M = (y - S) / h, T = (w - C) / c;
      P.setAttribute("x", x), P.setAttribute("y", R), P.setAttribute("width", M), P.setAttribute("height", T), m.append(P), a == null || a.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${R}" width="${M}" height="${T}"/>`);
    }
    o(this, Za) && (a.push("</g></svg>')"), r.backgroundImage = a.join("")), this.container.append(u), this.container.style.clipPath = `url(#${g})`;
  }
  _createPopup() {
    const {
      container: e,
      data: t
    } = this;
    e.setAttribute("aria-haspopup", "dialog");
    const s = b(this, Ja, new Km({
      data: {
        color: t.color,
        titleObj: t.titleObj,
        modificationDate: t.modificationDate,
        contentsObj: t.contentsObj,
        richText: t.richText,
        parentRect: t.rect,
        borderStyle: 0,
        id: `popup_${t.id}`,
        rotation: t.rotation
      },
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(s.render());
  }
  render() {
    at("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(e, t = null) {
    const s = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[e];
      if (i)
        for (const {
          page: n,
          id: r,
          exportValues: a
        } of i) {
          if (n === -1 || r === t)
            continue;
          const h = typeof a == "string" ? a : null, c = document.querySelector(`[data-element-id="${r}"]`);
          if (c && !ea.has(c)) {
            Q(`_getElementsByName - element not allowed: ${r}`);
            continue;
          }
          s.push({
            id: r,
            exportValue: h,
            domElement: c
          });
        }
      return s;
    }
    for (const i of document.getElementsByName(e)) {
      const {
        exportValue: n
      } = i, r = i.getAttribute("data-element-id");
      r !== t && ea.has(i) && s.push({
        id: r,
        exportValue: n,
        domElement: i
      });
    }
    return s;
  }
  show() {
    var e;
    this.container && (this.container.hidden = !1), (e = this.popup) == null || e.maybeShow();
  }
  hide() {
    var e;
    this.container && (this.container.hidden = !0), (e = this.popup) == null || e.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const e = this.getElementsToTriggerPopup();
    if (Array.isArray(e))
      for (const t of e)
        t.classList.add("highlightArea");
    else
      e.classList.add("highlightArea");
  }
  get _isEditable() {
    return !1;
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: e,
      data: {
        id: t
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var s;
      (s = this.linkService.eventBus) == null || s.dispatch("switchannotationeditormode", {
        source: this,
        mode: e,
        editId: t
      });
    });
  }
};
sr = new WeakMap(), Za = new WeakMap(), Ja = new WeakMap(), ec = new WeakSet(), Xm = function(e) {
  const {
    container: {
      style: t
    },
    data: {
      rect: s,
      rotation: i
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth: n,
          pageHeight: r,
          pageX: a,
          pageY: h
        }
      }
    }
  } = this;
  s == null || s.splice(0, 4, ...e);
  const {
    width: c,
    height: d
  } = mi(e);
  t.left = `${100 * (e[0] - a) / n}%`, t.top = `${100 * (r - e[3] + h) / r}%`, i === 0 ? (t.width = `${100 * c / n}%`, t.height = `${100 * d / r}%`) : this.setRotation(i);
};
let wt = bb;
var Gs, bn, rp, IA, ap, LA;
class RA extends wt {
  constructor(t, s = null) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !!(s != null && s.ignoreBorder),
      createQuadrilaterals: !0
    });
    p(this, Gs);
    p(this, rp);
    p(this, ap);
    this.isTooltipOnly = t.data.isTooltipOnly;
  }
  render() {
    const {
      data: t,
      linkService: s
    } = this, i = document.createElement("a");
    i.setAttribute("data-element-id", t.id);
    let n = !1;
    return t.url ? (s.addLinkAttributes(i, t.url, t.newWindow), n = !0) : t.action ? (this._bindNamedAction(i, t.action), n = !0) : t.attachment ? (v(this, rp, IA).call(this, i, t.attachment, t.attachmentDest), n = !0) : t.setOCGState ? (v(this, ap, LA).call(this, i, t.setOCGState), n = !0) : t.dest ? (this._bindLink(i, t.dest), n = !0) : (t.actions && (t.actions.Action || t.actions["Mouse Up"] || t.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, t), n = !0), t.resetForm ? (this._bindResetFormAction(i, t.resetForm), n = !0) : this.isTooltipOnly && !n && (this._bindLink(i, ""), n = !0)), this.container.classList.add("linkAnnotation"), n && this.container.append(i), this.container;
  }
  _bindLink(t, s) {
    t.href = this.linkService.getDestinationHash(s), t.onclick = () => (s && this.linkService.goToDestination(s), !1), (s || s === "") && v(this, Gs, bn).call(this);
  }
  _bindNamedAction(t, s) {
    t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeNamedAction(s), !1), v(this, Gs, bn).call(this);
  }
  _bindJSAction(t, s) {
    t.href = this.linkService.getAnchorUrl("");
    const i = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const n of Object.keys(s.actions)) {
      const r = i.get(n);
      r && (t[r] = () => {
        var a;
        return (a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: s.id,
            name: n
          }
        }), !1;
      });
    }
    t.onclick || (t.onclick = () => !1), v(this, Gs, bn).call(this);
  }
  _bindResetFormAction(t, s) {
    const i = t.onclick;
    if (i || (t.href = this.linkService.getAnchorUrl("")), v(this, Gs, bn).call(this), !this._fieldObjects) {
      Q('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), i || (t.onclick = () => !1);
      return;
    }
    t.onclick = () => {
      var u;
      i == null || i();
      const {
        fields: n,
        refs: r,
        include: a
      } = s, h = [];
      if (n.length !== 0 || r.length !== 0) {
        const f = new Set(r);
        for (const m of n) {
          const g = this._fieldObjects[m] || [];
          for (const {
            id: A
          } of g)
            f.add(A);
        }
        for (const m of Object.values(this._fieldObjects))
          for (const g of m)
            f.has(g.id) === a && h.push(g);
      } else
        for (const f of Object.values(this._fieldObjects))
          h.push(...f);
      const c = this.annotationStorage, d = [];
      for (const f of h) {
        const {
          id: m
        } = f;
        switch (d.push(m), f.type) {
          case "text": {
            const A = f.defaultValue || "";
            c.setValue(m, {
              value: A
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const A = f.defaultValue === f.exportValues;
            c.setValue(m, {
              value: A
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const A = f.defaultValue || "";
            c.setValue(m, {
              value: A
            });
            break;
          }
          default:
            continue;
        }
        const g = document.querySelector(`[data-element-id="${m}"]`);
        if (g) {
          if (!ea.has(g)) {
            Q(`_bindResetFormAction - element not allowed: ${m}`);
            continue;
          }
        } else
          continue;
        g.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && ((u = this.linkService.eventBus) == null || u.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: d,
          name: "ResetForm"
        }
      })), !1;
    };
  }
}
Gs = new WeakSet(), bn = function() {
  this.container.setAttribute("data-internal-link", "");
}, rp = new WeakSet(), IA = function(t, s, i = null) {
  t.href = this.linkService.getAnchorUrl(""), s.description && (t.title = s.description), t.onclick = () => {
    var n;
    return (n = this.downloadManager) == null || n.openOrDownloadData(s.content, s.filename, i), !1;
  }, v(this, Gs, bn).call(this);
}, ap = new WeakSet(), LA = function(t, s) {
  t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeSetOCGState(s), !1), v(this, Gs, bn).call(this);
};
class cS extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const e = document.createElement("img");
    return e.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e), this.container;
  }
}
class na extends wt {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(e) {
    var t;
    this.data.hasOwnCanvas && (((t = e.previousSibling) == null ? void 0 : t.nodeName) === "CANVAS" && (e.previousSibling.hidden = !0), e.hidden = !1);
  }
  _getKeyModifier(e) {
    return ue.platform.isMac ? e.metaKey : e.ctrlKey;
  }
  _setEventListener(e, t, s, i, n) {
    s.includes("mouse") ? e.addEventListener(s, (r) => {
      var a;
      (a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r),
          shift: r.shiftKey,
          modifier: this._getKeyModifier(r)
        }
      });
    }) : e.addEventListener(s, (r) => {
      var a;
      if (s === "blur") {
        if (!t.focused || !r.relatedTarget)
          return;
        t.focused = !1;
      } else if (s === "focus") {
        if (t.focused)
          return;
        t.focused = !0;
      }
      n && ((a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: n(r)
        }
      }));
    });
  }
  _setEventListeners(e, t, s, i) {
    var n, r, a;
    for (const [h, c] of s)
      (c === "Action" || (n = this.data.actions) != null && n[c]) && ((c === "Focus" || c === "Blur") && (t || (t = {
        focused: !1
      })), this._setEventListener(e, t, h, c, i), c === "Focus" && !((r = this.data.actions) != null && r.Blur) ? this._setEventListener(e, t, "blur", "Blur", null) : c === "Blur" && !((a = this.data.actions) != null && a.Focus) && this._setEventListener(e, t, "focus", "Focus", null));
  }
  _setBackgroundColor(e) {
    const t = this.data.backgroundColor || null;
    e.style.backgroundColor = t === null ? "transparent" : U.makeHexColor(t[0], t[1], t[2]);
  }
  _setTextStyle(e) {
    const t = ["left", "center", "right"], {
      fontColor: s
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || lS, n = e.style;
    let r;
    const a = 2, h = (c) => Math.round(10 * c) / 10;
    if (this.data.multiLine) {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - a), d = Math.round(c / (Yg * i)) || 1, u = c / d;
      r = Math.min(i, h(u / Yg));
    } else {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - a);
      r = Math.min(i, h(c / Yg));
    }
    n.fontSize = `calc(${r}px * var(--scale-factor))`, n.color = U.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (n.textAlign = t[this.data.textAlignment]);
  }
  _setRequired(e, t) {
    t ? e.setAttribute("required", !0) : e.removeAttribute("required"), e.setAttribute("aria-required", t);
  }
}
class dS extends na {
  constructor(e) {
    const t = e.renderForms || e.data.hasOwnCanvas || !e.data.hasAppearance && !!e.data.fieldValue;
    super(e, {
      isRenderable: t
    });
  }
  setPropertyOnSiblings(e, t, s, i) {
    const n = this.annotationStorage;
    for (const r of this._getElementsByName(e.name, e.id))
      r.domElement && (r.domElement[t] = s), n.setValue(r.id, {
        [i]: s
      });
  }
  render() {
    var i, n;
    const e = this.annotationStorage, t = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let s = null;
    if (this.renderForms) {
      const r = e.getValue(t, {
        value: this.data.fieldValue
      });
      let a = r.value || "";
      const h = e.getValue(t, {
        charLimit: this.data.maxLen
      }).charLimit;
      h && a.length > h && (a = a.slice(0, h));
      let c = r.formattedValue || ((i = this.data.textContent) == null ? void 0 : i.join(`
`)) || null;
      c && this.data.comb && (c = c.replaceAll(/\s+/g, ""));
      const d = {
        userValue: a,
        formattedValue: c,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = c ?? a, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = "text", s.setAttribute("value", c ?? a), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), ea.add(s), s.setAttribute("data-element-id", t), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = ru, this._setRequired(s, this.data.required), h && (s.maxLength = h), s.addEventListener("input", (f) => {
        e.setValue(t, {
          value: f.target.value
        }), this.setPropertyOnSiblings(s, "value", f.target.value, "value"), d.formattedValue = null;
      }), s.addEventListener("resetform", (f) => {
        const m = this.data.defaultFieldValue ?? "";
        s.value = d.userValue = m, d.formattedValue = null;
      });
      let u = (f) => {
        const {
          formattedValue: m
        } = d;
        m != null && (f.target.value = m), f.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        s.addEventListener("focus", (m) => {
          var A;
          if (d.focused)
            return;
          const {
            target: g
          } = m;
          d.userValue && (g.value = d.userValue), d.lastCommittedValue = g.value, d.commitKey = 1, (A = this.data.actions) != null && A.Focus || (d.focused = !0);
        }), s.addEventListener("updatefromsandbox", (m) => {
          this.showElementAndHideCanvas(m.target);
          const g = {
            value(A) {
              d.userValue = A.detail.value ?? "", e.setValue(t, {
                value: d.userValue.toString()
              }), A.target.value = d.userValue;
            },
            formattedValue(A) {
              const {
                formattedValue: E
              } = A.detail;
              d.formattedValue = E, E != null && A.target !== document.activeElement && (A.target.value = E), e.setValue(t, {
                formattedValue: E
              });
            },
            selRange(A) {
              A.target.setSelectionRange(...A.detail.selRange);
            },
            charLimit: (A) => {
              var S;
              const {
                charLimit: E
              } = A.detail, {
                target: y
              } = A;
              if (E === 0) {
                y.removeAttribute("maxLength");
                return;
              }
              y.setAttribute("maxLength", E);
              let w = d.userValue;
              !w || w.length <= E || (w = w.slice(0, E), y.value = d.userValue = w, e.setValue(t, {
                value: w
              }), (S = this.linkService.eventBus) == null || S.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: t,
                  name: "Keystroke",
                  value: w,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: y.selectionStart,
                  selEnd: y.selectionEnd
                }
              }));
            }
          };
          this._dispatchEventFromSandbox(g, m);
        }), s.addEventListener("keydown", (m) => {
          var E;
          d.commitKey = 1;
          let g = -1;
          if (m.key === "Escape" ? g = 0 : m.key === "Enter" && !this.data.multiLine ? g = 2 : m.key === "Tab" && (d.commitKey = 3), g === -1)
            return;
          const {
            value: A
          } = m.target;
          d.lastCommittedValue !== A && (d.lastCommittedValue = A, d.userValue = A, (E = this.linkService.eventBus) == null || E.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: A,
              willCommit: !0,
              commitKey: g,
              selStart: m.target.selectionStart,
              selEnd: m.target.selectionEnd
            }
          }));
        });
        const f = u;
        u = null, s.addEventListener("blur", (m) => {
          var A, E;
          if (!d.focused || !m.relatedTarget)
            return;
          (A = this.data.actions) != null && A.Blur || (d.focused = !1);
          const {
            value: g
          } = m.target;
          d.userValue = g, d.lastCommittedValue !== g && ((E = this.linkService.eventBus) == null || E.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: g,
              willCommit: !0,
              commitKey: d.commitKey,
              selStart: m.target.selectionStart,
              selEnd: m.target.selectionEnd
            }
          })), f(m);
        }), (n = this.data.actions) != null && n.Keystroke && s.addEventListener("beforeinput", (m) => {
          var P;
          d.lastCommittedValue = null;
          const {
            data: g,
            target: A
          } = m, {
            value: E,
            selectionStart: y,
            selectionEnd: w
          } = A;
          let S = y, C = w;
          switch (m.inputType) {
            case "deleteWordBackward": {
              const x = E.substring(0, y).match(/\w*[^\w]*$/);
              x && (S -= x[0].length);
              break;
            }
            case "deleteWordForward": {
              const x = E.substring(y).match(/^[^\w]*\w*/);
              x && (C += x[0].length);
              break;
            }
            case "deleteContentBackward":
              y === w && (S -= 1);
              break;
            case "deleteContentForward":
              y === w && (C += 1);
              break;
          }
          m.preventDefault(), (P = this.linkService.eventBus) == null || P.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: E,
              change: g || "",
              willCommit: !1,
              selStart: S,
              selEnd: C
            }
          });
        }), this._setEventListeners(s, d, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (m) => m.target.value);
      }
      if (u && s.addEventListener("blur", u), this.data.comb) {
        const m = (this.data.rect[2] - this.data.rect[0]) / h;
        s.classList.add("comb"), s.style.letterSpacing = `calc(${m}px * var(--scale-factor) - 1ch)`;
      }
    } else
      s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
    return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class uS extends na {
  constructor(e) {
    super(e, {
      isRenderable: !!e.data.hasOwnCanvas
    });
  }
}
class fS extends na {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.exportValue === t.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", e.setValue(s, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const n = document.createElement("input");
    return ea.add(n), n.setAttribute("data-element-id", s), n.disabled = t.readOnly, this._setRequired(n, this.data.required), n.type = "checkbox", n.name = t.fieldName, i && n.setAttribute("checked", !0), n.setAttribute("exportValue", t.exportValue), n.tabIndex = ru, n.addEventListener("change", (r) => {
      const {
        name: a,
        checked: h
      } = r.target;
      for (const c of this._getElementsByName(a, s)) {
        const d = h && c.exportValue === t.exportValue;
        c.domElement && (c.domElement.checked = d), e.setValue(c.id, {
          value: d
        });
      }
      e.setValue(s, {
        value: h
      });
    }), n.addEventListener("resetform", (r) => {
      const a = t.defaultFieldValue || "Off";
      r.target.checked = a === t.exportValue;
    }), this.enableScripting && this.hasJSActions && (n.addEventListener("updatefromsandbox", (r) => {
      const a = {
        value(h) {
          h.target.checked = h.detail.value !== "Off", e.setValue(s, {
            value: h.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(a, r);
    }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (r) => r.target.checked)), this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class _A extends na {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.fieldValue === t.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== t.buttonValue, e.setValue(s, {
      value: i
    })), i)
      for (const r of this._getElementsByName(t.fieldName, s))
        e.setValue(r.id, {
          value: !1
        });
    const n = document.createElement("input");
    if (ea.add(n), n.setAttribute("data-element-id", s), n.disabled = t.readOnly, this._setRequired(n, this.data.required), n.type = "radio", n.name = t.fieldName, i && n.setAttribute("checked", !0), n.tabIndex = ru, n.addEventListener("change", (r) => {
      const {
        name: a,
        checked: h
      } = r.target;
      for (const c of this._getElementsByName(a, s))
        e.setValue(c.id, {
          value: !1
        });
      e.setValue(s, {
        value: h
      });
    }), n.addEventListener("resetform", (r) => {
      const a = t.defaultFieldValue;
      r.target.checked = a != null && a === t.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const r = t.buttonValue;
      n.addEventListener("updatefromsandbox", (a) => {
        const h = {
          value: (c) => {
            const d = r === c.detail.value;
            for (const u of this._getElementsByName(c.target.name)) {
              const f = d && u.id === s;
              u.domElement && (u.domElement.checked = f), e.setValue(u.id, {
                value: f
              });
            }
          }
        };
        this._dispatchEventFromSandbox(h, a);
      }), this._setEventListeners(n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (a) => a.target.checked);
    }
    return this._setBackgroundColor(n), this._setDefaultPropertiesFromJS(n), this.container.append(n), this.container;
  }
}
class pS extends RA {
  constructor(e) {
    super(e, {
      ignoreBorder: e.data.hasAppearance
    });
  }
  render() {
    const e = super.render();
    e.classList.add("buttonWidgetAnnotation", "pushButton");
    const t = e.lastChild;
    return this.enableScripting && this.hasJSActions && t && (this._setDefaultPropertiesFromJS(t), t.addEventListener("updatefromsandbox", (s) => {
      this._dispatchEventFromSandbox({}, s);
    })), e;
  }
}
class gS extends na {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const e = this.annotationStorage, t = this.data.id, s = e.getValue(t, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    ea.add(i), i.setAttribute("data-element-id", t), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = ru;
    let n = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (d) => {
      const u = this.data.defaultFieldValue;
      for (const f of i.options)
        f.selected = f.value === u;
    });
    for (const d of this.data.options) {
      const u = document.createElement("option");
      u.textContent = d.displayValue, u.value = d.exportValue, s.value.includes(d.exportValue) && (u.setAttribute("selected", !0), n = !1), i.append(u);
    }
    let r = null;
    if (n) {
      const d = document.createElement("option");
      d.value = " ", d.setAttribute("hidden", !0), d.setAttribute("selected", !0), i.prepend(d), r = () => {
        d.remove(), i.removeEventListener("input", r), r = null;
      }, i.addEventListener("input", r);
    }
    const a = (d) => {
      const u = d ? "value" : "textContent", {
        options: f,
        multiple: m
      } = i;
      return m ? Array.prototype.filter.call(f, (g) => g.selected).map((g) => g[u]) : f.selectedIndex === -1 ? null : f[f.selectedIndex][u];
    };
    let h = a(!1);
    const c = (d) => {
      const u = d.target.options;
      return Array.prototype.map.call(u, (f) => ({
        displayValue: f.textContent,
        exportValue: f.value
      }));
    };
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (d) => {
      const u = {
        value(f) {
          r == null || r();
          const m = f.detail.value, g = new Set(Array.isArray(m) ? m : [m]);
          for (const A of i.options)
            A.selected = g.has(A.value);
          e.setValue(t, {
            value: a(!0)
          }), h = a(!1);
        },
        multipleSelection(f) {
          i.multiple = !0;
        },
        remove(f) {
          const m = i.options, g = f.detail.remove;
          m[g].selected = !1, i.remove(g), m.length > 0 && Array.prototype.findIndex.call(m, (E) => E.selected) === -1 && (m[0].selected = !0), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        clear(f) {
          for (; i.length !== 0; )
            i.remove(0);
          e.setValue(t, {
            value: null,
            items: []
          }), h = a(!1);
        },
        insert(f) {
          const {
            index: m,
            displayValue: g,
            exportValue: A
          } = f.detail.insert, E = i.children[m], y = document.createElement("option");
          y.textContent = g, y.value = A, E ? E.before(y) : i.append(y), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        items(f) {
          const {
            items: m
          } = f.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const g of m) {
            const {
              displayValue: A,
              exportValue: E
            } = g, y = document.createElement("option");
            y.textContent = A, y.value = E, i.append(y);
          }
          i.options.length > 0 && (i.options[0].selected = !0), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        indices(f) {
          const m = new Set(f.detail.indices);
          for (const g of f.target.options)
            g.selected = m.has(g.index);
          e.setValue(t, {
            value: a(!0)
          }), h = a(!1);
        },
        editable(f) {
          f.target.disabled = !f.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(u, d);
    }), i.addEventListener("input", (d) => {
      var m;
      const u = a(!0), f = a(!1);
      e.setValue(t, {
        value: u
      }), d.preventDefault(), (m = this.linkService.eventBus) == null || m.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: t,
          name: "Keystroke",
          value: h,
          change: f,
          changeEx: u,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (d) => d.target.value)) : i.addEventListener("input", function(d) {
      e.setValue(t, {
        value: a(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
}
class Km extends wt {
  constructor(e) {
    const {
      data: t,
      elements: s
    } = e;
    super(e, {
      isRenderable: wt._hasPopupData(t)
    }), this.elements = s, this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const e = this.popup = new mS({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    }), t = [];
    for (const s of this.elements)
      s.popup = e, t.push(s.data.id), s.addHighlightArea();
    return this.container.setAttribute("aria-controls", t.map((s) => `${My}${s}`).join(",")), this.container;
  }
}
var qa, op, lp, to, ir, yt, Xs, nr, sc, ic, eo, Ks, We, Ys, nc, Qs, rc, rr, ar, so, _u, ac, Ym, hp, MA, cp, OA, dp, DA, up, kA, io, Mu, no, Ou, oc, Qm;
class mS {
  constructor({
    container: e,
    color: t,
    elements: s,
    titleObj: i,
    modificationDate: n,
    contentsObj: r,
    richText: a,
    parent: h,
    rect: c,
    parentRect: d,
    open: u
  }) {
    p(this, so);
    p(this, ac);
    p(this, hp);
    p(this, cp);
    p(this, dp);
    p(this, up);
    p(this, io);
    p(this, no);
    p(this, oc);
    p(this, qa, v(this, dp, DA).bind(this));
    p(this, op, v(this, oc, Qm).bind(this));
    p(this, lp, v(this, no, Ou).bind(this));
    p(this, to, v(this, io, Mu).bind(this));
    p(this, ir, null);
    p(this, yt, null);
    p(this, Xs, null);
    p(this, nr, null);
    p(this, sc, null);
    p(this, ic, null);
    p(this, eo, null);
    p(this, Ks, !1);
    p(this, We, null);
    p(this, Ys, null);
    p(this, nc, null);
    p(this, Qs, null);
    p(this, rc, null);
    p(this, rr, null);
    p(this, ar, !1);
    var f;
    b(this, yt, e), b(this, rc, i), b(this, Xs, r), b(this, Qs, a), b(this, ic, h), b(this, ir, t), b(this, nc, c), b(this, eo, d), b(this, sc, s), b(this, nr, Ny.toDateObject(n)), this.trigger = s.flatMap((m) => m.getElementsToTriggerPopup());
    for (const m of this.trigger)
      m.addEventListener("click", o(this, to)), m.addEventListener("mouseenter", o(this, lp)), m.addEventListener("mouseleave", o(this, op)), m.classList.add("popupTriggerArea");
    for (const m of s)
      (f = m.container) == null || f.addEventListener("keydown", o(this, qa));
    o(this, yt).hidden = !0, u && v(this, io, Mu).call(this);
  }
  render() {
    if (o(this, We))
      return;
    const e = b(this, We, document.createElement("div"));
    if (e.className = "popup", o(this, ir)) {
      const n = e.style.outlineColor = U.makeHexColor(...o(this, ir));
      CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? e.style.backgroundColor = `color-mix(in srgb, ${n} 30%, white)` : e.style.backgroundColor = U.makeHexColor(...o(this, ir).map((a) => Math.floor(0.7 * (255 - a) + a)));
    }
    const t = document.createElement("span");
    t.className = "header";
    const s = document.createElement("h1");
    if (t.append(s), {
      dir: s.dir,
      str: s.textContent
    } = o(this, rc), e.append(t), o(this, nr)) {
      const n = document.createElement("span");
      n.classList.add("popupDate"), n.setAttribute("data-l10n-id", "pdfjs-annotation-date-string"), n.setAttribute("data-l10n-args", JSON.stringify({
        date: o(this, nr).toLocaleDateString(),
        time: o(this, nr).toLocaleTimeString()
      })), t.append(n);
    }
    const i = o(this, so, _u);
    if (i)
      CA.render({
        xfaHtml: i,
        intent: "richText",
        div: e
      }), e.lastChild.classList.add("richText", "popupContent");
    else {
      const n = this._formatContents(o(this, Xs));
      e.append(n);
    }
    o(this, yt).append(e);
  }
  _formatContents({
    str: e,
    dir: t
  }) {
    const s = document.createElement("p");
    s.classList.add("popupContent"), s.dir = t;
    const i = e.split(/(?:\r\n?|\n)/);
    for (let n = 0, r = i.length; n < r; ++n) {
      const a = i[n];
      s.append(document.createTextNode(a)), n < r - 1 && s.append(document.createElement("br"));
    }
    return s;
  }
  updateEdited({
    rect: e,
    popupContent: t
  }) {
    var s;
    o(this, rr) || b(this, rr, {
      contentsObj: o(this, Xs),
      richText: o(this, Qs)
    }), e && b(this, Ys, null), t && (b(this, Qs, v(this, cp, OA).call(this, t)), b(this, Xs, null)), (s = o(this, We)) == null || s.remove(), b(this, We, null);
  }
  resetEdited() {
    var e;
    o(this, rr) && ({
      contentsObj: oe(this, Xs)._,
      richText: oe(this, Qs)._
    } = o(this, rr), b(this, rr, null), (e = o(this, We)) == null || e.remove(), b(this, We, null), b(this, Ys, null));
  }
  forceHide() {
    b(this, ar, this.isVisible), o(this, ar) && (o(this, yt).hidden = !0);
  }
  maybeShow() {
    o(this, ar) && (o(this, We) || v(this, no, Ou).call(this), b(this, ar, !1), o(this, yt).hidden = !1);
  }
  get isVisible() {
    return o(this, yt).hidden === !1;
  }
}
qa = new WeakMap(), op = new WeakMap(), lp = new WeakMap(), to = new WeakMap(), ir = new WeakMap(), yt = new WeakMap(), Xs = new WeakMap(), nr = new WeakMap(), sc = new WeakMap(), ic = new WeakMap(), eo = new WeakMap(), Ks = new WeakMap(), We = new WeakMap(), Ys = new WeakMap(), nc = new WeakMap(), Qs = new WeakMap(), rc = new WeakMap(), rr = new WeakMap(), ar = new WeakMap(), so = new WeakSet(), _u = function() {
  const e = o(this, Qs), t = o(this, Xs);
  return e != null && e.str && (!(t != null && t.str) || t.str === e.str) && o(this, Qs).html || null;
}, ac = new WeakSet(), Ym = function() {
  var e, t, s;
  return ((s = (t = (e = o(this, so, _u)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.fontSize) || 0;
}, hp = new WeakSet(), MA = function() {
  var e, t, s;
  return ((s = (t = (e = o(this, so, _u)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.color) || null;
}, cp = new WeakSet(), OA = function(e) {
  const t = [], s = {
    str: e,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: t
      }]
    }
  }, i = {
    style: {
      color: o(this, hp, MA),
      fontSize: o(this, ac, Ym) ? `calc(${o(this, ac, Ym)}px * var(--scale-factor))` : ""
    }
  };
  for (const n of e.split(`
`))
    t.push({
      name: "span",
      value: n,
      attributes: i
    });
  return s;
}, dp = new WeakSet(), DA = function(e) {
  e.altKey || e.shiftKey || e.ctrlKey || e.metaKey || (e.key === "Enter" || e.key === "Escape" && o(this, Ks)) && v(this, io, Mu).call(this);
}, up = new WeakSet(), kA = function() {
  if (o(this, Ys) !== null)
    return;
  const {
    page: {
      view: e
    },
    viewport: {
      rawDims: {
        pageWidth: t,
        pageHeight: s,
        pageX: i,
        pageY: n
      }
    }
  } = o(this, ic);
  let r = !!o(this, eo), a = r ? o(this, eo) : o(this, nc);
  for (const g of o(this, sc))
    if (!a || U.intersect(g.data.rect, a) !== null) {
      a = g.data.rect, r = !0;
      break;
    }
  const h = U.normalizeRect([a[0], e[3] - a[1] + e[1], a[2], e[3] - a[3] + e[1]]), c = 5, d = r ? a[2] - a[0] + c : 0, u = h[0] + d, f = h[1];
  b(this, Ys, [100 * (u - i) / t, 100 * (f - n) / s]);
  const {
    style: m
  } = o(this, yt);
  m.left = `${o(this, Ys)[0]}%`, m.top = `${o(this, Ys)[1]}%`;
}, io = new WeakSet(), Mu = function() {
  b(this, Ks, !o(this, Ks)), o(this, Ks) ? (v(this, no, Ou).call(this), o(this, yt).addEventListener("click", o(this, to)), o(this, yt).addEventListener("keydown", o(this, qa))) : (v(this, oc, Qm).call(this), o(this, yt).removeEventListener("click", o(this, to)), o(this, yt).removeEventListener("keydown", o(this, qa)));
}, no = new WeakSet(), Ou = function() {
  o(this, We) || this.render(), this.isVisible ? o(this, Ks) && o(this, yt).classList.add("focused") : (v(this, up, kA).call(this), o(this, yt).hidden = !1, o(this, yt).style.zIndex = parseInt(o(this, yt).style.zIndex) + 1e3);
}, oc = new WeakSet(), Qm = function() {
  o(this, yt).classList.remove("focused"), !(o(this, Ks) || !this.isVisible) && (o(this, yt).hidden = !0, o(this, yt).style.zIndex = parseInt(o(this, yt).style.zIndex) - 1e3);
};
class FA extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = e.data.textContent, this.textPosition = e.data.textPosition, this.annotationEditorType = q.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const e = document.createElement("div");
      e.classList.add("annotationTextContent"), e.setAttribute("role", "comment");
      for (const t of this.textContent) {
        const s = document.createElement("span");
        s.textContent = t, e.append(s);
      }
      this.container.append(e);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
  get _isEditable() {
    return this.data.hasOwnCanvas;
  }
}
var lc;
class vS extends wt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    p(this, lc, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = mi(t.rect), n = this.svgFactory.create(s, i, !0), r = b(this, lc, this.svgFactory.createElement("svg:line"));
    return r.setAttribute("x1", t.rect[2] - t.lineCoordinates[0]), r.setAttribute("y1", t.rect[3] - t.lineCoordinates[1]), r.setAttribute("x2", t.rect[2] - t.lineCoordinates[2]), r.setAttribute("y2", t.rect[3] - t.lineCoordinates[3]), r.setAttribute("stroke-width", t.borderStyle.width || 1), r.setAttribute("stroke", "transparent"), r.setAttribute("fill", "transparent"), n.append(r), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, lc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
lc = new WeakMap();
var hc;
class bS extends wt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    p(this, hc, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = mi(t.rect), n = this.svgFactory.create(s, i, !0), r = t.borderStyle.width, a = b(this, hc, this.svgFactory.createElement("svg:rect"));
    return a.setAttribute("x", r / 2), a.setAttribute("y", r / 2), a.setAttribute("width", s - r), a.setAttribute("height", i - r), a.setAttribute("stroke-width", r || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), n.append(a), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, hc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
hc = new WeakMap();
var cc;
class yS extends wt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    p(this, cc, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = mi(t.rect), n = this.svgFactory.create(s, i, !0), r = t.borderStyle.width, a = b(this, cc, this.svgFactory.createElement("svg:ellipse"));
    return a.setAttribute("cx", s / 2), a.setAttribute("cy", i / 2), a.setAttribute("rx", s / 2 - r / 2), a.setAttribute("ry", i / 2 - r / 2), a.setAttribute("stroke-width", r || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), n.append(a), this.container.append(n), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, cc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
cc = new WeakMap();
var dc;
class NA extends wt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    p(this, dc, null);
    this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        vertices: s,
        borderStyle: i,
        popupRef: n
      }
    } = this;
    if (!s)
      return this.container;
    const {
      width: r,
      height: a
    } = mi(t), h = this.svgFactory.create(r, a, !0);
    let c = [];
    for (let u = 0, f = s.length; u < f; u += 2) {
      const m = s[u] - t[0], g = t[3] - s[u + 1];
      c.push(`${m},${g}`);
    }
    c = c.join(" ");
    const d = b(this, dc, this.svgFactory.createElement(this.svgElementName));
    return d.setAttribute("points", c), d.setAttribute("stroke-width", i.width || 1), d.setAttribute("stroke", "transparent"), d.setAttribute("fill", "transparent"), h.append(d), this.container.append(h), !n && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, dc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
dc = new WeakMap();
class AS extends NA {
  constructor(e) {
    super(e), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class ES extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var uc;
class BA extends wt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    p(this, uc, []);
    this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = q.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        inkLists: s,
        borderStyle: i,
        popupRef: n
      }
    } = this, {
      width: r,
      height: a
    } = mi(t), h = this.svgFactory.create(r, a, !0);
    for (const c of s) {
      let d = [];
      for (let f = 0, m = c.length; f < m; f += 2) {
        const g = c[f] - t[0], A = t[3] - c[f + 1];
        d.push(`${g},${A}`);
      }
      d = d.join(" ");
      const u = this.svgFactory.createElement(this.svgElementName);
      o(this, uc).push(u), u.setAttribute("points", d), u.setAttribute("stroke-width", i.width || 1), u.setAttribute("stroke", "transparent"), u.setAttribute("fill", "transparent"), !n && this.hasPopupData && this._createPopup(), h.append(u);
    }
    return this.container.append(h), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, uc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
uc = new WeakMap();
class wS extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
  }
}
class SS extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
  }
}
class xS extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
  }
}
class PS extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
  }
}
class jA extends wt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var fc, pc, Zm;
class TS extends wt {
  constructor(t) {
    var i;
    super(t, {
      isRenderable: !0
    });
    p(this, pc);
    p(this, fc, null);
    const {
      file: s
    } = this.data;
    this.filename = s.filename, this.content = s.content, (i = this.linkService.eventBus) == null || i.dispatch("fileattachmentannotation", {
      source: this,
      ...s
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: t,
      data: s
    } = this;
    let i;
    s.hasAppearance || s.fillAlpha === 0 ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(s.name) ? "paperclip" : "pushpin"}.svg`, s.fillAlpha && s.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(s.fillAlpha * 100)}%);`)), i.addEventListener("dblclick", v(this, pc, Zm).bind(this)), b(this, fc, i);
    const {
      isMac: n
    } = ue.platform;
    return t.addEventListener("keydown", (r) => {
      r.key === "Enter" && (n ? r.metaKey : r.ctrlKey) && v(this, pc, Zm).call(this);
    }), !s.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), t.append(i), t;
  }
  getElementsToTriggerPopup() {
    return o(this, fc);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
fc = new WeakMap(), pc = new WeakSet(), Zm = function() {
  var t;
  (t = this.downloadManager) == null || t.openOrDownloadData(this.content, this.filename);
};
var gc, or, ro, fp, HA, mc, Jm, Py;
let CS = (Py = class {
  constructor({
    div: e,
    accessibilityManager: t,
    annotationCanvasMap: s,
    annotationEditorUIManager: i,
    page: n,
    viewport: r
  }) {
    p(this, fp);
    p(this, mc);
    p(this, gc, null);
    p(this, or, null);
    p(this, ro, /* @__PURE__ */ new Map());
    this.div = e, b(this, gc, t), b(this, or, s), this.page = n, this.viewport = r, this.zIndex = 0, this._annotationEditorUIManager = i;
  }
  async render(e) {
    var r;
    const {
      annotations: t
    } = e, s = this.div;
    ta(s, this.viewport);
    const i = /* @__PURE__ */ new Map(), n = {
      data: null,
      layer: s,
      linkService: e.linkService,
      downloadManager: e.downloadManager,
      imageResourcesPath: e.imageResourcesPath || "",
      renderForms: e.renderForms !== !1,
      svgFactory: new rb(),
      annotationStorage: e.annotationStorage || new cb(),
      enableScripting: e.enableScripting === !0,
      hasJSActions: e.hasJSActions,
      fieldObjects: e.fieldObjects,
      parent: this,
      elements: null
    };
    for (const a of t) {
      if (a.noHTML)
        continue;
      const h = a.annotationType === Tt.POPUP;
      if (h) {
        const u = i.get(a.id);
        if (!u)
          continue;
        n.elements = u;
      } else {
        const {
          width: u,
          height: f
        } = mi(a.rect);
        if (u <= 0 || f <= 0)
          continue;
      }
      n.data = a;
      const c = hS.create(n);
      if (!c.isRenderable)
        continue;
      if (!h && a.popupRef) {
        const u = i.get(a.popupRef);
        u ? u.push(c) : i.set(a.popupRef, [c]);
      }
      const d = c.render();
      a.hidden && (d.style.visibility = "hidden"), v(this, fp, HA).call(this, d, a.id), c.annotationEditorType > 0 && (o(this, ro).set(c.data.id, c), (r = this._annotationEditorUIManager) == null || r.renderAnnotationElement(c));
    }
    v(this, mc, Jm).call(this);
  }
  update({
    viewport: e
  }) {
    const t = this.div;
    this.viewport = e, ta(t, {
      rotation: e.rotation
    }), v(this, mc, Jm).call(this), t.hidden = !1;
  }
  getEditableAnnotations() {
    return Array.from(o(this, ro).values());
  }
  getEditableAnnotation(e) {
    return o(this, ro).get(e);
  }
}, gc = new WeakMap(), or = new WeakMap(), ro = new WeakMap(), fp = new WeakSet(), HA = function(e, t) {
  var i;
  const s = e.firstChild || e;
  s.id = `${My}${t}`, this.div.append(e), (i = o(this, gc)) == null || i.moveElementInDOM(this.div, e, s, !1);
}, mc = new WeakSet(), Jm = function() {
  if (!o(this, or))
    return;
  const e = this.div;
  for (const [t, s] of o(this, or)) {
    const i = e.querySelector(`[data-annotation-id="${t}"]`);
    if (!i)
      continue;
    s.className = "annotationContent";
    const {
      firstChild: n
    } = i;
    n ? n.nodeName === "CANVAS" ? n.replaceWith(s) : n.classList.contains("annotationContent") ? n.after(s) : n.before(s) : i.append(s);
  }
  o(this, or).clear();
}, Py);
const du = /\r\n?|\n/g;
var vc, bc, yc, Ac, Ec, Ge, be, wc, ye, ao, pp, $A, gp, VA, mp, UA, oo, Du, lo, ku, ho, Fu, vp, zA, Sc, tv, bp, WA;
const ct = class ct extends nt {
  constructor(t) {
    super({
      ...t,
      name: "freeTextEditor"
    });
    p(this, pp);
    p(this, gp);
    p(this, mp);
    p(this, oo);
    p(this, ho);
    p(this, vp);
    p(this, bp);
    p(this, vc, this.editorDivBlur.bind(this));
    p(this, bc, this.editorDivFocus.bind(this));
    p(this, yc, this.editorDivInput.bind(this));
    p(this, Ac, this.editorDivKeydown.bind(this));
    p(this, Ec, this.editorDivPaste.bind(this));
    p(this, Ge, void 0);
    p(this, be, "");
    p(this, wc, `${this.id}-editor`);
    p(this, ye, void 0);
    p(this, ao, null);
    b(this, Ge, t.color || ct._defaultColor || nt._defaultLineColor), b(this, ye, t.fontSize || ct._defaultFontSize);
  }
  static get _keyboardManager() {
    const t = ct.prototype, s = (r) => r.isEmpty(), i = Vl.TRANSLATE_SMALL, n = Vl.TRANSLATE_BIG;
    return et(this, "_keyboardManager", new iu([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], t.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], t.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], t._translateEmpty, {
      args: [-i, 0],
      checker: s
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t._translateEmpty, {
      args: [-n, 0],
      checker: s
    }], [["ArrowRight", "mac+ArrowRight"], t._translateEmpty, {
      args: [i, 0],
      checker: s
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t._translateEmpty, {
      args: [n, 0],
      checker: s
    }], [["ArrowUp", "mac+ArrowUp"], t._translateEmpty, {
      args: [0, -i],
      checker: s
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t._translateEmpty, {
      args: [0, -n],
      checker: s
    }], [["ArrowDown", "mac+ArrowDown"], t._translateEmpty, {
      args: [0, i],
      checker: s
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t._translateEmpty, {
      args: [0, n],
      checker: s
    }]]));
  }
  static initialize(t, s) {
    nt.initialize(t, s, {
      strings: ["pdfjs-free-text-default-content"]
    });
    const i = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case X.FREETEXT_SIZE:
        ct._defaultFontSize = s;
        break;
      case X.FREETEXT_COLOR:
        ct._defaultColor = s;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case X.FREETEXT_SIZE:
        v(this, pp, $A).call(this, s);
        break;
      case X.FREETEXT_COLOR:
        v(this, gp, VA).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[X.FREETEXT_SIZE, ct._defaultFontSize], [X.FREETEXT_COLOR, ct._defaultColor || nt._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[X.FREETEXT_SIZE, o(this, ye)], [X.FREETEXT_COLOR, o(this, Ge)]];
  }
  _translateEmpty(t, s) {
    this._uiManager.translateSelectedEditors(t, s, !0);
  }
  getInitialTranslation() {
    const t = this.parentScale;
    return [-ct._internalPadding * t, -(ct._internalPadding + o(this, ye)) * t];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (this.isInEditMode())
      return;
    this.parent.setEditingState(!1), this.parent.updateToolbar(q.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant");
    const t = this._uiManager._signal;
    this.editorDiv.addEventListener("keydown", o(this, Ac), {
      signal: t
    }), this.editorDiv.addEventListener("focus", o(this, bc), {
      signal: t
    }), this.editorDiv.addEventListener("blur", o(this, vc), {
      signal: t
    }), this.editorDiv.addEventListener("input", o(this, yc), {
      signal: t
    }), this.editorDiv.addEventListener("paste", o(this, Ec), {
      signal: t
    });
  }
  disableEditMode() {
    this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", o(this, wc)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", o(this, Ac)), this.editorDiv.removeEventListener("focus", o(this, bc)), this.editorDiv.removeEventListener("blur", o(this, vc)), this.editorDiv.removeEventListener("input", o(this, yc)), this.editorDiv.removeEventListener("paste", o(this, Ec)), this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), t.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded() {
    var t;
    this.width || (this.enableEditMode(), this.editorDiv.focus(), (t = this._initialOptions) != null && t.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const t = o(this, be), s = b(this, be, v(this, mp, UA).call(this).trimEnd());
    if (t === s)
      return;
    const i = (n) => {
      if (b(this, be, n), !n) {
        this.remove();
        return;
      }
      v(this, ho, Fu).call(this), this._uiManager.rebuild(this), v(this, oo, Du).call(this);
    };
    this.addCommands({
      cmd: () => {
        i(s);
      },
      undo: () => {
        i(t);
      },
      mustExec: !1
    }), v(this, oo, Du).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  dblclick(t) {
    this.enterInEditMode();
  }
  keydown(t) {
    t.target === this.div && t.key === "Enter" && (this.enterInEditMode(), t.preventDefault());
  }
  editorDivKeydown(t) {
    ct._keyboardManager.exec(this, t);
  }
  editorDivFocus(t) {
    this.isEditing = !0;
  }
  editorDivBlur(t) {
    this.isEditing = !1;
  }
  editorDivInput(t) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", o(this, wc)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), nt._l10nPromise.get("pdfjs-free-text-default-content").then((n) => {
      var r;
      return (r = this.editorDiv) == null ? void 0 : r.setAttribute("default-content", n);
    }), this.editorDiv.contentEditable = !0;
    const {
      style: i
    } = this.editorDiv;
    if (i.fontSize = `calc(${o(this, ye)}px * var(--scale-factor))`, i.color = o(this, Ge), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), rf(this, this.div, ["dblclick", "keydown"]), this.width) {
      const [n, r] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: a
        } = o(this, ao);
        let [h, c] = this.getInitialTranslation();
        [h, c] = this.pageTranslationToScreen(h, c);
        const [d, u] = this.pageDimensions, [f, m] = this.pageTranslation;
        let g, A;
        switch (this.rotation) {
          case 0:
            g = t + (a[0] - f) / d, A = s + this.height - (a[1] - m) / u;
            break;
          case 90:
            g = t + (a[0] - f) / d, A = s - (a[1] - m) / u, [h, c] = [c, -h];
            break;
          case 180:
            g = t - this.width + (a[0] - f) / d, A = s - (a[1] - m) / u, [h, c] = [-h, -c];
            break;
          case 270:
            g = t + (a[0] - f - this.height * u) / d, A = s + (a[1] - m - this.width * d) / u, [h, c] = [-c, h];
            break;
        }
        this.setAt(g * n, A * r, h, c);
      } else
        this.setAt(t * n, s * r, this.width * n, this.height * r);
      v(this, ho, Fu).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  editorDivPaste(t) {
    var g, A, E;
    const s = t.clipboardData || window.clipboardData, {
      types: i
    } = s;
    if (i.length === 1 && i[0] === "text/plain")
      return;
    t.preventDefault();
    const n = v(g = ct, Sc, tv).call(g, s.getData("text") || "").replaceAll(du, `
`);
    if (!n)
      return;
    const r = window.getSelection();
    if (!r.rangeCount)
      return;
    this.editorDiv.normalize(), r.deleteFromDocument();
    const a = r.getRangeAt(0);
    if (!n.includes(`
`)) {
      a.insertNode(document.createTextNode(n)), this.editorDiv.normalize(), r.collapseToStart();
      return;
    }
    const {
      startContainer: h,
      startOffset: c
    } = a, d = [], u = [];
    if (h.nodeType === Node.TEXT_NODE) {
      const y = h.parentElement;
      if (u.push(h.nodeValue.slice(c).replaceAll(du, "")), y !== this.editorDiv) {
        let w = d;
        for (const S of this.editorDiv.childNodes) {
          if (S === y) {
            w = u;
            continue;
          }
          w.push(v(A = ct, lo, ku).call(A, S));
        }
      }
      d.push(h.nodeValue.slice(0, c).replaceAll(du, ""));
    } else if (h === this.editorDiv) {
      let y = d, w = 0;
      for (const S of this.editorDiv.childNodes)
        w++ === c && (y = u), y.push(v(E = ct, lo, ku).call(E, S));
    }
    b(this, be, `${d.join(`
`)}${n}${u.join(`
`)}`), v(this, ho, Fu).call(this);
    const f = new Range();
    let m = d.reduce((y, w) => y + w.length, 0);
    for (const {
      firstChild: y
    } of this.editorDiv.childNodes)
      if (y.nodeType === Node.TEXT_NODE) {
        const w = y.nodeValue.length;
        if (m <= w) {
          f.setStart(y, m), f.setEnd(y, m);
          break;
        }
        m -= w;
      }
    r.removeAllRanges(), r.addRange(f);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static deserialize(t, s, i) {
    var a;
    let n = null;
    if (t instanceof FA) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: h,
            fontColor: c
          },
          rect: d,
          rotation: u,
          id: f
        },
        textContent: m,
        textPosition: g,
        parent: {
          page: {
            pageNumber: A
          }
        }
      } = t;
      if (!m || m.length === 0)
        return null;
      n = t = {
        annotationType: q.FREETEXT,
        color: Array.from(c),
        fontSize: h,
        value: m.join(`
`),
        position: g,
        pageIndex: A - 1,
        rect: d.slice(0),
        rotation: u,
        id: f,
        deleted: !1
      };
    }
    const r = super.deserialize(t, s, i);
    return b(r, ye, t.fontSize), b(r, Ge, U.makeHexColor(...t.color)), b(r, be, v(a = ct, Sc, tv).call(a, t.value)), r.annotationElementId = t.id || null, b(r, ao, n), r;
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return {
        pageIndex: this.pageIndex,
        id: this.annotationElementId,
        deleted: !0
      };
    const s = ct._internalPadding * this.parentScale, i = this.getRect(s, s), n = nt._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : o(this, Ge)), r = {
      annotationType: q.FREETEXT,
      color: n,
      fontSize: o(this, ye),
      value: v(this, vp, zA).call(this),
      pageIndex: this.pageIndex,
      rect: i,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return t ? r : this.annotationElementId && !v(this, bp, WA).call(this, r) ? null : (r.id = this.annotationElementId, r);
  }
  renderAnnotationElement(t) {
    const s = super.renderAnnotationElement(t);
    if (this.deleted)
      return s;
    const {
      style: i
    } = s;
    i.fontSize = `calc(${o(this, ye)}px * var(--scale-factor))`, i.color = o(this, Ge), s.replaceChildren();
    for (const r of o(this, be).split(`
`)) {
      const a = document.createElement("div");
      a.append(r ? document.createTextNode(r) : document.createElement("br")), s.append(a);
    }
    const n = ct._internalPadding * this.parentScale;
    return t.updateEdited({
      rect: this.getRect(n, n),
      popupContent: o(this, be)
    }), s;
  }
  resetAnnotationElement(t) {
    super.resetAnnotationElement(t), t.resetEdited();
  }
};
vc = new WeakMap(), bc = new WeakMap(), yc = new WeakMap(), Ac = new WeakMap(), Ec = new WeakMap(), Ge = new WeakMap(), be = new WeakMap(), wc = new WeakMap(), ye = new WeakMap(), ao = new WeakMap(), pp = new WeakSet(), $A = function(t) {
  const s = (n) => {
    this.editorDiv.style.fontSize = `calc(${n}px * var(--scale-factor))`, this.translate(0, -(n - o(this, ye)) * this.parentScale), b(this, ye, n), v(this, oo, Du).call(this);
  }, i = o(this, ye);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.FREETEXT_SIZE,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, gp = new WeakSet(), VA = function(t) {
  const s = (n) => {
    b(this, Ge, this.editorDiv.style.color = n);
  }, i = o(this, Ge);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.FREETEXT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, mp = new WeakSet(), UA = function() {
  var s;
  const t = [];
  this.editorDiv.normalize();
  for (const i of this.editorDiv.childNodes)
    t.push(v(s = ct, lo, ku).call(s, i));
  return t.join(`
`);
}, oo = new WeakSet(), Du = function() {
  const [t, s] = this.parentDimensions;
  let i;
  if (this.isAttachedToDOM)
    i = this.div.getBoundingClientRect();
  else {
    const {
      currentLayer: n,
      div: r
    } = this, a = r.style.display, h = r.classList.contains("hidden");
    r.classList.remove("hidden"), r.style.display = "hidden", n.div.append(this.div), i = r.getBoundingClientRect(), r.remove(), r.style.display = a, r.classList.toggle("hidden", h);
  }
  this.rotation % 180 === this.parentRotation % 180 ? (this.width = i.width / t, this.height = i.height / s) : (this.width = i.height / t, this.height = i.width / s), this.fixAndSetPosition();
}, lo = new WeakSet(), ku = function(t) {
  return (t.nodeType === Node.TEXT_NODE ? t.nodeValue : t.innerText).replaceAll(du, "");
}, ho = new WeakSet(), Fu = function() {
  if (this.editorDiv.replaceChildren(), !!o(this, be))
    for (const t of o(this, be).split(`
`)) {
      const s = document.createElement("div");
      s.append(t ? document.createTextNode(t) : document.createElement("br")), this.editorDiv.append(s);
    }
}, vp = new WeakSet(), zA = function() {
  return o(this, be).replaceAll(" ", " ");
}, Sc = new WeakSet(), tv = function(t) {
  return t.replaceAll(" ", " ");
}, bp = new WeakSet(), WA = function(t) {
  const {
    value: s,
    fontSize: i,
    color: n,
    pageIndex: r
  } = o(this, ao);
  return this._hasBeenMoved || t.value !== s || t.fontSize !== i || t.color.some((a, h) => a !== n[h]) || t.pageIndex !== r;
}, p(ct, lo), p(ct, Sc), K(ct, "_freeTextDefaultContent", ""), K(ct, "_internalPadding", 0), K(ct, "_defaultColor", null), K(ct, "_defaultFontSize", 10), K(ct, "_type", "freetext"), K(ct, "_editorType", q.FREETEXT);
let qm = ct;
var xc, Ui, Xe, yp, GA, co, Nu, Ap, XA, Ep, KA, Pc, sv, Ty;
let ev = (Ty = class {
  constructor(e, t = 0, s = 0, i = !0) {
    p(this, yp);
    p(this, co);
    p(this, Ap);
    p(this, Ep);
    p(this, Pc);
    p(this, xc, void 0);
    p(this, Ui, []);
    p(this, Xe, []);
    let n = 1 / 0, r = -1 / 0, a = 1 / 0, h = -1 / 0;
    const d = 10 ** -4;
    for (const {
      x: y,
      y: w,
      width: S,
      height: C
    } of e) {
      const P = Math.floor((y - t) / d) * d, x = Math.ceil((y + S + t) / d) * d, R = Math.floor((w - t) / d) * d, M = Math.ceil((w + C + t) / d) * d, T = [P, R, M, !0], I = [x, R, M, !1];
      o(this, Ui).push(T, I), n = Math.min(n, P), r = Math.max(r, x), a = Math.min(a, R), h = Math.max(h, M);
    }
    const u = r - n + 2 * s, f = h - a + 2 * s, m = n - s, g = a - s, A = o(this, Ui).at(i ? -1 : -2), E = [A[0], A[2]];
    for (const y of o(this, Ui)) {
      const [w, S, C] = y;
      y[0] = (w - m) / u, y[1] = (S - g) / f, y[2] = (C - g) / f;
    }
    b(this, xc, {
      x: m,
      y: g,
      width: u,
      height: f,
      lastPoint: E
    });
  }
  getOutlines() {
    o(this, Ui).sort((t, s) => t[0] - s[0] || t[1] - s[1] || t[2] - s[2]);
    const e = [];
    for (const t of o(this, Ui))
      t[3] ? (e.push(...v(this, Pc, sv).call(this, t)), v(this, Ap, XA).call(this, t)) : (v(this, Ep, KA).call(this, t), e.push(...v(this, Pc, sv).call(this, t)));
    return v(this, yp, GA).call(this, e);
  }
}, xc = new WeakMap(), Ui = new WeakMap(), Xe = new WeakMap(), yp = new WeakSet(), GA = function(e) {
  const t = [], s = /* @__PURE__ */ new Set();
  for (const r of e) {
    const [a, h, c] = r;
    t.push([a, h, r], [a, c, r]);
  }
  t.sort((r, a) => r[1] - a[1] || r[0] - a[0]);
  for (let r = 0, a = t.length; r < a; r += 2) {
    const h = t[r][2], c = t[r + 1][2];
    h.push(c), c.push(h), s.add(h), s.add(c);
  }
  const i = [];
  let n;
  for (; s.size > 0; ) {
    const r = s.values().next().value;
    let [a, h, c, d, u] = r;
    s.delete(r);
    let f = a, m = h;
    for (n = [a, c], i.push(n); ; ) {
      let g;
      if (s.has(d))
        g = d;
      else if (s.has(u))
        g = u;
      else
        break;
      s.delete(g), [a, h, c, d, u] = g, f !== a && (n.push(f, m, a, m === h ? h : c), f = a), m = m === h ? c : h;
    }
    n.push(f, m);
  }
  return new RS(i, o(this, xc));
}, co = new WeakSet(), Nu = function(e) {
  const t = o(this, Xe);
  let s = 0, i = t.length - 1;
  for (; s <= i; ) {
    const n = s + i >> 1, r = t[n][0];
    if (r === e)
      return n;
    r < e ? s = n + 1 : i = n - 1;
  }
  return i + 1;
}, Ap = new WeakSet(), XA = function([, e, t]) {
  const s = v(this, co, Nu).call(this, e);
  o(this, Xe).splice(s, 0, [e, t]);
}, Ep = new WeakSet(), KA = function([, e, t]) {
  const s = v(this, co, Nu).call(this, e);
  for (let i = s; i < o(this, Xe).length; i++) {
    const [n, r] = o(this, Xe)[i];
    if (n !== e)
      break;
    if (n === e && r === t) {
      o(this, Xe).splice(i, 1);
      return;
    }
  }
  for (let i = s - 1; i >= 0; i--) {
    const [n, r] = o(this, Xe)[i];
    if (n !== e)
      break;
    if (n === e && r === t) {
      o(this, Xe).splice(i, 1);
      return;
    }
  }
}, Pc = new WeakSet(), sv = function(e) {
  const [t, s, i] = e, n = [[t, s, i]], r = v(this, co, Nu).call(this, i);
  for (let a = 0; a < r; a++) {
    const [h, c] = o(this, Xe)[a];
    for (let d = 0, u = n.length; d < u; d++) {
      const [, f, m] = n[d];
      if (!(c <= f || m <= h)) {
        if (f >= h) {
          if (m > c)
            n[d][1] = c;
          else {
            if (u === 1)
              return [];
            n.splice(d, 1), d--, u--;
          }
          continue;
        }
        n[d][2] = h, m > c && n.push([t, c, m]);
      }
    }
  }
  return n;
}, Ty);
class YA {
  toSVGPath() {
    throw new Error("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    throw new Error("Abstract getter `box` must be implemented.");
  }
  serialize(e, t) {
    throw new Error("Abstract method `serialize` must be implemented.");
  }
  get free() {
    return this instanceof nv;
  }
}
var Tc, uo;
class RS extends YA {
  constructor(t, s) {
    super();
    p(this, Tc, void 0);
    p(this, uo, void 0);
    b(this, uo, t), b(this, Tc, s);
  }
  toSVGPath() {
    const t = [];
    for (const s of o(this, uo)) {
      let [i, n] = s;
      t.push(`M${i} ${n}`);
      for (let r = 2; r < s.length; r += 2) {
        const a = s[r], h = s[r + 1];
        a === i ? (t.push(`V${h}`), n = h) : h === n && (t.push(`H${a}`), i = a);
      }
      t.push("Z");
    }
    return t.join(" ");
  }
  serialize([t, s, i, n], r) {
    const a = [], h = i - t, c = n - s;
    for (const d of o(this, uo)) {
      const u = new Array(d.length);
      for (let f = 0; f < d.length; f += 2)
        u[f] = t + d[f] * h, u[f + 1] = n - d[f + 1] * c;
      a.push(u);
    }
    return a;
  }
  get box() {
    return o(this, Tc);
  }
}
Tc = new WeakMap(), uo = new WeakMap();
var ds, Zs, fo, po, us, Z, lr, hr, Cc, Rc, go, mo, zi, Ic, wp, Sp, Lc, iv;
const _s = class _s {
  constructor({
    x: e,
    y: t
  }, s, i, n, r, a = 0) {
    p(this, Lc);
    p(this, ds, void 0);
    p(this, Zs, []);
    p(this, fo, void 0);
    p(this, po, void 0);
    p(this, us, []);
    p(this, Z, new Float64Array(18));
    p(this, lr, void 0);
    p(this, hr, void 0);
    p(this, Cc, void 0);
    p(this, Rc, void 0);
    p(this, go, void 0);
    p(this, mo, void 0);
    p(this, zi, []);
    b(this, ds, s), b(this, mo, n * i), b(this, po, r), o(this, Z).set([NaN, NaN, NaN, NaN, e, t], 6), b(this, fo, a), b(this, Rc, o(_s, Ic) * i), b(this, Cc, o(_s, Sp) * i), b(this, go, i), o(this, zi).push(e, t);
  }
  get free() {
    return !0;
  }
  isEmpty() {
    return isNaN(o(this, Z)[8]);
  }
  add({
    x: e,
    y: t
  }) {
    var T;
    b(this, lr, e), b(this, hr, t);
    const [s, i, n, r] = o(this, ds);
    let [a, h, c, d] = o(this, Z).subarray(8, 12);
    const u = e - c, f = t - d, m = Math.hypot(u, f);
    if (m < o(this, Cc))
      return !1;
    const g = m - o(this, Rc), A = g / m, E = A * u, y = A * f;
    let w = a, S = h;
    a = c, h = d, c += E, d += y, (T = o(this, zi)) == null || T.push(e, t);
    const C = -y / g, P = E / g, x = C * o(this, mo), R = P * o(this, mo);
    return o(this, Z).set(o(this, Z).subarray(2, 8), 0), o(this, Z).set([c + x, d + R], 4), o(this, Z).set(o(this, Z).subarray(14, 18), 12), o(this, Z).set([c - x, d - R], 16), isNaN(o(this, Z)[6]) ? (o(this, us).length === 0 && (o(this, Z).set([a + x, h + R], 2), o(this, us).push(NaN, NaN, NaN, NaN, (a + x - s) / n, (h + R - i) / r), o(this, Z).set([a - x, h - R], 14), o(this, Zs).push(NaN, NaN, NaN, NaN, (a - x - s) / n, (h - R - i) / r)), o(this, Z).set([w, S, a, h, c, d], 6), !this.isEmpty()) : (o(this, Z).set([w, S, a, h, c, d], 6), Math.abs(Math.atan2(S - h, w - a) - Math.atan2(y, E)) < Math.PI / 2 ? ([a, h, c, d] = o(this, Z).subarray(2, 6), o(this, us).push(NaN, NaN, NaN, NaN, ((a + c) / 2 - s) / n, ((h + d) / 2 - i) / r), [a, h, w, S] = o(this, Z).subarray(14, 18), o(this, Zs).push(NaN, NaN, NaN, NaN, ((w + a) / 2 - s) / n, ((S + h) / 2 - i) / r), !0) : ([w, S, a, h, c, d] = o(this, Z).subarray(0, 6), o(this, us).push(((w + 5 * a) / 6 - s) / n, ((S + 5 * h) / 6 - i) / r, ((5 * a + c) / 6 - s) / n, ((5 * h + d) / 6 - i) / r, ((a + c) / 2 - s) / n, ((h + d) / 2 - i) / r), [c, d, a, h, w, S] = o(this, Z).subarray(12, 18), o(this, Zs).push(((w + 5 * a) / 6 - s) / n, ((S + 5 * h) / 6 - i) / r, ((5 * a + c) / 6 - s) / n, ((5 * h + d) / 6 - i) / r, ((a + c) / 2 - s) / n, ((h + d) / 2 - i) / r), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const e = o(this, us), t = o(this, Zs), s = o(this, Z).subarray(4, 6), i = o(this, Z).subarray(16, 18), [n, r, a, h] = o(this, ds), [c, d, u, f] = v(this, Lc, iv).call(this);
    if (isNaN(o(this, Z)[6]) && !this.isEmpty())
      return `M${(o(this, Z)[2] - n) / a} ${(o(this, Z)[3] - r) / h} L${(o(this, Z)[4] - n) / a} ${(o(this, Z)[5] - r) / h} L${c} ${d} L${u} ${f} L${(o(this, Z)[16] - n) / a} ${(o(this, Z)[17] - r) / h} L${(o(this, Z)[14] - n) / a} ${(o(this, Z)[15] - r) / h} Z`;
    const m = [];
    m.push(`M${e[4]} ${e[5]}`);
    for (let g = 6; g < e.length; g += 6)
      isNaN(e[g]) ? m.push(`L${e[g + 4]} ${e[g + 5]}`) : m.push(`C${e[g]} ${e[g + 1]} ${e[g + 2]} ${e[g + 3]} ${e[g + 4]} ${e[g + 5]}`);
    m.push(`L${(s[0] - n) / a} ${(s[1] - r) / h} L${c} ${d} L${u} ${f} L${(i[0] - n) / a} ${(i[1] - r) / h}`);
    for (let g = t.length - 6; g >= 6; g -= 6)
      isNaN(t[g]) ? m.push(`L${t[g + 4]} ${t[g + 5]}`) : m.push(`C${t[g]} ${t[g + 1]} ${t[g + 2]} ${t[g + 3]} ${t[g + 4]} ${t[g + 5]}`);
    return m.push(`L${t[4]} ${t[5]} Z`), m.join(" ");
  }
  getOutlines() {
    var y;
    const e = o(this, us), t = o(this, Zs), s = o(this, Z), i = s.subarray(4, 6), n = s.subarray(16, 18), [r, a, h, c] = o(this, ds), d = new Float64Array((((y = o(this, zi)) == null ? void 0 : y.length) ?? 0) + 2);
    for (let w = 0, S = d.length - 2; w < S; w += 2)
      d[w] = (o(this, zi)[w] - r) / h, d[w + 1] = (o(this, zi)[w + 1] - a) / c;
    d[d.length - 2] = (o(this, lr) - r) / h, d[d.length - 1] = (o(this, hr) - a) / c;
    const [u, f, m, g] = v(this, Lc, iv).call(this);
    if (isNaN(s[6]) && !this.isEmpty()) {
      const w = new Float64Array(36);
      return w.set([NaN, NaN, NaN, NaN, (s[2] - r) / h, (s[3] - a) / c, NaN, NaN, NaN, NaN, (s[4] - r) / h, (s[5] - a) / c, NaN, NaN, NaN, NaN, u, f, NaN, NaN, NaN, NaN, m, g, NaN, NaN, NaN, NaN, (s[16] - r) / h, (s[17] - a) / c, NaN, NaN, NaN, NaN, (s[14] - r) / h, (s[15] - a) / c], 0), new nv(w, d, o(this, ds), o(this, go), o(this, fo), o(this, po));
    }
    const A = new Float64Array(o(this, us).length + 24 + o(this, Zs).length);
    let E = e.length;
    for (let w = 0; w < E; w += 2) {
      if (isNaN(e[w])) {
        A[w] = A[w + 1] = NaN;
        continue;
      }
      A[w] = e[w], A[w + 1] = e[w + 1];
    }
    A.set([NaN, NaN, NaN, NaN, (i[0] - r) / h, (i[1] - a) / c, NaN, NaN, NaN, NaN, u, f, NaN, NaN, NaN, NaN, m, g, NaN, NaN, NaN, NaN, (n[0] - r) / h, (n[1] - a) / c], E), E += 24;
    for (let w = t.length - 6; w >= 6; w -= 6)
      for (let S = 0; S < 6; S += 2) {
        if (isNaN(t[w + S])) {
          A[E] = A[E + 1] = NaN, E += 2;
          continue;
        }
        A[E] = t[w + S], A[E + 1] = t[w + S + 1], E += 2;
      }
    return A.set([NaN, NaN, NaN, NaN, t[4], t[5]], E), new nv(A, d, o(this, ds), o(this, go), o(this, fo), o(this, po));
  }
};
ds = new WeakMap(), Zs = new WeakMap(), fo = new WeakMap(), po = new WeakMap(), us = new WeakMap(), Z = new WeakMap(), lr = new WeakMap(), hr = new WeakMap(), Cc = new WeakMap(), Rc = new WeakMap(), go = new WeakMap(), mo = new WeakMap(), zi = new WeakMap(), Ic = new WeakMap(), wp = new WeakMap(), Sp = new WeakMap(), Lc = new WeakSet(), iv = function() {
  const e = o(this, Z).subarray(4, 6), t = o(this, Z).subarray(16, 18), [s, i, n, r] = o(this, ds);
  return [(o(this, lr) + (e[0] - t[0]) / 2 - s) / n, (o(this, hr) + (e[1] - t[1]) / 2 - i) / r, (o(this, lr) + (t[0] - e[0]) / 2 - s) / n, (o(this, hr) + (t[1] - e[1]) / 2 - i) / r];
}, p(_s, Ic, 8), p(_s, wp, 2), p(_s, Sp, o(_s, Ic) + o(_s, wp));
let hf = _s;
var vo, cr, Js, _c, Ae, Mc, Et, dr, xl, ur, Pl, xp, QA;
class nv extends YA {
  constructor(t, s, i, n, r, a) {
    super();
    p(this, dr);
    p(this, ur);
    p(this, xp);
    p(this, vo, void 0);
    p(this, cr, null);
    p(this, Js, void 0);
    p(this, _c, void 0);
    p(this, Ae, void 0);
    p(this, Mc, void 0);
    p(this, Et, void 0);
    b(this, Et, t), b(this, Ae, s), b(this, vo, i), b(this, Mc, n), b(this, Js, r), b(this, _c, a), v(this, xp, QA).call(this, a);
    const {
      x: h,
      y: c,
      width: d,
      height: u
    } = o(this, cr);
    for (let f = 0, m = t.length; f < m; f += 2)
      t[f] = (t[f] - h) / d, t[f + 1] = (t[f + 1] - c) / u;
    for (let f = 0, m = s.length; f < m; f += 2)
      s[f] = (s[f] - h) / d, s[f + 1] = (s[f + 1] - c) / u;
  }
  toSVGPath() {
    const t = [`M${o(this, Et)[4]} ${o(this, Et)[5]}`];
    for (let s = 6, i = o(this, Et).length; s < i; s += 6) {
      if (isNaN(o(this, Et)[s])) {
        t.push(`L${o(this, Et)[s + 4]} ${o(this, Et)[s + 5]}`);
        continue;
      }
      t.push(`C${o(this, Et)[s]} ${o(this, Et)[s + 1]} ${o(this, Et)[s + 2]} ${o(this, Et)[s + 3]} ${o(this, Et)[s + 4]} ${o(this, Et)[s + 5]}`);
    }
    return t.push("Z"), t.join(" ");
  }
  serialize([t, s, i, n], r) {
    const a = i - t, h = n - s;
    let c, d;
    switch (r) {
      case 0:
        c = v(this, dr, xl).call(this, o(this, Et), t, n, a, -h), d = v(this, dr, xl).call(this, o(this, Ae), t, n, a, -h);
        break;
      case 90:
        c = v(this, ur, Pl).call(this, o(this, Et), t, s, a, h), d = v(this, ur, Pl).call(this, o(this, Ae), t, s, a, h);
        break;
      case 180:
        c = v(this, dr, xl).call(this, o(this, Et), i, s, -a, h), d = v(this, dr, xl).call(this, o(this, Ae), i, s, -a, h);
        break;
      case 270:
        c = v(this, ur, Pl).call(this, o(this, Et), i, n, -a, -h), d = v(this, ur, Pl).call(this, o(this, Ae), i, n, -a, -h);
        break;
    }
    return {
      outline: Array.from(c),
      points: [Array.from(d)]
    };
  }
  get box() {
    return o(this, cr);
  }
  getNewOutline(t, s) {
    const {
      x: i,
      y: n,
      width: r,
      height: a
    } = o(this, cr), [h, c, d, u] = o(this, vo), f = r * d, m = a * u, g = i * d + h, A = n * u + c, E = new hf({
      x: o(this, Ae)[0] * f + g,
      y: o(this, Ae)[1] * m + A
    }, o(this, vo), o(this, Mc), t, o(this, _c), s ?? o(this, Js));
    for (let y = 2; y < o(this, Ae).length; y += 2)
      E.add({
        x: o(this, Ae)[y] * f + g,
        y: o(this, Ae)[y + 1] * m + A
      });
    return E.getOutlines();
  }
}
vo = new WeakMap(), cr = new WeakMap(), Js = new WeakMap(), _c = new WeakMap(), Ae = new WeakMap(), Mc = new WeakMap(), Et = new WeakMap(), dr = new WeakSet(), xl = function(t, s, i, n, r) {
  const a = new Float64Array(t.length);
  for (let h = 0, c = t.length; h < c; h += 2)
    a[h] = s + t[h] * n, a[h + 1] = i + t[h + 1] * r;
  return a;
}, ur = new WeakSet(), Pl = function(t, s, i, n, r) {
  const a = new Float64Array(t.length);
  for (let h = 0, c = t.length; h < c; h += 2)
    a[h] = s + t[h + 1] * n, a[h + 1] = i + t[h] * r;
  return a;
}, xp = new WeakSet(), QA = function(t) {
  const s = o(this, Et);
  let i = s[4], n = s[5], r = i, a = n, h = i, c = n, d = i, u = n;
  const f = t ? Math.max : Math.min;
  for (let y = 6, w = s.length; y < w; y += 6) {
    if (isNaN(s[y]))
      r = Math.min(r, s[y + 4]), a = Math.min(a, s[y + 5]), h = Math.max(h, s[y + 4]), c = Math.max(c, s[y + 5]), u < s[y + 5] ? (d = s[y + 4], u = s[y + 5]) : u === s[y + 5] && (d = f(d, s[y + 4]));
    else {
      const S = U.bezierBoundingBox(i, n, ...s.slice(y, y + 6));
      r = Math.min(r, S[0]), a = Math.min(a, S[1]), h = Math.max(h, S[2]), c = Math.max(c, S[3]), u < S[3] ? (d = S[2], u = S[3]) : u === S[3] && (d = f(d, S[2]));
    }
    i = s[y + 4], n = s[y + 5];
  }
  const m = r - o(this, Js), g = a - o(this, Js), A = h - r + 2 * o(this, Js), E = c - a + 2 * o(this, Js);
  b(this, cr, {
    x: m,
    y: g,
    width: A,
    height: E,
    lastPoint: [d, u]
  });
};
var Oc, Dc, Ke, fr, bo, Rt, kc, yo, Fc, Nc, Ye, Ao, Bc, rv, jc, av, Pp, JA, qs, yn, Tp, qA, fs, Ei, qe;
let ZA = (qe = class {
  constructor({
    editor: e = null,
    uiManager: t = null
  }) {
    p(this, Bc);
    p(this, jc);
    p(this, Pp);
    p(this, qs);
    p(this, Tp);
    p(this, fs);
    p(this, Oc, v(this, Pp, JA).bind(this));
    p(this, Dc, v(this, Tp, qA).bind(this));
    p(this, Ke, null);
    p(this, fr, null);
    p(this, bo, void 0);
    p(this, Rt, null);
    p(this, kc, !1);
    p(this, yo, !1);
    p(this, Fc, null);
    p(this, Nc, void 0);
    p(this, Ye, null);
    p(this, Ao, void 0);
    var s;
    e ? (b(this, yo, !1), b(this, Ao, X.HIGHLIGHT_COLOR), b(this, Fc, e)) : (b(this, yo, !0), b(this, Ao, X.HIGHLIGHT_DEFAULT_COLOR)), b(this, Ye, (e == null ? void 0 : e._uiManager) || t), b(this, Nc, o(this, Ye)._eventBus), b(this, bo, (e == null ? void 0 : e.color) || ((s = o(this, Ye)) == null ? void 0 : s.highlightColors.values().next().value) || "#FFFF98");
  }
  static get _keyboardManager() {
    return et(this, "_keyboardManager", new iu([[["Escape", "mac+Escape"], qe.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], qe.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], qe.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], qe.prototype._moveToPrevious], [["Home", "mac+Home"], qe.prototype._moveToBeginning], [["End", "mac+End"], qe.prototype._moveToEnd]]));
  }
  renderButton() {
    const e = b(this, Ke, document.createElement("button"));
    e.className = "colorPicker", e.tabIndex = "0", e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e.setAttribute("aria-haspopup", !0);
    const t = o(this, Ye)._signal;
    e.addEventListener("click", v(this, qs, yn).bind(this), {
      signal: t
    }), e.addEventListener("keydown", o(this, Oc), {
      signal: t
    });
    const s = b(this, fr, document.createElement("span"));
    return s.className = "swatch", s.setAttribute("aria-hidden", !0), s.style.backgroundColor = o(this, bo), e.append(s), e;
  }
  renderMainDropdown() {
    const e = b(this, Rt, v(this, Bc, rv).call(this));
    return e.setAttribute("aria-orientation", "horizontal"), e.setAttribute("aria-labelledby", "highlightColorPickerLabel"), e;
  }
  _colorSelectFromKeyboard(e) {
    if (e.target === o(this, Ke)) {
      v(this, qs, yn).call(this, e);
      return;
    }
    const t = e.target.getAttribute("data-color");
    t && v(this, jc, av).call(this, t, e);
  }
  _moveToNext(e) {
    var t, s;
    if (!o(this, fs, Ei)) {
      v(this, qs, yn).call(this, e);
      return;
    }
    if (e.target === o(this, Ke)) {
      (t = o(this, Rt).firstChild) == null || t.focus();
      return;
    }
    (s = e.target.nextSibling) == null || s.focus();
  }
  _moveToPrevious(e) {
    var t, s;
    if (e.target === ((t = o(this, Rt)) == null ? void 0 : t.firstChild) || e.target === o(this, Ke)) {
      o(this, fs, Ei) && this._hideDropdownFromKeyboard();
      return;
    }
    o(this, fs, Ei) || v(this, qs, yn).call(this, e), (s = e.target.previousSibling) == null || s.focus();
  }
  _moveToBeginning(e) {
    var t;
    if (!o(this, fs, Ei)) {
      v(this, qs, yn).call(this, e);
      return;
    }
    (t = o(this, Rt).firstChild) == null || t.focus();
  }
  _moveToEnd(e) {
    var t;
    if (!o(this, fs, Ei)) {
      v(this, qs, yn).call(this, e);
      return;
    }
    (t = o(this, Rt).lastChild) == null || t.focus();
  }
  hideDropdown() {
    var e;
    (e = o(this, Rt)) == null || e.classList.add("hidden"), window.removeEventListener("pointerdown", o(this, Dc));
  }
  _hideDropdownFromKeyboard() {
    var e;
    if (!o(this, yo)) {
      if (!o(this, fs, Ei)) {
        (e = o(this, Fc)) == null || e.unselect();
        return;
      }
      this.hideDropdown(), o(this, Ke).focus({
        preventScroll: !0,
        focusVisible: o(this, kc)
      });
    }
  }
  updateColor(e) {
    if (o(this, fr) && (o(this, fr).style.backgroundColor = e), !o(this, Rt))
      return;
    const t = o(this, Ye).highlightColors.values();
    for (const s of o(this, Rt).children)
      s.setAttribute("aria-selected", t.next().value === e);
  }
  destroy() {
    var e, t;
    (e = o(this, Ke)) == null || e.remove(), b(this, Ke, null), b(this, fr, null), (t = o(this, Rt)) == null || t.remove(), b(this, Rt, null);
  }
}, Oc = new WeakMap(), Dc = new WeakMap(), Ke = new WeakMap(), fr = new WeakMap(), bo = new WeakMap(), Rt = new WeakMap(), kc = new WeakMap(), yo = new WeakMap(), Fc = new WeakMap(), Nc = new WeakMap(), Ye = new WeakMap(), Ao = new WeakMap(), Bc = new WeakSet(), rv = function() {
  const e = document.createElement("div"), t = o(this, Ye)._signal;
  e.addEventListener("contextmenu", fe, {
    signal: t
  }), e.className = "dropdown", e.role = "listbox", e.setAttribute("aria-multiselectable", !1), e.setAttribute("aria-orientation", "vertical"), e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [s, i] of o(this, Ye).highlightColors) {
    const n = document.createElement("button");
    n.tabIndex = "0", n.role = "option", n.setAttribute("data-color", i), n.title = s, n.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${s}`);
    const r = document.createElement("span");
    n.append(r), r.className = "swatch", r.style.backgroundColor = i, n.setAttribute("aria-selected", i === o(this, bo)), n.addEventListener("click", v(this, jc, av).bind(this, i), {
      signal: t
    }), e.append(n);
  }
  return e.addEventListener("keydown", o(this, Oc), {
    signal: t
  }), e;
}, jc = new WeakSet(), av = function(e, t) {
  t.stopPropagation(), o(this, Nc).dispatch("switchannotationeditorparams", {
    source: this,
    type: o(this, Ao),
    value: e
  });
}, Pp = new WeakSet(), JA = function(e) {
  qe._keyboardManager.exec(this, e);
}, qs = new WeakSet(), yn = function(e) {
  if (o(this, fs, Ei)) {
    this.hideDropdown();
    return;
  }
  if (b(this, kc, e.detail === 0), window.addEventListener("pointerdown", o(this, Dc), {
    signal: o(this, Ye)._signal
  }), o(this, Rt)) {
    o(this, Rt).classList.remove("hidden");
    return;
  }
  const t = b(this, Rt, v(this, Bc, rv).call(this));
  o(this, Ke).append(t);
}, Tp = new WeakSet(), qA = function(e) {
  var t;
  (t = o(this, Rt)) != null && t.contains(e.target) || this.hideDropdown();
}, fs = new WeakSet(), Ei = function() {
  return o(this, Rt) && !o(this, Rt).classList.contains("hidden");
}, qe);
var Eo, Hc, Wi, pr, wo, Ie, $c, Vc, gr, Qe, ee, Ee, Cp, So, mr, It, xo, ps, Uc, zc, ov, Wc, lv, Rp, tE, Ip, eE, Lp, sE, Gc, hv, vr, Tl, Gi, ca, _p, iE, Po, Bu, br, Cl, Mp, nE, Op, rE, Dp, aE, kp, oE;
const tt = class tt extends nt {
  constructor(t) {
    super({
      ...t,
      name: "highlightEditor"
    });
    p(this, zc);
    p(this, Wc);
    p(this, Rp);
    p(this, Ip);
    p(this, Lp);
    p(this, Gc);
    p(this, vr);
    p(this, _p);
    p(this, Po);
    p(this, br);
    p(this, Mp);
    p(this, Op);
    p(this, Eo, null);
    p(this, Hc, 0);
    p(this, Wi, void 0);
    p(this, pr, null);
    p(this, wo, null);
    p(this, Ie, null);
    p(this, $c, null);
    p(this, Vc, 0);
    p(this, gr, null);
    p(this, Qe, null);
    p(this, ee, null);
    p(this, Ee, !1);
    p(this, Cp, v(this, _p, iE).bind(this));
    p(this, So, null);
    p(this, mr, void 0);
    p(this, It, null);
    p(this, xo, "");
    p(this, ps, void 0);
    p(this, Uc, "");
    this.color = t.color || tt._defaultColor, b(this, ps, t.thickness || tt._defaultThickness), b(this, mr, t.opacity || tt._defaultOpacity), b(this, Wi, t.boxes || null), b(this, Uc, t.methodOfCreation || ""), b(this, xo, t.text || ""), this._isDraggable = !1, t.highlightId > -1 ? (b(this, Ee, !0), v(this, Wc, lv).call(this, t), v(this, vr, Tl).call(this)) : (b(this, Eo, t.anchorNode), b(this, Hc, t.anchorOffset), b(this, $c, t.focusNode), b(this, Vc, t.focusOffset), v(this, zc, ov).call(this), v(this, vr, Tl).call(this), this.rotate(this.rotation));
  }
  static get _keyboardManager() {
    const t = tt.prototype;
    return et(this, "_keyboardManager", new iu([[["ArrowLeft", "mac+ArrowLeft"], t._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], t._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], t._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], t._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: o(this, Ee) ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: o(this, ps),
      methodOfCreation: o(this, Uc)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(t) {
    return {
      numberOfColors: t.get("color").size
    };
  }
  static initialize(t, s) {
    var i;
    nt.initialize(t, s), tt._defaultColor || (tt._defaultColor = ((i = s.highlightColors) == null ? void 0 : i.values().next().value) || "#fff066");
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case X.HIGHLIGHT_DEFAULT_COLOR:
        tt._defaultColor = s;
        break;
      case X.HIGHLIGHT_THICKNESS:
        tt._defaultThickness = s;
        break;
    }
  }
  translateInPage(t, s) {
  }
  get toolbarPosition() {
    return o(this, So);
  }
  updateParams(t, s) {
    switch (t) {
      case X.HIGHLIGHT_COLOR:
        v(this, Rp, tE).call(this, s);
        break;
      case X.HIGHLIGHT_THICKNESS:
        v(this, Ip, eE).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[X.HIGHLIGHT_DEFAULT_COLOR, tt._defaultColor], [X.HIGHLIGHT_THICKNESS, tt._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[X.HIGHLIGHT_COLOR, this.color || tt._defaultColor], [X.HIGHLIGHT_THICKNESS, o(this, ps) || tt._defaultThickness], [X.HIGHLIGHT_FREE, o(this, Ee)]];
  }
  async addEditToolbar() {
    const t = await super.addEditToolbar();
    return t ? (this._uiManager.highlightColors && (b(this, wo, new ZA({
      editor: this
    })), t.addColorPicker(o(this, wo))), t) : null;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(v(this, br, Cl).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(t, s) {
    return super.getRect(t, s, v(this, br, Cl).call(this));
  }
  onceAdded() {
    this.parent.addUndoableEditor(this), this.div.focus();
  }
  remove() {
    v(this, Gc, hv).call(this), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (v(this, vr, Tl).call(this), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    var i;
    let s = !1;
    this.parent && !t ? v(this, Gc, hv).call(this) : t && (v(this, vr, Tl).call(this, t), s = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(t), this.show(this._isVisible), s && this.select();
  }
  rotate(t) {
    var n, r, a;
    const {
      drawLayer: s
    } = this.parent;
    let i;
    o(this, Ee) ? (t = (t - this.rotation + 360) % 360, i = v(n = tt, Gi, ca).call(n, o(this, Qe).box, t)) : i = v(r = tt, Gi, ca).call(r, this, t), s.rotate(o(this, ee), t), s.rotate(o(this, It), t), s.updateBox(o(this, ee), i), s.updateBox(o(this, It), v(a = tt, Gi, ca).call(a, o(this, Ie).box, t));
  }
  render() {
    if (this.div)
      return this.div;
    const t = super.render();
    o(this, xo) && (t.setAttribute("aria-label", o(this, xo)), t.setAttribute("role", "mark")), o(this, Ee) ? t.classList.add("free") : this.div.addEventListener("keydown", o(this, Cp), {
      signal: this._uiManager._signal
    });
    const s = b(this, gr, document.createElement("div"));
    t.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal", s.style.clipPath = o(this, pr);
    const [i, n] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * n), rf(this, o(this, gr), ["pointerover", "pointerleave"]), this.enableEditing(), t;
  }
  pointerover() {
    this.parent.drawLayer.addClass(o(this, It), "hovered");
  }
  pointerleave() {
    this.parent.drawLayer.removeClass(o(this, It), "hovered");
  }
  _moveCaret(t) {
    switch (this.parent.unselect(this), t) {
      case 0:
      case 2:
        v(this, Po, Bu).call(this, !0);
        break;
      case 1:
      case 3:
        v(this, Po, Bu).call(this, !1);
        break;
    }
  }
  select() {
    var t, s;
    super.select(), o(this, It) && ((t = this.parent) == null || t.drawLayer.removeClass(o(this, It), "hovered"), (s = this.parent) == null || s.drawLayer.addClass(o(this, It), "selected"));
  }
  unselect() {
    var t;
    super.unselect(), o(this, It) && ((t = this.parent) == null || t.drawLayer.removeClass(o(this, It), "selected"), o(this, Ee) || v(this, Po, Bu).call(this, !1));
  }
  get _mustFixPosition() {
    return !o(this, Ee);
  }
  show(t = this._isVisible) {
    super.show(t), this.parent && (this.parent.drawLayer.show(o(this, ee), t), this.parent.drawLayer.show(o(this, It), t));
  }
  static startHighlighting(t, s, {
    target: i,
    x: n,
    y: r
  }) {
    const {
      x: a,
      y: h,
      width: c,
      height: d
    } = i.getBoundingClientRect(), u = (E) => {
      v(this, Dp, aE).call(this, t, E);
    }, f = t._signal, m = {
      capture: !0,
      passive: !1,
      signal: f
    }, g = (E) => {
      E.preventDefault(), E.stopPropagation();
    }, A = (E) => {
      i.removeEventListener("pointermove", u), window.removeEventListener("blur", A), window.removeEventListener("pointerup", A), window.removeEventListener("pointerdown", g, m), window.removeEventListener("contextmenu", fe), v(this, kp, oE).call(this, t, E);
    };
    window.addEventListener("blur", A, {
      signal: f
    }), window.addEventListener("pointerup", A, {
      signal: f
    }), window.addEventListener("pointerdown", g, m), window.addEventListener("contextmenu", fe, {
      signal: f
    }), i.addEventListener("pointermove", u, {
      signal: f
    }), this._freeHighlight = new hf({
      x: n,
      y: r
    }, [a, h, c, d], t.scale, this._defaultThickness / 2, s, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = t.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
  }
  static deserialize(t, s, i) {
    var A;
    const n = super.deserialize(t, s, i), {
      rect: [r, a, h, c],
      color: d,
      quadPoints: u
    } = t;
    n.color = U.makeHexColor(...d), b(n, mr, t.opacity);
    const [f, m] = n.pageDimensions;
    n.width = (h - r) / f, n.height = (c - a) / m;
    const g = b(n, Wi, []);
    for (let E = 0; E < u.length; E += 8)
      g.push({
        x: (u[4] - h) / f,
        y: (c - (1 - u[E + 5])) / m,
        width: (u[E + 2] - u[E]) / f,
        height: (u[E + 5] - u[E + 1]) / m
      });
    return v(A = n, zc, ov).call(A), n;
  }
  serialize(t = !1) {
    if (this.isEmpty() || t)
      return null;
    const s = this.getRect(0, 0), i = nt._colorManager.convert(this.color);
    return {
      annotationType: q.HIGHLIGHT,
      color: i,
      opacity: o(this, mr),
      thickness: o(this, ps),
      quadPoints: v(this, Mp, nE).call(this),
      outlines: v(this, Op, rE).call(this, s),
      pageIndex: this.pageIndex,
      rect: s,
      rotation: v(this, br, Cl).call(this),
      structTreeParentId: this._structTreeParentId
    };
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
Eo = new WeakMap(), Hc = new WeakMap(), Wi = new WeakMap(), pr = new WeakMap(), wo = new WeakMap(), Ie = new WeakMap(), $c = new WeakMap(), Vc = new WeakMap(), gr = new WeakMap(), Qe = new WeakMap(), ee = new WeakMap(), Ee = new WeakMap(), Cp = new WeakMap(), So = new WeakMap(), mr = new WeakMap(), It = new WeakMap(), xo = new WeakMap(), ps = new WeakMap(), Uc = new WeakMap(), zc = new WeakSet(), ov = function() {
  const t = new ev(o(this, Wi), 1e-3);
  b(this, Qe, t.getOutlines()), {
    x: this.x,
    y: this.y,
    width: this.width,
    height: this.height
  } = o(this, Qe).box;
  const s = new ev(o(this, Wi), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  b(this, Ie, s.getOutlines());
  const {
    lastPoint: i
  } = o(this, Ie).box;
  b(this, So, [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height]);
}, Wc = new WeakSet(), lv = function({
  highlightOutlines: t,
  highlightId: s,
  clipPathId: i
}) {
  var u, f;
  b(this, Qe, t);
  const n = 1.5;
  if (b(this, Ie, t.getNewOutline(o(this, ps) / 2 + n, 25e-4)), s >= 0)
    b(this, ee, s), b(this, pr, i), this.parent.drawLayer.finalizeLine(s, t), b(this, It, this.parent.drawLayer.highlightOutline(o(this, Ie)));
  else if (this.parent) {
    const m = this.parent.viewport.rotation;
    this.parent.drawLayer.updateLine(o(this, ee), t), this.parent.drawLayer.updateBox(o(this, ee), v(u = tt, Gi, ca).call(u, o(this, Qe).box, (m - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(o(this, It), o(this, Ie)), this.parent.drawLayer.updateBox(o(this, It), v(f = tt, Gi, ca).call(f, o(this, Ie).box, m));
  }
  const {
    x: r,
    y: a,
    width: h,
    height: c
  } = t.box;
  switch (this.rotation) {
    case 0:
      this.x = r, this.y = a, this.width = h, this.height = c;
      break;
    case 90: {
      const [m, g] = this.parentDimensions;
      this.x = a, this.y = 1 - r, this.width = h * g / m, this.height = c * m / g;
      break;
    }
    case 180:
      this.x = 1 - r, this.y = 1 - a, this.width = h, this.height = c;
      break;
    case 270: {
      const [m, g] = this.parentDimensions;
      this.x = 1 - a, this.y = r, this.width = h * g / m, this.height = c * m / g;
      break;
    }
  }
  const {
    lastPoint: d
  } = o(this, Ie).box;
  b(this, So, [(d[0] - r) / h, (d[1] - a) / c]);
}, Rp = new WeakSet(), tE = function(t) {
  const s = (n) => {
    var r, a;
    this.color = n, (r = this.parent) == null || r.drawLayer.changeColor(o(this, ee), n), (a = o(this, wo)) == null || a.updateColor(n);
  }, i = this.color;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.HIGHLIGHT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.highlightColorNames.get(t)
  }, !0);
}, Ip = new WeakSet(), eE = function(t) {
  const s = o(this, ps), i = (n) => {
    b(this, ps, n), v(this, Lp, sE).call(this, n);
  };
  this.addCommands({
    cmd: i.bind(this, t),
    undo: i.bind(this, s),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "thickness_changed",
    thickness: t
  }, !0);
}, Lp = new WeakSet(), sE = function(t) {
  if (!o(this, Ee))
    return;
  v(this, Wc, lv).call(this, {
    highlightOutlines: o(this, Qe).getNewOutline(t / 2)
  }), this.fixAndSetPosition();
  const [s, i] = this.parentDimensions;
  this.setDims(this.width * s, this.height * i);
}, Gc = new WeakSet(), hv = function() {
  o(this, ee) === null || !this.parent || (this.parent.drawLayer.remove(o(this, ee)), b(this, ee, null), this.parent.drawLayer.remove(o(this, It)), b(this, It, null));
}, vr = new WeakSet(), Tl = function(t = this.parent) {
  o(this, ee) === null && ({
    id: oe(this, ee)._,
    clipPathId: oe(this, pr)._
  } = t.drawLayer.highlight(o(this, Qe), this.color, o(this, mr)), b(this, It, t.drawLayer.highlightOutline(o(this, Ie))), o(this, gr) && (o(this, gr).style.clipPath = o(this, pr)));
}, Gi = new WeakSet(), ca = function({
  x: t,
  y: s,
  width: i,
  height: n
}, r) {
  switch (r) {
    case 90:
      return {
        x: 1 - s - n,
        y: t,
        width: n,
        height: i
      };
    case 180:
      return {
        x: 1 - t - i,
        y: 1 - s - n,
        width: i,
        height: n
      };
    case 270:
      return {
        x: s,
        y: 1 - t - i,
        width: n,
        height: i
      };
  }
  return {
    x: t,
    y: s,
    width: i,
    height: n
  };
}, _p = new WeakSet(), iE = function(t) {
  tt._keyboardManager.exec(this, t);
}, Po = new WeakSet(), Bu = function(t) {
  if (!o(this, Eo))
    return;
  const s = window.getSelection();
  t ? s.setPosition(o(this, Eo), o(this, Hc)) : s.setPosition(o(this, $c), o(this, Vc));
}, br = new WeakSet(), Cl = function() {
  return o(this, Ee) ? this.rotation : 0;
}, Mp = new WeakSet(), nE = function() {
  if (o(this, Ee))
    return null;
  const [t, s] = this.pageDimensions, i = o(this, Wi), n = new Float32Array(i.length * 8);
  let r = 0;
  for (const {
    x: a,
    y: h,
    width: c,
    height: d
  } of i) {
    const u = a * t, f = (1 - h - d) * s;
    n[r] = n[r + 4] = u, n[r + 1] = n[r + 3] = f, n[r + 2] = n[r + 6] = u + c * t, n[r + 5] = n[r + 7] = f + d * s, r += 8;
  }
  return n;
}, Op = new WeakSet(), rE = function(t) {
  return o(this, Qe).serialize(t, v(this, br, Cl).call(this));
}, Dp = new WeakSet(), aE = function(t, s) {
  this._freeHighlight.add(s) && t.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
}, kp = new WeakSet(), oE = function(t, s) {
  this._freeHighlight.isEmpty() ? t.drawLayer.removeFreeHighlight(this._freeHighlightId) : t.createAndAddNewEditor(s, !1, {
    highlightId: this._freeHighlightId,
    highlightOutlines: this._freeHighlight.getOutlines(),
    clipPathId: this._freeHighlightClipId,
    methodOfCreation: "main_toolbar"
  }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
}, p(tt, Gi), p(tt, Dp), p(tt, kp), K(tt, "_defaultColor", null), K(tt, "_defaultOpacity", 1), K(tt, "_defaultThickness", 12), K(tt, "_l10nPromise"), K(tt, "_type", "highlight"), K(tt, "_editorType", q.HIGHLIGHT), K(tt, "_freeHighlightId", -1), K(tt, "_freeHighlight", null), K(tt, "_freeHighlightClipId", "");
let cf = tt;
var yr, Ar, Xc, Kc, Yc, Er, gs, ti, Le, wr, Sr, ei, xr, Pr, Xi, Fp, lE, Np, hE, Bp, cE, jp, dE, Qc, dv, Hp, uE, Zc, uv, $p, fE, Vp, pE, Up, gE, zp, mE, Wp, vE, si, An, Jc, fv, To, ju, Co, Hu, Ki, da, qc, pv, Ro, $u, Gp, bE, td, gv, Xp, yE, Kp, AE, ed, mv, Io, Vu, Tr, Rl;
const ft = class ft extends nt {
  constructor(t) {
    super({
      ...t,
      name: "inkEditor"
    });
    p(this, Fp);
    p(this, Np);
    p(this, Bp);
    p(this, jp);
    p(this, Qc);
    p(this, Hp);
    p(this, Zc);
    p(this, $p);
    p(this, Vp);
    p(this, Up);
    p(this, zp);
    p(this, Wp);
    p(this, si);
    p(this, Jc);
    p(this, To);
    p(this, Co);
    p(this, Ki);
    p(this, qc);
    p(this, Ro);
    p(this, Kp);
    p(this, ed);
    p(this, Io);
    p(this, Tr);
    p(this, yr, 0);
    p(this, Ar, 0);
    p(this, Xc, this.canvasPointermove.bind(this));
    p(this, Kc, this.canvasPointerleave.bind(this));
    p(this, Yc, this.canvasPointerup.bind(this));
    p(this, Er, this.canvasPointerdown.bind(this));
    p(this, gs, null);
    p(this, ti, new Path2D());
    p(this, Le, !1);
    p(this, wr, !1);
    p(this, Sr, !1);
    p(this, ei, null);
    p(this, xr, 0);
    p(this, Pr, 0);
    p(this, Xi, null);
    this.color = t.color || null, this.thickness = t.thickness || null, this.opacity = t.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
  }
  static initialize(t, s) {
    nt.initialize(t, s);
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case X.INK_THICKNESS:
        ft._defaultThickness = s;
        break;
      case X.INK_COLOR:
        ft._defaultColor = s;
        break;
      case X.INK_OPACITY:
        ft._defaultOpacity = s / 100;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case X.INK_THICKNESS:
        v(this, Fp, lE).call(this, s);
        break;
      case X.INK_COLOR:
        v(this, Np, hE).call(this, s);
        break;
      case X.INK_OPACITY:
        v(this, Bp, cE).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[X.INK_THICKNESS, ft._defaultThickness], [X.INK_COLOR, ft._defaultColor || nt._defaultLineColor], [X.INK_OPACITY, Math.round(ft._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[X.INK_THICKNESS, this.thickness || ft._defaultThickness], [X.INK_COLOR, this.color || ft._defaultColor || nt._defaultLineColor], [X.INK_OPACITY, Math.round(100 * (this.opacity ?? ft._defaultOpacity))]];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.canvas || (v(this, To, ju).call(this), v(this, Co, Hu).call(this)), this.isAttachedToDOM || (this.parent.add(this), v(this, Ki, da).call(this)), v(this, Tr, Rl).call(this)));
  }
  remove() {
    var t;
    this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, o(this, gs) && (clearTimeout(o(this, gs)), b(this, gs, null)), (t = o(this, ei)) == null || t.disconnect(), b(this, ei, null), super.remove());
  }
  setParent(t) {
    !this.parent && t ? this._uiManager.removeShouldRescale(this) : this.parent && t === null && this._uiManager.addShouldRescale(this), super.setParent(t);
  }
  onScaleChanging() {
    const [t, s] = this.parentDimensions, i = this.width * t, n = this.height * s;
    this.setDimensions(i, n);
  }
  enableEditMode() {
    o(this, Le) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", o(this, Er), {
      signal: this._uiManager._signal
    }));
  }
  disableEditMode() {
    !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", o(this, Er)));
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  commit() {
    o(this, Le) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), b(this, Le, !0), this.div.classList.add("disabled"), v(this, Tr, Rl).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
      preventScroll: !0
    }));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), this.enableEditMode());
  }
  canvasPointerdown(t) {
    t.button !== 0 || !this.isInEditMode() || o(this, Le) || (this.setInForeground(), t.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
      preventScroll: !0
    }), v(this, Hp, uE).call(this, t.offsetX, t.offsetY));
  }
  canvasPointermove(t) {
    t.preventDefault(), v(this, Zc, uv).call(this, t.offsetX, t.offsetY);
  }
  canvasPointerup(t) {
    t.preventDefault(), v(this, Jc, fv).call(this, t);
  }
  canvasPointerleave(t) {
    v(this, Jc, fv).call(this, t);
  }
  get isResizable() {
    return !this.isEmpty() && o(this, Le);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [i, n, r, a] = v(this, jp, dE).call(this);
    if (this.setAt(i, n, 0, 0), this.setDims(r, a), v(this, To, ju).call(this), this.width) {
      const [h, c] = this.parentDimensions;
      this.setAspectRatio(this.width * h, this.height * c), this.setAt(t * h, s * c, this.width * h, this.height * c), b(this, Sr, !0), v(this, Ki, da).call(this), this.setDims(this.width * h, this.height * c), v(this, si, An).call(this), this.div.classList.add("disabled");
    } else
      this.div.classList.add("editing"), this.enableEditMode();
    return v(this, Co, Hu).call(this), this.div;
  }
  setDimensions(t, s) {
    const i = Math.round(t), n = Math.round(s);
    if (o(this, xr) === i && o(this, Pr) === n)
      return;
    b(this, xr, i), b(this, Pr, n), this.canvas.style.visibility = "hidden";
    const [r, a] = this.parentDimensions;
    this.width = t / r, this.height = s / a, this.fixAndSetPosition(), o(this, Le) && v(this, qc, pv).call(this, t, s), v(this, Ki, da).call(this), v(this, si, An).call(this), this.canvas.style.visibility = "visible", this.fixDims();
  }
  static deserialize(t, s, i) {
    var E, y, w;
    if (t instanceof BA)
      return null;
    const n = super.deserialize(t, s, i);
    n.thickness = t.thickness, n.color = U.makeHexColor(...t.color), n.opacity = t.opacity;
    const [r, a] = n.pageDimensions, h = n.width * r, c = n.height * a, d = n.parentScale, u = t.thickness / 2;
    b(n, Le, !0), b(n, xr, Math.round(h)), b(n, Pr, Math.round(c));
    const {
      paths: f,
      rect: m,
      rotation: g
    } = t;
    for (let {
      bezier: S
    } of f) {
      S = v(E = ft, Xp, yE).call(E, S, m, g);
      const C = [];
      n.paths.push(C);
      let P = d * (S[0] - u), x = d * (S[1] - u);
      for (let M = 2, T = S.length; M < T; M += 6) {
        const I = d * (S[M] - u), _ = d * (S[M + 1] - u), k = d * (S[M + 2] - u), F = d * (S[M + 3] - u), V = d * (S[M + 4] - u), $ = d * (S[M + 5] - u);
        C.push([[P, x], [I, _], [k, F], [V, $]]), P = V, x = $;
      }
      const R = v(this, Gp, bE).call(this, C);
      n.bezierPath2D.push(R);
    }
    const A = v(y = n, ed, mv).call(y);
    return b(n, Ar, Math.max(nt.MIN_SIZE, A[2] - A[0])), b(n, yr, Math.max(nt.MIN_SIZE, A[3] - A[1])), v(w = n, qc, pv).call(w, h, c), n;
  }
  serialize() {
    if (this.isEmpty())
      return null;
    const t = this.getRect(0, 0), s = nt._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: q.INK,
      color: s,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: v(this, Kp, AE).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, t),
      pageIndex: this.pageIndex,
      rect: t,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
};
yr = new WeakMap(), Ar = new WeakMap(), Xc = new WeakMap(), Kc = new WeakMap(), Yc = new WeakMap(), Er = new WeakMap(), gs = new WeakMap(), ti = new WeakMap(), Le = new WeakMap(), wr = new WeakMap(), Sr = new WeakMap(), ei = new WeakMap(), xr = new WeakMap(), Pr = new WeakMap(), Xi = new WeakMap(), Fp = new WeakSet(), lE = function(t) {
  const s = (n) => {
    this.thickness = n, v(this, Tr, Rl).call(this);
  }, i = this.thickness;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Np = new WeakSet(), hE = function(t) {
  const s = (n) => {
    this.color = n, v(this, si, An).call(this);
  }, i = this.color;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.INK_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Bp = new WeakSet(), cE = function(t) {
  const s = (n) => {
    this.opacity = n, v(this, si, An).call(this);
  };
  t /= 100;
  const i = this.opacity;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: X.INK_OPACITY,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, jp = new WeakSet(), dE = function() {
  const {
    parentRotation: t,
    parentDimensions: [s, i]
  } = this;
  switch (t) {
    case 90:
      return [0, i, i, s];
    case 180:
      return [s, i, s, i];
    case 270:
      return [s, 0, i, s];
    default:
      return [0, 0, s, i];
  }
}, Qc = new WeakSet(), dv = function() {
  const {
    ctx: t,
    color: s,
    opacity: i,
    thickness: n,
    parentScale: r,
    scaleFactor: a
  } = this;
  t.lineWidth = n * r / a, t.lineCap = "round", t.lineJoin = "round", t.miterLimit = 10, t.strokeStyle = `${s}${J0(i)}`;
}, Hp = new WeakSet(), uE = function(t, s) {
  const i = this._uiManager._signal;
  this.canvas.addEventListener("contextmenu", fe, {
    signal: i
  }), this.canvas.addEventListener("pointerleave", o(this, Kc), {
    signal: i
  }), this.canvas.addEventListener("pointermove", o(this, Xc), {
    signal: i
  }), this.canvas.addEventListener("pointerup", o(this, Yc), {
    signal: i
  }), this.canvas.removeEventListener("pointerdown", o(this, Er)), this.isEditing = !0, o(this, Sr) || (b(this, Sr, !0), v(this, Ki, da).call(this), this.thickness || (this.thickness = ft._defaultThickness), this.color || (this.color = ft._defaultColor || nt._defaultLineColor), this.opacity ?? (this.opacity = ft._defaultOpacity)), this.currentPath.push([t, s]), b(this, wr, !1), v(this, Qc, dv).call(this), b(this, Xi, () => {
    v(this, Up, gE).call(this), o(this, Xi) && window.requestAnimationFrame(o(this, Xi));
  }), window.requestAnimationFrame(o(this, Xi));
}, Zc = new WeakSet(), uv = function(t, s) {
  const [i, n] = this.currentPath.at(-1);
  if (this.currentPath.length > 1 && t === i && s === n)
    return;
  const r = this.currentPath;
  let a = o(this, ti);
  if (r.push([t, s]), b(this, wr, !0), r.length <= 2) {
    a.moveTo(...r[0]), a.lineTo(t, s);
    return;
  }
  r.length === 3 && (b(this, ti, a = new Path2D()), a.moveTo(...r[0])), v(this, zp, mE).call(this, a, ...r.at(-3), ...r.at(-2), t, s);
}, $p = new WeakSet(), fE = function() {
  if (this.currentPath.length === 0)
    return;
  const t = this.currentPath.at(-1);
  o(this, ti).lineTo(...t);
}, Vp = new WeakSet(), pE = function(t, s) {
  b(this, Xi, null), t = Math.min(Math.max(t, 0), this.canvas.width), s = Math.min(Math.max(s, 0), this.canvas.height), v(this, Zc, uv).call(this, t, s), v(this, $p, fE).call(this);
  let i;
  if (this.currentPath.length !== 1)
    i = v(this, Wp, vE).call(this);
  else {
    const c = [t, s];
    i = [[c, c.slice(), c.slice(), c]];
  }
  const n = o(this, ti), r = this.currentPath;
  this.currentPath = [], b(this, ti, new Path2D());
  const a = () => {
    this.allRawPaths.push(r), this.paths.push(i), this.bezierPath2D.push(n), this._uiManager.rebuild(this);
  }, h = () => {
    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (v(this, To, ju).call(this), v(this, Co, Hu).call(this)), v(this, Tr, Rl).call(this));
  };
  this.addCommands({
    cmd: a,
    undo: h,
    mustExec: !0
  });
}, Up = new WeakSet(), gE = function() {
  if (!o(this, wr))
    return;
  b(this, wr, !1);
  const t = Math.ceil(this.thickness * this.parentScale), s = this.currentPath.slice(-3), i = s.map((a) => a[0]), n = s.map((a) => a[1]);
  Math.min(...i) - t, Math.max(...i) + t, Math.min(...n) - t, Math.max(...n) + t;
  const {
    ctx: r
  } = this;
  r.save(), r.clearRect(0, 0, this.canvas.width, this.canvas.height);
  for (const a of this.bezierPath2D)
    r.stroke(a);
  r.stroke(o(this, ti)), r.restore();
}, zp = new WeakSet(), mE = function(t, s, i, n, r, a, h) {
  const c = (s + n) / 2, d = (i + r) / 2, u = (n + a) / 2, f = (r + h) / 2;
  t.bezierCurveTo(c + 2 * (n - c) / 3, d + 2 * (r - d) / 3, u + 2 * (n - u) / 3, f + 2 * (r - f) / 3, u, f);
}, Wp = new WeakSet(), vE = function() {
  const t = this.currentPath;
  if (t.length <= 2)
    return [[t[0], t[0], t.at(-1), t.at(-1)]];
  const s = [];
  let i, [n, r] = t[0];
  for (i = 1; i < t.length - 2; i++) {
    const [m, g] = t[i], [A, E] = t[i + 1], y = (m + A) / 2, w = (g + E) / 2, S = [n + 2 * (m - n) / 3, r + 2 * (g - r) / 3], C = [y + 2 * (m - y) / 3, w + 2 * (g - w) / 3];
    s.push([[n, r], S, C, [y, w]]), [n, r] = [y, w];
  }
  const [a, h] = t[i], [c, d] = t[i + 1], u = [n + 2 * (a - n) / 3, r + 2 * (h - r) / 3], f = [c + 2 * (a - c) / 3, d + 2 * (h - d) / 3];
  return s.push([[n, r], u, f, [c, d]]), s;
}, si = new WeakSet(), An = function() {
  if (this.isEmpty()) {
    v(this, Ro, $u).call(this);
    return;
  }
  v(this, Qc, dv).call(this);
  const {
    canvas: t,
    ctx: s
  } = this;
  s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, t.width, t.height), v(this, Ro, $u).call(this);
  for (const i of this.bezierPath2D)
    s.stroke(i);
}, Jc = new WeakSet(), fv = function(t) {
  this.canvas.removeEventListener("pointerleave", o(this, Kc)), this.canvas.removeEventListener("pointermove", o(this, Xc)), this.canvas.removeEventListener("pointerup", o(this, Yc)), this.canvas.addEventListener("pointerdown", o(this, Er), {
    signal: this._uiManager._signal
  }), o(this, gs) && clearTimeout(o(this, gs)), b(this, gs, setTimeout(() => {
    b(this, gs, null), this.canvas.removeEventListener("contextmenu", fe);
  }, 10)), v(this, Vp, pE).call(this, t.offsetX, t.offsetY), this.addToAnnotationStorage(), this.setInBackground();
}, To = new WeakSet(), ju = function() {
  this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
}, Co = new WeakSet(), Hu = function() {
  b(this, ei, new ResizeObserver((t) => {
    const s = t[0].contentRect;
    s.width && s.height && this.setDimensions(s.width, s.height);
  })), o(this, ei).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var t;
    (t = o(this, ei)) == null || t.disconnect(), b(this, ei, null);
  }, {
    once: !0
  });
}, Ki = new WeakSet(), da = function() {
  if (!o(this, Sr))
    return;
  const [t, s] = this.parentDimensions;
  this.canvas.width = Math.ceil(this.width * t), this.canvas.height = Math.ceil(this.height * s), v(this, Ro, $u).call(this);
}, qc = new WeakSet(), pv = function(t, s) {
  const i = v(this, Io, Vu).call(this), n = (t - i) / o(this, Ar), r = (s - i) / o(this, yr);
  this.scaleFactor = Math.min(n, r);
}, Ro = new WeakSet(), $u = function() {
  const t = v(this, Io, Vu).call(this) / 2;
  this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + t, this.translationY * this.scaleFactor + t);
}, Gp = new WeakSet(), bE = function(t) {
  const s = new Path2D();
  for (let i = 0, n = t.length; i < n; i++) {
    const [r, a, h, c] = t[i];
    i === 0 && s.moveTo(...r), s.bezierCurveTo(a[0], a[1], h[0], h[1], c[0], c[1]);
  }
  return s;
}, td = new WeakSet(), gv = function(t, s, i) {
  const [n, r, a, h] = s;
  switch (i) {
    case 0:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] += n, t[c + 1] = h - t[c + 1];
      break;
    case 90:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = t[c + 1] + n, t[c + 1] = u + r;
      }
      break;
    case 180:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] = a - t[c], t[c + 1] += r;
      break;
    case 270:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = a - t[c + 1], t[c + 1] = h - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return t;
}, Xp = new WeakSet(), yE = function(t, s, i) {
  const [n, r, a, h] = s;
  switch (i) {
    case 0:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] -= n, t[c + 1] = h - t[c + 1];
      break;
    case 90:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = t[c + 1] - r, t[c + 1] = u - n;
      }
      break;
    case 180:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] = a - t[c], t[c + 1] -= r;
      break;
    case 270:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = h - t[c + 1], t[c + 1] = a - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return t;
}, Kp = new WeakSet(), AE = function(t, s, i, n) {
  var d, u;
  const r = [], a = this.thickness / 2, h = t * s + a, c = t * i + a;
  for (const f of this.paths) {
    const m = [], g = [];
    for (let A = 0, E = f.length; A < E; A++) {
      const [y, w, S, C] = f[A];
      if (y[0] === C[0] && y[1] === C[1] && E === 1) {
        const F = t * y[0] + h, V = t * y[1] + c;
        m.push(F, V), g.push(F, V);
        break;
      }
      const P = t * y[0] + h, x = t * y[1] + c, R = t * w[0] + h, M = t * w[1] + c, T = t * S[0] + h, I = t * S[1] + c, _ = t * C[0] + h, k = t * C[1] + c;
      A === 0 && (m.push(P, x), g.push(P, x)), m.push(R, M, T, I, _, k), g.push(R, M), A === E - 1 && g.push(_, k);
    }
    r.push({
      bezier: v(d = ft, td, gv).call(d, m, n, this.rotation),
      points: v(u = ft, td, gv).call(u, g, n, this.rotation)
    });
  }
  return r;
}, ed = new WeakSet(), mv = function() {
  let t = 1 / 0, s = -1 / 0, i = 1 / 0, n = -1 / 0;
  for (const r of this.paths)
    for (const [a, h, c, d] of r) {
      const u = U.bezierBoundingBox(...a, ...h, ...c, ...d);
      t = Math.min(t, u[0]), i = Math.min(i, u[1]), s = Math.max(s, u[2]), n = Math.max(n, u[3]);
    }
  return [t, i, s, n];
}, Io = new WeakSet(), Vu = function() {
  return o(this, Le) ? Math.ceil(this.thickness * this.parentScale) : 0;
}, Tr = new WeakSet(), Rl = function(t = !1) {
  if (this.isEmpty())
    return;
  if (!o(this, Le)) {
    v(this, si, An).call(this);
    return;
  }
  const s = v(this, ed, mv).call(this), i = v(this, Io, Vu).call(this);
  b(this, Ar, Math.max(nt.MIN_SIZE, s[2] - s[0])), b(this, yr, Math.max(nt.MIN_SIZE, s[3] - s[1]));
  const n = Math.ceil(i + o(this, Ar) * this.scaleFactor), r = Math.ceil(i + o(this, yr) * this.scaleFactor), [a, h] = this.parentDimensions;
  this.width = n / a, this.height = r / h, this.setAspectRatio(n, r);
  const c = this.translationX, d = this.translationY;
  this.translationX = -s[0], this.translationY = -s[1], v(this, Ki, da).call(this), v(this, si, An).call(this), b(this, xr, n), b(this, Pr, r), this.setDims(n, r);
  const u = t ? i / this.scaleFactor / 2 : 0;
  this.translate(c - this.translationX - u, d - this.translationY - u);
}, p(ft, Gp), p(ft, td), p(ft, Xp), K(ft, "_defaultColor", null), K(ft, "_defaultOpacity", 1), K(ft, "_defaultThickness", 1), K(ft, "_type", "ink"), K(ft, "_editorType", q.INK);
let cv = ft;
var zt, Wt, Yi, ii, Qi, Lo, ms, ni, vs, Ze, sd, Cr, Il, Rr, Ll, _o, Uu, id, bv, Yp, EE, Qp, wE, nd, yv, Mo, zu, Zp, SE;
const $l = class $l extends nt {
  constructor(t) {
    super({
      ...t,
      name: "stampEditor"
    });
    p(this, Cr);
    p(this, Rr);
    p(this, _o);
    p(this, id);
    p(this, Yp);
    p(this, Qp);
    p(this, nd);
    p(this, Mo);
    p(this, Zp);
    p(this, zt, null);
    p(this, Wt, null);
    p(this, Yi, null);
    p(this, ii, null);
    p(this, Qi, null);
    p(this, Lo, "");
    p(this, ms, null);
    p(this, ni, null);
    p(this, vs, null);
    p(this, Ze, !1);
    p(this, sd, !1);
    b(this, ii, t.bitmapUrl), b(this, Qi, t.bitmapFile);
  }
  static initialize(t, s) {
    nt.initialize(t, s);
  }
  static get supportedTypes() {
    return et(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((s) => `image/${s}`));
  }
  static get supportedTypesStr() {
    return et(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(t) {
    return this.supportedTypes.includes(t);
  }
  static paste(t, s) {
    s.pasteEditor(q.STAMP, {
      bitmapFile: t.getAsFile()
    });
  }
  remove() {
    var t, s;
    o(this, Wt) && (b(this, zt, null), this._uiManager.imageManager.deleteId(o(this, Wt)), (t = o(this, ms)) == null || t.remove(), b(this, ms, null), (s = o(this, ni)) == null || s.disconnect(), b(this, ni, null), o(this, vs) && (clearTimeout(o(this, vs)), b(this, vs, null))), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      o(this, Wt) && v(this, _o, Uu).call(this);
      return;
    }
    super.rebuild(), this.div !== null && (o(this, Wt) && o(this, ms) === null && v(this, _o, Uu).call(this), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded() {
    this._isDraggable = !0, this.div.focus();
  }
  isEmpty() {
    return !(o(this, Yi) || o(this, zt) || o(this, ii) || o(this, Qi) || o(this, Wt));
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    if (this.width && (t = this.x, s = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), o(this, zt) ? v(this, id, bv).call(this) : v(this, _o, Uu).call(this), this.width) {
      const [i, n] = this.parentDimensions;
      this.setAt(t * i, s * n, this.width * i, this.height * n);
    }
    return this.div;
  }
  getImageForAltText() {
    return o(this, ms);
  }
  static deserialize(t, s, i) {
    if (t instanceof jA)
      return null;
    const n = super.deserialize(t, s, i), {
      rect: r,
      bitmapUrl: a,
      bitmapId: h,
      isSvg: c,
      accessibilityData: d
    } = t;
    h && i.imageManager.isValidId(h) ? b(n, Wt, h) : b(n, ii, a), b(n, Ze, c);
    const [u, f] = n.pageDimensions;
    return n.width = (r[2] - r[0]) / u, n.height = (r[3] - r[1]) / f, d && (n.altTextData = d), n;
  }
  serialize(t = !1, s = null) {
    if (this.isEmpty())
      return null;
    const i = {
      annotationType: q.STAMP,
      bitmapId: o(this, Wt),
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: o(this, Ze),
      structTreeParentId: this._structTreeParentId
    };
    if (t)
      return i.bitmapUrl = v(this, Mo, zu).call(this, !0), i.accessibilityData = this.altTextData, i;
    const {
      decorative: n,
      altText: r
    } = this.altTextData;
    if (!n && r && (i.accessibilityData = {
      type: "Figure",
      alt: r
    }), s === null)
      return i;
    s.stamps || (s.stamps = /* @__PURE__ */ new Map());
    const a = o(this, Ze) ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
    if (!s.stamps.has(o(this, Wt)))
      s.stamps.set(o(this, Wt), {
        area: a,
        serialized: i
      }), i.bitmap = v(this, Mo, zu).call(this, !1);
    else if (o(this, Ze)) {
      const h = s.stamps.get(o(this, Wt));
      a > h.area && (h.area = a, h.serialized.bitmap.close(), h.serialized.bitmap = v(this, Mo, zu).call(this, !1));
    }
    return i;
  }
};
zt = new WeakMap(), Wt = new WeakMap(), Yi = new WeakMap(), ii = new WeakMap(), Qi = new WeakMap(), Lo = new WeakMap(), ms = new WeakMap(), ni = new WeakMap(), vs = new WeakMap(), Ze = new WeakMap(), sd = new WeakMap(), Cr = new WeakSet(), Il = function(t, s = !1) {
  if (!t) {
    this.remove();
    return;
  }
  b(this, zt, t.bitmap), s || (b(this, Wt, t.id), b(this, Ze, t.isSvg)), t.file && b(this, Lo, t.file.name), v(this, id, bv).call(this);
}, Rr = new WeakSet(), Ll = function() {
  b(this, Yi, null), this._uiManager.enableWaiting(!1), o(this, ms) && this.div.focus();
}, _o = new WeakSet(), Uu = function() {
  if (o(this, Wt)) {
    this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(o(this, Wt)).then((i) => v(this, Cr, Il).call(this, i, !0)).finally(() => v(this, Rr, Ll).call(this));
    return;
  }
  if (o(this, ii)) {
    const i = o(this, ii);
    b(this, ii, null), this._uiManager.enableWaiting(!0), b(this, Yi, this._uiManager.imageManager.getFromUrl(i).then((n) => v(this, Cr, Il).call(this, n)).finally(() => v(this, Rr, Ll).call(this)));
    return;
  }
  if (o(this, Qi)) {
    const i = o(this, Qi);
    b(this, Qi, null), this._uiManager.enableWaiting(!0), b(this, Yi, this._uiManager.imageManager.getFromFile(i).then((n) => v(this, Cr, Il).call(this, n)).finally(() => v(this, Rr, Ll).call(this)));
    return;
  }
  const t = document.createElement("input");
  t.type = "file", t.accept = $l.supportedTypesStr;
  const s = this._uiManager._signal;
  b(this, Yi, new Promise((i) => {
    t.addEventListener("change", async () => {
      if (!t.files || t.files.length === 0)
        this.remove();
      else {
        this._uiManager.enableWaiting(!0);
        const n = await this._uiManager.imageManager.getFromFile(t.files[0]);
        v(this, Cr, Il).call(this, n);
      }
      i();
    }, {
      signal: s
    }), t.addEventListener("cancel", () => {
      this.remove(), i();
    }, {
      signal: s
    });
  }).finally(() => v(this, Rr, Ll).call(this))), t.click();
}, id = new WeakSet(), bv = function() {
  const {
    div: t
  } = this;
  let {
    width: s,
    height: i
  } = o(this, zt);
  const [n, r] = this.pageDimensions, a = 0.75;
  if (this.width)
    s = this.width * n, i = this.height * r;
  else if (s > a * n || i > a * r) {
    const u = Math.min(a * n / s, a * r / i);
    s *= u, i *= u;
  }
  const [h, c] = this.parentDimensions;
  this.setDims(s * h / n, i * c / r), this._uiManager.enableWaiting(!1);
  const d = b(this, ms, document.createElement("canvas"));
  t.append(d), t.hidden = !1, v(this, nd, yv).call(this, s, i), v(this, Zp, SE).call(this), o(this, sd) || (this.parent.addUndoableEditor(this), b(this, sd, !0)), this._reportTelemetry({
    action: "inserted_image"
  }), o(this, Lo) && d.setAttribute("aria-label", o(this, Lo));
}, Yp = new WeakSet(), EE = function(t, s) {
  var a;
  const [i, n] = this.parentDimensions;
  this.width = t / i, this.height = s / n, this.setDims(t, s), (a = this._initialOptions) != null && a.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, o(this, vs) !== null && clearTimeout(o(this, vs)), b(this, vs, setTimeout(() => {
    b(this, vs, null), v(this, nd, yv).call(this, t, s);
  }, 200));
}, Qp = new WeakSet(), wE = function(t, s) {
  const {
    width: i,
    height: n
  } = o(this, zt);
  let r = i, a = n, h = o(this, zt);
  for (; r > 2 * t || a > 2 * s; ) {
    const c = r, d = a;
    r > 2 * t && (r = r >= 16384 ? Math.floor(r / 2) - 1 : Math.ceil(r / 2)), a > 2 * s && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2));
    const u = new OffscreenCanvas(r, a);
    u.getContext("2d").drawImage(h, 0, 0, c, d, 0, 0, r, a), h = u.transferToImageBitmap();
  }
  return h;
}, nd = new WeakSet(), yv = function(t, s) {
  t = Math.ceil(t), s = Math.ceil(s);
  const i = o(this, ms);
  if (!i || i.width === t && i.height === s)
    return;
  i.width = t, i.height = s;
  const n = o(this, Ze) ? o(this, zt) : v(this, Qp, wE).call(this, t, s);
  if (this._uiManager.hasMLManager && !this.hasAltText()) {
    const h = new OffscreenCanvas(t, s).getContext("2d");
    h.drawImage(n, 0, 0, n.width, n.height, 0, 0, t, s), this._uiManager.mlGuess({
      service: "image-to-text",
      request: {
        data: h.getImageData(0, 0, t, s).data,
        width: t,
        height: s,
        channels: 4
      }
    }).then((c) => {
      const d = (c == null ? void 0 : c.output) || "";
      this.parent && d && !this.hasAltText() && (this.altTextData = {
        altText: d,
        decorative: !1
      });
    });
  }
  const r = i.getContext("2d");
  r.filter = this._uiManager.hcmFilter, r.drawImage(n, 0, 0, n.width, n.height, 0, 0, t, s);
}, Mo = new WeakSet(), zu = function(t) {
  if (t) {
    if (o(this, Ze)) {
      const n = this._uiManager.imageManager.getSvgUrl(o(this, Wt));
      if (n)
        return n;
    }
    const s = document.createElement("canvas");
    return {
      width: s.width,
      height: s.height
    } = o(this, zt), s.getContext("2d").drawImage(o(this, zt), 0, 0), s.toDataURL();
  }
  if (o(this, Ze)) {
    const [s, i] = this.pageDimensions, n = Math.round(this.width * s * rl.PDF_TO_CSS_UNITS), r = Math.round(this.height * i * rl.PDF_TO_CSS_UNITS), a = new OffscreenCanvas(n, r);
    return a.getContext("2d").drawImage(o(this, zt), 0, 0, o(this, zt).width, o(this, zt).height, 0, 0, n, r), a.transferToImageBitmap();
  }
  return structuredClone(o(this, zt));
}, Zp = new WeakSet(), SE = function() {
  this._uiManager._signal && (b(this, ni, new ResizeObserver((t) => {
    const s = t[0].contentRect;
    s.width && s.height && v(this, Yp, EE).call(this, s.width, s.height);
  })), o(this, ni).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var t;
    (t = o(this, ni)) == null || t.disconnect(), b(this, ni, null);
  }, {
    once: !0
  }));
}, K($l, "_type", "stamp"), K($l, "_editorType", q.STAMP);
let vv = $l;
var Ir, Oo, bs, Lr, ri, ai, oi, we, Zi, Do, ko, se, z, xe, Ji, Jp, xE, rd, Av, ad, Ev, od, wv, Fo, Wu;
let IS = (xe = class {
  constructor({
    uiManager: e,
    pageIndex: t,
    div: s,
    accessibilityManager: i,
    annotationLayer: n,
    drawLayer: r,
    textLayer: a,
    viewport: h,
    l10n: c
  }) {
    p(this, Jp);
    p(this, rd);
    p(this, ad);
    p(this, od);
    p(this, Fo);
    p(this, Ir, void 0);
    p(this, Oo, !1);
    p(this, bs, null);
    p(this, Lr, null);
    p(this, ri, null);
    p(this, ai, null);
    p(this, oi, null);
    p(this, we, /* @__PURE__ */ new Map());
    p(this, Zi, !1);
    p(this, Do, !1);
    p(this, ko, !1);
    p(this, se, null);
    p(this, z, void 0);
    const d = [...o(xe, Ji).values()];
    if (!xe._initialized) {
      xe._initialized = !0;
      for (const u of d)
        u.initialize(c, e);
    }
    e.registerEditorTypes(d), b(this, z, e), this.pageIndex = t, this.div = s, b(this, Ir, i), b(this, bs, n), this.viewport = h, b(this, se, a), this.drawLayer = r, o(this, z).addLayer(this);
  }
  get isEmpty() {
    return o(this, we).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && o(this, z).getMode() === q.NONE;
  }
  updateToolbar(e) {
    o(this, z).updateToolbar(e);
  }
  updateMode(e = o(this, z).getMode()) {
    switch (v(this, Fo, Wu).call(this), e) {
      case q.NONE:
        this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case q.INK:
        this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
        break;
      case q.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: t
    } = this.div;
    for (const s of o(xe, Ji).values())
      t.toggle(`${s._type}Editing`, e === s._editorType);
    this.div.hidden = !1;
  }
  hasTextLayer(e) {
    var t;
    return e === ((t = o(this, se)) == null ? void 0 : t.div);
  }
  addInkEditorIfNeeded(e) {
    if (o(this, z).getMode() !== q.INK)
      return;
    if (!e) {
      for (const s of o(this, we).values())
        if (s.isEmpty()) {
          s.setInBackground();
          return;
        }
    }
    this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, !1).setInBackground();
  }
  setEditingState(e) {
    o(this, z).setEditingState(e);
  }
  addCommands(e) {
    o(this, z).addCommands(e);
  }
  togglePointerEvents(e = !1) {
    this.div.classList.toggle("disabled", !e);
  }
  toggleAnnotationLayerPointerEvents(e = !1) {
    var t;
    (t = o(this, bs)) == null || t.div.classList.toggle("disabled", !e);
  }
  enable() {
    this.div.tabIndex = 0, this.togglePointerEvents(!0);
    const e = /* @__PURE__ */ new Set();
    for (const s of o(this, we).values())
      s.enableEditing(), s.show(!0), s.annotationElementId && (o(this, z).removeChangedExistingAnnotation(s), e.add(s.annotationElementId));
    if (!o(this, bs))
      return;
    const t = o(this, bs).getEditableAnnotations();
    for (const s of t) {
      if (s.hide(), o(this, z).isDeletedAnnotationElement(s.data.id) || e.has(s.data.id))
        continue;
      const i = this.deserialize(s);
      i && (this.addOrRebuild(i), i.enableEditing());
    }
  }
  disable() {
    var i;
    b(this, ko, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
    const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
    for (const n of o(this, we).values())
      if (n.disableEditing(), !!n.annotationElementId) {
        if (n.serialize() !== null) {
          e.set(n.annotationElementId, n);
          continue;
        } else
          t.set(n.annotationElementId, n);
        (i = this.getEditableAnnotation(n.annotationElementId)) == null || i.show(), n.remove();
      }
    if (o(this, bs)) {
      const n = o(this, bs).getEditableAnnotations();
      for (const r of n) {
        const {
          id: a
        } = r.data;
        if (o(this, z).isDeletedAnnotationElement(a))
          continue;
        let h = t.get(a);
        if (h) {
          h.resetAnnotationElement(r), h.show(!1), r.show();
          continue;
        }
        h = e.get(a), h && (o(this, z).addChangedExistingAnnotation(h), h.renderAnnotationElement(r), h.show(!1)), r.show();
      }
    }
    v(this, Fo, Wu).call(this), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: s
    } = this.div;
    for (const n of o(xe, Ji).values())
      s.remove(`${n._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), b(this, ko, !1);
  }
  getEditableAnnotation(e) {
    var t;
    return ((t = o(this, bs)) == null ? void 0 : t.getEditableAnnotation(e)) || null;
  }
  setActiveEditor(e) {
    o(this, z).getActive() !== e && o(this, z).setActiveEditor(e);
  }
  enableTextSelection() {
    var e;
    this.div.tabIndex = -1, (e = o(this, se)) != null && e.div && !o(this, ai) && (b(this, ai, v(this, Jp, xE).bind(this)), o(this, se).div.addEventListener("pointerdown", o(this, ai), {
      signal: o(this, z)._signal
    }), o(this, se).div.classList.add("highlighting"));
  }
  disableTextSelection() {
    var e;
    this.div.tabIndex = 0, (e = o(this, se)) != null && e.div && o(this, ai) && (o(this, se).div.removeEventListener("pointerdown", o(this, ai)), b(this, ai, null), o(this, se).div.classList.remove("highlighting"));
  }
  enableClick() {
    if (o(this, ri))
      return;
    const e = o(this, z)._signal;
    b(this, ri, this.pointerdown.bind(this)), b(this, Lr, this.pointerup.bind(this)), this.div.addEventListener("pointerdown", o(this, ri), {
      signal: e
    }), this.div.addEventListener("pointerup", o(this, Lr), {
      signal: e
    });
  }
  disableClick() {
    o(this, ri) && (this.div.removeEventListener("pointerdown", o(this, ri)), this.div.removeEventListener("pointerup", o(this, Lr)), b(this, ri, null), b(this, Lr, null));
  }
  attach(e) {
    o(this, we).set(e.id, e);
    const {
      annotationElementId: t
    } = e;
    t && o(this, z).isDeletedAnnotationElement(t) && o(this, z).removeDeletedAnnotationElement(e);
  }
  detach(e) {
    var t;
    o(this, we).delete(e.id), (t = o(this, Ir)) == null || t.removePointerInTextLayer(e.contentDiv), !o(this, ko) && e.annotationElementId && o(this, z).addDeletedAnnotationElement(e);
  }
  remove(e) {
    this.detach(e), o(this, z).removeEditor(e), e.div.remove(), e.isAttachedToDOM = !1, o(this, Do) || this.addInkEditorIfNeeded(!1);
  }
  changeParent(e) {
    var t;
    e.parent !== this && (e.parent && e.annotationElementId && (o(this, z).addDeletedAnnotationElement(e.annotationElementId), nt.deleteAnnotationElement(e), e.annotationElementId = null), this.attach(e), (t = e.parent) == null || t.detach(e), e.setParent(this), e.div && e.isAttachedToDOM && (e.div.remove(), this.div.append(e.div)));
  }
  add(e) {
    if (!(e.parent === this && e.isAttachedToDOM)) {
      if (this.changeParent(e), o(this, z).addEditor(e), this.attach(e), !e.isAttachedToDOM) {
        const t = e.render();
        this.div.append(t), e.isAttachedToDOM = !0;
      }
      e.fixAndSetPosition(), e.onceAdded(), o(this, z).addToAnnotationStorage(e), e._reportTelemetry(e.telemetryInitialData);
    }
  }
  moveEditorInDOM(e) {
    var s;
    if (!e.isAttachedToDOM)
      return;
    const {
      activeElement: t
    } = document;
    e.div.contains(t) && !o(this, oi) && (e._focusEventsAllowed = !1, b(this, oi, setTimeout(() => {
      b(this, oi, null), e.div.contains(document.activeElement) ? e._focusEventsAllowed = !0 : (e.div.addEventListener("focusin", () => {
        e._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: o(this, z)._signal
      }), t.focus());
    }, 0))), e._structTreeParentId = (s = o(this, Ir)) == null ? void 0 : s.moveElementInDOM(this.div, e.div, e.contentDiv, !0);
  }
  addOrRebuild(e) {
    e.needsToBeRebuilt() ? (e.parent || (e.parent = this), e.rebuild(), e.show()) : this.add(e);
  }
  addUndoableEditor(e) {
    const t = () => e._uiManager.rebuild(e), s = () => {
      e.remove();
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !1
    });
  }
  getNextId() {
    return o(this, z).getId();
  }
  get _signal() {
    return o(this, z)._signal;
  }
  canCreateNewEmptyEditor() {
    var e;
    return (e = o(this, rd, Av)) == null ? void 0 : e.canCreateNewEmptyEditor();
  }
  pasteEditor(e, t) {
    o(this, z).updateToolbar(e), o(this, z).updateMode(e);
    const {
      offsetX: s,
      offsetY: i
    } = v(this, od, wv).call(this), n = this.getNextId(), r = v(this, ad, Ev).call(this, {
      parent: this,
      id: n,
      x: s,
      y: i,
      uiManager: o(this, z),
      isCentered: !0,
      ...t
    });
    r && this.add(r);
  }
  deserialize(e) {
    var t;
    return ((t = o(xe, Ji).get(e.annotationType ?? e.annotationEditorType)) == null ? void 0 : t.deserialize(e, this, o(this, z))) || null;
  }
  createAndAddNewEditor(e, t, s = {}) {
    const i = this.getNextId(), n = v(this, ad, Ev).call(this, {
      parent: this,
      id: i,
      x: e.offsetX,
      y: e.offsetY,
      uiManager: o(this, z),
      isCentered: t,
      ...s
    });
    return n && this.add(n), n;
  }
  addNewEditor() {
    this.createAndAddNewEditor(v(this, od, wv).call(this), !0);
  }
  setSelected(e) {
    o(this, z).setSelected(e);
  }
  toggleSelected(e) {
    o(this, z).toggleSelected(e);
  }
  isSelected(e) {
    return o(this, z).isSelected(e);
  }
  unselect(e) {
    o(this, z).unselect(e);
  }
  pointerup(e) {
    const {
      isMac: t
    } = ue.platform;
    if (!(e.button !== 0 || e.ctrlKey && t) && e.target === this.div && o(this, Zi)) {
      if (b(this, Zi, !1), !o(this, Oo)) {
        b(this, Oo, !0);
        return;
      }
      if (o(this, z).getMode() === q.STAMP) {
        o(this, z).unselectAll();
        return;
      }
      this.createAndAddNewEditor(e, !1);
    }
  }
  pointerdown(e) {
    if (o(this, z).getMode() === q.HIGHLIGHT && this.enableTextSelection(), o(this, Zi)) {
      b(this, Zi, !1);
      return;
    }
    const {
      isMac: t
    } = ue.platform;
    if (e.button !== 0 || e.ctrlKey && t || e.target !== this.div)
      return;
    b(this, Zi, !0);
    const s = o(this, z).getActive();
    b(this, Oo, !s || s.isEmpty());
  }
  findNewParent(e, t, s) {
    const i = o(this, z).findParent(t, s);
    return i === null || i === this ? !1 : (i.changeParent(e), !0);
  }
  destroy() {
    var e, t;
    ((e = o(this, z).getActive()) == null ? void 0 : e.parent) === this && (o(this, z).commitOrRemove(), o(this, z).setActiveEditor(null)), o(this, oi) && (clearTimeout(o(this, oi)), b(this, oi, null));
    for (const s of o(this, we).values())
      (t = o(this, Ir)) == null || t.removePointerInTextLayer(s.contentDiv), s.setParent(null), s.isAttachedToDOM = !1, s.div.remove();
    this.div = null, o(this, we).clear(), o(this, z).removeLayer(this);
  }
  render({
    viewport: e
  }) {
    this.viewport = e, ta(this.div, e);
    for (const t of o(this, z).getEditors(this.pageIndex))
      this.add(t), t.rebuild();
    this.updateMode();
  }
  update({
    viewport: e
  }) {
    o(this, z).commitOrRemove(), v(this, Fo, Wu).call(this);
    const t = this.viewport.rotation, s = e.rotation;
    if (this.viewport = e, ta(this.div, {
      rotation: s
    }), t !== s)
      for (const i of o(this, we).values())
        i.rotate(s);
    this.addInkEditorIfNeeded(!1);
  }
  get pageDimensions() {
    const {
      pageWidth: e,
      pageHeight: t
    } = this.viewport.rawDims;
    return [e, t];
  }
  get scale() {
    return o(this, z).viewParameters.realScale;
  }
}, Ir = new WeakMap(), Oo = new WeakMap(), bs = new WeakMap(), Lr = new WeakMap(), ri = new WeakMap(), ai = new WeakMap(), oi = new WeakMap(), we = new WeakMap(), Zi = new WeakMap(), Do = new WeakMap(), ko = new WeakMap(), se = new WeakMap(), z = new WeakMap(), Ji = new WeakMap(), Jp = new WeakSet(), xE = function(e) {
  if (o(this, z).unselectAll(), e.target === o(this, se).div) {
    const {
      isMac: t
    } = ue.platform;
    if (e.button !== 0 || e.ctrlKey && t)
      return;
    o(this, z).showAllEditors("highlight", !0, !0), o(this, se).div.classList.add("free"), cf.startHighlighting(this, o(this, z).direction === "ltr", e), o(this, se).div.addEventListener("pointerup", () => {
      o(this, se).div.classList.remove("free");
    }, {
      once: !0,
      signal: o(this, z)._signal
    }), e.preventDefault();
  }
}, rd = new WeakSet(), Av = function() {
  return o(xe, Ji).get(o(this, z).getMode());
}, ad = new WeakSet(), Ev = function(e) {
  const t = o(this, rd, Av);
  return t ? new t.prototype.constructor(e) : null;
}, od = new WeakSet(), wv = function() {
  const {
    x: e,
    y: t,
    width: s,
    height: i
  } = this.div.getBoundingClientRect(), n = Math.max(0, e), r = Math.max(0, t), a = Math.min(window.innerWidth, e + s), h = Math.min(window.innerHeight, t + i), c = (n + a) / 2 - e, d = (r + h) / 2 - t, [u, f] = this.viewport.rotation % 180 === 0 ? [c, d] : [d, c];
  return {
    offsetX: u,
    offsetY: f
  };
}, Fo = new WeakSet(), Wu = function() {
  b(this, Do, !0);
  for (const e of o(this, we).values())
    e.isEmpty() && e.remove();
  b(this, Do, !1);
}, K(xe, "_initialized", !1), p(xe, Ji, new Map([qm, cv, vv, cf].map((e) => [e._editorType, e]))), xe);
var ys, ld, Lt, qi, hd, Mt, Sv, cd, xv, qp, PE;
let LS = (Mt = class {
  constructor({
    pageIndex: e
  }) {
    p(this, cd);
    p(this, qp);
    p(this, ys, null);
    p(this, ld, 0);
    p(this, Lt, /* @__PURE__ */ new Map());
    p(this, qi, /* @__PURE__ */ new Map());
    this.pageIndex = e;
  }
  setParent(e) {
    if (!o(this, ys)) {
      b(this, ys, e);
      return;
    }
    if (o(this, ys) !== e) {
      if (o(this, Lt).size > 0)
        for (const t of o(this, Lt).values())
          t.remove(), e.append(t);
      b(this, ys, e);
    }
  }
  static get _svgFactory() {
    return et(this, "_svgFactory", new rb());
  }
  highlight(e, t, s, i = !1) {
    const n = oe(this, ld)._++, r = v(this, cd, xv).call(this, e.box);
    r.classList.add("highlight"), e.free && r.classList.add("free");
    const a = Mt._svgFactory.createElement("defs");
    r.append(a);
    const h = Mt._svgFactory.createElement("path");
    a.append(h);
    const c = `path_p${this.pageIndex}_${n}`;
    h.setAttribute("id", c), h.setAttribute("d", e.toSVGPath()), i && o(this, qi).set(n, h);
    const d = v(this, qp, PE).call(this, a, c), u = Mt._svgFactory.createElement("use");
    return r.append(u), r.setAttribute("fill", t), r.setAttribute("fill-opacity", s), u.setAttribute("href", `#${c}`), o(this, Lt).set(n, r), {
      id: n,
      clipPathId: `url(#${d})`
    };
  }
  highlightOutline(e) {
    const t = oe(this, ld)._++, s = v(this, cd, xv).call(this, e.box);
    s.classList.add("highlightOutline");
    const i = Mt._svgFactory.createElement("defs");
    s.append(i);
    const n = Mt._svgFactory.createElement("path");
    i.append(n);
    const r = `path_p${this.pageIndex}_${t}`;
    n.setAttribute("id", r), n.setAttribute("d", e.toSVGPath()), n.setAttribute("vector-effect", "non-scaling-stroke");
    let a;
    if (e.free) {
      s.classList.add("free");
      const d = Mt._svgFactory.createElement("mask");
      i.append(d), a = `mask_p${this.pageIndex}_${t}`, d.setAttribute("id", a), d.setAttribute("maskUnits", "objectBoundingBox");
      const u = Mt._svgFactory.createElement("rect");
      d.append(u), u.setAttribute("width", "1"), u.setAttribute("height", "1"), u.setAttribute("fill", "white");
      const f = Mt._svgFactory.createElement("use");
      d.append(f), f.setAttribute("href", `#${r}`), f.setAttribute("stroke", "none"), f.setAttribute("fill", "black"), f.setAttribute("fill-rule", "nonzero"), f.classList.add("mask");
    }
    const h = Mt._svgFactory.createElement("use");
    s.append(h), h.setAttribute("href", `#${r}`), a && h.setAttribute("mask", `url(#${a})`);
    const c = h.cloneNode();
    return s.append(c), h.classList.add("mainOutline"), c.classList.add("secondaryOutline"), o(this, Lt).set(t, s), t;
  }
  finalizeLine(e, t) {
    const s = o(this, qi).get(e);
    o(this, qi).delete(e), this.updateBox(e, t.box), s.setAttribute("d", t.toSVGPath());
  }
  updateLine(e, t) {
    o(this, Lt).get(e).firstChild.firstChild.setAttribute("d", t.toSVGPath());
  }
  removeFreeHighlight(e) {
    this.remove(e), o(this, qi).delete(e);
  }
  updatePath(e, t) {
    o(this, qi).get(e).setAttribute("d", t.toSVGPath());
  }
  updateBox(e, t) {
    var s;
    v(s = Mt, hd, Sv).call(s, o(this, Lt).get(e), t);
  }
  show(e, t) {
    o(this, Lt).get(e).classList.toggle("hidden", !t);
  }
  rotate(e, t) {
    o(this, Lt).get(e).setAttribute("data-main-rotation", t);
  }
  changeColor(e, t) {
    o(this, Lt).get(e).setAttribute("fill", t);
  }
  changeOpacity(e, t) {
    o(this, Lt).get(e).setAttribute("fill-opacity", t);
  }
  addClass(e, t) {
    o(this, Lt).get(e).classList.add(t);
  }
  removeClass(e, t) {
    o(this, Lt).get(e).classList.remove(t);
  }
  remove(e) {
    o(this, ys) !== null && (o(this, Lt).get(e).remove(), o(this, Lt).delete(e));
  }
  destroy() {
    b(this, ys, null);
    for (const e of o(this, Lt).values())
      e.remove();
    o(this, Lt).clear();
  }
}, ys = new WeakMap(), ld = new WeakMap(), Lt = new WeakMap(), qi = new WeakMap(), hd = new WeakSet(), Sv = function(e, {
  x: t = 0,
  y: s = 0,
  width: i = 1,
  height: n = 1
} = {}) {
  const {
    style: r
  } = e;
  r.top = `${100 * s}%`, r.left = `${100 * t}%`, r.width = `${100 * i}%`, r.height = `${100 * n}%`;
}, cd = new WeakSet(), xv = function(e) {
  var s;
  const t = Mt._svgFactory.create(1, 1, !0);
  return o(this, ys).append(t), t.setAttribute("aria-hidden", !0), v(s = Mt, hd, Sv).call(s, t, e), t;
}, qp = new WeakSet(), PE = function(e, t) {
  const s = Mt._svgFactory.createElement("clipPath");
  e.append(s);
  const i = `clip_${t}`;
  s.setAttribute("id", i), s.setAttribute("clipPathUnits", "objectBoundingBox");
  const n = Mt._svgFactory.createElement("use");
  return s.append(n), n.setAttribute("href", `#${t}`), n.classList.add("clip"), i;
}, p(Mt, hd), Mt);
G.AbortException;
G.AnnotationEditorLayer;
G.AnnotationEditorParamsType;
G.AnnotationEditorType;
G.AnnotationEditorUIManager;
var _S = G.AnnotationLayer;
G.AnnotationMode;
G.CMapCompressionType;
G.ColorPicker;
G.DOMSVGFactory;
G.DrawLayer;
G.FeatureTest;
var xT = G.GlobalWorkerOptions;
G.ImageKind;
G.InvalidPDFException;
G.MissingPDFException;
G.OPS;
G.Outliner;
G.PDFDataRangeTransport;
G.PDFDateString;
G.PDFWorker;
var MS = G.PasswordResponses;
G.PermissionFlag;
G.PixelsPerInch;
G.RenderingCancelledException;
var OS = G.TextLayer;
G.UnexpectedResponseException;
G.Util;
G.VerbosityLevel;
G.XfaLayer;
G.build;
G.createValidAbsoluteUrl;
G.fetchData;
var DS = G.getDocument;
G.getFilenameFromUrl;
G.getPdfFilenameFromUrl;
G.getXfaPageViewport;
G.isDataScheme;
G.isPdfFile;
G.noContextMenu;
G.normalizeUnicode;
G.renderTextLayer;
G.setLayerDimensions;
G.shadow;
G.updateTextLayer;
G.version;
function kS(l, e, t) {
  const s = l.contentWindow.document.createElement("style");
  s.textContent = `
    @page {
      margin: 3mm;
      size: ${e}pt ${t}pt;
    }
    body {
      margin: 0;
    }
    canvas {
      width: 100%;
      page-break-after: always;
      page-break-before: avoid;
      page-break-inside: avoid;
    }
  `, l.contentWindow.document.head.appendChild(s), l.contentWindow.document.body.style.width = "100%";
}
function FS(l) {
  return new Promise((e) => {
    const t = document.createElement("iframe");
    t.width = "0", t.height = "0", t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.border = "none", t.style.overflow = "hidden", t.onload = () => e(t), l.appendChild(t);
  });
}
function NS(l, e) {
  const t = URL.createObjectURL(
    new Blob([l], {
      type: "application/pdf"
    })
  ), s = document.createElement("a");
  s.href = t, s.download = e, s.style.display = "none", document.body.append(s), s.click(), setTimeout(() => {
    URL.revokeObjectURL(t), document.body.removeChild(s);
  }, 1e3);
}
function $b(l) {
  for (; l != null && l.firstChild; )
    l.removeChild(l.firstChild);
}
function em(l) {
  l == null || l.querySelectorAll("canvas").forEach((e) => {
    var t;
    e.width = 1, e.height = 1, (t = e.getContext("2d")) == null || t.clearRect(0, 0, 1, 1);
  });
}
function Vb(l) {
  return Object.prototype.hasOwnProperty.call(l, "_pdfInfo");
}
function BS({
  onError: l,
  onPasswordRequest: e,
  onProgress: t,
  source: s
}) {
  const i = sf(null), n = sf(null);
  return E0(async () => {
    const r = yb(s);
    if (r) {
      if (Vb(r)) {
        i.value = r;
        return;
      }
      try {
        n.value = DS(
          r
        ), e && (n.value.onPassword = (a, h) => {
          e({
            callback: a,
            isWrongPassword: h === MS.INCORRECT_PASSWORD
          });
        }), t && (n.value.onProgress = t), i.value = await n.value.promise;
      } catch (a) {
        if (i.value = null, l)
          l(a);
        else
          throw a;
      }
    }
  }), cm(i, (r, a) => {
    a == null || a.destroy();
  }), Cy(() => {
    var r, a, h, c;
    (r = n.value) != null && r.onPassword && (n.value.onPassword = null), (a = n.value) != null && a.onProgress && (n.value.onProgress = null), (h = n.value) == null || h.destroy(), Vb(yb(s)) || (c = i.value) == null || c.destroy();
  }), {
    doc: i
  };
}
var jl = {};
jl.d = (l, e) => {
  for (var t in e)
    jl.o(e, t) && !jl.o(l, t) && Object.defineProperty(l, t, { enumerable: !0, get: e[t] });
};
jl.o = (l, e) => Object.prototype.hasOwnProperty.call(l, e);
var gt = globalThis.pdfjsViewer = {};
jl.d(gt, {
  AnnotationLayerBuilder: () => (
    /* reexport */
    BE
  ),
  DownloadManager: () => (
    /* reexport */
    Ox
  ),
  EventBus: () => (
    /* reexport */
    jE
  ),
  FindState: () => (
    /* reexport */
    wi
  ),
  GenericL10n: () => (
    /* reexport */
    ol
  ),
  LinkTarget: () => (
    /* reexport */
    En
  ),
  PDFFindController: () => (
    /* reexport */
    Ax
  ),
  PDFHistory: () => (
    /* reexport */
    LP
  ),
  PDFLinkService: () => (
    /* reexport */
    uf
  ),
  PDFPageView: () => (
    /* reexport */
    n0
  ),
  PDFScriptingManager: () => (
    /* reexport */
    UP
  ),
  PDFSinglePageViewer: () => (
    /* reexport */
    XP
  ),
  PDFViewer: () => (
    /* reexport */
    h0
  ),
  ProgressBar: () => (
    /* reexport */
    ZS
  ),
  RenderingStates: () => (
    /* reexport */
    At
  ),
  ScrollMode: () => (
    /* reexport */
    J
  ),
  SimpleLinkService: () => (
    /* reexport */
    fb
  ),
  SpreadMode: () => (
    /* reexport */
    Zt
  ),
  StructTreeLayerBuilder: () => (
    /* reexport */
    qE
  ),
  TextLayerBuilder: () => (
    /* reexport */
    gf
  ),
  XfaLayerBuilder: () => (
    /* reexport */
    i0
  ),
  parseQueryString: () => (
    /* reexport */
    Wg
  )
});
const jS = "auto", TE = 1, Ub = 1.1, HS = 0.1, $S = 10, sm = 0, VS = 1.25, zb = 40, Wb = 5, At = {
  INITIAL: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3
}, va = {
  UNKNOWN: 0,
  NORMAL: 1,
  CHANGING: 2,
  FULLSCREEN: 3
}, xs = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_PERMISSIONS: 2
}, J = {
  UNKNOWN: -1,
  VERTICAL: 0,
  HORIZONTAL: 1,
  WRAPPED: 2,
  PAGE: 3
}, Zt = {
  UNKNOWN: -1,
  NONE: 0,
  ODD: 1,
  EVEN: 2
};
class US {
  constructor() {
    const e = window.devicePixelRatio || 1;
    this.sx = e, this.sy = e;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
}
function CE(l, e, t = !1) {
  let s = l.offsetParent;
  if (!s) {
    console.error("offsetParent is not set -- cannot scroll");
    return;
  }
  let i = l.offsetTop + l.clientTop, n = l.offsetLeft + l.clientLeft;
  for (; s.clientHeight === s.scrollHeight && s.clientWidth === s.scrollWidth || t && (s.classList.contains("markedContent") || getComputedStyle(s).overflow === "hidden"); )
    if (i += s.offsetTop, n += s.offsetLeft, s = s.offsetParent, !s)
      return;
  e && (e.top !== void 0 && (i += e.top), e.left !== void 0 && (n += e.left, s.scrollLeft = n)), s.scrollTop = i;
}
function zS(l, e, t = void 0) {
  const s = function(r) {
    n || (n = window.requestAnimationFrame(function() {
      n = null;
      const h = l.scrollLeft, c = i.lastX;
      h !== c && (i.right = h > c), i.lastX = h;
      const d = l.scrollTop, u = i.lastY;
      d !== u && (i.down = d > u), i.lastY = d, e(i);
    }));
  }, i = {
    right: !0,
    down: !0,
    lastX: l.scrollLeft,
    lastY: l.scrollTop,
    _eventHandler: s
  };
  let n = null;
  return l.addEventListener("scroll", s, {
    useCapture: !0,
    signal: t
  }), t == null || t.addEventListener("abort", () => window.cancelAnimationFrame(n), {
    once: !0
  }), i;
}
function Wg(l) {
  const e = /* @__PURE__ */ new Map();
  for (const [t, s] of new URLSearchParams(l))
    e.set(t.toLowerCase(), s);
  return e;
}
const Gb = /[\x00-\x1F]/g;
function df(l, e = !1) {
  return Gb.test(l) ? e ? l.replaceAll(Gb, (t) => t === "\0" ? "" : " ") : l.replaceAll("\0", "") : l;
}
function zl(l, e, t = 0) {
  let s = t, i = l.length - 1;
  if (i < 0 || !e(l[i]))
    return l.length;
  if (e(l[s]))
    return s;
  for (; s < i; ) {
    const n = s + i >> 1, r = l[n];
    e(r) ? i = n : s = n + 1;
  }
  return s;
}
function Xb(l) {
  if (Math.floor(l) === l)
    return [l, 1];
  const e = 1 / l, t = 8;
  if (e > t)
    return [1, t];
  if (Math.floor(e) === e)
    return [1, e];
  const s = l > 1 ? e : l;
  let i = 0, n = 1, r = 1, a = 1;
  for (; ; ) {
    const c = i + r, d = n + a;
    if (d > t)
      break;
    s <= c / d ? (r = c, a = d) : (i = c, n = d);
  }
  let h;
  return s - i / n < r / a - s ? h = s === l ? [i, n] : [n, i] : h = s === l ? [r, a] : [a, r], h;
}
function uu(l, e) {
  return l - l % e;
}
function WS(l, e, t) {
  if (l < 2)
    return l;
  let s = e[l].div, i = s.offsetTop + s.clientTop;
  i >= t && (s = e[l - 1].div, i = s.offsetTop + s.clientTop);
  for (let n = l - 2; n >= 0 && (s = e[n].div, !(s.offsetTop + s.clientTop + s.clientHeight <= i)); --n)
    l = n;
  return l;
}
function GS({
  scrollEl: l,
  views: e,
  sortByVisibility: t = !1,
  horizontal: s = !1,
  rtl: i = !1
}) {
  const n = l.scrollTop, r = n + l.clientHeight, a = l.scrollLeft, h = a + l.clientWidth;
  function c(w) {
    const S = w.div;
    return S.offsetTop + S.clientTop + S.clientHeight > n;
  }
  function d(w) {
    const S = w.div, C = S.offsetLeft + S.clientLeft, P = C + S.clientWidth;
    return i ? C < h : P > a;
  }
  const u = [], f = /* @__PURE__ */ new Set(), m = e.length;
  let g = zl(e, s ? d : c);
  g > 0 && g < m && !s && (g = WS(g, e, n));
  let A = s ? h : -1;
  for (let w = g; w < m; w++) {
    const S = e[w], C = S.div, P = C.offsetLeft + C.clientLeft, x = C.offsetTop + C.clientTop, R = C.clientWidth, M = C.clientHeight, T = P + R, I = x + M;
    if (A === -1)
      I >= r && (A = I);
    else if ((s ? P : x) > A)
      break;
    if (I <= n || x >= r || T <= a || P >= h)
      continue;
    const _ = Math.max(0, n - x) + Math.max(0, I - r), k = Math.max(0, a - P) + Math.max(0, T - h), F = (M - _) / M, V = (R - k) / R, $ = F * V * 100 | 0;
    u.push({
      id: S.id,
      x: P,
      y: x,
      view: S,
      percent: $,
      widthPercent: V * 100 | 0
    }), f.add(S.id);
  }
  const E = u[0], y = u.at(-1);
  return t && u.sort(function(w, S) {
    const C = w.percent - S.percent;
    return Math.abs(C) > 1e-3 ? -C : w.id - S.id;
  }), {
    first: E,
    last: y,
    views: u,
    ids: f
  };
}
function RE(l) {
  return Number.isInteger(l) && l % 90 === 0;
}
function XS(l) {
  return Number.isInteger(l) && Object.values(J).includes(l) && l !== J.UNKNOWN;
}
function KS(l) {
  return Number.isInteger(l) && Object.values(Zt).includes(l) && l !== Zt.UNKNOWN;
}
function Kb(l) {
  return l.width <= l.height;
}
new Promise(function(l) {
  window.requestAnimationFrame(l);
});
const YS = document.documentElement.style;
function QS(l, e, t) {
  return Math.min(Math.max(l, e), t);
}
var tn, _r, Mr, No, Or;
class ZS {
  constructor(e) {
    p(this, tn, null);
    p(this, _r, null);
    p(this, Mr, 0);
    p(this, No, null);
    p(this, Or, !0);
    b(this, tn, e.classList), b(this, No, e.style);
  }
  get percent() {
    return o(this, Mr);
  }
  set percent(e) {
    if (b(this, Mr, QS(e, 0, 100)), isNaN(e)) {
      o(this, tn).add("indeterminate");
      return;
    }
    o(this, tn).remove("indeterminate"), o(this, No).setProperty("--progressBar-percent", `${o(this, Mr)}%`);
  }
  setWidth(e) {
    if (!e)
      return;
    const s = e.parentNode.offsetWidth - e.offsetWidth;
    s > 0 && o(this, No).setProperty("--progressBar-end-offset", `${s}px`);
  }
  setDisableAutoFetch(e = 5e3) {
    isNaN(o(this, Mr)) || (o(this, _r) && clearTimeout(o(this, _r)), this.show(), b(this, _r, setTimeout(() => {
      b(this, _r, null), this.hide();
    }, e)));
  }
  hide() {
    o(this, Or) && (b(this, Or, !1), o(this, tn).add("hidden"));
  }
  show() {
    o(this, Or) || (b(this, Or, !0), o(this, tn).remove("hidden"));
  }
}
tn = new WeakMap(), _r = new WeakMap(), Mr = new WeakMap(), No = new WeakMap(), Or = new WeakMap();
function JS(l) {
  let e = J.VERTICAL, t = Zt.NONE;
  switch (l) {
    case "SinglePage":
      e = J.PAGE;
      break;
    case "OneColumn":
      break;
    case "TwoPageLeft":
      e = J.PAGE;
    case "TwoColumnLeft":
      t = Zt.ODD;
      break;
    case "TwoPageRight":
      e = J.PAGE;
    case "TwoColumnRight":
      t = Zt.EVEN;
      break;
  }
  return {
    scrollMode: e,
    spreadMode: t
  };
}
const Fe = {
  SPACE: 0,
  ALPHA_LETTER: 1,
  PUNCT: 2,
  HAN_LETTER: 3,
  KATAKANA_LETTER: 4,
  HIRAGANA_LETTER: 5,
  HALFWIDTH_KATAKANA_LETTER: 6,
  THAI_LETTER: 7
};
function qS(l) {
  return l < 11904;
}
function tx(l) {
  return (l & 65408) === 0;
}
function ex(l) {
  return l >= 97 && l <= 122 || l >= 65 && l <= 90;
}
function sx(l) {
  return l >= 48 && l <= 57;
}
function ix(l) {
  return l === 32 || l === 9 || l === 13 || l === 10;
}
function nx(l) {
  return l >= 13312 && l <= 40959 || l >= 63744 && l <= 64255;
}
function rx(l) {
  return l >= 12448 && l <= 12543;
}
function ax(l) {
  return l >= 12352 && l <= 12447;
}
function ox(l) {
  return l >= 65376 && l <= 65439;
}
function lx(l) {
  return (l & 65408) === 3584;
}
function fu(l) {
  return qS(l) ? tx(l) ? ix(l) ? Fe.SPACE : ex(l) || sx(l) || l === 95 ? Fe.ALPHA_LETTER : Fe.PUNCT : lx(l) ? Fe.THAI_LETTER : l === 160 ? Fe.SPACE : Fe.ALPHA_LETTER : nx(l) ? Fe.HAN_LETTER : rx(l) ? Fe.KATAKANA_LETTER : ax(l) ? Fe.HIRAGANA_LETTER : ox(l) ? Fe.HALFWIDTH_KATAKANA_LETTER : Fe.ALPHA_LETTER;
}
let Yb;
function hx() {
  return Yb || (Yb = " ¨ª¯²-µ¸-º¼-¾Ĳ-ĳĿ-ŀŉſǄ-ǌǱ-ǳʰ-ʸ˘-˝ˠ-ˤʹͺ;΄-΅·ϐ-ϖϰ-ϲϴ-ϵϹևٵ-ٸक़-य़ড়-ঢ়য়ਲ਼ਸ਼ਖ਼-ਜ਼ਫ਼ଡ଼-ଢ଼ำຳໜ-ໝ༌གྷཌྷདྷབྷཛྷཀྵჼᴬ-ᴮᴰ-ᴺᴼ-ᵍᵏ-ᵪᵸᶛ-ᶿẚ-ẛάέήίόύώΆ᾽-῁ΈΉ῍-῏ΐΊ῝-῟ΰΎ῭-`ΌΏ´-῾ - ‑‗․-… ″-‴‶-‷‼‾⁇-⁉⁗ ⁰-ⁱ⁴-₎ₐ-ₜ₨℀-℃℅-ℇ℉-ℓℕ-№ℙ-ℝ℠-™ℤΩℨK-ℭℯ-ℱℳ-ℹ℻-⅀ⅅ-ⅉ⅐-ⅿ↉∬-∭∯-∰〈-〉①-⓪⨌⩴-⩶⫝̸ⱼ-ⱽⵯ⺟⻳⼀-⿕　〶〸-〺゛-゜ゟヿㄱ-ㆎ㆒-㆟㈀-㈞㈠-㉇㉐-㉾㊀-㏿ꚜ-ꚝꝰꟲ-ꟴꟸ-ꟹꭜ-ꭟꭩ豈-嗀塚晴凞-羽蘒諸逸-都飯-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷼︐-︙︰-﹄﹇-﹒﹔-﹦﹨-﹫ﹰ-ﹲﹴﹶ-ﻼ！-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ￠-￦"), Yb;
}
const wi = {
  FOUND: 0,
  NOT_FOUND: 1,
  WRAPPED: 2,
  PENDING: 3
}, cx = 250, dx = -50, ux = -400, Qb = {
  "‐": "-",
  "‘": "'",
  "’": "'",
  "‚": "'",
  "‛": "'",
  "“": '"',
  "”": '"',
  "„": '"',
  "‟": '"',
  "¼": "1/4",
  "½": "1/2",
  "¾": "3/4"
}, Zb = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
let Jb;
const fx = /\p{M}+/gu, px = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu, gx = /([^\p{M}])\p{M}*$/u, mx = /^\p{M}*([^\p{M}])/u, vx = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g, qb = /* @__PURE__ */ new Map(), bx = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]", ty = /* @__PURE__ */ new Map();
let im = null, nm = null;
function rm(l) {
  const e = [];
  let t;
  for (; (t = vx.exec(l)) !== null; ) {
    let {
      index: m
    } = t;
    for (const g of t[0]) {
      let A = qb.get(g);
      A || (A = g.normalize("NFD").length, qb.set(g, A)), e.push([A, m++]);
    }
  }
  let s;
  if (e.length === 0 && im)
    s = im;
  else if (e.length > 0 && nm)
    s = nm;
  else {
    const m = Object.keys(Qb).join(""), g = hx(), y = `([${m}])|([${g}])|((?:゙|゚)\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|((?:\\p{Ideographic}|[぀-ヿ])\\n)|(\\n)`;
    e.length === 0 ? s = im = new RegExp(y + "|(\\u0000)", "gum") : s = nm = new RegExp(y + `|(${bx})`, "gum");
  }
  const i = [];
  for (; (t = fx.exec(l)) !== null; )
    i.push([t[0].length, t.index]);
  let n = l.normalize("NFD");
  const r = [[0, 0]];
  let a = 0, h = 0, c = 0, d = 0, u = 0, f = !1;
  return n = n.replace(s, (m, g, A, E, y, w, S, C, P, x) => {
    var R, M, T;
    if (x -= d, g) {
      const I = Qb[g], _ = I.length;
      for (let k = 1; k < _; k++)
        r.push([x - c + k, c - k]);
      return c -= _ - 1, I;
    }
    if (A) {
      let I = ty.get(A);
      I || (I = A.normalize("NFKC"), ty.set(A, I));
      const _ = I.length;
      for (let k = 1; k < _; k++)
        r.push([x - c + k, c - k]);
      return c -= _ - 1, I;
    }
    if (E)
      return f = !0, x + u === ((R = i[a]) == null ? void 0 : R[1]) ? ++a : (r.push([x - 1 - c + 1, c - 1]), c -= 1, d += 1), r.push([x - c + 1, c]), d += 1, u += 1, E.charAt(0);
    if (y) {
      const I = y.endsWith(`
`), _ = I ? y.length - 2 : y.length;
      f = !0;
      let k = _;
      x + u === ((M = i[a]) == null ? void 0 : M[1]) && (k -= i[a][0], ++a);
      for (let F = 1; F <= k; F++)
        r.push([x - 1 - c + F, c - F]);
      return c -= k, d += k, I ? (x += _ - 1, r.push([x - c + 1, 1 + c]), c += 1, d += 1, u += 1, y.slice(0, _)) : y;
    }
    if (w) {
      const I = w.length - 2;
      return r.push([x - c + I, 1 + c]), c += 1, d += 1, u += 1, w.slice(0, -2);
    }
    if (S) {
      const I = S.length - 1;
      return r.push([x - c + I, c]), d += 1, u += 1, S.slice(0, -1);
    }
    if (C)
      return r.push([x - c + 1, c - 1]), c -= 1, d += 1, u += 1, " ";
    if (x + u === ((T = e[h]) == null ? void 0 : T[1])) {
      const I = e[h][0] - 1;
      ++h;
      for (let _ = 1; _ <= I; _++)
        r.push([x - (c - _), c - _]);
      c -= I, d += I;
    }
    return P;
  }), r.push([n.length, c]), [n, r, f];
}
function yx(l, e, t) {
  if (!l)
    return [e, t];
  const s = e, i = e + t - 1;
  let n = zl(l, (d) => d[0] >= s);
  l[n][0] > s && --n;
  let r = zl(l, (d) => d[0] >= i, n);
  l[r][0] > i && --r;
  const a = s + l[n][1], c = i + l[r][1] + 1 - a;
  return [a, c];
}
var Bt, Bo, Dr, tg, IE, dd, Pv, ud, Tv, eg, LE, sg, _E, ig, ME, fd, Cv, ng, OE, rg, DE, jo, Gu, kr, _l, en, ua, ag, kE, pd, Rv, gd, Iv, Ho, Xu, og, FE, md, Lv, vd, _v, Fr, Ml;
class Ax {
  constructor({
    linkService: e,
    eventBus: t,
    updateMatchesCountOnProgress: s = !0
  }) {
    p(this, tg);
    p(this, dd);
    p(this, ud);
    p(this, eg);
    p(this, sg);
    p(this, ig);
    p(this, fd);
    p(this, ng);
    p(this, rg);
    p(this, jo);
    p(this, kr);
    p(this, en);
    p(this, ag);
    p(this, pd);
    p(this, gd);
    p(this, Ho);
    p(this, og);
    p(this, md);
    p(this, vd);
    p(this, Fr);
    p(this, Bt, null);
    p(this, Bo, !0);
    p(this, Dr, 0);
    this._linkService = e, this._eventBus = t, b(this, Bo, s), this.onIsPageVisible = null, v(this, dd, Pv).call(this), t._on("find", v(this, tg, IE).bind(this)), t._on("findbarclose", v(this, og, FE).bind(this));
  }
  get highlightMatches() {
    return this._highlightMatches;
  }
  get pageMatches() {
    return this._pageMatches;
  }
  get pageMatchesLength() {
    return this._pageMatchesLength;
  }
  get selected() {
    return this._selected;
  }
  get state() {
    return o(this, Bt);
  }
  setDocument(e) {
    this._pdfDocument && v(this, dd, Pv).call(this), e && (this._pdfDocument = e, this._firstPageCapability.resolve());
  }
  scrollMatchIntoView({
    element: e = null,
    selectedLeft: t = 0,
    pageIndex: s = -1,
    matchIndex: i = -1
  }) {
    if (!this._scrollMatches || !e)
      return;
    if (i === -1 || i !== this._selected.matchIdx)
      return;
    if (s === -1 || s !== this._selected.pageIdx)
      return;
    this._scrollMatches = !1;
    const n = {
      top: dx,
      left: t + ux
    };
    CE(e, n, !0);
  }
}
Bt = new WeakMap(), Bo = new WeakMap(), Dr = new WeakMap(), tg = new WeakSet(), IE = function(e) {
  if (!e)
    return;
  const t = this._pdfDocument, {
    type: s
  } = e;
  (o(this, Bt) === null || v(this, eg, LE).call(this, e)) && (this._dirtyMatch = !0), b(this, Bt, e), s !== "highlightallchange" && v(this, Fr, Ml).call(this, wi.PENDING), this._firstPageCapability.promise.then(() => {
    if (!this._pdfDocument || t && this._pdfDocument !== t)
      return;
    v(this, rg, DE).call(this);
    const i = !this._highlightMatches, n = !!this._findTimeout;
    this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), s ? this._dirtyMatch ? v(this, en, ua).call(this) : s === "again" ? (v(this, en, ua).call(this), i && o(this, Bt).highlightAll && v(this, kr, _l).call(this)) : s === "highlightallchange" ? (n ? v(this, en, ua).call(this) : this._highlightMatches = !0, v(this, kr, _l).call(this)) : v(this, en, ua).call(this) : this._findTimeout = setTimeout(() => {
      v(this, en, ua).call(this), this._findTimeout = null;
    }, cx);
  });
}, dd = new WeakSet(), Pv = function() {
  this._highlightMatches = !1, this._scrollMatches = !1, this._pdfDocument = null, this._pageMatches = [], this._pageMatchesLength = [], b(this, Dr, 0), b(this, Bt, null), this._selected = {
    pageIdx: -1,
    matchIdx: -1
  }, this._offset = {
    pageIdx: null,
    matchIdx: null,
    wrapped: !1
  }, this._extractTextPromises = [], this._pageContents = [], this._pageDiffs = [], this._hasDiacritics = [], this._matchesCountTotal = 0, this._pagesToSearch = null, this._pendingFindMatches = /* @__PURE__ */ new Set(), this._resumePageIdx = null, this._dirtyMatch = !1, clearTimeout(this._findTimeout), this._findTimeout = null, this._firstPageCapability = Promise.withResolvers();
}, ud = new WeakSet(), Tv = function() {
  const {
    query: e
  } = o(this, Bt);
  return typeof e == "string" ? (e !== this._rawQuery && (this._rawQuery = e, [this._normalizedQuery] = rm(e)), this._normalizedQuery) : (e || []).filter((t) => !!t).map((t) => rm(t)[0]);
}, eg = new WeakSet(), LE = function(e) {
  var r;
  const t = e.query, s = o(this, Bt).query, i = typeof t;
  if (i !== typeof s)
    return !0;
  if (i === "string") {
    if (t !== s)
      return !0;
  } else if (JSON.stringify(t) !== JSON.stringify(s))
    return !0;
  switch (e.type) {
    case "again":
      const a = this._selected.pageIdx + 1, h = this._linkService;
      return a >= 1 && a <= h.pagesCount && a !== h.page && !(((r = this.onIsPageVisible) == null ? void 0 : r.call(this, a)) ?? !0);
    case "highlightallchange":
      return !1;
  }
  return !0;
}, sg = new WeakSet(), _E = function(e, t, s) {
  let i = e.slice(0, t).match(gx);
  if (i) {
    const n = e.charCodeAt(t), r = i[1].charCodeAt(0);
    if (fu(n) === fu(r))
      return !1;
  }
  if (i = e.slice(t + s).match(mx), i) {
    const n = e.charCodeAt(t + s - 1), r = i[1].charCodeAt(0);
    if (fu(n) === fu(r))
      return !1;
  }
  return !0;
}, ig = new WeakSet(), ME = function(e, t, s, i) {
  const n = this._pageMatches[s] = [], r = this._pageMatchesLength[s] = [];
  if (!e)
    return;
  const a = this._pageDiffs[s];
  let h;
  for (; (h = e.exec(i)) !== null; ) {
    if (t && !v(this, sg, _E).call(this, i, h.index, h[0].length))
      continue;
    const [c, d] = yx(a, h.index, h[0].length);
    d && (n.push(c), r.push(d));
  }
}, fd = new WeakSet(), Cv = function(e, t) {
  const {
    matchDiacritics: s
  } = o(this, Bt);
  let i = !1;
  e = e.replaceAll(px, (r, a, h, c, d, u) => a ? `[ ]*\\${a}[ ]*` : h ? `[ ]*${h}[ ]*` : c ? "[ ]+" : s ? d || u : d ? Zb.has(d.charCodeAt(0)) ? d : "" : t ? (i = !0, `${u}\\p{M}*`) : u);
  const n = "[ ]*";
  return e.endsWith(n) && (e = e.slice(0, e.length - n.length)), s && t && (Jb || (Jb = String.fromCharCode(...Zb)), i = !0, e = `${e}(?=[${Jb}]|[^\\p{M}]|$)`), [i, e];
}, ng = new WeakSet(), OE = function(e) {
  let t = o(this, ud, Tv);
  if (t.length === 0)
    return;
  const {
    caseSensitive: s,
    entireWord: i
  } = o(this, Bt), n = this._pageContents[e], r = this._hasDiacritics[e];
  let a = !1;
  typeof t == "string" ? [a, t] = v(this, fd, Cv).call(this, t, r) : t = t.sort().reverse().map((d) => {
    const [u, f] = v(this, fd, Cv).call(this, d, r);
    return a || (a = u), `(${f})`;
  }).join("|");
  const h = `g${a ? "u" : ""}${s ? "" : "i"}`;
  t = t ? new RegExp(t, h) : null, v(this, ig, ME).call(this, t, i, e, n), o(this, Bt).highlightAll && v(this, jo, Gu).call(this, e), this._resumePageIdx === e && (this._resumePageIdx = null, v(this, pd, Rv).call(this));
  const c = this._pageMatches[e].length;
  this._matchesCountTotal += c, o(this, Bo) ? c > 0 && v(this, vd, _v).call(this) : ++oe(this, Dr)._ === this._linkService.pagesCount && v(this, vd, _v).call(this);
}, rg = new WeakSet(), DE = function() {
  if (this._extractTextPromises.length > 0)
    return;
  let e = Promise.resolve();
  const t = {
    disableNormalization: !0
  };
  for (let s = 0, i = this._linkService.pagesCount; s < i; s++) {
    const {
      promise: n,
      resolve: r
    } = Promise.withResolvers();
    this._extractTextPromises[s] = n, e = e.then(() => this._pdfDocument.getPage(s + 1).then((a) => a.getTextContent(t)).then((a) => {
      const h = [];
      for (const c of a.items)
        h.push(c.str), c.hasEOL && h.push(`
`);
      [this._pageContents[s], this._pageDiffs[s], this._hasDiacritics[s]] = rm(h.join("")), r();
    }, (a) => {
      console.error(`Unable to get text content for page ${s + 1}`, a), this._pageContents[s] = "", this._pageDiffs[s] = null, this._hasDiacritics[s] = !1, r();
    }));
  }
}, jo = new WeakSet(), Gu = function(e) {
  this._scrollMatches && this._selected.pageIdx === e && (this._linkService.page = e + 1), this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: e
  });
}, kr = new WeakSet(), _l = function() {
  this._eventBus.dispatch("updatetextlayermatches", {
    source: this,
    pageIndex: -1
  });
}, en = new WeakSet(), ua = function() {
  const e = o(this, Bt).findPrevious, t = this._linkService.page - 1, s = this._linkService.pagesCount;
  if (this._highlightMatches = !0, this._dirtyMatch) {
    this._dirtyMatch = !1, this._selected.pageIdx = this._selected.matchIdx = -1, this._offset.pageIdx = t, this._offset.matchIdx = null, this._offset.wrapped = !1, this._resumePageIdx = null, this._pageMatches.length = 0, this._pageMatchesLength.length = 0, b(this, Dr, 0), this._matchesCountTotal = 0, v(this, kr, _l).call(this);
    for (let r = 0; r < s; r++)
      this._pendingFindMatches.has(r) || (this._pendingFindMatches.add(r), this._extractTextPromises[r].then(() => {
        this._pendingFindMatches.delete(r), v(this, ng, OE).call(this, r);
      }));
  }
  if (o(this, ud, Tv).length === 0) {
    v(this, Fr, Ml).call(this, wi.FOUND);
    return;
  }
  if (this._resumePageIdx)
    return;
  const n = this._offset;
  if (this._pagesToSearch = s, n.matchIdx !== null) {
    const r = this._pageMatches[n.pageIdx].length;
    if (!e && n.matchIdx + 1 < r || e && n.matchIdx > 0) {
      n.matchIdx = e ? n.matchIdx - 1 : n.matchIdx + 1, v(this, Ho, Xu).call(this, !0);
      return;
    }
    v(this, gd, Iv).call(this, e);
  }
  v(this, pd, Rv).call(this);
}, ag = new WeakSet(), kE = function(e) {
  const t = this._offset, s = e.length, i = o(this, Bt).findPrevious;
  return s ? (t.matchIdx = i ? s - 1 : 0, v(this, Ho, Xu).call(this, !0), !0) : (v(this, gd, Iv).call(this, i), t.wrapped && (t.matchIdx = null, this._pagesToSearch < 0) ? (v(this, Ho, Xu).call(this, !1), !0) : !1);
}, pd = new WeakSet(), Rv = function() {
  this._resumePageIdx !== null && console.error("There can only be one pending page.");
  let e = null;
  do {
    const t = this._offset.pageIdx;
    if (e = this._pageMatches[t], !e) {
      this._resumePageIdx = t;
      break;
    }
  } while (!v(this, ag, kE).call(this, e));
}, gd = new WeakSet(), Iv = function(e) {
  const t = this._offset, s = this._linkService.pagesCount;
  t.pageIdx = e ? t.pageIdx - 1 : t.pageIdx + 1, t.matchIdx = null, this._pagesToSearch--, (t.pageIdx >= s || t.pageIdx < 0) && (t.pageIdx = e ? s - 1 : 0, t.wrapped = !0);
}, Ho = new WeakSet(), Xu = function(e = !1) {
  let t = wi.NOT_FOUND;
  const s = this._offset.wrapped;
  if (this._offset.wrapped = !1, e) {
    const i = this._selected.pageIdx;
    this._selected.pageIdx = this._offset.pageIdx, this._selected.matchIdx = this._offset.matchIdx, t = s ? wi.WRAPPED : wi.FOUND, i !== -1 && i !== this._selected.pageIdx && v(this, jo, Gu).call(this, i);
  }
  v(this, Fr, Ml).call(this, t, o(this, Bt).findPrevious), this._selected.pageIdx !== -1 && (this._scrollMatches = !0, v(this, jo, Gu).call(this, this._selected.pageIdx));
}, og = new WeakSet(), FE = function(e) {
  const t = this._pdfDocument;
  this._firstPageCapability.promise.then(() => {
    !this._pdfDocument || t && this._pdfDocument !== t || (this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), this._resumePageIdx && (this._resumePageIdx = null, this._dirtyMatch = !0), v(this, Fr, Ml).call(this, wi.FOUND), this._highlightMatches = !1, v(this, kr, _l).call(this));
  });
}, md = new WeakSet(), Lv = function() {
  var n;
  const {
    pageIdx: e,
    matchIdx: t
  } = this._selected;
  let s = 0, i = this._matchesCountTotal;
  if (t !== -1) {
    for (let r = 0; r < e; r++)
      s += ((n = this._pageMatches[r]) == null ? void 0 : n.length) || 0;
    s += t + 1;
  }
  return (s < 1 || s > i) && (s = i = 0), {
    current: s,
    total: i
  };
}, vd = new WeakSet(), _v = function() {
  this._eventBus.dispatch("updatefindmatchescount", {
    source: this,
    matchesCount: v(this, md, Lv).call(this)
  });
}, Fr = new WeakSet(), Ml = function(e, t = !1) {
  var s, i;
  !o(this, Bo) && (o(this, Dr) !== this._linkService.pagesCount || e === wi.PENDING) || this._eventBus.dispatch("updatefindcontrolstate", {
    source: this,
    state: e,
    previous: t,
    entireWord: ((s = o(this, Bt)) == null ? void 0 : s.entireWord) ?? null,
    matchesCount: v(this, md, Lv).call(this),
    rawQuery: ((i = o(this, Bt)) == null ? void 0 : i.query) ?? null
  });
};
const Ex = "noopener noreferrer nofollow", En = {
  NONE: 0,
  SELF: 1,
  BLANK: 2,
  PARENT: 3,
  TOP: 4
};
var lg, NE;
const hg = class hg {
  constructor({
    eventBus: e,
    externalLinkTarget: t = null,
    externalLinkRel: s = null,
    ignoreDestinationZoom: i = !1
  } = {}) {
    K(this, "externalLinkEnabled", !0);
    this.eventBus = e, this.externalLinkTarget = t, this.externalLinkRel = s, this._ignoreDestinationZoom = i, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null;
  }
  setDocument(e, t = null) {
    this.baseUrl = t, this.pdfDocument = e;
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setHistory(e) {
    this.pdfHistory = e;
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
  }
  set page(e) {
    this.pdfDocument && (this.pdfViewer.currentPageNumber = e);
  }
  get rotation() {
    return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
  }
  set rotation(e) {
    this.pdfDocument && (this.pdfViewer.pagesRotation = e);
  }
  get isInPresentationMode() {
    return this.pdfDocument ? this.pdfViewer.isInPresentationMode : !1;
  }
  async goToDestination(e) {
    if (!this.pdfDocument)
      return;
    let t, s, i;
    if (typeof e == "string" ? (t = e, s = await this.pdfDocument.getDestination(e)) : (t = null, s = await e), !Array.isArray(s)) {
      console.error(`goToDestination: "${s}" is not a valid destination array, for dest="${e}".`);
      return;
    }
    const [n] = s;
    if (n && typeof n == "object") {
      if (i = this.pdfDocument.cachedPageNumber(n), !i)
        try {
          i = await this.pdfDocument.getPageIndex(n) + 1;
        } catch {
          console.error(`goToDestination: "${n}" is not a valid page reference, for dest="${e}".`);
          return;
        }
    } else
      Number.isInteger(n) && (i = n + 1);
    if (!i || i < 1 || i > this.pagesCount) {
      console.error(`goToDestination: "${i}" is not a valid page number, for dest="${e}".`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.push({
      namedDest: t,
      explicitDest: s,
      pageNumber: i
    })), this.pdfViewer.scrollPageIntoView({
      pageNumber: i,
      destArray: s,
      ignoreDestinationZoom: this._ignoreDestinationZoom
    });
  }
  goToPage(e) {
    if (!this.pdfDocument)
      return;
    const t = typeof e == "string" && this.pdfViewer.pageLabelToPageNumber(e) || e | 0;
    if (!(Number.isInteger(t) && t > 0 && t <= this.pagesCount)) {
      console.error(`PDFLinkService.goToPage: "${e}" is not a valid page.`);
      return;
    }
    this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.pushPage(t)), this.pdfViewer.scrollPageIntoView({
      pageNumber: t
    });
  }
  addLinkAttributes(e, t, s = !1) {
    if (!t || typeof t != "string")
      throw new Error('A valid "url" parameter must provided.');
    const i = s ? En.BLANK : this.externalLinkTarget, n = this.externalLinkRel;
    this.externalLinkEnabled ? e.href = e.title = t : (e.href = "", e.title = `Disabled: ${t}`, e.onclick = () => !1);
    let r = "";
    switch (i) {
      case En.NONE:
        break;
      case En.SELF:
        r = "_self";
        break;
      case En.BLANK:
        r = "_blank";
        break;
      case En.PARENT:
        r = "_parent";
        break;
      case En.TOP:
        r = "_top";
        break;
    }
    e.target = r, e.rel = typeof n == "string" ? n : Ex;
  }
  getDestinationHash(e) {
    if (typeof e == "string") {
      if (e.length > 0)
        return this.getAnchorUrl("#" + escape(e));
    } else if (Array.isArray(e)) {
      const t = JSON.stringify(e);
      if (t.length > 0)
        return this.getAnchorUrl("#" + escape(t));
    }
    return this.getAnchorUrl("");
  }
  getAnchorUrl(e) {
    return this.baseUrl ? this.baseUrl + e : e;
  }
  setHash(e) {
    var i;
    if (!this.pdfDocument)
      return;
    let t, s;
    if (e.includes("=")) {
      const n = Wg(e);
      if (n.has("search")) {
        const r = n.get("search").replaceAll('"', ""), a = n.get("phrase") === "true";
        this.eventBus.dispatch("findfromurlhash", {
          source: this,
          query: a ? r : r.match(/\S+/g)
        });
      }
      if (n.has("page") && (t = n.get("page") | 0 || 1), n.has("zoom")) {
        const r = n.get("zoom").split(","), a = r[0], h = parseFloat(a);
        a.includes("Fit") ? a === "Fit" || a === "FitB" ? s = [null, {
          name: a
        }] : a === "FitH" || a === "FitBH" || a === "FitV" || a === "FitBV" ? s = [null, {
          name: a
        }, r.length > 1 ? r[1] | 0 : null] : a === "FitR" ? r.length !== 5 ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : s = [null, {
          name: a
        }, r[1] | 0, r[2] | 0, r[3] | 0, r[4] | 0] : console.error(`PDFLinkService.setHash: "${a}" is not a valid zoom value.`) : s = [null, {
          name: "XYZ"
        }, r.length > 1 ? r[1] | 0 : null, r.length > 2 ? r[2] | 0 : null, h ? h / 100 : a];
      }
      s ? this.pdfViewer.scrollPageIntoView({
        pageNumber: t || this.page,
        destArray: s,
        allowNegativeOffset: !0
      }) : t && (this.page = t), n.has("pagemode") && this.eventBus.dispatch("pagemode", {
        source: this,
        mode: n.get("pagemode")
      }), n.has("nameddest") && this.goToDestination(n.get("nameddest"));
      return;
    }
    s = unescape(e);
    try {
      s = JSON.parse(s), Array.isArray(s) || (s = s.toString());
    } catch {
    }
    if (typeof s == "string" || v(i = hg, lg, NE).call(i, s)) {
      this.goToDestination(s);
      return;
    }
    console.error(`PDFLinkService.setHash: "${unescape(e)}" is not a valid destination.`);
  }
  executeNamedAction(e) {
    var t, s;
    if (this.pdfDocument) {
      switch (e) {
        case "GoBack":
          (t = this.pdfHistory) == null || t.back();
          break;
        case "GoForward":
          (s = this.pdfHistory) == null || s.forward();
          break;
        case "NextPage":
          this.pdfViewer.nextPage();
          break;
        case "PrevPage":
          this.pdfViewer.previousPage();
          break;
        case "LastPage":
          this.page = this.pagesCount;
          break;
        case "FirstPage":
          this.page = 1;
          break;
      }
      this.eventBus.dispatch("namedaction", {
        source: this,
        action: e
      });
    }
  }
  async executeSetOCGState(e) {
    if (!this.pdfDocument)
      return;
    const t = this.pdfDocument, s = await this.pdfViewer.optionalContentConfigPromise;
    t === this.pdfDocument && (s.setOCGState(e), this.pdfViewer.optionalContentConfigPromise = Promise.resolve(s));
  }
};
lg = new WeakSet(), NE = function(e) {
  if (!Array.isArray(e) || e.length < 2)
    return !1;
  const [t, s, ...i] = e;
  if (!(typeof t == "object" && Number.isInteger(t == null ? void 0 : t.num) && Number.isInteger(t == null ? void 0 : t.gen)) && !Number.isInteger(t) || !(typeof s == "object" && typeof (s == null ? void 0 : s.name) == "string"))
    return !1;
  let n = !0;
  switch (s.name) {
    case "XYZ":
      if (i.length !== 3)
        return !1;
      break;
    case "Fit":
    case "FitB":
      return i.length === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (i.length !== 1)
        return !1;
      break;
    case "FitR":
      if (i.length !== 4)
        return !1;
      n = !1;
      break;
    default:
      return !1;
  }
  for (const r of i)
    if (!(typeof r == "number" || n && r === null))
      return !1;
  return !0;
}, p(hg, lg);
let uf = hg;
class fb extends uf {
  setDocument(e, t = null) {
  }
}
const {
  AbortException: wx,
  AnnotationEditorLayer: Sx,
  AnnotationEditorParamsType: PT,
  AnnotationEditorType: Pi,
  AnnotationEditorUIManager: xx,
  AnnotationLayer: Px,
  AnnotationMode: pi,
  build: TT,
  CMapCompressionType: CT,
  ColorPicker: RT,
  createValidAbsoluteUrl: Tx,
  DOMSVGFactory: IT,
  DrawLayer: Cx,
  FeatureTest: LT,
  fetchData: ey,
  getDocument: _T,
  getFilenameFromUrl: MT,
  getPdfFilenameFromUrl: Rx,
  getXfaPageViewport: OT,
  GlobalWorkerOptions: DT,
  ImageKind: kT,
  InvalidPDFException: FT,
  isDataScheme: NT,
  isPdfFile: Ix,
  MissingPDFException: BT,
  noContextMenu: jT,
  normalizeUnicode: Lx,
  OPS: HT,
  Outliner: $T,
  PasswordResponses: VT,
  PDFDataRangeTransport: UT,
  PDFDateString: zT,
  PDFWorker: WT,
  PermissionFlag: pu,
  PixelsPerInch: Ds,
  RenderingCancelledException: Mv,
  renderTextLayer: GT,
  setLayerDimensions: _x,
  shadow: ff,
  TextLayer: Mx,
  UnexpectedResponseException: XT,
  updateTextLayer: KT,
  Util: YT,
  VerbosityLevel: QT,
  version: sy,
  XfaLayer: am
} = globalThis.pdfjsLib;
var bd, sn, yd, Ov;
class BE {
  constructor({
    pdfPage: e,
    linkService: t,
    downloadManager: s,
    annotationStorage: i = null,
    imageResourcesPath: n = "",
    renderForms: r = !0,
    enableScripting: a = !1,
    hasJSActionsPromise: h = null,
    fieldObjectsPromise: c = null,
    annotationCanvasMap: d = null,
    accessibilityManager: u = null,
    annotationEditorUIManager: f = null,
    onAppend: m = null
  }) {
    p(this, yd);
    p(this, bd, null);
    p(this, sn, null);
    this.pdfPage = e, this.linkService = t, this.downloadManager = s, this.imageResourcesPath = n, this.renderForms = r, this.annotationStorage = i, this.enableScripting = a, this._hasJSActionsPromise = h || Promise.resolve(!1), this._fieldObjectsPromise = c || Promise.resolve(null), this._annotationCanvasMap = d, this._accessibilityManager = u, this._annotationEditorUIManager = f, b(this, bd, m), this.annotationLayer = null, this.div = null, this._cancelled = !1, this._eventBus = t.eventBus;
  }
  async render(e, t = "display") {
    var a, h;
    if (this.div) {
      if (this._cancelled || !this.annotationLayer)
        return;
      this.annotationLayer.update({
        viewport: e.clone({
          dontFlip: !0
        })
      });
      return;
    }
    const [s, i, n] = await Promise.all([this.pdfPage.getAnnotations({
      intent: t
    }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
    if (this._cancelled)
      return;
    const r = this.div = document.createElement("div");
    if (r.className = "annotationLayer", (a = o(this, bd)) == null || a.call(this, r), s.length === 0) {
      this.hide();
      return;
    }
    this.annotationLayer = new Px({
      div: r,
      accessibilityManager: this._accessibilityManager,
      annotationCanvasMap: this._annotationCanvasMap,
      annotationEditorUIManager: this._annotationEditorUIManager,
      page: this.pdfPage,
      viewport: e.clone({
        dontFlip: !0
      })
    }), await this.annotationLayer.render({
      annotations: s,
      imageResourcesPath: this.imageResourcesPath,
      renderForms: this.renderForms,
      linkService: this.linkService,
      downloadManager: this.downloadManager,
      annotationStorage: this.annotationStorage,
      enableScripting: this.enableScripting,
      hasJSActions: i,
      fieldObjects: n
    }), this.linkService.isInPresentationMode && v(this, yd, Ov).call(this, va.FULLSCREEN), o(this, sn) || (b(this, sn, new AbortController()), (h = this._eventBus) == null || h._on("presentationmodechanged", (c) => {
      v(this, yd, Ov).call(this, c.state);
    }, {
      signal: o(this, sn).signal
    }));
  }
  cancel() {
    var e;
    this._cancelled = !0, (e = o(this, sn)) == null || e.abort(), b(this, sn, null);
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
}
bd = new WeakMap(), sn = new WeakMap(), yd = new WeakSet(), Ov = function(e) {
  if (!this.div)
    return;
  let t = !1;
  switch (e) {
    case va.FULLSCREEN:
      t = !0;
      break;
    case va.NORMAL:
      break;
    default:
      return;
  }
  for (const s of this.div.childNodes)
    s.hasAttribute("data-internal-link") || (s.inert = t);
};
function iy(l, e) {
  const t = document.createElement("a");
  if (!t.click)
    throw new Error('DownloadManager: "a.click()" is not supported.');
  t.href = l, t.target = "_parent", "download" in t && (t.download = e), (document.body || document.documentElement).append(t), t.click(), t.remove();
}
var sb;
class Ox {
  constructor() {
    p(this, sb, /* @__PURE__ */ new WeakMap());
  }
  downloadData(e, t, s) {
    const i = URL.createObjectURL(new Blob([e], {
      type: s
    }));
    iy(i, t);
  }
  openOrDownloadData(e, t, s = null) {
    const n = Ix(t) ? "application/pdf" : "";
    return this.downloadData(e, t, n), !1;
  }
  download(e, t, s, i) {
    let n;
    if (e)
      n = URL.createObjectURL(new Blob([e], {
        type: "application/pdf"
      }));
    else {
      if (!Tx(t, "http://example.com")) {
        console.error(`download - not a valid URL: ${t}`);
        return;
      }
      n = t + "#pdfjs.action=download";
    }
    iy(n, s);
  }
}
sb = new WeakMap();
const ny = {
  EVENT: "event",
  TIMEOUT: "timeout"
};
async function Dx({
  target: l,
  name: e,
  delay: t = 0
}) {
  if (typeof l != "object" || !(e && typeof e == "string") || !(Number.isInteger(t) && t >= 0))
    throw new Error("waitOnEventOrTimeout - invalid parameters.");
  const {
    promise: s,
    resolve: i
  } = Promise.withResolvers(), n = new AbortController();
  function r(c) {
    n.abort(), clearTimeout(h), i(c);
  }
  const a = l instanceof jE ? "_on" : "addEventListener";
  l[a](e, r.bind(null, ny.EVENT), {
    signal: n.signal
  });
  const h = setTimeout(r.bind(null, ny.TIMEOUT), t);
  return s;
}
var $o;
class jE {
  constructor() {
    p(this, $o, /* @__PURE__ */ Object.create(null));
  }
  on(e, t, s = null) {
    this._on(e, t, {
      external: !0,
      once: s == null ? void 0 : s.once,
      signal: s == null ? void 0 : s.signal
    });
  }
  off(e, t, s = null) {
    this._off(e, t);
  }
  dispatch(e, t) {
    const s = o(this, $o)[e];
    if (!s || s.length === 0)
      return;
    let i;
    for (const {
      listener: n,
      external: r,
      once: a
    } of s.slice(0)) {
      if (a && this._off(e, n), r) {
        (i || (i = [])).push(n);
        continue;
      }
      n(t);
    }
    if (i) {
      for (const n of i)
        n(t);
      i = null;
    }
  }
  _on(e, t, s = null) {
    var r;
    let i = null;
    if ((s == null ? void 0 : s.signal) instanceof AbortSignal) {
      const {
        signal: a
      } = s;
      if (a.aborted) {
        console.error("Cannot use an `aborted` signal.");
        return;
      }
      const h = () => this._off(e, t);
      i = () => a.removeEventListener("abort", h), a.addEventListener("abort", h);
    }
    ((r = o(this, $o))[e] || (r[e] = [])).push({
      listener: t,
      external: (s == null ? void 0 : s.external) === !0,
      once: (s == null ? void 0 : s.once) === !0,
      rmAbort: i
    });
  }
  _off(e, t, s = null) {
    var n;
    const i = o(this, $o)[e];
    if (i)
      for (let r = 0, a = i.length; r < a; r++) {
        const h = i[r];
        if (h.listener === t) {
          (n = h.rmAbort) == null || n.call(h), i.splice(r, 1);
          return;
        }
      }
  }
}
$o = new WeakMap();
class Gg {
  constructor(e) {
    this.value = e;
  }
  valueOf() {
    return this.value;
  }
}
class Pt extends Gg {
  constructor(e = "???") {
    super(e);
  }
  toString(e) {
    return `{${this.value}}`;
  }
}
class vi extends Gg {
  constructor(e, t = {}) {
    super(e), this.opts = t;
  }
  toString(e) {
    try {
      return e.memoizeIntlObject(Intl.NumberFormat, this.opts).format(this.value);
    } catch (t) {
      return e.reportError(t), this.value.toString(10);
    }
  }
}
class Hl extends Gg {
  constructor(e, t = {}) {
    super(e), this.opts = t;
  }
  toString(e) {
    try {
      return e.memoizeIntlObject(Intl.DateTimeFormat, this.opts).format(this.value);
    } catch (t) {
      return e.reportError(t), new Date(this.value).toISOString();
    }
  }
}
const ry = 100, kx = "⁨", Fx = "⁩";
function Nx(l, e, t) {
  if (t === e || t instanceof vi && e instanceof vi && t.value === e.value)
    return !0;
  if (e instanceof vi && typeof t == "string") {
    let s = l.memoizeIntlObject(Intl.PluralRules, e.opts).select(e.value);
    if (t === s)
      return !0;
  }
  return !1;
}
function ay(l, e, t) {
  return e[t] ? al(l, e[t].value) : (l.reportError(new RangeError("No default")), new Pt());
}
function Dv(l, e) {
  const t = [], s = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    i.type === "narg" ? s[i.name] = Wl(l, i.value) : t.push(Wl(l, i));
  return {
    positional: t,
    named: s
  };
}
function Wl(l, e) {
  switch (e.type) {
    case "str":
      return e.value;
    case "num":
      return new vi(e.value, {
        minimumFractionDigits: e.precision
      });
    case "var":
      return Bx(l, e);
    case "mesg":
      return jx(l, e);
    case "term":
      return Hx(l, e);
    case "func":
      return $x(l, e);
    case "select":
      return Vx(l, e);
    default:
      return new Pt();
  }
}
function Bx(l, {
  name: e
}) {
  let t;
  if (l.params)
    if (Object.prototype.hasOwnProperty.call(l.params, e))
      t = l.params[e];
    else
      return new Pt(`$${e}`);
  else if (l.args && Object.prototype.hasOwnProperty.call(l.args, e))
    t = l.args[e];
  else
    return l.reportError(new ReferenceError(`Unknown variable: $${e}`)), new Pt(`$${e}`);
  if (t instanceof Gg)
    return t;
  switch (typeof t) {
    case "string":
      return t;
    case "number":
      return new vi(t);
    case "object":
      if (t instanceof Date)
        return new Hl(t.getTime());
    default:
      return l.reportError(new TypeError(`Variable type not supported: $${e}, ${typeof t}`)), new Pt(`$${e}`);
  }
}
function jx(l, {
  name: e,
  attr: t
}) {
  const s = l.bundle._messages.get(e);
  if (!s)
    return l.reportError(new ReferenceError(`Unknown message: ${e}`)), new Pt(e);
  if (t) {
    const i = s.attributes[t];
    return i ? al(l, i) : (l.reportError(new ReferenceError(`Unknown attribute: ${t}`)), new Pt(`${e}.${t}`));
  }
  return s.value ? al(l, s.value) : (l.reportError(new ReferenceError(`No value: ${e}`)), new Pt(e));
}
function Hx(l, {
  name: e,
  attr: t,
  args: s
}) {
  const i = `-${e}`, n = l.bundle._terms.get(i);
  if (!n)
    return l.reportError(new ReferenceError(`Unknown term: ${i}`)), new Pt(i);
  if (t) {
    const a = n.attributes[t];
    if (a) {
      l.params = Dv(l, s).named;
      const h = al(l, a);
      return l.params = null, h;
    }
    return l.reportError(new ReferenceError(`Unknown attribute: ${t}`)), new Pt(`${i}.${t}`);
  }
  l.params = Dv(l, s).named;
  const r = al(l, n.value);
  return l.params = null, r;
}
function $x(l, {
  name: e,
  args: t
}) {
  let s = l.bundle._functions[e];
  if (!s)
    return l.reportError(new ReferenceError(`Unknown function: ${e}()`)), new Pt(`${e}()`);
  if (typeof s != "function")
    return l.reportError(new TypeError(`Function ${e}() is not callable`)), new Pt(`${e}()`);
  try {
    let i = Dv(l, t);
    return s(i.positional, i.named);
  } catch (i) {
    return l.reportError(i), new Pt(`${e}()`);
  }
}
function Vx(l, {
  selector: e,
  variants: t,
  star: s
}) {
  let i = Wl(l, e);
  if (i instanceof Pt)
    return ay(l, t, s);
  for (const n of t) {
    const r = Wl(l, n.key);
    if (Nx(l, i, r))
      return al(l, n.value);
  }
  return ay(l, t, s);
}
function HE(l, e) {
  if (l.dirty.has(e))
    return l.reportError(new RangeError("Cyclic reference")), new Pt();
  l.dirty.add(e);
  const t = [], s = l.bundle._useIsolating && e.length > 1;
  for (const i of e) {
    if (typeof i == "string") {
      t.push(l.bundle._transform(i));
      continue;
    }
    if (l.placeables++, l.placeables > ry)
      throw l.dirty.delete(e), new RangeError(`Too many placeables expanded: ${l.placeables}, max allowed is ${ry}`);
    s && t.push(kx), t.push(Wl(l, i).toString(l)), s && t.push(Fx);
  }
  return l.dirty.delete(e), t.join("");
}
function al(l, e) {
  return typeof e == "string" ? l.bundle._transform(e) : HE(l, e);
}
class Ux {
  constructor(e, t, s) {
    this.dirty = /* @__PURE__ */ new WeakSet(), this.params = null, this.placeables = 0, this.bundle = e, this.errors = t, this.args = s;
  }
  reportError(e) {
    if (!this.errors || !(e instanceof Error))
      throw e;
    this.errors.push(e);
  }
  memoizeIntlObject(e, t) {
    let s = this.bundle._intls.get(e);
    s || (s = {}, this.bundle._intls.set(e, s));
    let i = JSON.stringify(t);
    return s[i] || (s[i] = new e(this.bundle.locales, t)), s[i];
  }
}
function pf(l, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const [s, i] of Object.entries(l))
    e.includes(s) && (t[s] = i.valueOf());
  return t;
}
const oy = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
function zx(l, e) {
  let t = l[0];
  if (t instanceof Pt)
    return new Pt(`NUMBER(${t.valueOf()})`);
  if (t instanceof vi)
    return new vi(t.valueOf(), {
      ...t.opts,
      ...pf(e, oy)
    });
  if (t instanceof Hl)
    return new vi(t.valueOf(), {
      ...pf(e, oy)
    });
  throw new TypeError("Invalid argument to NUMBER");
}
const ly = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
function Wx(l, e) {
  let t = l[0];
  if (t instanceof Pt)
    return new Pt(`DATETIME(${t.valueOf()})`);
  if (t instanceof Hl)
    return new Hl(t.valueOf(), {
      ...t.opts,
      ...pf(e, ly)
    });
  if (t instanceof vi)
    return new Hl(t.valueOf(), {
      ...pf(e, ly)
    });
  throw new TypeError("Invalid argument to DATETIME");
}
const hy = /* @__PURE__ */ new Map();
function Gx(l) {
  const e = Array.isArray(l) ? l.join(" ") : l;
  let t = hy.get(e);
  return t === void 0 && (t = /* @__PURE__ */ new Map(), hy.set(e, t)), t;
}
class Xx {
  constructor(e, {
    functions: t,
    useIsolating: s = !0,
    transform: i = (n) => n
  } = {}) {
    this._terms = /* @__PURE__ */ new Map(), this._messages = /* @__PURE__ */ new Map(), this.locales = Array.isArray(e) ? e : [e], this._functions = {
      NUMBER: zx,
      DATETIME: Wx,
      ...t
    }, this._useIsolating = s, this._transform = i, this._intls = Gx(e);
  }
  hasMessage(e) {
    return this._messages.has(e);
  }
  getMessage(e) {
    return this._messages.get(e);
  }
  addResource(e, {
    allowOverrides: t = !1
  } = {}) {
    const s = [];
    for (let i = 0; i < e.body.length; i++) {
      let n = e.body[i];
      if (n.id.startsWith("-")) {
        if (t === !1 && this._terms.has(n.id)) {
          s.push(new Error(`Attempt to override an existing term: "${n.id}"`));
          continue;
        }
        this._terms.set(n.id, n);
      } else {
        if (t === !1 && this._messages.has(n.id)) {
          s.push(new Error(`Attempt to override an existing message: "${n.id}"`));
          continue;
        }
        this._messages.set(n.id, n);
      }
    }
    return s;
  }
  formatPattern(e, t = null, s = null) {
    if (typeof e == "string")
      return this._transform(e);
    let i = new Ux(this, s, t);
    try {
      return HE(i, e).toString(i);
    } catch (n) {
      if (i.errors && n instanceof Error)
        return i.errors.push(n), new Pt().toString(i);
      throw n;
    }
  }
}
const om = /^(-?[a-zA-Z][\w-]*) *= */gm, cy = /\.([a-zA-Z][\w-]*) *= */y, Kx = /\*?\[/y, lm = /(-?[0-9]+(?:\.([0-9]+))?)/y, Yx = /([a-zA-Z][\w-]*)/y, dy = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y, Qx = /^[A-Z][A-Z0-9_-]*$/, gu = /([^{}\n\r]+)/y, Zx = /([^\\"\n\r]*)/y, uy = /\\([\\"])/y, fy = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y, Jx = /^\n+/, py = / +$/, qx = / *\r?\n/g, tP = /( *)$/, eP = /{\s*/y, gy = /\s*}/y, sP = /\[\s*/y, iP = /\s*] */y, nP = /\s*\(\s*/y, rP = /\s*->\s*/y, aP = /\s*:\s*/y, oP = /\s*,?\s*/y, lP = /\s+/y;
class hP {
  constructor(e) {
    this.body = [], om.lastIndex = 0;
    let t = 0;
    for (; ; ) {
      let T = om.exec(e);
      if (T === null)
        break;
      t = om.lastIndex;
      try {
        this.body.push(h(T[1]));
      } catch (I) {
        if (I instanceof SyntaxError)
          continue;
        throw I;
      }
    }
    function s(T) {
      return T.lastIndex = t, T.test(e);
    }
    function i(T, I) {
      if (e[t] === T)
        return t++, !0;
      if (I)
        throw new I(`Expected ${T}`);
      return !1;
    }
    function n(T, I) {
      if (s(T))
        return t = T.lastIndex, !0;
      if (I)
        throw new I(`Expected ${T.toString()}`);
      return !1;
    }
    function r(T) {
      T.lastIndex = t;
      let I = T.exec(e);
      if (I === null)
        throw new SyntaxError(`Expected ${T.toString()}`);
      return t = T.lastIndex, I;
    }
    function a(T) {
      return r(T)[1];
    }
    function h(T) {
      let I = d(), _ = c();
      if (I === null && Object.keys(_).length === 0)
        throw new SyntaxError("Expected message value or attributes");
      return {
        id: T,
        value: I,
        attributes: _
      };
    }
    function c() {
      let T = /* @__PURE__ */ Object.create(null);
      for (; s(cy); ) {
        let I = a(cy), _ = d();
        if (_ === null)
          throw new SyntaxError("Expected attribute value");
        T[I] = _;
      }
      return T;
    }
    function d() {
      let T;
      if (s(gu) && (T = a(gu)), e[t] === "{" || e[t] === "}")
        return u(T ? [T] : [], 1 / 0);
      let I = x();
      return I ? T ? u([T, I], I.length) : (I.value = R(I.value, Jx), u([I], I.length)) : T ? R(T, py) : null;
    }
    function u(T = [], I) {
      for (; ; ) {
        if (s(gu)) {
          T.push(a(gu));
          continue;
        }
        if (e[t] === "{") {
          T.push(f());
          continue;
        }
        if (e[t] === "}")
          throw new SyntaxError("Unbalanced closing brace");
        let V = x();
        if (V) {
          T.push(V), I = Math.min(I, V.length);
          continue;
        }
        break;
      }
      let _ = T.length - 1, k = T[_];
      typeof k == "string" && (T[_] = R(k, py));
      let F = [];
      for (let V of T)
        V instanceof my && (V = V.value.slice(0, V.value.length - I)), V && F.push(V);
      return F;
    }
    function f() {
      n(eP, SyntaxError);
      let T = m();
      if (n(gy))
        return T;
      if (n(rP)) {
        let I = E();
        return n(gy, SyntaxError), {
          type: "select",
          selector: T,
          ...I
        };
      }
      throw new SyntaxError("Unclosed placeable");
    }
    function m() {
      if (e[t] === "{")
        return f();
      if (s(dy)) {
        let [, T, I, _ = null] = r(dy);
        if (T === "$")
          return {
            type: "var",
            name: I
          };
        if (n(nP)) {
          let k = g();
          if (T === "-")
            return {
              type: "term",
              name: I,
              attr: _,
              args: k
            };
          if (Qx.test(I))
            return {
              type: "func",
              name: I,
              args: k
            };
          throw new SyntaxError("Function names must be all upper-case");
        }
        return T === "-" ? {
          type: "term",
          name: I,
          attr: _,
          args: []
        } : {
          type: "mesg",
          name: I,
          attr: _
        };
      }
      return w();
    }
    function g() {
      let T = [];
      for (; ; ) {
        switch (e[t]) {
          case ")":
            return t++, T;
          case void 0:
            throw new SyntaxError("Unclosed argument list");
        }
        T.push(A()), n(oP);
      }
    }
    function A() {
      let T = m();
      return T.type !== "mesg" ? T : n(aP) ? {
        type: "narg",
        name: T.name,
        value: w()
      } : T;
    }
    function E() {
      let T = [], I = 0, _;
      for (; s(Kx); ) {
        i("*") && (_ = I);
        let k = y(), F = d();
        if (F === null)
          throw new SyntaxError("Expected variant value");
        T[I++] = {
          key: k,
          value: F
        };
      }
      if (I === 0)
        return null;
      if (_ === void 0)
        throw new SyntaxError("Expected default variant");
      return {
        variants: T,
        star: _
      };
    }
    function y() {
      n(sP, SyntaxError);
      let T;
      return s(lm) ? T = S() : T = {
        type: "str",
        value: a(Yx)
      }, n(iP, SyntaxError), T;
    }
    function w() {
      if (s(lm))
        return S();
      if (e[t] === '"')
        return C();
      throw new SyntaxError("Invalid expression");
    }
    function S() {
      let [, T, I = ""] = r(lm), _ = I.length;
      return {
        type: "num",
        value: parseFloat(T),
        precision: _
      };
    }
    function C() {
      i('"', SyntaxError);
      let T = "";
      for (; ; ) {
        if (T += a(Zx), e[t] === "\\") {
          T += P();
          continue;
        }
        if (i('"'))
          return {
            type: "str",
            value: T
          };
        throw new SyntaxError("Unclosed string literal");
      }
    }
    function P() {
      if (s(uy))
        return a(uy);
      if (s(fy)) {
        let [, T, I] = r(fy), _ = parseInt(T || I, 16);
        return _ <= 55295 || 57344 <= _ ? String.fromCodePoint(_) : "�";
      }
      throw new SyntaxError("Unknown escape sequence");
    }
    function x() {
      let T = t;
      switch (n(lP), e[t]) {
        case ".":
        case "[":
        case "*":
        case "}":
        case void 0:
          return !1;
        case "{":
          return M(e.slice(T, t));
      }
      return e[t - 1] === " " ? M(e.slice(T, t)) : !1;
    }
    function R(T, I) {
      return T.replace(I, "");
    }
    function M(T) {
      let I = T.replace(qx, `
`), _ = tP.exec(T)[1].length;
      return new my(I, _);
    }
  }
}
class my {
  constructor(e, t) {
    this.value = e, this.length = t;
  }
}
const cP = /<|&#?\w+;/, dP = {
  "http://www.w3.org/1999/xhtml": ["em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark", "bdi", "bdo", "span", "br", "wbr"]
}, uP = {
  "http://www.w3.org/1999/xhtml": {
    global: ["title", "aria-label", "aria-valuetext"],
    a: ["download"],
    area: ["download", "alt"],
    input: ["alt", "placeholder"],
    menuitem: ["label"],
    menu: ["label"],
    optgroup: ["label"],
    option: ["label"],
    track: ["label"],
    img: ["alt"],
    textarea: ["placeholder"],
    th: ["abbr"]
  },
  "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul": {
    global: ["accesskey", "aria-label", "aria-valuetext", "label", "title", "tooltiptext"],
    description: ["value"],
    key: ["key", "keycode"],
    label: ["value"],
    textbox: ["placeholder", "value"]
  }
};
function fP(l, e) {
  const {
    value: t
  } = e;
  if (typeof t == "string")
    if (l.localName === "title" && l.namespaceURI === "http://www.w3.org/1999/xhtml")
      l.textContent = t;
    else if (!cP.test(t))
      l.textContent = t;
    else {
      const s = l.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "template");
      s.innerHTML = t, pP(s.content, l);
    }
  $E(e, l);
}
function pP(l, e) {
  for (const t of l.childNodes)
    if (t.nodeType !== t.TEXT_NODE) {
      if (t.hasAttribute("data-l10n-name")) {
        const s = mP(e, t);
        l.replaceChild(s, t);
        continue;
      }
      if (bP(t)) {
        const s = vP(t);
        l.replaceChild(s, t);
        continue;
      }
      console.warn(`An element of forbidden type "${t.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`), l.replaceChild(kv(t), t);
    }
  e.textContent = "", e.appendChild(l);
}
function gP(l, e) {
  if (!l)
    return !1;
  for (let t of l)
    if (t.name === e)
      return !0;
  return !1;
}
function $E(l, e) {
  const t = e.hasAttribute("data-l10n-attrs") ? e.getAttribute("data-l10n-attrs").split(",").map((s) => s.trim()) : null;
  for (const s of Array.from(e.attributes))
    vy(s.name, e, t) && !gP(l.attributes, s.name) && e.removeAttribute(s.name);
  if (l.attributes)
    for (const s of Array.from(l.attributes))
      vy(s.name, e, t) && e.getAttribute(s.name) !== s.value && e.setAttribute(s.name, s.value);
}
function mP(l, e) {
  const t = e.getAttribute("data-l10n-name"), s = l.querySelector(`[data-l10n-name="${t}"]`);
  if (!s)
    return console.warn(`An element named "${t}" wasn't found in the source.`), kv(e);
  if (s.localName !== e.localName)
    return console.warn(`An element named "${t}" was found in the translation but its type ${e.localName} didn't match the element found in the source (${s.localName}).`), kv(e);
  l.removeChild(s);
  const i = s.cloneNode(!1);
  return VE(e, i);
}
function vP(l) {
  const e = l.ownerDocument.createElement(l.localName);
  return VE(l, e);
}
function kv(l) {
  return l.ownerDocument.createTextNode(l.textContent);
}
function bP(l) {
  const e = dP[l.namespaceURI];
  return e && e.includes(l.localName);
}
function vy(l, e, t = null) {
  if (t && t.includes(l))
    return !0;
  const s = uP[e.namespaceURI];
  if (!s)
    return !1;
  const i = l.toLowerCase(), n = e.localName;
  if (s.global.includes(i))
    return !0;
  if (!s[n])
    return !1;
  if (s[n].includes(i))
    return !0;
  if (e.namespaceURI === "http://www.w3.org/1999/xhtml" && n === "input" && i === "value") {
    const r = e.type.toLowerCase();
    if (r === "submit" || r === "button" || r === "reset")
      return !0;
  }
  return !1;
}
function VE(l, e) {
  return e.textContent = l.textContent, $E(l, e), e;
}
class yP extends Array {
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
}
class AP extends yP {
  constructor(e) {
    if (super(), Symbol.asyncIterator in Object(e))
      this.iterator = e[Symbol.asyncIterator]();
    else if (Symbol.iterator in Object(e))
      this.iterator = e[Symbol.iterator]();
    else
      throw new TypeError("Argument must implement the iteration protocol.");
  }
  [Symbol.asyncIterator]() {
    const e = this;
    let t = 0;
    return {
      async next() {
        return e.length <= t && e.push(e.iterator.next()), e[t++];
      }
    };
  }
  async touchNext(e = 1) {
    let t = 0;
    for (; t++ < e; ) {
      const s = this[this.length - 1];
      if (s && (await s).done)
        break;
      this.push(this.iterator.next());
    }
    return this[this.length - 1];
  }
}
class EP {
  constructor(e = [], t) {
    this.resourceIds = e, this.generateBundles = t, this.onChange(!0);
  }
  addResourceIds(e, t = !1) {
    return this.resourceIds.push(...e), this.onChange(t), this.resourceIds.length;
  }
  removeResourceIds(e) {
    return this.resourceIds = this.resourceIds.filter((t) => !e.includes(t)), this.onChange(), this.resourceIds.length;
  }
  async formatWithFallback(e, t) {
    const s = [];
    let i = !1;
    for await (const n of this.bundles) {
      i = !0;
      const r = xP(t, n, e, s);
      if (r.size === 0)
        break;
      if (typeof console < "u") {
        const a = n.locales[0], h = Array.from(r).join(", ");
        console.warn(`[fluent] Missing translations in ${a}: ${h}`);
      }
    }
    return !i && typeof console < "u" && console.warn(`[fluent] Request for keys failed because no resource bundles got generated.
  keys: ${JSON.stringify(e)}.
  resourceIds: ${JSON.stringify(this.resourceIds)}.`), s;
  }
  formatMessages(e) {
    return this.formatWithFallback(e, SP);
  }
  formatValues(e) {
    return this.formatWithFallback(e, wP);
  }
  async formatValue(e, t) {
    const [s] = await this.formatValues([{
      id: e,
      args: t
    }]);
    return s;
  }
  handleEvent() {
    this.onChange();
  }
  onChange(e = !1) {
    this.bundles = AP.from(this.generateBundles(this.resourceIds)), e && this.bundles.touchNext(2);
  }
}
function wP(l, e, t, s) {
  return t.value ? l.formatPattern(t.value, s, e) : null;
}
function SP(l, e, t, s) {
  const i = {
    value: null,
    attributes: null
  };
  t.value && (i.value = l.formatPattern(t.value, s, e));
  let n = Object.keys(t.attributes);
  if (n.length > 0) {
    i.attributes = new Array(n.length);
    for (let [r, a] of n.entries()) {
      let h = l.formatPattern(t.attributes[a], s, e);
      i.attributes[r] = {
        name: a,
        value: h
      };
    }
  }
  return i;
}
function xP(l, e, t, s) {
  const i = [], n = /* @__PURE__ */ new Set();
  return t.forEach(({
    id: r,
    args: a
  }, h) => {
    if (s[h] !== void 0)
      return;
    let c = e.getMessage(r);
    if (c) {
      if (i.length = 0, s[h] = l(e, i, c, a), i.length > 0 && typeof console < "u") {
        const d = e.locales[0], u = i.join(", ");
        console.warn(`[fluent][resolver] errors in ${d}/${r}: ${u}.`);
      }
    } else
      n.add(r);
  }), n;
}
const wn = "data-l10n-id", fl = "data-l10n-args", PP = `[${wn}]`;
class TP extends EP {
  constructor(e, t) {
    super(e, t), this.roots = /* @__PURE__ */ new Set(), this.pendingrAF = null, this.pendingElements = /* @__PURE__ */ new Set(), this.windowElement = null, this.mutationObserver = null, this.observerConfig = {
      attributes: !0,
      characterData: !1,
      childList: !0,
      subtree: !0,
      attributeFilter: [wn, fl]
    };
  }
  onChange(e = !1) {
    super.onChange(e), this.roots && this.translateRoots();
  }
  setAttributes(e, t, s) {
    return e.setAttribute(wn, t), s ? e.setAttribute(fl, JSON.stringify(s)) : e.removeAttribute(fl), e;
  }
  getAttributes(e) {
    return {
      id: e.getAttribute(wn),
      args: JSON.parse(e.getAttribute(fl) || null)
    };
  }
  connectRoot(e) {
    for (const t of this.roots)
      if (t === e || t.contains(e) || e.contains(t))
        throw new Error("Cannot add a root that overlaps with existing root.");
    if (this.windowElement) {
      if (this.windowElement !== e.ownerDocument.defaultView)
        throw new Error(`Cannot connect a root:
          DOMLocalization already has a root from a different window.`);
    } else
      this.windowElement = e.ownerDocument.defaultView, this.mutationObserver = new this.windowElement.MutationObserver((t) => this.translateMutations(t));
    this.roots.add(e), this.mutationObserver.observe(e, this.observerConfig);
  }
  disconnectRoot(e) {
    return this.roots.delete(e), this.pauseObserving(), this.roots.size === 0 ? (this.mutationObserver = null, this.windowElement && this.pendingrAF && this.windowElement.cancelAnimationFrame(this.pendingrAF), this.windowElement = null, this.pendingrAF = null, this.pendingElements.clear(), !0) : (this.resumeObserving(), !1);
  }
  translateRoots() {
    const e = Array.from(this.roots);
    return Promise.all(e.map((t) => this.translateFragment(t)));
  }
  pauseObserving() {
    this.mutationObserver && (this.translateMutations(this.mutationObserver.takeRecords()), this.mutationObserver.disconnect());
  }
  resumeObserving() {
    if (this.mutationObserver)
      for (const e of this.roots)
        this.mutationObserver.observe(e, this.observerConfig);
  }
  translateMutations(e) {
    for (const t of e)
      switch (t.type) {
        case "attributes":
          t.target.hasAttribute("data-l10n-id") && this.pendingElements.add(t.target);
          break;
        case "childList":
          for (const s of t.addedNodes)
            if (s.nodeType === s.ELEMENT_NODE)
              if (s.childElementCount)
                for (const i of this.getTranslatables(s))
                  this.pendingElements.add(i);
              else
                s.hasAttribute(wn) && this.pendingElements.add(s);
          break;
      }
    this.pendingElements.size > 0 && this.pendingrAF === null && (this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
      this.translateElements(Array.from(this.pendingElements)), this.pendingElements.clear(), this.pendingrAF = null;
    }));
  }
  translateFragment(e) {
    return this.translateElements(this.getTranslatables(e));
  }
  async translateElements(e) {
    if (!e.length)
      return;
    const t = e.map(this.getKeysForElement), s = await this.formatMessages(t);
    return this.applyTranslations(e, s);
  }
  applyTranslations(e, t) {
    this.pauseObserving();
    for (let s = 0; s < e.length; s++)
      t[s] !== void 0 && fP(e[s], t[s]);
    this.resumeObserving();
  }
  getTranslatables(e) {
    const t = Array.from(e.querySelectorAll(PP));
    return typeof e.hasAttribute == "function" && e.hasAttribute(wn) && t.push(e), t;
  }
  getKeysForElement(e) {
    return {
      id: e.getAttribute(wn),
      args: JSON.parse(e.getAttribute(fl) || null)
    };
  }
}
var Ad, Vo, Uo, Se, cg, UE, dg, zE;
const pa = class pa {
  constructor({
    lang: e,
    isRTL: t
  }, s = null) {
    p(this, Ad, void 0);
    p(this, Vo, /* @__PURE__ */ new Set());
    p(this, Uo, void 0);
    p(this, Se, void 0);
    var i, n;
    b(this, Uo, v(i = pa, cg, UE).call(i, e)), b(this, Se, s), b(this, Ad, t ?? v(n = pa, dg, zE).call(n, o(this, Uo)) ? "rtl" : "ltr");
  }
  _setL10n(e) {
    b(this, Se, e);
  }
  getLanguage() {
    return o(this, Uo);
  }
  getDirection() {
    return o(this, Ad);
  }
  async get(e, t = null, s) {
    if (Array.isArray(e))
      return e = e.map((r) => ({
        id: r
      })), (await o(this, Se).formatMessages(e)).map((r) => r.value);
    const i = await o(this, Se).formatMessages([{
      id: e,
      args: t
    }]);
    return (i == null ? void 0 : i[0].value) || s;
  }
  async translate(e) {
    o(this, Vo).add(e);
    try {
      o(this, Se).connectRoot(e), await o(this, Se).translateRoots();
    } catch {
    }
  }
  async destroy() {
    for (const e of o(this, Vo))
      o(this, Se).disconnectRoot(e);
    o(this, Vo).clear(), o(this, Se).pauseObserving();
  }
  pause() {
    o(this, Se).pauseObserving();
  }
  resume() {
    o(this, Se).resumeObserving();
  }
};
Ad = new WeakMap(), Vo = new WeakMap(), Uo = new WeakMap(), Se = new WeakMap(), cg = new WeakSet(), UE = function(e) {
  return e = (e == null ? void 0 : e.toLowerCase()) || "en-us", {
    en: "en-us",
    es: "es-es",
    fy: "fy-nl",
    ga: "ga-ie",
    gu: "gu-in",
    hi: "hi-in",
    hy: "hy-am",
    nb: "nb-no",
    ne: "ne-np",
    nn: "nn-no",
    pa: "pa-in",
    pt: "pt-pt",
    sv: "sv-se",
    zh: "zh-cn"
  }[e] || e;
}, dg = new WeakSet(), zE = function(e) {
  const t = e.split("-", 1)[0];
  return ["ar", "he", "fa", "ps", "ur"].includes(t);
}, p(pa, cg), p(pa, dg);
let Fv = pa;
function by(l, e) {
  const t = new hP(e), s = new Xx(l), i = s.addResource(t);
  return i.length && console.error("L10n errors", i), s;
}
var ug, WE, fg, GE, pg, XE, gg, KE, Ed, Nv;
const Ne = class Ne extends Fv {
  constructor(e) {
    super({
      lang: e
    });
    const t = e ? v(Ne, ug, WE).bind(Ne, "en-us", this.getLanguage()) : v(Ne, gg, KE).bind(Ne, this.getLanguage());
    this._setL10n(new TP([], t));
  }
};
ug = new WeakSet(), WE = async function* (e, t) {
  const {
    baseURL: s,
    paths: i
  } = await v(this, pg, XE).call(this), n = [t];
  if (e !== t) {
    const r = t.split("-", 1)[0];
    r !== t && n.push(r), n.push(e);
  }
  for (const r of n) {
    const a = await v(this, fg, GE).call(this, r, s, i);
    a ? yield a : r === "en-us" && (yield v(this, Ed, Nv).call(this, r));
  }
}, fg = new WeakSet(), GE = async function(e, t, s) {
  const i = s[e];
  if (!i)
    return null;
  const n = new URL(i, t), r = await ey(n, "text");
  return by(e, r);
}, pg = new WeakSet(), XE = async function() {
  try {
    const {
      href: e
    } = document.querySelector('link[type="application/l10n"]'), t = await ey(e, "json");
    return {
      baseURL: e.replace(/[^/]*$/, "") || "./",
      paths: t
    };
  } catch {
  }
  return {
    baseURL: "./",
    paths: /* @__PURE__ */ Object.create(null)
  };
}, gg = new WeakSet(), KE = async function* (e) {
  yield v(this, Ed, Nv).call(this, e);
}, Ed = new WeakSet(), Nv = async function(e) {
  return by(e, `pdfjs-previous-button =
    .title = Previous Page
pdfjs-previous-button-label = Previous
pdfjs-next-button =
    .title = Next Page
pdfjs-next-button-label = Next
pdfjs-page-input =
    .title = Page
pdfjs-of-pages = of { $pagesCount }
pdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })
pdfjs-zoom-out-button =
    .title = Zoom Out
pdfjs-zoom-out-button-label = Zoom Out
pdfjs-zoom-in-button =
    .title = Zoom In
pdfjs-zoom-in-button-label = Zoom In
pdfjs-zoom-select =
    .title = Zoom
pdfjs-presentation-mode-button =
    .title = Switch to Presentation Mode
pdfjs-presentation-mode-button-label = Presentation Mode
pdfjs-open-file-button =
    .title = Open File
pdfjs-open-file-button-label = Open
pdfjs-print-button =
    .title = Print
pdfjs-print-button-label = Print
pdfjs-save-button =
    .title = Save
pdfjs-save-button-label = Save
pdfjs-download-button =
    .title = Download
pdfjs-download-button-label = Download
pdfjs-bookmark-button =
    .title = Current Page (View URL from Current Page)
pdfjs-bookmark-button-label = Current Page
pdfjs-tools-button =
    .title = Tools
pdfjs-tools-button-label = Tools
pdfjs-first-page-button =
    .title = Go to First Page
pdfjs-first-page-button-label = Go to First Page
pdfjs-last-page-button =
    .title = Go to Last Page
pdfjs-last-page-button-label = Go to Last Page
pdfjs-page-rotate-cw-button =
    .title = Rotate Clockwise
pdfjs-page-rotate-cw-button-label = Rotate Clockwise
pdfjs-page-rotate-ccw-button =
    .title = Rotate Counterclockwise
pdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise
pdfjs-cursor-text-select-tool-button =
    .title = Enable Text Selection Tool
pdfjs-cursor-text-select-tool-button-label = Text Selection Tool
pdfjs-cursor-hand-tool-button =
    .title = Enable Hand Tool
pdfjs-cursor-hand-tool-button-label = Hand Tool
pdfjs-scroll-page-button =
    .title = Use Page Scrolling
pdfjs-scroll-page-button-label = Page Scrolling
pdfjs-scroll-vertical-button =
    .title = Use Vertical Scrolling
pdfjs-scroll-vertical-button-label = Vertical Scrolling
pdfjs-scroll-horizontal-button =
    .title = Use Horizontal Scrolling
pdfjs-scroll-horizontal-button-label = Horizontal Scrolling
pdfjs-scroll-wrapped-button =
    .title = Use Wrapped Scrolling
pdfjs-scroll-wrapped-button-label = Wrapped Scrolling
pdfjs-spread-none-button =
    .title = Do not join page spreads
pdfjs-spread-none-button-label = No Spreads
pdfjs-spread-odd-button =
    .title = Join page spreads starting with odd-numbered pages
pdfjs-spread-odd-button-label = Odd Spreads
pdfjs-spread-even-button =
    .title = Join page spreads starting with even-numbered pages
pdfjs-spread-even-button-label = Even Spreads
pdfjs-document-properties-button =
    .title = Document Properties…
pdfjs-document-properties-button-label = Document Properties…
pdfjs-document-properties-file-name = File name:
pdfjs-document-properties-file-size = File size:
pdfjs-document-properties-kb = { $size_kb } KB ({ $size_b } bytes)
pdfjs-document-properties-mb = { $size_mb } MB ({ $size_b } bytes)
pdfjs-document-properties-title = Title:
pdfjs-document-properties-author = Author:
pdfjs-document-properties-subject = Subject:
pdfjs-document-properties-keywords = Keywords:
pdfjs-document-properties-creation-date = Creation Date:
pdfjs-document-properties-modification-date = Modification Date:
pdfjs-document-properties-date-string = { $date }, { $time }
pdfjs-document-properties-creator = Creator:
pdfjs-document-properties-producer = PDF Producer:
pdfjs-document-properties-version = PDF Version:
pdfjs-document-properties-page-count = Page Count:
pdfjs-document-properties-page-size = Page Size:
pdfjs-document-properties-page-size-unit-inches = in
pdfjs-document-properties-page-size-unit-millimeters = mm
pdfjs-document-properties-page-size-orientation-portrait = portrait
pdfjs-document-properties-page-size-orientation-landscape = landscape
pdfjs-document-properties-page-size-name-a-three = A3
pdfjs-document-properties-page-size-name-a-four = A4
pdfjs-document-properties-page-size-name-letter = Letter
pdfjs-document-properties-page-size-name-legal = Legal
pdfjs-document-properties-page-size-dimension-string = { $width } × { $height } { $unit } ({ $orientation })
pdfjs-document-properties-page-size-dimension-name-string = { $width } × { $height } { $unit } ({ $name }, { $orientation })
pdfjs-document-properties-linearized = Fast Web View:
pdfjs-document-properties-linearized-yes = Yes
pdfjs-document-properties-linearized-no = No
pdfjs-document-properties-close-button = Close
pdfjs-print-progress-message = Preparing document for printing…
pdfjs-print-progress-percent = { $progress }%
pdfjs-print-progress-close-button = Cancel
pdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.
pdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.
pdfjs-toggle-sidebar-button =
    .title = Toggle Sidebar
pdfjs-toggle-sidebar-notification-button =
    .title = Toggle Sidebar (document contains outline/attachments/layers)
pdfjs-toggle-sidebar-button-label = Toggle Sidebar
pdfjs-document-outline-button =
    .title = Show Document Outline (double-click to expand/collapse all items)
pdfjs-document-outline-button-label = Document Outline
pdfjs-attachments-button =
    .title = Show Attachments
pdfjs-attachments-button-label = Attachments
pdfjs-layers-button =
    .title = Show Layers (double-click to reset all layers to the default state)
pdfjs-layers-button-label = Layers
pdfjs-thumbs-button =
    .title = Show Thumbnails
pdfjs-thumbs-button-label = Thumbnails
pdfjs-current-outline-item-button =
    .title = Find Current Outline Item
pdfjs-current-outline-item-button-label = Current Outline Item
pdfjs-findbar-button =
    .title = Find in Document
pdfjs-findbar-button-label = Find
pdfjs-additional-layers = Additional Layers
pdfjs-thumb-page-title =
    .title = Page { $page }
pdfjs-thumb-page-canvas =
    .aria-label = Thumbnail of Page { $page }
pdfjs-find-input =
    .title = Find
    .placeholder = Find in document…
pdfjs-find-previous-button =
    .title = Find the previous occurrence of the phrase
pdfjs-find-previous-button-label = Previous
pdfjs-find-next-button =
    .title = Find the next occurrence of the phrase
pdfjs-find-next-button-label = Next
pdfjs-find-highlight-checkbox = Highlight All
pdfjs-find-match-case-checkbox-label = Match Case
pdfjs-find-match-diacritics-checkbox-label = Match Diacritics
pdfjs-find-entire-word-checkbox-label = Whole Words
pdfjs-find-reached-top = Reached top of document, continued from bottom
pdfjs-find-reached-bottom = Reached end of document, continued from top
pdfjs-find-match-count =
    { $total ->
        [one] { $current } of { $total } match
       *[other] { $current } of { $total } matches
    }
pdfjs-find-match-count-limit =
    { $limit ->
        [one] More than { $limit } match
       *[other] More than { $limit } matches
    }
pdfjs-find-not-found = Phrase not found
pdfjs-page-scale-width = Page Width
pdfjs-page-scale-fit = Page Fit
pdfjs-page-scale-auto = Automatic Zoom
pdfjs-page-scale-actual = Actual Size
pdfjs-page-scale-percent = { $scale }%
pdfjs-page-landmark =
    .aria-label = Page { $page }
pdfjs-loading-error = An error occurred while loading the PDF.
pdfjs-invalid-file-error = Invalid or corrupted PDF file.
pdfjs-missing-file-error = Missing PDF file.
pdfjs-unexpected-response-error = Unexpected server response.
pdfjs-rendering-error = An error occurred while rendering the page.
pdfjs-annotation-date-string = { $date }, { $time }
pdfjs-text-annotation-type =
    .alt = [{ $type } Annotation]
pdfjs-password-label = Enter the password to open this PDF file.
pdfjs-password-invalid = Invalid password. Please try again.
pdfjs-password-ok-button = OK
pdfjs-password-cancel-button = Cancel
pdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.
pdfjs-editor-free-text-button =
    .title = Text
pdfjs-editor-free-text-button-label = Text
pdfjs-editor-ink-button =
    .title = Draw
pdfjs-editor-ink-button-label = Draw
pdfjs-editor-stamp-button =
    .title = Add or edit images
pdfjs-editor-stamp-button-label = Add or edit images
pdfjs-editor-highlight-button =
    .title = Highlight
pdfjs-editor-highlight-button-label = Highlight
pdfjs-highlight-floating-button1 =
    .title = Highlight
    .aria-label = Highlight
pdfjs-highlight-floating-button-label = Highlight
pdfjs-editor-remove-ink-button =
    .title = Remove drawing
pdfjs-editor-remove-freetext-button =
    .title = Remove text
pdfjs-editor-remove-stamp-button =
    .title = Remove image
pdfjs-editor-remove-highlight-button =
    .title = Remove highlight
pdfjs-editor-free-text-color-input = Color
pdfjs-editor-free-text-size-input = Size
pdfjs-editor-ink-color-input = Color
pdfjs-editor-ink-thickness-input = Thickness
pdfjs-editor-ink-opacity-input = Opacity
pdfjs-editor-stamp-add-image-button =
    .title = Add image
pdfjs-editor-stamp-add-image-button-label = Add image
pdfjs-editor-free-highlight-thickness-input = Thickness
pdfjs-editor-free-highlight-thickness-title =
    .title = Change thickness when highlighting items other than text
pdfjs-free-text =
    .aria-label = Text Editor
pdfjs-free-text-default-content = Start typing…
pdfjs-ink =
    .aria-label = Draw Editor
pdfjs-ink-canvas =
    .aria-label = User-created image
pdfjs-editor-alt-text-button-label = Alt text
pdfjs-editor-alt-text-edit-button-label = Edit alt text
pdfjs-editor-alt-text-dialog-label = Choose an option
pdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people can’t see the image or when it doesn’t load.
pdfjs-editor-alt-text-add-description-label = Add a description
pdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.
pdfjs-editor-alt-text-mark-decorative-label = Mark as decorative
pdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.
pdfjs-editor-alt-text-cancel-button = Cancel
pdfjs-editor-alt-text-save-button = Save
pdfjs-editor-alt-text-decorative-tooltip = Marked as decorative
pdfjs-editor-alt-text-textarea =
    .placeholder = For example, “A young man sits down at a table to eat a meal”
pdfjs-editor-resizer-label-top-left = Top left corner — resize
pdfjs-editor-resizer-label-top-middle = Top middle — resize
pdfjs-editor-resizer-label-top-right = Top right corner — resize
pdfjs-editor-resizer-label-middle-right = Middle right — resize
pdfjs-editor-resizer-label-bottom-right = Bottom right corner — resize
pdfjs-editor-resizer-label-bottom-middle = Bottom middle — resize
pdfjs-editor-resizer-label-bottom-left = Bottom left corner — resize
pdfjs-editor-resizer-label-middle-left = Middle left — resize
pdfjs-editor-highlight-colorpicker-label = Highlight color
pdfjs-editor-colorpicker-button =
    .title = Change color
pdfjs-editor-colorpicker-dropdown =
    .aria-label = Color choices
pdfjs-editor-colorpicker-yellow =
    .title = Yellow
pdfjs-editor-colorpicker-green =
    .title = Green
pdfjs-editor-colorpicker-blue =
    .title = Blue
pdfjs-editor-colorpicker-pink =
    .title = Pink
pdfjs-editor-colorpicker-red =
    .title = Red
pdfjs-editor-highlight-show-all-button-label = Show all
pdfjs-editor-highlight-show-all-button =
    .title = Show all`);
}, p(Ne, ug), p(Ne, fg), p(Ne, pg), p(Ne, gg), p(Ne, Ed);
let ol = Ne;
const CP = 1e3, RP = 50, IP = 1e3;
function hm() {
  return document.location.hash;
}
var nn, Je, Is, zo, Ku, Wo, Yu, Nr, Ol, Go, Qu, wd, Bv, mg, YE, vg, QE, Sd, jv, bg, ZE, yg, JE;
class LP {
  constructor({
    linkService: e,
    eventBus: t
  }) {
    p(this, Je);
    p(this, zo);
    p(this, Wo);
    p(this, Nr);
    p(this, Go);
    p(this, wd);
    p(this, mg);
    p(this, vg);
    p(this, Sd);
    p(this, bg);
    p(this, yg);
    p(this, nn, null);
    this.linkService = e, this.eventBus = t, this._initialized = !1, this._fingerprint = "", this.reset(), this.eventBus._on("pagesinit", () => {
      this._isPagesLoaded = !1, this.eventBus._on("pagesloaded", (s) => {
        this._isPagesLoaded = !!s.pagesCount;
      }, {
        once: !0
      });
    });
  }
  initialize({
    fingerprint: e,
    resetHistory: t = !1,
    updateUrl: s = !1
  }) {
    if (!e || typeof e != "string") {
      console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
      return;
    }
    this._initialized && this.reset();
    const i = this._fingerprint !== "" && this._fingerprint !== e;
    this._fingerprint = e, this._updateUrl = s === !0, this._initialized = !0, v(this, bg, ZE).call(this);
    const n = window.history.state;
    if (this._popStateInProgress = !1, this._blockHashChange = 0, this._currentHash = hm(), this._numPositionUpdates = 0, this._uid = this._maxUid = 0, this._destination = null, this._position = null, !v(this, Nr, Ol).call(this, n, !0) || t) {
      const {
        hash: a,
        page: h,
        rotation: c
      } = v(this, wd, Bv).call(this, !0);
      if (!a || i || t) {
        v(this, Je, Is).call(this, null, !0);
        return;
      }
      v(this, Je, Is).call(this, {
        hash: a,
        page: h,
        rotation: c
      }, !0);
      return;
    }
    const r = n.destination;
    v(this, Go, Qu).call(this, r, n.uid, !0), r.rotation !== void 0 && (this._initialRotation = r.rotation), r.dest ? (this._initialBookmark = JSON.stringify(r.dest), this._destination.page = null) : r.hash ? this._initialBookmark = r.hash : r.page && (this._initialBookmark = `page=${r.page}`);
  }
  reset() {
    this._initialized && (v(this, Sd, jv).call(this), this._initialized = !1, v(this, yg, JE).call(this)), this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._initialBookmark = null, this._initialRotation = null;
  }
  push({
    namedDest: e = null,
    explicitDest: t,
    pageNumber: s
  }) {
    if (!this._initialized)
      return;
    if (e && typeof e != "string") {
      console.error(`PDFHistory.push: "${e}" is not a valid namedDest parameter.`);
      return;
    } else if (Array.isArray(t)) {
      if (!v(this, Wo, Yu).call(this, s) && (s !== null || this._destination)) {
        console.error(`PDFHistory.push: "${s}" is not a valid pageNumber parameter.`);
        return;
      }
    } else {
      console.error(`PDFHistory.push: "${t}" is not a valid explicitDest parameter.`);
      return;
    }
    const i = e || JSON.stringify(t);
    if (!i)
      return;
    let n = !1;
    if (this._destination && (_P(this._destination.hash, i) || MP(this._destination.dest, t))) {
      if (this._destination.page)
        return;
      n = !0;
    }
    this._popStateInProgress && !n || (v(this, Je, Is).call(this, {
      dest: t,
      hash: i,
      page: s,
      rotation: this.linkService.rotation
    }, n), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
      this._popStateInProgress = !1;
    })));
  }
  pushPage(e) {
    var t;
    if (this._initialized) {
      if (!v(this, Wo, Yu).call(this, e)) {
        console.error(`PDFHistory.pushPage: "${e}" is not a valid page number.`);
        return;
      }
      ((t = this._destination) == null ? void 0 : t.page) !== e && (this._popStateInProgress || (v(this, Je, Is).call(this, {
        dest: null,
        hash: `page=${e}`,
        page: e,
        rotation: this.linkService.rotation
      }), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
        this._popStateInProgress = !1;
      }))));
    }
  }
  pushCurrentPosition() {
    !this._initialized || this._popStateInProgress || v(this, zo, Ku).call(this);
  }
  back() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const e = window.history.state;
    v(this, Nr, Ol).call(this, e) && e.uid > 0 && window.history.back();
  }
  forward() {
    if (!this._initialized || this._popStateInProgress)
      return;
    const e = window.history.state;
    v(this, Nr, Ol).call(this, e) && e.uid < this._maxUid && window.history.forward();
  }
  get popStateInProgress() {
    return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
  }
  get initialBookmark() {
    return this._initialized ? this._initialBookmark : null;
  }
  get initialRotation() {
    return this._initialized ? this._initialRotation : null;
  }
}
nn = new WeakMap(), Je = new WeakSet(), Is = function(e, t = !1) {
  const s = t || !this._destination, i = {
    fingerprint: this._fingerprint,
    uid: s ? this._uid : this._uid + 1,
    destination: e
  };
  v(this, Go, Qu).call(this, e, i.uid);
  let n;
  if (this._updateUrl && (e != null && e.hash)) {
    const r = document.location.href.split("#", 1)[0];
    r.startsWith("file://") || (n = `${r}#${e.hash}`);
  }
  s ? window.history.replaceState(i, "", n) : window.history.pushState(i, "", n);
}, zo = new WeakSet(), Ku = function(e = !1) {
  if (!this._position)
    return;
  let t = this._position;
  if (e && (t = Object.assign(/* @__PURE__ */ Object.create(null), this._position), t.temporary = !0), !this._destination) {
    v(this, Je, Is).call(this, t);
    return;
  }
  if (this._destination.temporary) {
    v(this, Je, Is).call(this, t, !0);
    return;
  }
  if (this._destination.hash === t.hash || !this._destination.page && this._numPositionUpdates <= RP)
    return;
  let s = !1;
  if (this._destination.page >= t.first && this._destination.page <= t.page) {
    if (this._destination.dest !== void 0 || !this._destination.first)
      return;
    s = !0;
  }
  v(this, Je, Is).call(this, t, s);
}, Wo = new WeakSet(), Yu = function(e) {
  return Number.isInteger(e) && e > 0 && e <= this.linkService.pagesCount;
}, Nr = new WeakSet(), Ol = function(e, t = !1) {
  if (!e)
    return !1;
  if (e.fingerprint !== this._fingerprint)
    if (t) {
      if (typeof e.fingerprint != "string" || e.fingerprint.length !== this._fingerprint.length)
        return !1;
      const [s] = performance.getEntriesByType("navigation");
      if ((s == null ? void 0 : s.type) !== "reload")
        return !1;
    } else
      return !1;
  return !(!Number.isInteger(e.uid) || e.uid < 0 || e.destination === null || typeof e.destination != "object");
}, Go = new WeakSet(), Qu = function(e, t, s = !1) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), s && (e != null && e.temporary) && delete e.temporary, this._destination = e, this._uid = t, this._maxUid = Math.max(this._maxUid, t), this._numPositionUpdates = 0;
}, wd = new WeakSet(), Bv = function(e = !1) {
  const t = unescape(hm()).substring(1), s = Wg(t), i = s.get("nameddest") || "";
  let n = s.get("page") | 0;
  return (!v(this, Wo, Yu).call(this, n) || e && i.length > 0) && (n = null), {
    hash: t,
    page: n,
    rotation: this.linkService.rotation
  };
}, mg = new WeakSet(), YE = function({
  location: e
}) {
  this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._position = {
    hash: e.pdfOpenParams.substring(1),
    page: this.linkService.page,
    first: e.pageNumber,
    rotation: e.rotation
  }, !this._popStateInProgress && (this._isPagesLoaded && this._destination && !this._destination.page && this._numPositionUpdates++, this._updateViewareaTimeout = setTimeout(() => {
    this._popStateInProgress || v(this, zo, Ku).call(this, !0), this._updateViewareaTimeout = null;
  }, IP));
}, vg = new WeakSet(), QE = function({
  state: e
}) {
  const t = hm(), s = this._currentHash !== t;
  if (this._currentHash = t, !e) {
    this._uid++;
    const {
      hash: n,
      page: r,
      rotation: a
    } = v(this, wd, Bv).call(this);
    v(this, Je, Is).call(this, {
      hash: n,
      page: r,
      rotation: a
    }, !0);
    return;
  }
  if (!v(this, Nr, Ol).call(this, e))
    return;
  this._popStateInProgress = !0, s && (this._blockHashChange++, Dx({
    target: window,
    name: "hashchange",
    delay: CP
  }).then(() => {
    this._blockHashChange--;
  }));
  const i = e.destination;
  v(this, Go, Qu).call(this, i, e.uid, !0), RE(i.rotation) && (this.linkService.rotation = i.rotation), i.dest ? this.linkService.goToDestination(i.dest) : i.hash ? this.linkService.setHash(i.hash) : i.page && (this.linkService.page = i.page), Promise.resolve().then(() => {
    this._popStateInProgress = !1;
  });
}, Sd = new WeakSet(), jv = function() {
  (!this._destination || this._destination.temporary) && v(this, zo, Ku).call(this);
}, bg = new WeakSet(), ZE = function() {
  if (o(this, nn))
    return;
  b(this, nn, new AbortController());
  const {
    signal: e
  } = o(this, nn);
  this.eventBus._on("updateviewarea", v(this, mg, YE).bind(this), {
    signal: e
  }), window.addEventListener("popstate", v(this, vg, QE).bind(this), {
    signal: e
  }), window.addEventListener("pagehide", v(this, Sd, jv).bind(this), {
    signal: e
  });
}, yg = new WeakSet(), JE = function() {
  var e;
  (e = o(this, nn)) == null || e.abort(), b(this, nn, null);
};
function _P(l, e) {
  return typeof l != "string" || typeof e != "string" ? !1 : l === e || Wg(l).get("nameddest") === e;
}
function MP(l, e) {
  function t(s, i) {
    if (typeof s != typeof i || Array.isArray(s) || Array.isArray(i))
      return !1;
    if (s !== null && typeof s == "object" && i !== null) {
      if (Object.keys(s).length !== Object.keys(i).length)
        return !1;
      for (const n in s)
        if (!t(s[n], i[n]))
          return !1;
      return !0;
    }
    return s === i || Number.isNaN(s) && Number.isNaN(i);
  }
  if (!(Array.isArray(l) && Array.isArray(e)) || l.length !== e.length)
    return !1;
  for (let s = 0, i = l.length; s < i; s++)
    if (!t(l[s], e[s]))
      return !1;
  return !0;
}
var xd, Pd, Td, Cd, Xo;
class OP {
  constructor(e) {
    p(this, xd, null);
    p(this, Pd, null);
    p(this, Td, null);
    p(this, Cd, null);
    p(this, Xo, void 0);
    this.pdfPage = e.pdfPage, this.accessibilityManager = e.accessibilityManager, this.l10n = e.l10n, this.l10n || (this.l10n = new ol()), this.annotationEditorLayer = null, this.div = null, this._cancelled = !1, b(this, Xo, e.uiManager), b(this, xd, e.annotationLayer || null), b(this, Cd, e.textLayer || null), b(this, Pd, e.drawLayer || null), b(this, Td, e.onAppend || null);
  }
  async render(e, t = "display") {
    var r;
    if (t !== "display" || this._cancelled)
      return;
    const s = e.clone({
      dontFlip: !0
    });
    if (this.div) {
      this.annotationEditorLayer.update({
        viewport: s
      }), this.show();
      return;
    }
    const i = this.div = document.createElement("div");
    i.className = "annotationEditorLayer", i.hidden = !0, i.dir = o(this, Xo).direction, (r = o(this, Td)) == null || r.call(this, i), this.annotationEditorLayer = new Sx({
      uiManager: o(this, Xo),
      div: i,
      accessibilityManager: this.accessibilityManager,
      pageIndex: this.pdfPage.pageNumber - 1,
      l10n: this.l10n,
      viewport: s,
      annotationLayer: o(this, xd),
      textLayer: o(this, Cd),
      drawLayer: o(this, Pd)
    });
    const n = {
      viewport: s,
      div: i,
      annotations: null,
      intent: t
    };
    this.annotationEditorLayer.render(n), this.show();
  }
  cancel() {
    this._cancelled = !0, this.div && this.annotationEditorLayer.destroy();
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
  show() {
    !this.div || this.annotationEditorLayer.isInvisible || (this.div.hidden = !1);
  }
}
xd = new WeakMap(), Pd = new WeakMap(), Td = new WeakMap(), Cd = new WeakMap(), Xo = new WeakMap();
{
  var Gl = /* @__PURE__ */ Object.create(null);
  const l = navigator.userAgent || "", e = navigator.platform || "", t = navigator.maxTouchPoints || 1, s = /Android/.test(l), i = /\b(iPad|iPhone|iPod)(?=;)/.test(l) || e === "MacIntel" && t > 1;
  (function() {
    (i || s) && (Gl.maxCanvasPixels = 5242880);
  })();
}
const D = {
  BROWSER: 1,
  VIEWER: 2,
  API: 4,
  WORKER: 8,
  PREFERENCE: 128
}, mn = {
  canvasMaxAreaInBytes: {
    value: -1,
    kind: D.BROWSER + D.API
  },
  isInAutomation: {
    value: !1,
    kind: D.BROWSER
  },
  supportsCaretBrowsingMode: {
    value: !1,
    kind: D.BROWSER
  },
  supportsDocumentFonts: {
    value: !0,
    kind: D.BROWSER
  },
  supportsIntegratedFind: {
    value: !1,
    kind: D.BROWSER
  },
  supportsMouseWheelZoomCtrlKey: {
    value: !0,
    kind: D.BROWSER
  },
  supportsMouseWheelZoomMetaKey: {
    value: !0,
    kind: D.BROWSER
  },
  supportsPinchToZoom: {
    value: !0,
    kind: D.BROWSER
  },
  annotationEditorMode: {
    value: 0,
    kind: D.VIEWER + D.PREFERENCE
  },
  annotationMode: {
    value: 2,
    kind: D.VIEWER + D.PREFERENCE
  },
  cursorToolOnLoad: {
    value: 0,
    kind: D.VIEWER + D.PREFERENCE
  },
  debuggerSrc: {
    value: "./debugger.mjs",
    kind: D.VIEWER
  },
  defaultZoomDelay: {
    value: 400,
    kind: D.VIEWER + D.PREFERENCE
  },
  defaultZoomValue: {
    value: "",
    kind: D.VIEWER + D.PREFERENCE
  },
  disableHistory: {
    value: !1,
    kind: D.VIEWER
  },
  disablePageLabels: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  enableHighlightEditor: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  enableHighlightFloatingButton: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  enableML: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  enablePermissions: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  enablePrintAutoRotate: {
    value: !0,
    kind: D.VIEWER + D.PREFERENCE
  },
  enableScripting: {
    value: !0,
    kind: D.VIEWER + D.PREFERENCE
  },
  enableStampEditor: {
    value: !0,
    kind: D.VIEWER + D.PREFERENCE
  },
  externalLinkRel: {
    value: "noopener noreferrer nofollow",
    kind: D.VIEWER
  },
  externalLinkTarget: {
    value: 0,
    kind: D.VIEWER + D.PREFERENCE
  },
  highlightEditorColors: {
    value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
    kind: D.VIEWER + D.PREFERENCE
  },
  historyUpdateUrl: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  ignoreDestinationZoom: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  imageResourcesPath: {
    value: "./images/",
    kind: D.VIEWER
  },
  maxCanvasPixels: {
    value: 2 ** 25,
    kind: D.VIEWER
  },
  forcePageColors: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  pageColorsBackground: {
    value: "Canvas",
    kind: D.VIEWER + D.PREFERENCE
  },
  pageColorsForeground: {
    value: "CanvasText",
    kind: D.VIEWER + D.PREFERENCE
  },
  pdfBugEnabled: {
    value: !1,
    kind: D.VIEWER + D.PREFERENCE
  },
  printResolution: {
    value: 150,
    kind: D.VIEWER
  },
  sidebarViewOnLoad: {
    value: -1,
    kind: D.VIEWER + D.PREFERENCE
  },
  scrollModeOnLoad: {
    value: -1,
    kind: D.VIEWER + D.PREFERENCE
  },
  spreadModeOnLoad: {
    value: -1,
    kind: D.VIEWER + D.PREFERENCE
  },
  textLayerMode: {
    value: 1,
    kind: D.VIEWER + D.PREFERENCE
  },
  viewOnLoad: {
    value: 0,
    kind: D.VIEWER + D.PREFERENCE
  },
  cMapPacked: {
    value: !0,
    kind: D.API
  },
  cMapUrl: {
    value: "../web/cmaps/",
    kind: D.API
  },
  disableAutoFetch: {
    value: !1,
    kind: D.API + D.PREFERENCE
  },
  disableFontFace: {
    value: !1,
    kind: D.API + D.PREFERENCE
  },
  disableRange: {
    value: !1,
    kind: D.API + D.PREFERENCE
  },
  disableStream: {
    value: !1,
    kind: D.API + D.PREFERENCE
  },
  docBaseUrl: {
    value: "",
    kind: D.API
  },
  enableHWA: {
    value: !0,
    kind: D.API + D.VIEWER + D.PREFERENCE
  },
  enableXfa: {
    value: !0,
    kind: D.API + D.PREFERENCE
  },
  fontExtraProperties: {
    value: !1,
    kind: D.API
  },
  isEvalSupported: {
    value: !0,
    kind: D.API
  },
  isOffscreenCanvasSupported: {
    value: !0,
    kind: D.API
  },
  maxImageSize: {
    value: -1,
    kind: D.API
  },
  pdfBug: {
    value: !1,
    kind: D.API
  },
  standardFontDataUrl: {
    value: "../web/standard_fonts/",
    kind: D.API
  },
  verbosity: {
    value: 1,
    kind: D.API
  },
  workerPort: {
    value: null,
    kind: D.WORKER
  },
  workerSrc: {
    value: "../build/pdf.worker.mjs",
    kind: D.WORKER
  }
};
mn.defaultUrl = {
  value: "compressed.tracemonkey-pldi-09.pdf",
  kind: D.VIEWER
}, mn.sandboxBundleSrc = {
  value: "../build/pdf.sandbox.mjs",
  kind: D.VIEWER
}, mn.viewerCssTheme = {
  value: 0,
  kind: D.VIEWER + D.PREFERENCE
};
mn.disablePreferences = {
  value: !1,
  kind: D.VIEWER
}, mn.locale = {
  value: navigator.language || "en-US",
  kind: D.VIEWER
};
const Si = /* @__PURE__ */ Object.create(null);
for (const l in Gl)
  Si[l] = Gl[l];
class DP {
  constructor() {
    throw new Error("Cannot initialize AppOptions.");
  }
  static get(e) {
    var t;
    return Si[e] ?? ((t = mn[e]) == null ? void 0 : t.value) ?? void 0;
  }
  static getAll(e = null, t = !1) {
    const s = /* @__PURE__ */ Object.create(null);
    for (const i in mn) {
      const n = mn[i];
      e && !(e & n.kind) || (s[i] = t ? n.value : Si[i] ?? n.value);
    }
    return s;
  }
  static set(e, t) {
    Si[e] = t;
  }
  static setAll(e, t = !1) {
    if (t) {
      if (this.get("disablePreferences"))
        return;
      for (const s in Si)
        if (Gl[s] === void 0) {
          console.warn('setAll: The Preferences may override manually set AppOptions; please use the "disablePreferences"-option in order to prevent that.');
          break;
        }
    }
    for (const s in e)
      Si[s] = e[s];
  }
  static remove(e) {
    delete Si[e];
    const t = Gl[e];
    t !== void 0 && (Si[e] = t);
  }
}
var As;
class kP {
  constructor(e) {
    p(this, As, null);
    this.pageIndex = e.pageIndex;
  }
  async render(e = "display") {
    e !== "display" || o(this, As) || this._cancelled || b(this, As, new Cx({
      pageIndex: this.pageIndex
    }));
  }
  cancel() {
    this._cancelled = !0, o(this, As) && (o(this, As).destroy(), b(this, As, null));
  }
  setParent(e) {
    var t;
    (t = o(this, As)) == null || t.setParent(e);
  }
  getDrawLayer() {
    return o(this, As);
  }
}
As = new WeakMap();
const yy = {
  Document: null,
  DocumentFragment: null,
  Part: "group",
  Sect: "group",
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  P: null,
  H: "heading",
  Title: null,
  FENote: "note",
  Sub: "group",
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  L: "list",
  LI: "listitem",
  LBody: null,
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  Caption: null,
  Figure: "figure",
  Formula: null,
  Artifact: null
}, FP = /^H(\d+)$/;
var _e, Rd, Hv, Id, $v;
class qE {
  constructor() {
    p(this, Rd);
    p(this, Id);
    p(this, _e, void 0);
  }
  get renderingDone() {
    return o(this, _e) !== void 0;
  }
  render(e) {
    if (o(this, _e) !== void 0)
      return o(this, _e);
    const t = v(this, Id, $v).call(this, e);
    return t == null || t.classList.add("structTree"), b(this, _e, t);
  }
  hide() {
    o(this, _e) && !o(this, _e).hidden && (o(this, _e).hidden = !0);
  }
  show() {
    var e;
    (e = o(this, _e)) != null && e.hidden && (o(this, _e).hidden = !1);
  }
}
_e = new WeakMap(), Rd = new WeakSet(), Hv = function(e, t) {
  const {
    alt: s,
    id: i,
    lang: n
  } = e;
  s !== void 0 && t.setAttribute("aria-label", df(s)), i !== void 0 && t.setAttribute("aria-owns", i), n !== void 0 && t.setAttribute("lang", df(n, !0));
}, Id = new WeakSet(), $v = function(e) {
  if (!e)
    return null;
  const t = document.createElement("span");
  if ("role" in e) {
    const {
      role: s
    } = e, i = s.match(FP);
    i ? (t.setAttribute("role", "heading"), t.setAttribute("aria-level", i[1])) : yy[s] && t.setAttribute("role", yy[s]);
  }
  if (v(this, Rd, Hv).call(this, e, t), e.children)
    if (e.children.length === 1 && "id" in e.children[0])
      v(this, Rd, Hv).call(this, e.children[0], t);
    else
      for (const s of e.children)
        t.append(v(this, Id, $v).call(this, s));
  return t;
};
var li, Me, hi, rn, Ko, Zu, Ld, Uv;
const ga = class ga {
  constructor() {
    p(this, Ld);
    p(this, li, !1);
    p(this, Me, null);
    p(this, hi, /* @__PURE__ */ new Map());
    p(this, rn, /* @__PURE__ */ new Map());
  }
  setTextMapping(e) {
    b(this, Me, e);
  }
  enable() {
    if (o(this, li))
      throw new Error("TextAccessibilityManager is already enabled.");
    if (!o(this, Me))
      throw new Error("Text divs and strings have not been set.");
    if (b(this, li, !0), b(this, Me, o(this, Me).slice()), o(this, Me).sort(v(ga, Ko, Zu)), o(this, hi).size > 0) {
      const e = o(this, Me);
      for (const [t, s] of o(this, hi)) {
        if (!document.getElementById(t)) {
          o(this, hi).delete(t);
          continue;
        }
        v(this, Ld, Uv).call(this, t, e[s]);
      }
    }
    for (const [e, t] of o(this, rn))
      this.addPointerInTextLayer(e, t);
    o(this, rn).clear();
  }
  disable() {
    o(this, li) && (o(this, rn).clear(), b(this, Me, null), b(this, li, !1));
  }
  removePointerInTextLayer(e) {
    if (!o(this, li)) {
      o(this, rn).delete(e);
      return;
    }
    const t = o(this, Me);
    if (!t || t.length === 0)
      return;
    const {
      id: s
    } = e, i = o(this, hi).get(s);
    if (i === void 0)
      return;
    const n = t[i];
    o(this, hi).delete(s);
    let r = n.getAttribute("aria-owns");
    r != null && r.includes(s) && (r = r.split(" ").filter((a) => a !== s).join(" "), r ? n.setAttribute("aria-owns", r) : (n.removeAttribute("aria-owns"), n.setAttribute("role", "presentation")));
  }
  addPointerInTextLayer(e, t) {
    const {
      id: s
    } = e;
    if (!s)
      return null;
    if (!o(this, li))
      return o(this, rn).set(e, t), null;
    t && this.removePointerInTextLayer(e);
    const i = o(this, Me);
    if (!i || i.length === 0)
      return null;
    const n = zl(i, (c) => {
      var d;
      return v(d = ga, Ko, Zu).call(d, e, c) < 0;
    }), r = Math.max(0, n - 1), a = i[r];
    v(this, Ld, Uv).call(this, s, a), o(this, hi).set(s, r);
    const h = a.parentNode;
    return h != null && h.classList.contains("markedContent") ? h.id : null;
  }
  moveElementInDOM(e, t, s, i) {
    const n = this.addPointerInTextLayer(s, i);
    if (!e.hasChildNodes())
      return e.append(t), n;
    const r = Array.from(e.childNodes).filter((c) => c !== t);
    if (r.length === 0)
      return n;
    const a = s || t, h = zl(r, (c) => {
      var d;
      return v(d = ga, Ko, Zu).call(d, a, c) < 0;
    });
    return h === 0 ? r[0].before(t) : r[h - 1].after(t), n;
  }
};
li = new WeakMap(), Me = new WeakMap(), hi = new WeakMap(), rn = new WeakMap(), Ko = new WeakSet(), Zu = function(e, t) {
  const s = e.getBoundingClientRect(), i = t.getBoundingClientRect();
  if (s.width === 0 && s.height === 0)
    return 1;
  if (i.width === 0 && i.height === 0)
    return -1;
  const n = s.y, r = s.y + s.height, a = s.y + s.height / 2, h = i.y, c = i.y + i.height, d = i.y + i.height / 2;
  if (a <= h && d >= r)
    return -1;
  if (d <= n && a >= c)
    return 1;
  const u = s.x + s.width / 2, f = i.x + i.width / 2;
  return u - f;
}, Ld = new WeakSet(), Uv = function(e, t) {
  const s = t.getAttribute("aria-owns");
  s != null && s.includes(e) || t.setAttribute("aria-owns", s ? `${s} ${e}` : e), t.removeAttribute("role");
}, p(ga, Ko);
let Vv = ga;
var an;
class NP {
  constructor({
    findController: e,
    eventBus: t,
    pageIndex: s
  }) {
    p(this, an, null);
    this.findController = e, this.matches = [], this.eventBus = t, this.pageIdx = s, this.textDivs = null, this.textContentItemsStr = null, this.enabled = !1;
  }
  setTextMapping(e, t) {
    this.textDivs = e, this.textContentItemsStr = t;
  }
  enable() {
    if (!this.textDivs || !this.textContentItemsStr)
      throw new Error("Text divs and strings have not been set.");
    if (this.enabled)
      throw new Error("TextHighlighter is already enabled.");
    this.enabled = !0, o(this, an) || (b(this, an, new AbortController()), this.eventBus._on("updatetextlayermatches", (e) => {
      (e.pageIndex === this.pageIdx || e.pageIndex === -1) && this._updateMatches();
    }, {
      signal: o(this, an).signal
    })), this._updateMatches();
  }
  disable() {
    var e;
    this.enabled && (this.enabled = !1, (e = o(this, an)) == null || e.abort(), b(this, an, null), this._updateMatches(!0));
  }
  _convertMatches(e, t) {
    if (!e)
      return [];
    const {
      textContentItemsStr: s
    } = this;
    let i = 0, n = 0;
    const r = s.length - 1, a = [];
    for (let h = 0, c = e.length; h < c; h++) {
      let d = e[h];
      for (; i !== r && d >= n + s[i].length; )
        n += s[i].length, i++;
      i === s.length && console.error("Could not find a matching mapping");
      const u = {
        begin: {
          divIdx: i,
          offset: d - n
        }
      };
      for (d += t[h]; i !== r && d > n + s[i].length; )
        n += s[i].length, i++;
      u.end = {
        divIdx: i,
        offset: d - n
      }, a.push(u);
    }
    return a;
  }
  _renderMatches(e) {
    if (e.length === 0)
      return;
    const {
      findController: t,
      pageIdx: s
    } = this, {
      textContentItemsStr: i,
      textDivs: n
    } = this, r = s === t.selected.pageIdx, a = t.selected.matchIdx, h = t.state.highlightAll;
    let c = null;
    const d = {
      divIdx: -1,
      offset: void 0
    };
    function u(y, w) {
      const S = y.divIdx;
      return n[S].textContent = "", f(S, 0, y.offset, w);
    }
    function f(y, w, S, C) {
      let P = n[y];
      if (P.nodeType === Node.TEXT_NODE) {
        const M = document.createElement("span");
        P.before(M), M.append(P), n[y] = M, P = M;
      }
      const x = i[y].substring(w, S), R = document.createTextNode(x);
      if (C) {
        const M = document.createElement("span");
        return M.className = `${C} appended`, M.append(R), P.append(M), C.includes("selected") ? M.offsetLeft : 0;
      }
      return P.append(R), 0;
    }
    let m = a, g = m + 1;
    if (h)
      m = 0, g = e.length;
    else if (!r)
      return;
    let A = -1, E = -1;
    for (let y = m; y < g; y++) {
      const w = e[y], S = w.begin;
      if (S.divIdx === A && S.offset === E)
        continue;
      A = S.divIdx, E = S.offset;
      const C = w.end, P = r && y === a, x = P ? " selected" : "";
      let R = 0;
      if (!c || S.divIdx !== c.divIdx ? (c !== null && f(c.divIdx, c.offset, d.offset), u(S)) : f(c.divIdx, c.offset, S.offset), S.divIdx === C.divIdx)
        R = f(S.divIdx, S.offset, C.offset, "highlight" + x);
      else {
        R = f(S.divIdx, S.offset, d.offset, "highlight begin" + x);
        for (let M = S.divIdx + 1, T = C.divIdx; M < T; M++)
          n[M].className = "highlight middle" + x;
        u(C, "highlight end" + x);
      }
      c = C, P && t.scrollMatchIntoView({
        element: n[S.divIdx],
        selectedLeft: R,
        pageIndex: s,
        matchIndex: a
      });
    }
    c && f(c.divIdx, c.offset, d.offset);
  }
  _updateMatches(e = !1) {
    if (!this.enabled && !e)
      return;
    const {
      findController: t,
      matches: s,
      pageIdx: i
    } = this, {
      textContentItemsStr: n,
      textDivs: r
    } = this;
    let a = -1;
    for (const d of s) {
      const u = Math.max(a, d.begin.divIdx);
      for (let f = u, m = d.end.divIdx; f <= m; f++) {
        const g = r[f];
        g.textContent = n[f], g.className = "";
      }
      a = d.end.divIdx + 1;
    }
    if (!(t != null && t.highlightMatches) || e)
      return;
    const h = t.pageMatches[i] || null, c = t.pageMatchesLength[i] || null;
    this.matches = this._convertMatches(h, c), this._renderMatches(this.matches);
  }
}
an = new WeakMap();
var _d, Md, Br, Es, Oe, on, Ag, t0, Eg, e0, wg, s0;
const Ms = class Ms {
  constructor({
    pdfPage: e,
    highlighter: t = null,
    accessibilityManager: s = null,
    enablePermissions: i = !1,
    onAppend: n = null
  }) {
    p(this, Ag);
    p(this, _d, !1);
    p(this, Md, null);
    p(this, Br, !1);
    p(this, Es, null);
    this.pdfPage = e, this.highlighter = t, this.accessibilityManager = s, b(this, _d, i === !0), b(this, Md, n), this.div = document.createElement("div"), this.div.tabIndex = 0, this.div.className = "textLayer";
  }
  async render(e, t = null) {
    var r, a, h, c, d;
    if (o(this, Br) && o(this, Es)) {
      o(this, Es).update({
        viewport: e,
        onBefore: this.hide.bind(this)
      }), this.show();
      return;
    }
    this.cancel(), b(this, Es, new Mx({
      textContentSource: this.pdfPage.streamTextContent(t || {
        includeMarkedContent: !0,
        disableNormalization: !0
      }),
      container: this.div,
      viewport: e
    }));
    const {
      textDivs: s,
      textContentItemsStr: i
    } = o(this, Es);
    (r = this.highlighter) == null || r.setTextMapping(s, i), (a = this.accessibilityManager) == null || a.setTextMapping(s), await o(this, Es).render(), b(this, Br, !0);
    const n = document.createElement("div");
    n.className = "endOfContent", this.div.append(n), v(this, Ag, t0).call(this, n), (h = o(this, Md)) == null || h.call(this, this.div), (c = this.highlighter) == null || c.enable(), (d = this.accessibilityManager) == null || d.enable();
  }
  hide() {
    var e;
    !this.div.hidden && o(this, Br) && ((e = this.highlighter) == null || e.disable(), this.div.hidden = !0);
  }
  show() {
    var e;
    this.div.hidden && o(this, Br) && (this.div.hidden = !1, (e = this.highlighter) == null || e.enable());
  }
  cancel() {
    var e, t, s, i;
    (e = o(this, Es)) == null || e.cancel(), b(this, Es, null), (t = this.highlighter) == null || t.disable(), (s = this.accessibilityManager) == null || s.disable(), v(i = Ms, Eg, e0).call(i, this.div);
  }
};
_d = new WeakMap(), Md = new WeakMap(), Br = new WeakMap(), Es = new WeakMap(), Oe = new WeakMap(), on = new WeakMap(), Ag = new WeakSet(), t0 = function(e) {
  var s;
  const {
    div: t
  } = this;
  t.addEventListener("mousedown", (i) => {
    e.classList.add("active");
  }), t.addEventListener("copy", (i) => {
    if (!o(this, _d)) {
      const n = document.getSelection();
      i.clipboardData.setData("text/plain", df(Lx(n.toString())));
    }
    i.preventDefault(), i.stopPropagation();
  }), o(Ms, Oe).set(t, e), v(s = Ms, wg, s0).call(s);
}, Eg = new WeakSet(), e0 = function(e) {
  var t;
  o(this, Oe).delete(e), o(this, Oe).size === 0 && ((t = o(this, on)) == null || t.abort(), b(this, on, null));
}, wg = new WeakSet(), s0 = function() {
  if (o(this, on))
    return;
  b(this, on, new AbortController());
  const {
    signal: e
  } = o(this, on), t = (n, r) => {
    r.append(n), n.style.width = "", n.style.height = "", n.classList.remove("active");
  };
  document.addEventListener("pointerup", () => {
    o(this, Oe).forEach(t);
  }, {
    signal: e
  });
  var s, i;
  document.addEventListener("selectionchange", () => {
    const n = document.getSelection();
    if (n.rangeCount === 0) {
      o(this, Oe).forEach(t);
      return;
    }
    const r = /* @__PURE__ */ new Set();
    for (let f = 0; f < n.rangeCount; f++) {
      const m = n.getRangeAt(f);
      for (const g of o(this, Oe).keys())
        !r.has(g) && m.intersectsNode(g) && r.add(g);
    }
    for (const [f, m] of o(this, Oe))
      r.has(f) ? m.classList.add("active") : t(m, f);
    if (s ?? (s = getComputedStyle(o(this, Oe).values().next().value).getPropertyValue("-moz-user-select") === "none"), s)
      return;
    const a = n.getRangeAt(0), h = i && (a.compareBoundaryPoints(Range.END_TO_END, i) === 0 || a.compareBoundaryPoints(Range.START_TO_END, i) === 0);
    let c = h ? a.startContainer : a.endContainer;
    c.nodeType === Node.TEXT_NODE && (c = c.parentNode);
    const d = c.parentElement.closest(".textLayer"), u = o(this, Oe).get(d);
    u && (u.style.width = d.style.width, u.style.height = d.style.height, c.parentElement.insertBefore(u, h ? c : c.nextSibling)), i = a.cloneRange();
  }, {
    signal: e
  });
}, p(Ms, Eg), p(Ms, wg), p(Ms, Oe, /* @__PURE__ */ new Map()), p(Ms, on, null);
let gf = Ms;
class i0 {
  constructor({
    pdfPage: e,
    annotationStorage: t = null,
    linkService: s,
    xfaHtml: i = null
  }) {
    this.pdfPage = e, this.annotationStorage = t, this.linkService = s, this.xfaHtml = i, this.div = null, this._cancelled = !1;
  }
  async render(e, t = "display") {
    if (t === "print") {
      const n = {
        viewport: e.clone({
          dontFlip: !0
        }),
        div: this.div,
        xfaHtml: this.xfaHtml,
        annotationStorage: this.annotationStorage,
        linkService: this.linkService,
        intent: t
      };
      return this.div = document.createElement("div"), n.div = this.div, am.render(n);
    }
    const s = await this.pdfPage.getXfa();
    if (this._cancelled || !s)
      return {
        textDivs: []
      };
    const i = {
      viewport: e.clone({
        dontFlip: !0
      }),
      div: this.div,
      xfaHtml: s,
      annotationStorage: this.annotationStorage,
      linkService: this.linkService,
      intent: t
    };
    return this.div ? am.update(i) : (this.div = document.createElement("div"), i.div = this.div, am.render(i));
  }
  cancel() {
    this._cancelled = !0;
  }
  hide() {
    this.div && (this.div.hidden = !0);
  }
}
const BP = {
  annotationEditorUIManager: null,
  annotationStorage: null,
  downloadManager: null,
  enableScripting: !1,
  fieldObjectsPromise: null,
  findController: null,
  hasJSActionsPromise: null,
  get linkService() {
    return new fb();
  }
}, jP = /* @__PURE__ */ new Map([["canvasWrapper", 0], ["textLayer", 1], ["annotationLayer", 2], ["annotationEditorLayer", 3], ["xfaLayer", 3]]);
var jr, Od, Hr, ln, hn, Dd, $r, Yo, Qo, ci, Vr, cn, dn, fa, Zo, Ju, Ur, Dl, kd, zv, Fd, Wv, Nd, Gv, Bd, Xv, jd, Kv, Sg, r0, xg, a0, Hd, Yv;
class n0 {
  constructor(e) {
    p(this, dn);
    p(this, Zo);
    p(this, Ur);
    p(this, kd);
    p(this, Fd);
    p(this, Nd);
    p(this, Bd);
    p(this, jd);
    p(this, Sg);
    p(this, xg);
    p(this, Hd);
    p(this, jr, pi.ENABLE_FORMS);
    p(this, Od, !1);
    p(this, Hr, !1);
    p(this, ln, null);
    p(this, hn, null);
    p(this, Dd, null);
    p(this, $r, null);
    p(this, Yo, At.INITIAL);
    p(this, Qo, xs.ENABLE);
    p(this, ci, {
      directDrawing: !0,
      initialOptionalContent: !0,
      regularAnnotations: !0
    });
    p(this, Vr, /* @__PURE__ */ new WeakMap());
    p(this, cn, [null, null, null, null]);
    var n;
    const t = e.container, s = e.defaultViewport;
    this.id = e.id, this.renderingId = "page" + this.id, b(this, ln, e.layerProperties || BP), this.pdfPage = null, this.pageLabel = null, this.rotation = 0, this.scale = e.scale || TE, this.viewport = s, this.pdfPageRotate = s.rotation, this._optionalContentConfigPromise = e.optionalContentConfigPromise || null, b(this, Qo, e.textLayerMode ?? xs.ENABLE), b(this, jr, e.annotationMode ?? pi.ENABLE_FORMS), this.imageResourcesPath = e.imageResourcesPath || "", this.maxCanvasPixels = e.maxCanvasPixels ?? DP.get("maxCanvasPixels"), this.pageColors = e.pageColors || null, b(this, Od, e.enableHWA || !1), this.eventBus = e.eventBus, this.renderingQueue = e.renderingQueue, this.l10n = e.l10n, this.l10n || (this.l10n = new ol()), this.renderTask = null, this.resume = null, this._isStandalone = !((n = this.renderingQueue) != null && n.hasViewer()), this._container = t, this._annotationCanvasMap = null, this.annotationLayer = null, this.annotationEditorLayer = null, this.textLayer = null, this.zoomLayer = null, this.xfaLayer = null, this.structTreeLayer = null, this.drawLayer = null;
    const i = document.createElement("div");
    if (i.className = "page", i.setAttribute("data-page-number", this.id), i.setAttribute("role", "region"), i.setAttribute("data-l10n-id", "pdfjs-page-landmark"), i.setAttribute("data-l10n-args", JSON.stringify({
      page: this.id
    })), this.div = i, v(this, Zo, Ju).call(this), t == null || t.append(i), this._isStandalone) {
      t == null || t.style.setProperty("--scale-factor", this.scale * Ds.PDF_TO_CSS_UNITS);
      const {
        optionalContentConfigPromise: r
      } = e;
      r && r.then((a) => {
        r === this._optionalContentConfigPromise && (o(this, ci).initialOptionalContent = a.hasInitialVisibility);
      }), e.l10n || this.l10n.translate(this.div);
    }
  }
  get renderingState() {
    return o(this, Yo);
  }
  set renderingState(e) {
    if (e !== o(this, Yo))
      switch (b(this, Yo, e), o(this, hn) && (clearTimeout(o(this, hn)), b(this, hn, null)), e) {
        case At.PAUSED:
          this.div.classList.remove("loading");
          break;
        case At.RUNNING:
          this.div.classList.add("loadingIcon"), b(this, hn, setTimeout(() => {
            this.div.classList.add("loading"), b(this, hn, null);
          }, 0));
          break;
        case At.INITIAL:
        case At.FINISHED:
          this.div.classList.remove("loadingIcon", "loading");
          break;
      }
  }
  setPdfPage(e) {
    var s, i, n, r;
    this._isStandalone && (((s = this.pageColors) == null ? void 0 : s.foreground) === "CanvasText" || ((i = this.pageColors) == null ? void 0 : i.background) === "Canvas") && ((n = this._container) == null || n.style.setProperty("--hcm-highlight-filter", e.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), (r = this._container) == null || r.style.setProperty("--hcm-highlight-selected-filter", e.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "Highlight"))), this.pdfPage = e, this.pdfPageRotate = e.rotate;
    const t = (this.rotation + this.pdfPageRotate) % 360;
    this.viewport = e.getViewport({
      scale: this.scale * Ds.PDF_TO_CSS_UNITS,
      rotation: t
    }), v(this, Zo, Ju).call(this), this.reset();
  }
  destroy() {
    var e;
    this.reset(), (e = this.pdfPage) == null || e.cleanup();
  }
  get _textHighlighter() {
    return ff(this, "_textHighlighter", new NP({
      pageIndex: this.id - 1,
      eventBus: this.eventBus,
      findController: o(this, ln).findController
    }));
  }
  _resetZoomLayer(e = !1) {
    if (!this.zoomLayer)
      return;
    const t = this.zoomLayer.firstChild;
    o(this, Vr).delete(t), t.width = 0, t.height = 0, e && this.zoomLayer.remove(), this.zoomLayer = null;
  }
  reset({
    keepZoomLayer: e = !1,
    keepAnnotationLayer: t = !1,
    keepAnnotationEditorLayer: s = !1,
    keepXfaLayer: i = !1,
    keepTextLayer: n = !1
  } = {}) {
    var m, g, A, E, y;
    this.cancelRendering({
      keepAnnotationLayer: t,
      keepAnnotationEditorLayer: s,
      keepXfaLayer: i,
      keepTextLayer: n
    }), this.renderingState = At.INITIAL;
    const r = this.div, a = r.childNodes, h = e && this.zoomLayer || null, c = t && ((m = this.annotationLayer) == null ? void 0 : m.div) || null, d = s && ((g = this.annotationEditorLayer) == null ? void 0 : g.div) || null, u = i && ((A = this.xfaLayer) == null ? void 0 : A.div) || null, f = n && ((E = this.textLayer) == null ? void 0 : E.div) || null;
    for (let w = a.length - 1; w >= 0; w--) {
      const S = a[w];
      switch (S) {
        case h:
        case c:
        case d:
        case u:
        case f:
          continue;
      }
      S.remove();
      const C = o(this, cn).indexOf(S);
      C >= 0 && (o(this, cn)[C] = null);
    }
    r.removeAttribute("data-loaded"), c && this.annotationLayer.hide(), d && this.annotationEditorLayer.hide(), u && this.xfaLayer.hide(), f && this.textLayer.hide(), (y = this.structTreeLayer) == null || y.hide(), h || (this.canvas && (o(this, Vr).delete(this.canvas), this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this._resetZoomLayer());
  }
  update({
    scale: e = 0,
    rotation: t = null,
    optionalContentConfigPromise: s = null,
    drawingDelay: i = -1
  }) {
    var r;
    this.scale = e || this.scale, typeof t == "number" && (this.rotation = t), s instanceof Promise && (this._optionalContentConfigPromise = s, s.then((a) => {
      s === this._optionalContentConfigPromise && (o(this, ci).initialOptionalContent = a.hasInitialVisibility);
    })), o(this, ci).directDrawing = !0;
    const n = (this.rotation + this.pdfPageRotate) % 360;
    if (this.viewport = this.viewport.clone({
      scale: this.scale * Ds.PDF_TO_CSS_UNITS,
      rotation: n
    }), v(this, Zo, Ju).call(this), this._isStandalone && ((r = this._container) == null || r.style.setProperty("--scale-factor", this.viewport.scale)), this.canvas) {
      let a = !1;
      if (o(this, Hr)) {
        if (this.maxCanvasPixels === 0)
          a = !0;
        else if (this.maxCanvasPixels > 0) {
          const {
            width: c,
            height: d
          } = this.viewport, {
            sx: u,
            sy: f
          } = this.outputScale;
          a = (Math.floor(c) * u | 0) * (Math.floor(d) * f | 0) > this.maxCanvasPixels;
        }
      }
      const h = i >= 0 && i < 1e3;
      if (h || a) {
        if (h && !a && this.renderingState !== At.FINISHED && (this.cancelRendering({
          keepZoomLayer: !0,
          keepAnnotationLayer: !0,
          keepAnnotationEditorLayer: !0,
          keepXfaLayer: !0,
          keepTextLayer: !0,
          cancelExtraDelay: i
        }), this.renderingState = At.FINISHED, o(this, ci).directDrawing = !1), this.cssTransform({
          target: this.canvas,
          redrawAnnotationLayer: !0,
          redrawAnnotationEditorLayer: !0,
          redrawXfaLayer: !0,
          redrawTextLayer: !h,
          hideTextLayer: h
        }), h)
          return;
        this.eventBus.dispatch("pagerendered", {
          source: this,
          pageNumber: this.id,
          cssTransform: !0,
          timestamp: performance.now(),
          error: o(this, $r)
        });
        return;
      }
      !this.zoomLayer && !this.canvas.hidden && (this.zoomLayer = this.canvas.parentNode, this.zoomLayer.style.position = "absolute");
    }
    this.zoomLayer && this.cssTransform({
      target: this.zoomLayer.firstChild
    }), this.reset({
      keepZoomLayer: !0,
      keepAnnotationLayer: !0,
      keepAnnotationEditorLayer: !0,
      keepXfaLayer: !0,
      keepTextLayer: !0
    });
  }
  cancelRendering({
    keepAnnotationLayer: e = !1,
    keepAnnotationEditorLayer: t = !1,
    keepXfaLayer: s = !1,
    keepTextLayer: i = !1,
    cancelExtraDelay: n = 0
  } = {}) {
    var r;
    this.renderTask && (this.renderTask.cancel(n), this.renderTask = null), this.resume = null, this.textLayer && (!i || !this.textLayer.div) && (this.textLayer.cancel(), this.textLayer = null), this.structTreeLayer && !this.textLayer && (this.structTreeLayer = null), this.annotationLayer && (!e || !this.annotationLayer.div) && (this.annotationLayer.cancel(), this.annotationLayer = null, this._annotationCanvasMap = null), this.annotationEditorLayer && (!t || !this.annotationEditorLayer.div) && (this.drawLayer && (this.drawLayer.cancel(), this.drawLayer = null), this.annotationEditorLayer.cancel(), this.annotationEditorLayer = null), this.xfaLayer && (!s || !this.xfaLayer.div) && (this.xfaLayer.cancel(), this.xfaLayer = null, (r = this._textHighlighter) == null || r.disable());
  }
  cssTransform({
    target: e,
    redrawAnnotationLayer: t = !1,
    redrawAnnotationEditorLayer: s = !1,
    redrawXfaLayer: i = !1,
    redrawTextLayer: n = !1,
    hideTextLayer: r = !1
  }) {
    var h;
    if (!e.hasAttribute("zooming")) {
      e.setAttribute("zooming", !0);
      const {
        style: c
      } = e;
      c.width = c.height = "";
    }
    const a = o(this, Vr).get(e);
    if (this.viewport !== a) {
      const c = this.viewport.rotation - a.rotation, d = Math.abs(c);
      let u = 1, f = 1;
      if (d === 90 || d === 270) {
        const {
          width: m,
          height: g
        } = this.viewport;
        u = g / m, f = m / g;
      }
      e.style.transform = `rotate(${c}deg) scale(${u}, ${f})`;
    }
    t && this.annotationLayer && v(this, kd, zv).call(this), s && this.annotationEditorLayer && (this.drawLayer && v(this, Nd, Gv).call(this), v(this, Fd, Wv).call(this)), i && this.xfaLayer && v(this, Bd, Xv).call(this), this.textLayer && (r ? (this.textLayer.hide(), (h = this.structTreeLayer) == null || h.hide()) : n && v(this, jd, Kv).call(this));
  }
  get width() {
    return this.viewport.width;
  }
  get height() {
    return this.viewport.height;
  }
  getPagePoint(e, t) {
    return this.viewport.convertToPdfPoint(e, t);
  }
  async draw() {
    this.renderingState !== At.INITIAL && (console.error("Must be in new state before drawing"), this.reset());
    const {
      div: e,
      l10n: t,
      pageColors: s,
      pdfPage: i,
      viewport: n
    } = this;
    if (!i)
      throw this.renderingState = At.FINISHED, new Error("pdfPage is not loaded");
    this.renderingState = At.RUNNING;
    const r = document.createElement("div");
    if (r.classList.add("canvasWrapper"), v(this, dn, fa).call(this, r, "canvasWrapper"), !this.textLayer && o(this, Qo) !== xs.DISABLE && !i.isPureXfa && (this._accessibilityManager || (this._accessibilityManager = new Vv()), this.textLayer = new gf({
      pdfPage: i,
      highlighter: this._textHighlighter,
      accessibilityManager: this._accessibilityManager,
      enablePermissions: o(this, Qo) === xs.ENABLE_PERMISSIONS,
      onAppend: (x) => {
        this.l10n.pause(), v(this, dn, fa).call(this, x, "textLayer"), this.l10n.resume();
      }
    })), !this.annotationLayer && o(this, jr) !== pi.DISABLE) {
      const {
        annotationStorage: x,
        annotationEditorUIManager: R,
        downloadManager: M,
        enableScripting: T,
        fieldObjectsPromise: I,
        hasJSActionsPromise: _,
        linkService: k
      } = o(this, ln);
      this._annotationCanvasMap || (this._annotationCanvasMap = /* @__PURE__ */ new Map()), this.annotationLayer = new BE({
        pdfPage: i,
        annotationStorage: x,
        imageResourcesPath: this.imageResourcesPath,
        renderForms: o(this, jr) === pi.ENABLE_FORMS,
        linkService: k,
        downloadManager: M,
        enableScripting: T,
        hasJSActionsPromise: _,
        fieldObjectsPromise: I,
        annotationCanvasMap: this._annotationCanvasMap,
        accessibilityManager: this._accessibilityManager,
        annotationEditorUIManager: R,
        onAppend: (F) => {
          v(this, dn, fa).call(this, F, "annotationLayer");
        }
      });
    }
    const a = (x) => {
      if (f == null || f(!1), this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
        this.renderingState = At.PAUSED, this.resume = () => {
          this.renderingState = At.RUNNING, x();
        };
        return;
      }
      x();
    }, {
      width: h,
      height: c
    } = n, d = document.createElement("canvas");
    d.setAttribute("role", "presentation"), d.hidden = !0;
    const u = !!(s != null && s.background && (s != null && s.foreground));
    let f = (x) => {
      (!u || x) && (d.hidden = !1, f = null);
    };
    r.append(d), this.canvas = d;
    const m = d.getContext("2d", {
      alpha: !1,
      willReadFrequently: !o(this, Od)
    }), g = this.outputScale = new US();
    if (this.maxCanvasPixels === 0) {
      const x = 1 / this.scale;
      g.sx *= x, g.sy *= x, b(this, Hr, !0);
    } else if (this.maxCanvasPixels > 0) {
      const x = h * c, R = Math.sqrt(this.maxCanvasPixels / x);
      g.sx > R || g.sy > R ? (g.sx = R, g.sy = R, b(this, Hr, !0)) : b(this, Hr, !1);
    }
    const A = Xb(g.sx), E = Xb(g.sy);
    d.width = uu(h * g.sx, A[0]), d.height = uu(c * g.sy, E[0]);
    const {
      style: y
    } = d;
    y.width = uu(h, A[1]) + "px", y.height = uu(c, E[1]) + "px", o(this, Vr).set(d, n);
    const w = g.scaled ? [g.sx, 0, 0, g.sy, 0, 0] : null, S = {
      canvasContext: m,
      transform: w,
      viewport: n,
      annotationMode: o(this, jr),
      optionalContentConfigPromise: this._optionalContentConfigPromise,
      annotationCanvasMap: this._annotationCanvasMap,
      pageColors: s
    }, C = this.renderTask = i.render(S);
    C.onContinue = a;
    const P = C.promise.then(async () => {
      var R;
      f == null || f(!0), await v(this, Hd, Yv).call(this, C), v(this, jd, Kv).call(this), this.annotationLayer && await v(this, kd, zv).call(this);
      const {
        annotationEditorUIManager: x
      } = o(this, ln);
      x && (this.drawLayer || (this.drawLayer = new kP({
        pageIndex: this.id
      })), await v(this, Nd, Gv).call(this), this.drawLayer.setParent(r), this.annotationEditorLayer || (this.annotationEditorLayer = new OP({
        uiManager: x,
        pdfPage: i,
        l10n: t,
        accessibilityManager: this._accessibilityManager,
        annotationLayer: (R = this.annotationLayer) == null ? void 0 : R.annotationLayer,
        textLayer: this.textLayer,
        drawLayer: this.drawLayer.getDrawLayer(),
        onAppend: (M) => {
          v(this, dn, fa).call(this, M, "annotationEditorLayer");
        }
      })), v(this, Fd, Wv).call(this));
    }, (x) => (x instanceof Mv || f == null || f(!0), v(this, Hd, Yv).call(this, C, x)));
    if (i.isPureXfa) {
      if (!this.xfaLayer) {
        const {
          annotationStorage: x,
          linkService: R
        } = o(this, ln);
        this.xfaLayer = new i0({
          pdfPage: i,
          annotationStorage: x,
          linkService: R
        });
      }
      v(this, Bd, Xv).call(this);
    }
    return e.setAttribute("data-loaded", !0), this.eventBus.dispatch("pagerender", {
      source: this,
      pageNumber: this.id
    }), P;
  }
  setPageLabel(e) {
    this.pageLabel = typeof e == "string" ? e : null, this.div.setAttribute("data-l10n-args", JSON.stringify({
      page: this.pageLabel ?? this.id
    })), this.pageLabel !== null ? this.div.setAttribute("data-page-label", this.pageLabel) : this.div.removeAttribute("data-page-label");
  }
  get thumbnailCanvas() {
    const {
      directDrawing: e,
      initialOptionalContent: t,
      regularAnnotations: s
    } = o(this, ci);
    return e && t && s ? this.canvas : null;
  }
}
jr = new WeakMap(), Od = new WeakMap(), Hr = new WeakMap(), ln = new WeakMap(), hn = new WeakMap(), Dd = new WeakMap(), $r = new WeakMap(), Yo = new WeakMap(), Qo = new WeakMap(), ci = new WeakMap(), Vr = new WeakMap(), cn = new WeakMap(), dn = new WeakSet(), fa = function(e, t) {
  const s = jP.get(t), i = o(this, cn)[s];
  if (o(this, cn)[s] = e, i) {
    i.replaceWith(e);
    return;
  }
  for (let n = s - 1; n >= 0; n--) {
    const r = o(this, cn)[n];
    if (r) {
      r.after(e);
      return;
    }
  }
  this.div.prepend(e);
}, Zo = new WeakSet(), Ju = function() {
  const {
    viewport: e
  } = this;
  if (this.pdfPage) {
    if (o(this, Dd) === e.rotation)
      return;
    b(this, Dd, e.rotation);
  }
  _x(this.div, e, !0, !1);
}, Ur = new WeakSet(), Dl = function(e, t) {
  this.eventBus.dispatch(e, {
    source: this,
    pageNumber: this.id,
    error: t
  });
}, kd = new WeakSet(), zv = async function() {
  let e = null;
  try {
    await this.annotationLayer.render(this.viewport, "display");
  } catch (t) {
    console.error(`#renderAnnotationLayer: "${t}".`), e = t;
  } finally {
    v(this, Ur, Dl).call(this, "annotationlayerrendered", e);
  }
}, Fd = new WeakSet(), Wv = async function() {
  let e = null;
  try {
    await this.annotationEditorLayer.render(this.viewport, "display");
  } catch (t) {
    console.error(`#renderAnnotationEditorLayer: "${t}".`), e = t;
  } finally {
    v(this, Ur, Dl).call(this, "annotationeditorlayerrendered", e);
  }
}, Nd = new WeakSet(), Gv = async function() {
  try {
    await this.drawLayer.render("display");
  } catch (e) {
    console.error(`#renderDrawLayer: "${e}".`);
  }
}, Bd = new WeakSet(), Xv = async function() {
  var t;
  let e = null;
  try {
    const s = await this.xfaLayer.render(this.viewport, "display");
    s != null && s.textDivs && this._textHighlighter && v(this, xg, a0).call(this, s.textDivs);
  } catch (s) {
    console.error(`#renderXfaLayer: "${s}".`), e = s;
  } finally {
    (t = this.xfaLayer) != null && t.div && (this.l10n.pause(), v(this, dn, fa).call(this, this.xfaLayer.div, "xfaLayer"), this.l10n.resume()), v(this, Ur, Dl).call(this, "xfalayerrendered", e);
  }
}, jd = new WeakSet(), Kv = async function() {
  if (!this.textLayer)
    return;
  let e = null;
  try {
    await this.textLayer.render(this.viewport);
  } catch (t) {
    if (t instanceof wx)
      return;
    console.error(`#renderTextLayer: "${t}".`), e = t;
  }
  v(this, Ur, Dl).call(this, "textlayerrendered", e), v(this, Sg, r0).call(this);
}, Sg = new WeakSet(), r0 = async function() {
  var s, i, n;
  if (!this.textLayer)
    return;
  this.structTreeLayer || (this.structTreeLayer = new qE());
  const e = await (this.structTreeLayer.renderingDone ? null : this.pdfPage.getStructTree()), t = (s = this.structTreeLayer) == null ? void 0 : s.render(e);
  t && (this.l10n.pause(), (i = this.canvas) == null || i.append(t), this.l10n.resume()), (n = this.structTreeLayer) == null || n.show();
}, xg = new WeakSet(), a0 = async function(e) {
  const t = await this.pdfPage.getTextContent(), s = [];
  for (const i of t.items)
    s.push(i.str);
  this._textHighlighter.setTextMapping(e, s), this._textHighlighter.enable();
}, Hd = new WeakSet(), Yv = async function(e, t = null) {
  if (e === this.renderTask && (this.renderTask = null), t instanceof Mv) {
    b(this, $r, null);
    return;
  }
  if (b(this, $r, t), this.renderingState = At.FINISHED, this._resetZoomLayer(!0), o(this, ci).regularAnnotations = !e.separateAnnots, this.eventBus.dispatch("pagerendered", {
    source: this,
    pageNumber: this.id,
    cssTransform: !1,
    timestamp: performance.now(),
    error: o(this, $r)
  }), t)
    throw t;
};
async function HP(l) {
  const e = "", t = e.split("#", 1)[0];
  let {
    info: s,
    metadata: i,
    contentDispositionFilename: n,
    contentLength: r
  } = await l.getMetadata();
  if (!r) {
    const {
      length: a
    } = await l.getDownloadInfo();
    r = a;
  }
  return {
    ...s,
    baseURL: t,
    filesize: r,
    filename: n || Rx(e),
    metadata: i == null ? void 0 : i.getRaw(),
    authors: i == null ? void 0 : i.get("dc:creator"),
    numPages: l.numPages,
    URL: e
  };
}
class $P {
  constructor(e) {
    this._ready = new Promise((t, s) => {
      import(
        /*webpackIgnore: true*/
        e
      ).then((n) => {
        t(n.QuickJSSandbox());
      }).catch(s);
    });
  }
  async createSandbox(e) {
    (await this._ready).create(e);
  }
  async dispatchEventInSandbox(e) {
    const t = await this._ready;
    setTimeout(() => t.dispatchEvent(e), 0);
  }
  async destroySandbox() {
    (await this._ready).nukeSandbox();
  }
}
var ws, zr, $d, Wr, Gr, Vd, ie, di, Jo, _t, De, Pg, o0, qo, qu, Ud, Qv, Tg, l0, Xr, kl;
class VP {
  constructor({
    eventBus: e,
    externalServices: t = null,
    docProperties: s = null
  }) {
    p(this, Pg);
    p(this, qo);
    p(this, Ud);
    p(this, Tg);
    p(this, Xr);
    p(this, ws, null);
    p(this, zr, null);
    p(this, $d, null);
    p(this, Wr, null);
    p(this, Gr, null);
    p(this, Vd, null);
    p(this, ie, null);
    p(this, di, null);
    p(this, Jo, !1);
    p(this, _t, null);
    p(this, De, null);
    b(this, Gr, e), b(this, Vd, t), b(this, $d, s);
  }
  setViewer(e) {
    b(this, di, e);
  }
  async setDocument(e) {
    var a;
    if (o(this, ie) && await v(this, Xr, kl).call(this), b(this, ie, e), !e)
      return;
    const [t, s, i] = await Promise.all([e.getFieldObjects(), e.getCalculationOrderIds(), e.getJSActions()]);
    if (!t && !i) {
      await v(this, Xr, kl).call(this);
      return;
    }
    if (e !== o(this, ie))
      return;
    try {
      b(this, _t, v(this, Tg, l0).call(this));
    } catch (h) {
      console.error(`setDocument: "${h.message}".`), await v(this, Xr, kl).call(this);
      return;
    }
    const n = o(this, Gr);
    b(this, Wr, new AbortController());
    const {
      signal: r
    } = o(this, Wr);
    n._on("updatefromsandbox", (h) => {
      (h == null ? void 0 : h.source) === window && v(this, Pg, o0).call(this, h.detail);
    }, {
      signal: r
    }), n._on("dispatcheventinsandbox", (h) => {
      var c;
      (c = o(this, _t)) == null || c.dispatchEventInSandbox(h.detail);
    }, {
      signal: r
    }), n._on("pagechanging", ({
      pageNumber: h,
      previous: c
    }) => {
      h !== c && (v(this, Ud, Qv).call(this, c), v(this, qo, qu).call(this, h));
    }, {
      signal: r
    }), n._on("pagerendered", ({
      pageNumber: h
    }) => {
      this._pageOpenPending.has(h) && h === o(this, di).currentPageNumber && v(this, qo, qu).call(this, h);
    }, {
      signal: r
    }), n._on("pagesdestroy", async () => {
      var h, c;
      await v(this, Ud, Qv).call(this, o(this, di).currentPageNumber), await ((h = o(this, _t)) == null ? void 0 : h.dispatchEventInSandbox({
        id: "doc",
        name: "WillClose"
      })), (c = o(this, ws)) == null || c.resolve();
    }, {
      signal: r
    });
    try {
      const h = await o(this, $d).call(this, e);
      if (e !== o(this, ie))
        return;
      await o(this, _t).createSandbox({
        objects: t,
        calculationOrder: s,
        appInfo: {
          platform: navigator.platform,
          language: navigator.language
        },
        docInfo: {
          ...h,
          actions: i
        }
      }), n.dispatch("sandboxcreated", {
        source: this
      });
    } catch (h) {
      console.error(`setDocument: "${h.message}".`), await v(this, Xr, kl).call(this);
      return;
    }
    await ((a = o(this, _t)) == null ? void 0 : a.dispatchEventInSandbox({
      id: "doc",
      name: "Open"
    })), await v(this, qo, qu).call(this, o(this, di).currentPageNumber, !0), Promise.resolve().then(() => {
      e === o(this, ie) && b(this, Jo, !0);
    });
  }
  async dispatchWillSave() {
    var e;
    return (e = o(this, _t)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "WillSave"
    });
  }
  async dispatchDidSave() {
    var e;
    return (e = o(this, _t)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "DidSave"
    });
  }
  async dispatchWillPrint() {
    var e;
    if (o(this, _t)) {
      await ((e = o(this, De)) == null ? void 0 : e.promise), b(this, De, Promise.withResolvers());
      try {
        await o(this, _t).dispatchEventInSandbox({
          id: "doc",
          name: "WillPrint"
        });
      } catch (t) {
        throw o(this, De).resolve(), b(this, De, null), t;
      }
      await o(this, De).promise;
    }
  }
  async dispatchDidPrint() {
    var e;
    return (e = o(this, _t)) == null ? void 0 : e.dispatchEventInSandbox({
      id: "doc",
      name: "DidPrint"
    });
  }
  get destroyPromise() {
    var e;
    return ((e = o(this, zr)) == null ? void 0 : e.promise) || null;
  }
  get ready() {
    return o(this, Jo);
  }
  get _pageOpenPending() {
    return ff(this, "_pageOpenPending", /* @__PURE__ */ new Set());
  }
  get _visitedPages() {
    return ff(this, "_visitedPages", /* @__PURE__ */ new Map());
  }
}
ws = new WeakMap(), zr = new WeakMap(), $d = new WeakMap(), Wr = new WeakMap(), Gr = new WeakMap(), Vd = new WeakMap(), ie = new WeakMap(), di = new WeakMap(), Jo = new WeakMap(), _t = new WeakMap(), De = new WeakMap(), Pg = new WeakSet(), o0 = async function(e) {
  var c, d;
  const t = o(this, di), s = t.isInPresentationMode || t.isChangingPresentationMode, {
    id: i,
    siblings: n,
    command: r,
    value: a
  } = e;
  if (!i) {
    switch (r) {
      case "clear":
        console.clear();
        break;
      case "error":
        console.error(a);
        break;
      case "layout":
        if (!s) {
          const u = JS(a);
          t.spreadMode = u.spreadMode;
        }
        break;
      case "page-num":
        t.currentPageNumber = a + 1;
        break;
      case "print":
        await t.pagesPromise, o(this, Gr).dispatch("print", {
          source: this
        });
        break;
      case "println":
        console.log(a);
        break;
      case "zoom":
        s || (t.currentScaleValue = a);
        break;
      case "SaveAs":
        o(this, Gr).dispatch("download", {
          source: this
        });
        break;
      case "FirstPage":
        t.currentPageNumber = 1;
        break;
      case "LastPage":
        t.currentPageNumber = t.pagesCount;
        break;
      case "NextPage":
        t.nextPage();
        break;
      case "PrevPage":
        t.previousPage();
        break;
      case "ZoomViewIn":
        s || t.increaseScale();
        break;
      case "ZoomViewOut":
        s || t.decreaseScale();
        break;
      case "WillPrintFinished":
        (c = o(this, De)) == null || c.resolve(), b(this, De, null);
        break;
    }
    return;
  }
  if (s && e.focus)
    return;
  delete e.id, delete e.siblings;
  const h = n ? [i, ...n] : [i];
  for (const u of h) {
    const f = document.querySelector(`[data-element-id="${u}"]`);
    f ? f.dispatchEvent(new CustomEvent("updatefromsandbox", {
      detail: e
    })) : (d = o(this, ie)) == null || d.annotationStorage.setValue(u, e);
  }
}, qo = new WeakSet(), qu = async function(e, t = !1) {
  const s = o(this, ie), i = this._visitedPages;
  if (t && b(this, ws, Promise.withResolvers()), !o(this, ws))
    return;
  const n = o(this, di).getPageView(e - 1);
  if ((n == null ? void 0 : n.renderingState) !== At.FINISHED) {
    this._pageOpenPending.add(e);
    return;
  }
  this._pageOpenPending.delete(e);
  const r = (async () => {
    var h, c;
    const a = await (i.has(e) ? null : (h = n.pdfPage) == null ? void 0 : h.getJSActions());
    s === o(this, ie) && await ((c = o(this, _t)) == null ? void 0 : c.dispatchEventInSandbox({
      id: "page",
      name: "PageOpen",
      pageNumber: e,
      actions: a
    }));
  })();
  i.set(e, r);
}, Ud = new WeakSet(), Qv = async function(e) {
  var n;
  const t = o(this, ie), s = this._visitedPages;
  if (!o(this, ws) || this._pageOpenPending.has(e))
    return;
  const i = s.get(e);
  i && (s.set(e, null), await i, t === o(this, ie) && await ((n = o(this, _t)) == null ? void 0 : n.dispatchEventInSandbox({
    id: "page",
    name: "PageClose",
    pageNumber: e
  })));
}, Tg = new WeakSet(), l0 = function() {
  if (b(this, zr, Promise.withResolvers()), o(this, _t))
    throw new Error("#initScripting: Scripting already exists.");
  return o(this, Vd).createScripting();
}, Xr = new WeakSet(), kl = async function() {
  var e, t, s, i;
  if (!o(this, _t)) {
    b(this, ie, null), (e = o(this, zr)) == null || e.resolve();
    return;
  }
  o(this, ws) && (await Promise.race([o(this, ws).promise, new Promise((n) => {
    setTimeout(n, 1e3);
  })]).catch(() => {
  }), b(this, ws, null)), b(this, ie, null);
  try {
    await o(this, _t).destroySandbox();
  } catch {
  }
  (t = o(this, De)) == null || t.reject(new Error("Scripting destroyed.")), b(this, De, null), (s = o(this, Wr)) == null || s.abort(), b(this, Wr, null), this._pageOpenPending.clear(), this._visitedPages.clear(), b(this, _t, null), b(this, Jo, !1), (i = o(this, zr)) == null || i.resolve();
};
class UP extends VP {
  constructor(e) {
    e.externalServices || window.addEventListener("updatefromsandbox", (t) => {
      e.eventBus.dispatch("updatefromsandbox", {
        source: window,
        detail: t.detail
      });
    }), e.externalServices || (e.externalServices = {
      createScripting: () => new $P(e.sandboxBundleSrc)
    }), e.docProperties || (e.docProperties = (t) => HP(t)), super(e);
  }
}
const zP = 3e4;
class WP {
  constructor() {
    this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1, Object.defineProperty(this, "hasViewer", {
      value: () => !!this.pdfViewer
    });
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setThumbnailViewer(e) {
    this.pdfThumbnailViewer = e;
  }
  isHighestPriority(e) {
    return this.highestPriorityPage === e.renderingId;
  }
  renderHighestPriority(e) {
    var t;
    this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), !this.pdfViewer.forceRendering(e) && (this.isThumbnailViewEnabled && ((t = this.pdfThumbnailViewer) != null && t.forceRendering()) || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), zP)));
  }
  getHighestPriority(e, t, s, i = !1) {
    const n = e.views, r = n.length;
    if (r === 0)
      return null;
    for (let u = 0; u < r; u++) {
      const f = n[u].view;
      if (!this.isViewFinished(f))
        return f;
    }
    const a = e.first.id, h = e.last.id;
    if (h - a + 1 > r) {
      const u = e.ids;
      for (let f = 1, m = h - a; f < m; f++) {
        const g = s ? a + f : h - f;
        if (u.has(g))
          continue;
        const A = t[g - 1];
        if (!this.isViewFinished(A))
          return A;
      }
    }
    let c = s ? h : a - 2, d = t[c];
    return d && !this.isViewFinished(d) || i && (c += s ? 1 : -1, d = t[c], d && !this.isViewFinished(d)) ? d : null;
  }
  isViewFinished(e) {
    return e.renderingState === At.FINISHED;
  }
  renderView(e) {
    switch (e.renderingState) {
      case At.FINISHED:
        return !1;
      case At.PAUSED:
        this.highestPriorityPage = e.renderingId, e.resume();
        break;
      case At.RUNNING:
        this.highestPriorityPage = e.renderingId;
        break;
      case At.INITIAL:
        this.highestPriorityPage = e.renderingId, e.draw().finally(() => {
          this.renderHighestPriority();
        }).catch((t) => {
          t instanceof Mv || console.error(`renderView: "${t}"`);
        });
        break;
    }
    return !0;
  }
}
const Ay = 10, mu = {
  FORCE_SCROLL_MODE_PAGE: 1e4,
  FORCE_LAZY_PAGE_INIT: 5e3,
  PAUSE_EAGER_PAGE_INIT: 250
};
function Ey(l) {
  return Object.values(Pi).includes(l) && l !== Pi.DISABLE;
}
var ui, Kr, zd, Zv;
class GP {
  constructor(e) {
    p(this, zd);
    p(this, ui, /* @__PURE__ */ new Set());
    p(this, Kr, 0);
    b(this, Kr, e);
  }
  push(e) {
    const t = o(this, ui);
    t.has(e) && t.delete(e), t.add(e), t.size > o(this, Kr) && v(this, zd, Zv).call(this);
  }
  resize(e, t = null) {
    b(this, Kr, e);
    const s = o(this, ui);
    if (t) {
      const i = s.size;
      let n = 1;
      for (const r of s)
        if (t.has(r.id) && (s.delete(r), s.add(r)), ++n > i)
          break;
    }
    for (; s.size > o(this, Kr); )
      v(this, zd, Zv).call(this);
  }
  has(e) {
    return o(this, ui).has(e);
  }
  [Symbol.iterator]() {
    return o(this, ui).keys();
  }
}
ui = new WeakMap(), Kr = new WeakMap(), zd = new WeakSet(), Zv = function() {
  const e = o(this, ui).keys().next().value;
  e == null || e.destroy(), o(this, ui).delete(e);
};
var un, Wd, Gd, fi, Qt, Yr, Xd, Kd, Yd, Qd, Qr, Zd, tl, fn, el, Jd, sl, Zr, pn, il, Cg, c0, Rg, d0, Ig, u0, Jr, Fl, nl, tf, Lg, f0, qd, Jv, _g, p0, Ss, xi, tu, qv, Mg, g0, Og, m0, eu, tb, Dg, v0;
class h0 {
  constructor(e) {
    p(this, Cg);
    p(this, Rg);
    p(this, Ig);
    p(this, Jr);
    p(this, nl);
    p(this, Lg);
    p(this, qd);
    p(this, _g);
    p(this, Ss);
    p(this, tu);
    p(this, Mg);
    p(this, Og);
    p(this, eu);
    p(this, Dg);
    p(this, un, null);
    p(this, Wd, null);
    p(this, Gd, null);
    p(this, fi, Pi.NONE);
    p(this, Qt, null);
    p(this, Yr, pi.ENABLE_FORMS);
    p(this, Xd, null);
    p(this, Kd, !1);
    p(this, Yd, !1);
    p(this, Qd, !1);
    p(this, Qr, null);
    p(this, Zd, null);
    p(this, tl, !1);
    p(this, fn, null);
    p(this, el, !1);
    p(this, Jd, 0);
    p(this, sl, new ResizeObserver(v(this, Dg, v0).bind(this)));
    p(this, Zr, null);
    p(this, pn, null);
    p(this, il, xs.ENABLE);
    var i, n;
    const t = "4.4.168";
    if (sy !== t)
      throw new Error(`The API version "${sy}" does not match the Viewer version "${t}".`);
    if (this.container = e.container, this.viewer = e.viewer || e.container.firstElementChild, ((i = this.container) == null ? void 0 : i.tagName) !== "DIV" || ((n = this.viewer) == null ? void 0 : n.tagName) !== "DIV")
      throw new Error("Invalid `container` and/or `viewer` option.");
    if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute")
      throw new Error("The `container` must be absolutely positioned.");
    o(this, sl).observe(this.container), this.eventBus = e.eventBus, this.linkService = e.linkService || new fb(), this.downloadManager = e.downloadManager || null, this.findController = e.findController || null, b(this, Wd, e.altTextManager || null), this.findController && (this.findController.onIsPageVisible = (r) => this._getVisiblePages().ids.has(r)), this._scriptingManager = e.scriptingManager || null, b(this, il, e.textLayerMode ?? xs.ENABLE), b(this, Yr, e.annotationMode ?? pi.ENABLE_FORMS), b(this, fi, e.annotationEditorMode ?? Pi.NONE), b(this, Gd, e.annotationEditorHighlightColors || null), b(this, Yd, e.enableHighlightFloatingButton === !0), this.imageResourcesPath = e.imageResourcesPath || "", this.enablePrintAutoRotate = e.enablePrintAutoRotate || !1, this.removePageBorders = e.removePageBorders || !1, this.maxCanvasPixels = e.maxCanvasPixels, this.l10n = e.l10n, this.l10n || (this.l10n = new ol()), b(this, Qd, e.enablePermissions || !1), this.pageColors = e.pageColors || null, b(this, Zd, e.mlManager || null), b(this, Kd, e.enableHWA || !1), this.defaultRenderingQueue = !e.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new WP(), this.renderingQueue.setViewer(this)) : this.renderingQueue = e.renderingQueue;
    const {
      abortSignal: s
    } = e;
    s == null || s.addEventListener("abort", () => {
      o(this, sl).disconnect(), b(this, sl, null);
    }, {
      once: !0
    }), this.scroll = zS(this.container, this._scrollUpdate.bind(this), s), this.presentationModeState = va.UNKNOWN, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders"), v(this, eu, tb).call(this), this.eventBus._on("thumbnailrendered", ({
      pageNumber: r,
      pdfPage: a
    }) => {
      const h = this._pages[r - 1];
      o(this, un).has(h) || a == null || a.cleanup();
    }), e.l10n || this.l10n.translate(this.container);
  }
  get pagesCount() {
    return this._pages.length;
  }
  getPageView(e) {
    return this._pages[e];
  }
  getCachedPageViews() {
    return new Set(o(this, un));
  }
  get pageViewsReady() {
    return this._pages.every((e) => e == null ? void 0 : e.pdfPage);
  }
  get renderForms() {
    return o(this, Yr) === pi.ENABLE_FORMS;
  }
  get enableScripting() {
    return !!this._scriptingManager;
  }
  get currentPageNumber() {
    return this._currentPageNumber;
  }
  set currentPageNumber(e) {
    if (!Number.isInteger(e))
      throw new Error("Invalid page number.");
    this.pdfDocument && (this._setCurrentPageNumber(e, !0) || console.error(`currentPageNumber: "${e}" is not a valid page.`));
  }
  _setCurrentPageNumber(e, t = !1) {
    var i;
    if (this._currentPageNumber === e)
      return t && v(this, tu, qv).call(this), !0;
    if (!(0 < e && e <= this.pagesCount))
      return !1;
    const s = this._currentPageNumber;
    return this._currentPageNumber = e, this.eventBus.dispatch("pagechanging", {
      source: this,
      pageNumber: e,
      pageLabel: ((i = this._pageLabels) == null ? void 0 : i[e - 1]) ?? null,
      previous: s
    }), t && v(this, tu, qv).call(this), !0;
  }
  get currentPageLabel() {
    var e;
    return ((e = this._pageLabels) == null ? void 0 : e[this._currentPageNumber - 1]) ?? null;
  }
  set currentPageLabel(e) {
    if (!this.pdfDocument)
      return;
    let t = e | 0;
    if (this._pageLabels) {
      const s = this._pageLabels.indexOf(e);
      s >= 0 && (t = s + 1);
    }
    this._setCurrentPageNumber(t, !0) || console.error(`currentPageLabel: "${e}" is not a valid page.`);
  }
  get currentScale() {
    return this._currentScale !== sm ? this._currentScale : TE;
  }
  set currentScale(e) {
    if (isNaN(e))
      throw new Error("Invalid numeric scale.");
    this.pdfDocument && v(this, Ss, xi).call(this, e, {
      noScroll: !1
    });
  }
  get currentScaleValue() {
    return this._currentScaleValue;
  }
  set currentScaleValue(e) {
    this.pdfDocument && v(this, Ss, xi).call(this, e, {
      noScroll: !1
    });
  }
  get pagesRotation() {
    return this._pagesRotation;
  }
  set pagesRotation(e) {
    if (!RE(e))
      throw new Error("Invalid pages rotation angle.");
    if (!this.pdfDocument || (e %= 360, e < 0 && (e += 360), this._pagesRotation === e))
      return;
    this._pagesRotation = e;
    const t = this._currentPageNumber;
    this.refresh(!0, {
      rotation: e
    }), this._currentScaleValue && v(this, Ss, xi).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this.eventBus.dispatch("rotationchanging", {
      source: this,
      pagesRotation: e,
      pageNumber: t
    }), this.defaultRenderingQueue && this.update();
  }
  get firstPagePromise() {
    return this.pdfDocument ? this._firstPageCapability.promise : null;
  }
  get onePageRendered() {
    return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
  }
  get pagesPromise() {
    return this.pdfDocument ? this._pagesCapability.promise : null;
  }
  get _layerProperties() {
    const e = this;
    return ff(this, "_layerProperties", {
      get annotationEditorUIManager() {
        return o(e, Qt);
      },
      get annotationStorage() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.annotationStorage;
      },
      get downloadManager() {
        return e.downloadManager;
      },
      get enableScripting() {
        return !!e._scriptingManager;
      },
      get fieldObjectsPromise() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.getFieldObjects();
      },
      get findController() {
        return e.findController;
      },
      get hasJSActionsPromise() {
        var t;
        return (t = e.pdfDocument) == null ? void 0 : t.hasJSActions();
      },
      get linkService() {
        return e.linkService;
      }
    });
  }
  async getAllText() {
    const e = [], t = [];
    for (let s = 1, i = this.pdfDocument.numPages; s <= i; ++s) {
      if (o(this, el))
        return null;
      t.length = 0;
      const n = await this.pdfDocument.getPage(s), {
        items: r
      } = await n.getTextContent();
      for (const a of r)
        a.str && t.push(a.str), a.hasEOL && t.push(`
`);
      e.push(df(t.join("")));
    }
    return e.join(`
`);
  }
  setDocument(e) {
    var f, m;
    if (this.pdfDocument && (this.eventBus.dispatch("pagesdestroy", {
      source: this
    }), this._cancelRendering(), this._resetView(), (f = this.findController) == null || f.setDocument(null), (m = this._scriptingManager) == null || m.setDocument(null), o(this, Qt) && (o(this, Qt).destroy(), b(this, Qt, null))), this.pdfDocument = e, !e)
      return;
    const t = e.numPages, s = e.getPage(1), i = e.getOptionalContentConfig({
      intent: "display"
    }), n = o(this, Qd) ? e.getPermissions() : Promise.resolve(), {
      eventBus: r,
      pageColors: a,
      viewer: h
    } = this;
    b(this, Qr, new AbortController());
    const {
      signal: c
    } = o(this, Qr);
    if (t > mu.FORCE_SCROLL_MODE_PAGE) {
      console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
      const g = this._scrollMode = J.PAGE;
      r.dispatch("scrollmodechanged", {
        source: this,
        mode: g
      });
    }
    this._pagesCapability.promise.then(() => {
      r.dispatch("pagesloaded", {
        source: this,
        pagesCount: t
      });
    }, () => {
    });
    const d = (g) => {
      const A = this._pages[g.pageNumber - 1];
      A && o(this, un).push(A);
    };
    r._on("pagerender", d, {
      signal: c
    });
    const u = (g) => {
      g.cssTransform || (this._onePageRenderedCapability.resolve({
        timestamp: g.timestamp
      }), r._off("pagerendered", u));
    };
    r._on("pagerendered", u, {
      signal: c
    }), Promise.all([s, n]).then(([g, A]) => {
      var x;
      if (e !== this.pdfDocument)
        return;
      this._firstPageCapability.resolve(g), this._optionalContentConfigPromise = i;
      const {
        annotationEditorMode: E,
        annotationMode: y,
        textLayerMode: w
      } = v(this, Cg, c0).call(this, A);
      if (w !== xs.DISABLE) {
        const R = b(this, fn, document.createElement("div"));
        R.id = "hiddenCopyElement", h.before(R);
      }
      if (E !== Pi.DISABLE) {
        const R = E;
        e.isPureXfa ? console.warn("Warning: XFA-editing is not implemented.") : Ey(R) ? (b(this, Qt, new xx(this.container, h, o(this, Wd), r, e, a, o(this, Gd), o(this, Yd), o(this, Zd))), r.dispatch("annotationeditoruimanager", {
          source: this,
          uiManager: o(this, Qt)
        }), R !== Pi.NONE && o(this, Qt).updateMode(R)) : console.error(`Invalid AnnotationEditor mode: ${R}`);
      }
      const S = this._scrollMode === J.PAGE ? null : h, C = this.currentScale, P = g.getViewport({
        scale: C * Ds.PDF_TO_CSS_UNITS
      });
      h.style.setProperty("--scale-factor", P.scale), ((a == null ? void 0 : a.foreground) === "CanvasText" || (a == null ? void 0 : a.background) === "Canvas") && (h.style.setProperty("--hcm-highlight-filter", e.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), h.style.setProperty("--hcm-highlight-selected-filter", e.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "ButtonText")));
      for (let R = 1; R <= t; ++R) {
        const M = new n0({
          container: S,
          eventBus: r,
          id: R,
          scale: C,
          defaultViewport: P.clone(),
          optionalContentConfigPromise: i,
          renderingQueue: this.renderingQueue,
          textLayerMode: w,
          annotationMode: y,
          imageResourcesPath: this.imageResourcesPath,
          maxCanvasPixels: this.maxCanvasPixels,
          pageColors: a,
          l10n: this.l10n,
          layerProperties: this._layerProperties,
          enableHWA: o(this, Kd)
        });
        this._pages.push(M);
      }
      (x = this._pages[0]) == null || x.setPdfPage(g), this._scrollMode === J.PAGE ? v(this, Jr, Fl).call(this) : this._spreadMode !== Zt.NONE && this._updateSpreadMode(), v(this, Rg, d0).call(this, c).then(async () => {
        var M, T;
        if (e !== this.pdfDocument)
          return;
        if ((M = this.findController) == null || M.setDocument(e), (T = this._scriptingManager) == null || T.setDocument(e), o(this, fn) && document.addEventListener("copy", v(this, Ig, u0).bind(this, w), {
          signal: c
        }), o(this, Qt) && r.dispatch("annotationeditormodechanged", {
          source: this,
          mode: o(this, fi)
        }), e.loadingParams.disableAutoFetch || t > mu.FORCE_LAZY_PAGE_INIT) {
          this._pagesCapability.resolve();
          return;
        }
        let R = t - 1;
        if (R <= 0) {
          this._pagesCapability.resolve();
          return;
        }
        for (let I = 2; I <= t; ++I) {
          const _ = e.getPage(I).then((k) => {
            const F = this._pages[I - 1];
            F.pdfPage || F.setPdfPage(k), --R === 0 && this._pagesCapability.resolve();
          }, (k) => {
            console.error(`Unable to get page ${I} to initialize viewer`, k), --R === 0 && this._pagesCapability.resolve();
          });
          I % mu.PAUSE_EAGER_PAGE_INIT === 0 && await _;
        }
      }), r.dispatch("pagesinit", {
        source: this
      }), e.getMetadata().then(({
        info: R
      }) => {
        e === this.pdfDocument && R.Language && (h.lang = R.Language);
      }), this.defaultRenderingQueue && this.update();
    }).catch((g) => {
      console.error("Unable to initialize viewer", g), this._pagesCapability.reject(g);
    });
  }
  setPageLabels(e) {
    var t;
    if (this.pdfDocument) {
      e ? Array.isArray(e) && this.pdfDocument.numPages === e.length ? this._pageLabels = e : (this._pageLabels = null, console.error("setPageLabels: Invalid page labels.")) : this._pageLabels = null;
      for (let s = 0, i = this._pages.length; s < i; s++)
        this._pages[s].setPageLabel(((t = this._pageLabels) == null ? void 0 : t[s]) ?? null);
    }
  }
  _resetView() {
    var e, t;
    this._pages = [], this._currentPageNumber = 1, this._currentScale = sm, this._currentScaleValue = null, this._pageLabels = null, b(this, un, new GP(Ay)), this._location = null, this._pagesRotation = 0, this._optionalContentConfigPromise = null, this._firstPageCapability = Promise.withResolvers(), this._onePageRenderedCapability = Promise.withResolvers(), this._pagesCapability = Promise.withResolvers(), this._scrollMode = J.VERTICAL, this._previousScrollMode = J.UNKNOWN, this._spreadMode = Zt.NONE, b(this, Zr, {
      previousPageNumber: 1,
      scrollDown: !0,
      pages: []
    }), (e = o(this, Qr)) == null || e.abort(), b(this, Qr, null), this.viewer.textContent = "", this._updateScrollMode(), this.viewer.removeAttribute("lang"), (t = o(this, fn)) == null || t.remove(), b(this, fn, null);
  }
  _scrollUpdate() {
    this.pagesCount !== 0 && this.update();
  }
  pageLabelToPageNumber(e) {
    if (!this._pageLabels)
      return null;
    const t = this._pageLabels.indexOf(e);
    return t < 0 ? null : t + 1;
  }
  scrollPageIntoView({
    pageNumber: e,
    destArray: t = null,
    allowNegativeOffset: s = !1,
    ignoreDestinationZoom: i = !1
  }) {
    if (!this.pdfDocument)
      return;
    const n = Number.isInteger(e) && this._pages[e - 1];
    if (!n) {
      console.error(`scrollPageIntoView: "${e}" is not a valid pageNumber parameter.`);
      return;
    }
    if (this.isInPresentationMode || !t) {
      this._setCurrentPageNumber(e, !0);
      return;
    }
    let r = 0, a = 0, h = 0, c = 0, d, u;
    const f = n.rotation % 180 !== 0, m = (f ? n.height : n.width) / n.scale / Ds.PDF_TO_CSS_UNITS, g = (f ? n.width : n.height) / n.scale / Ds.PDF_TO_CSS_UNITS;
    let A = 0;
    switch (t[1].name) {
      case "XYZ":
        r = t[2], a = t[3], A = t[4], r = r !== null ? r : 0, a = a !== null ? a : g;
        break;
      case "Fit":
      case "FitB":
        A = "page-fit";
        break;
      case "FitH":
      case "FitBH":
        a = t[2], A = "page-width", a === null && this._location ? (r = this._location.left, a = this._location.top) : (typeof a != "number" || a < 0) && (a = g);
        break;
      case "FitV":
      case "FitBV":
        r = t[2], h = m, c = g, A = "page-height";
        break;
      case "FitR":
        r = t[2], a = t[3], h = t[4] - r, c = t[5] - a;
        let S = zb, C = Wb;
        this.removePageBorders && (S = C = 0), d = (this.container.clientWidth - S) / h / Ds.PDF_TO_CSS_UNITS, u = (this.container.clientHeight - C) / c / Ds.PDF_TO_CSS_UNITS, A = Math.min(Math.abs(d), Math.abs(u));
        break;
      default:
        console.error(`scrollPageIntoView: "${t[1].name}" is not a valid destination type.`);
        return;
    }
    if (i || (A && A !== this._currentScale ? this.currentScaleValue = A : this._currentScale === sm && (this.currentScaleValue = jS)), A === "page-fit" && !t[4]) {
      v(this, nl, tf).call(this, n);
      return;
    }
    const E = [n.viewport.convertToViewportPoint(r, a), n.viewport.convertToViewportPoint(r + h, a + c)];
    let y = Math.min(E[0][0], E[1][0]), w = Math.min(E[0][1], E[1][1]);
    s || (y = Math.max(y, 0), w = Math.max(w, 0)), v(this, nl, tf).call(this, n, {
      left: y,
      top: w
    });
  }
  _updateLocation(e) {
    const t = this._currentScale, s = this._currentScaleValue, i = parseFloat(s) === t ? Math.round(t * 1e4) / 100 : s, n = e.id, r = this._pages[n - 1], a = this.container, h = r.getPagePoint(a.scrollLeft - e.x, a.scrollTop - e.y), c = Math.round(h[0]), d = Math.round(h[1]);
    let u = `#page=${n}`;
    this.isInPresentationMode || (u += `&zoom=${i},${c},${d}`), this._location = {
      pageNumber: n,
      scale: i,
      top: d,
      left: c,
      rotation: this._pagesRotation,
      pdfOpenParams: u
    };
  }
  update() {
    const e = this._getVisiblePages(), t = e.views, s = t.length;
    if (s === 0)
      return;
    const i = Math.max(Ay, 2 * s + 1);
    o(this, un).resize(i, e.ids), this.renderingQueue.renderHighestPriority(e);
    const n = this._spreadMode === Zt.NONE && (this._scrollMode === J.PAGE || this._scrollMode === J.VERTICAL), r = this._currentPageNumber;
    let a = !1;
    for (const h of t) {
      if (h.percent < 100)
        break;
      if (h.id === r && n) {
        a = !0;
        break;
      }
    }
    this._setCurrentPageNumber(a ? r : t[0].id), this._updateLocation(e.first), this.eventBus.dispatch("updateviewarea", {
      source: this,
      location: this._location
    });
  }
  containsElement(e) {
    return this.container.contains(e);
  }
  focus() {
    this.container.focus();
  }
  get _isContainerRtl() {
    return getComputedStyle(this.container).direction === "rtl";
  }
  get isInPresentationMode() {
    return this.presentationModeState === va.FULLSCREEN;
  }
  get isChangingPresentationMode() {
    return this.presentationModeState === va.CHANGING;
  }
  get isHorizontalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollWidth > this.container.clientWidth;
  }
  get isVerticalScrollbarEnabled() {
    return this.isInPresentationMode ? !1 : this.container.scrollHeight > this.container.clientHeight;
  }
  _getVisiblePages() {
    const e = this._scrollMode === J.PAGE ? o(this, Zr).pages : this._pages, t = this._scrollMode === J.HORIZONTAL, s = t && this._isContainerRtl;
    return GS({
      scrollEl: this.container,
      views: e,
      sortByVisibility: !0,
      horizontal: t,
      rtl: s
    });
  }
  cleanup() {
    for (const e of this._pages)
      e.renderingState !== At.FINISHED && e.reset();
  }
  _cancelRendering() {
    for (const e of this._pages)
      e.cancelRendering();
  }
  forceRendering(e) {
    const t = e || this._getVisiblePages(), s = v(this, Og, m0).call(this, t), i = this._spreadMode !== Zt.NONE && this._scrollMode !== J.HORIZONTAL, n = this.renderingQueue.getHighestPriority(t, this._pages, s, i);
    return n ? (v(this, Mg, g0).call(this, n).then(() => {
      this.renderingQueue.renderView(n);
    }), !0) : !1;
  }
  get hasEqualPageSizes() {
    const e = this._pages[0];
    for (let t = 1, s = this._pages.length; t < s; ++t) {
      const i = this._pages[t];
      if (i.width !== e.width || i.height !== e.height)
        return !1;
    }
    return !0;
  }
  getPagesOverview() {
    let e;
    return this._pages.map((t) => {
      const s = t.pdfPage.getViewport({
        scale: 1
      }), i = Kb(s);
      if (e === void 0)
        e = i;
      else if (this.enablePrintAutoRotate && i !== e)
        return {
          width: s.height,
          height: s.width,
          rotation: (s.rotation - 90) % 360
        };
      return {
        width: s.width,
        height: s.height,
        rotation: s.rotation
      };
    });
  }
  get optionalContentConfigPromise() {
    return this.pdfDocument ? this._optionalContentConfigPromise ? this._optionalContentConfigPromise : (console.error("optionalContentConfigPromise: Not initialized yet."), this.pdfDocument.getOptionalContentConfig({
      intent: "display"
    })) : Promise.resolve(null);
  }
  set optionalContentConfigPromise(e) {
    if (!(e instanceof Promise))
      throw new Error(`Invalid optionalContentConfigPromise: ${e}`);
    this.pdfDocument && this._optionalContentConfigPromise && (this._optionalContentConfigPromise = e, this.refresh(!1, {
      optionalContentConfigPromise: e
    }), this.eventBus.dispatch("optionalcontentconfigchanged", {
      source: this,
      promise: e
    }));
  }
  get scrollMode() {
    return this._scrollMode;
  }
  set scrollMode(e) {
    if (this._scrollMode !== e) {
      if (!XS(e))
        throw new Error(`Invalid scroll mode: ${e}`);
      this.pagesCount > mu.FORCE_SCROLL_MODE_PAGE || (this._previousScrollMode = this._scrollMode, this._scrollMode = e, this.eventBus.dispatch("scrollmodechanged", {
        source: this,
        mode: e
      }), this._updateScrollMode(this._currentPageNumber));
    }
  }
  _updateScrollMode(e = null) {
    const t = this._scrollMode, s = this.viewer;
    s.classList.toggle("scrollHorizontal", t === J.HORIZONTAL), s.classList.toggle("scrollWrapped", t === J.WRAPPED), !(!this.pdfDocument || !e) && (t === J.PAGE ? v(this, Jr, Fl).call(this) : this._previousScrollMode === J.PAGE && this._updateSpreadMode(), this._currentScaleValue && isNaN(this._currentScaleValue) && v(this, Ss, xi).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(e, !0), this.update());
  }
  get spreadMode() {
    return this._spreadMode;
  }
  set spreadMode(e) {
    if (this._spreadMode !== e) {
      if (!KS(e))
        throw new Error(`Invalid spread mode: ${e}`);
      this._spreadMode = e, this.eventBus.dispatch("spreadmodechanged", {
        source: this,
        mode: e
      }), this._updateSpreadMode(this._currentPageNumber);
    }
  }
  _updateSpreadMode(e = null) {
    if (!this.pdfDocument)
      return;
    const t = this.viewer, s = this._pages;
    if (this._scrollMode === J.PAGE)
      v(this, Jr, Fl).call(this);
    else if (t.textContent = "", this._spreadMode === Zt.NONE)
      for (const i of this._pages)
        t.append(i.div);
    else {
      const i = this._spreadMode - 1;
      let n = null;
      for (let r = 0, a = s.length; r < a; ++r)
        n === null ? (n = document.createElement("div"), n.className = "spread", t.append(n)) : r % 2 === i && (n = n.cloneNode(!1), t.append(n)), n.append(s[r].div);
    }
    e && (this._currentScaleValue && isNaN(this._currentScaleValue) && v(this, Ss, xi).call(this, this._currentScaleValue, {
      noScroll: !0
    }), this._setCurrentPageNumber(e, !0), this.update());
  }
  _getPageAdvance(e, t = !1) {
    switch (this._scrollMode) {
      case J.WRAPPED: {
        const {
          views: s
        } = this._getVisiblePages(), i = /* @__PURE__ */ new Map();
        for (const {
          id: n,
          y: r,
          percent: a,
          widthPercent: h
        } of s) {
          if (a === 0 || h < 100)
            continue;
          let c = i.get(r);
          c || i.set(r, c || (c = [])), c.push(n);
        }
        for (const n of i.values()) {
          const r = n.indexOf(e);
          if (r === -1)
            continue;
          const a = n.length;
          if (a === 1)
            break;
          if (t)
            for (let h = r - 1, c = 0; h >= c; h--) {
              const d = n[h], u = n[h + 1] - 1;
              if (d < u)
                return e - u;
            }
          else
            for (let h = r + 1, c = a; h < c; h++) {
              const d = n[h], u = n[h - 1] + 1;
              if (d > u)
                return u - e;
            }
          if (t) {
            const h = n[0];
            if (h < e)
              return e - h + 1;
          } else {
            const h = n[a - 1];
            if (h > e)
              return h - e + 1;
          }
          break;
        }
        break;
      }
      case J.HORIZONTAL:
        break;
      case J.PAGE:
      case J.VERTICAL: {
        if (this._spreadMode === Zt.NONE)
          break;
        const s = this._spreadMode - 1;
        if (t && e % 2 !== s)
          break;
        if (!t && e % 2 === s)
          break;
        const {
          views: i
        } = this._getVisiblePages(), n = t ? e - 1 : e + 1;
        for (const {
          id: r,
          percent: a,
          widthPercent: h
        } of i)
          if (r === n) {
            if (a > 0 && h === 100)
              return 2;
            break;
          }
        break;
      }
    }
    return 1;
  }
  nextPage() {
    const e = this._currentPageNumber, t = this.pagesCount;
    if (e >= t)
      return !1;
    const s = this._getPageAdvance(e, !1) || 1;
    return this.currentPageNumber = Math.min(e + s, t), !0;
  }
  previousPage() {
    const e = this._currentPageNumber;
    if (e <= 1)
      return !1;
    const t = this._getPageAdvance(e, !0) || 1;
    return this.currentPageNumber = Math.max(e - t, 1), !0;
  }
  updateScale({
    drawingDelay: e,
    scaleFactor: t = null,
    steps: s = null,
    origin: i
  }) {
    if (s === null && t === null)
      throw new Error("Invalid updateScale options: either `steps` or `scaleFactor` must be provided.");
    if (!this.pdfDocument)
      return;
    let n = this._currentScale;
    if (t > 0 && t !== 1)
      n = Math.round(n * t * 100) / 100;
    else if (s) {
      const r = s > 0 ? Ub : 1 / Ub, a = s > 0 ? Math.ceil : Math.floor;
      s = Math.abs(s);
      do
        n = a((n * r).toFixed(2) * 10) / 10;
      while (--s > 0);
    }
    n = Math.max(HS, Math.min($S, n)), v(this, Ss, xi).call(this, n, {
      noScroll: !1,
      drawingDelay: e,
      origin: i
    });
  }
  increaseScale(e = {}) {
    this.updateScale({
      ...e,
      steps: e.steps ?? 1
    });
  }
  decreaseScale(e = {}) {
    this.updateScale({
      ...e,
      steps: -(e.steps ?? 1)
    });
  }
  get containerTopLeft() {
    return o(this, Xd) || b(this, Xd, [this.container.offsetTop, this.container.offsetLeft]);
  }
  get annotationEditorMode() {
    return o(this, Qt) ? o(this, fi) : Pi.DISABLE;
  }
  set annotationEditorMode({
    mode: e,
    editId: t = null,
    isFromKeyboard: s = !1
  }) {
    if (!o(this, Qt))
      throw new Error("The AnnotationEditor is not enabled.");
    if (o(this, fi) !== e) {
      if (!Ey(e))
        throw new Error(`Invalid AnnotationEditor mode: ${e}`);
      this.pdfDocument && (b(this, fi, e), this.eventBus.dispatch("annotationeditormodechanged", {
        source: this,
        mode: e
      }), o(this, Qt).updateMode(e, t, s));
    }
  }
  set annotationEditorParams({
    type: e,
    value: t
  }) {
    if (!o(this, Qt))
      throw new Error("The AnnotationEditor is not enabled.");
    o(this, Qt).updateParams(e, t);
  }
  refresh(e = !1, t = /* @__PURE__ */ Object.create(null)) {
    if (this.pdfDocument) {
      for (const s of this._pages)
        s.update(t);
      o(this, pn) !== null && (clearTimeout(o(this, pn)), b(this, pn, null)), e || this.update();
    }
  }
}
un = new WeakMap(), Wd = new WeakMap(), Gd = new WeakMap(), fi = new WeakMap(), Qt = new WeakMap(), Yr = new WeakMap(), Xd = new WeakMap(), Kd = new WeakMap(), Yd = new WeakMap(), Qd = new WeakMap(), Qr = new WeakMap(), Zd = new WeakMap(), tl = new WeakMap(), fn = new WeakMap(), el = new WeakMap(), Jd = new WeakMap(), sl = new WeakMap(), Zr = new WeakMap(), pn = new WeakMap(), il = new WeakMap(), Cg = new WeakSet(), c0 = function(e) {
  const t = {
    annotationEditorMode: o(this, fi),
    annotationMode: o(this, Yr),
    textLayerMode: o(this, il)
  };
  return e && (!e.includes(pu.COPY) && o(this, il) === xs.ENABLE && (t.textLayerMode = xs.ENABLE_PERMISSIONS), e.includes(pu.MODIFY_CONTENTS) || (t.annotationEditorMode = Pi.DISABLE), !e.includes(pu.MODIFY_ANNOTATIONS) && !e.includes(pu.FILL_INTERACTIVE_FORMS) && o(this, Yr) === pi.ENABLE_FORMS && (t.annotationMode = pi.ENABLE)), t;
}, Rg = new WeakSet(), d0 = async function(e) {
  if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0)
    return;
  const t = Promise.withResolvers();
  function s() {
    document.visibilityState === "hidden" && t.resolve();
  }
  document.addEventListener("visibilitychange", s, {
    signal: e
  }), await Promise.race([this._onePageRenderedCapability.promise, t.promise]), document.removeEventListener("visibilitychange", s);
}, Ig = new WeakSet(), u0 = function(e, t) {
  const s = document.getSelection(), {
    focusNode: i,
    anchorNode: n
  } = s;
  if (n && i && s.containsNode(o(this, fn))) {
    if (o(this, tl) || e === xs.ENABLE_PERMISSIONS) {
      t.preventDefault(), t.stopPropagation();
      return;
    }
    b(this, tl, !0);
    const {
      classList: r
    } = this.viewer;
    r.add("copyAll");
    const a = new AbortController();
    window.addEventListener("keydown", (h) => b(this, el, h.key === "Escape"), {
      signal: a.signal
    }), this.getAllText().then(async (h) => {
      h !== null && await navigator.clipboard.writeText(h);
    }).catch((h) => {
      console.warn(`Something goes wrong when extracting the text: ${h.message}`);
    }).finally(() => {
      b(this, tl, !1), b(this, el, !1), a.abort(), r.remove("copyAll");
    }), t.preventDefault(), t.stopPropagation();
  }
}, Jr = new WeakSet(), Fl = function() {
  if (this._scrollMode !== J.PAGE)
    throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
  const e = this._currentPageNumber, t = o(this, Zr), s = this.viewer;
  if (s.textContent = "", t.pages.length = 0, this._spreadMode === Zt.NONE && !this.isInPresentationMode) {
    const i = this._pages[e - 1];
    s.append(i.div), t.pages.push(i);
  } else {
    const i = /* @__PURE__ */ new Set(), n = this._spreadMode - 1;
    n === -1 ? i.add(e - 1) : e % 2 !== n ? (i.add(e - 1), i.add(e)) : (i.add(e - 2), i.add(e - 1));
    const r = document.createElement("div");
    if (r.className = "spread", this.isInPresentationMode) {
      const a = document.createElement("div");
      a.className = "dummyPage", r.append(a);
    }
    for (const a of i) {
      const h = this._pages[a];
      h && (r.append(h.div), t.pages.push(h));
    }
    s.append(r);
  }
  t.scrollDown = e >= t.previousPageNumber, t.previousPageNumber = e;
}, nl = new WeakSet(), tf = function(e, t = null) {
  const {
    div: s,
    id: i
  } = e;
  if (this._currentPageNumber !== i && this._setCurrentPageNumber(i), this._scrollMode === J.PAGE && (v(this, Jr, Fl).call(this), this.update()), !t && !this.isInPresentationMode) {
    const n = s.offsetLeft + s.clientLeft, r = n + s.clientWidth, {
      scrollLeft: a,
      clientWidth: h
    } = this.container;
    (this._scrollMode === J.HORIZONTAL || n < a || r > a + h) && (t = {
      left: 0,
      top: 0
    });
  }
  CE(s, t), !this._currentScaleValue && this._location && (this._location = null);
}, Lg = new WeakSet(), f0 = function(e) {
  return e === this._currentScale || Math.abs(e - this._currentScale) < 1e-15;
}, qd = new WeakSet(), Jv = function(e, t, {
  noScroll: s = !1,
  preset: i = !1,
  drawingDelay: n = -1,
  origin: r = null
}) {
  if (this._currentScaleValue = t.toString(), v(this, Lg, f0).call(this, e)) {
    i && this.eventBus.dispatch("scalechanging", {
      source: this,
      scale: e,
      presetValue: t
    });
    return;
  }
  this.viewer.style.setProperty("--scale-factor", e * Ds.PDF_TO_CSS_UNITS);
  const a = n >= 0 && n < 1e3;
  this.refresh(!0, {
    scale: e,
    drawingDelay: a ? n : -1
  }), a && b(this, pn, setTimeout(() => {
    b(this, pn, null), this.refresh();
  }, n));
  const h = this._currentScale;
  if (this._currentScale = e, !s) {
    let c = this._currentPageNumber, d;
    if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode) && (c = this._location.pageNumber, d = [null, {
      name: "XYZ"
    }, this._location.left, this._location.top, null]), this.scrollPageIntoView({
      pageNumber: c,
      destArray: d,
      allowNegativeOffset: !0
    }), Array.isArray(r)) {
      const u = e / h - 1, [f, m] = this.containerTopLeft;
      this.container.scrollLeft += (r[0] - m) * u, this.container.scrollTop += (r[1] - f) * u;
    }
  }
  this.eventBus.dispatch("scalechanging", {
    source: this,
    scale: e,
    presetValue: i ? t : void 0
  }), this.defaultRenderingQueue && this.update();
}, _g = new WeakSet(), p0 = function() {
  return this._spreadMode !== Zt.NONE && this._scrollMode !== J.HORIZONTAL ? 2 : 1;
}, Ss = new WeakSet(), xi = function(e, t) {
  let s = parseFloat(e);
  if (s > 0)
    t.preset = !1, v(this, qd, Jv).call(this, s, e, t);
  else {
    const i = this._pages[this._currentPageNumber - 1];
    if (!i)
      return;
    let n = zb, r = Wb;
    this.isInPresentationMode ? (n = r = 4, this._spreadMode !== Zt.NONE && (n *= 2)) : this.removePageBorders ? n = r = 0 : this._scrollMode === J.HORIZONTAL && ([n, r] = [r, n]);
    const a = (this.container.clientWidth - n) / i.width * i.scale / o(this, _g, p0), h = (this.container.clientHeight - r) / i.height * i.scale;
    switch (e) {
      case "page-actual":
        s = 1;
        break;
      case "page-width":
        s = a;
        break;
      case "page-height":
        s = h;
        break;
      case "page-fit":
        s = Math.min(a, h);
        break;
      case "auto":
        const c = Kb(i) ? a : Math.min(h, a);
        s = Math.min(VS, c);
        break;
      default:
        console.error(`#setScale: "${e}" is an unknown zoom value.`);
        return;
    }
    t.preset = !0, v(this, qd, Jv).call(this, s, e, t);
  }
}, tu = new WeakSet(), qv = function() {
  const e = this._pages[this._currentPageNumber - 1];
  this.isInPresentationMode && v(this, Ss, xi).call(this, this._currentScaleValue, {
    noScroll: !0
  }), v(this, nl, tf).call(this, e);
}, Mg = new WeakSet(), g0 = async function(e) {
  if (e.pdfPage)
    return e.pdfPage;
  try {
    const t = await this.pdfDocument.getPage(e.id);
    return e.pdfPage || e.setPdfPage(t), t;
  } catch (t) {
    return console.error("Unable to get page for page view", t), null;
  }
}, Og = new WeakSet(), m0 = function(e) {
  var t, s;
  if (((t = e.first) == null ? void 0 : t.id) === 1)
    return !0;
  if (((s = e.last) == null ? void 0 : s.id) === this.pagesCount)
    return !1;
  switch (this._scrollMode) {
    case J.PAGE:
      return o(this, Zr).scrollDown;
    case J.HORIZONTAL:
      return this.scroll.right;
  }
  return this.scroll.down;
}, eu = new WeakSet(), tb = function(e = this.container.clientHeight) {
  e !== o(this, Jd) && (b(this, Jd, e), YS.setProperty("--viewer-container-height", `${e}px`));
}, Dg = new WeakSet(), v0 = function(e) {
  for (const t of e)
    if (t.target === this.container) {
      v(this, eu, tb).call(this, Math.floor(t.borderBoxSize[0].blockSize)), b(this, Xd, null);
      break;
    }
};
class XP extends h0 {
  _resetView() {
    super._resetView(), this._scrollMode = J.PAGE, this._spreadMode = Zt.NONE;
  }
  set scrollMode(e) {
  }
  _updateScrollMode() {
  }
  set spreadMode(e) {
  }
  _updateSpreadMode() {
  }
}
gt.AnnotationLayerBuilder;
gt.DownloadManager;
gt.EventBus;
gt.FindState;
gt.GenericL10n;
gt.LinkTarget;
gt.PDFFindController;
gt.PDFHistory;
var KP = gt.PDFLinkService;
gt.PDFPageView;
gt.PDFScriptingManager;
gt.PDFSinglePageViewer;
gt.PDFViewer;
gt.ProgressBar;
gt.RenderingStates;
gt.ScrollMode;
gt.SimpleLinkService;
gt.SpreadMode;
gt.StructTreeLayerBuilder;
gt.TextLayerBuilder;
gt.XfaLayerBuilder;
gt.parseQueryString;
const YP = ["id"], QP = ["id"], ZP = /* @__PURE__ */ Ry("canvas", null, null, -1), JP = {
  key: 0,
  class: "textLayer"
}, qP = {
  key: 1,
  class: "annotationLayer"
}, ZT = /* @__PURE__ */ w0({
  __name: "VuePdfEmbed",
  props: {
    annotationLayer: { type: Boolean },
    height: {},
    id: {},
    imageResourcesPath: {},
    page: {},
    rotation: { default: 0 },
    scale: { default: 1 },
    source: {},
    textLayer: { type: Boolean },
    width: {}
  },
  emits: ["internal-link-clicked", "loaded", "loading-failed", "password-requested", "progress", "rendered", "rendering-failed"],
  setup(l, { expose: e, emit: t }) {
    const s = l, i = sf([]), n = S0([]), r = sf(null);
    let a = null;
    const { doc: h } = BS({
      onError: (y) => {
        i.value = [], t("loading-failed", y);
      },
      onPasswordRequest({ callback: y, isWrongPassword: w }) {
        t("password-requested", { callback: y, isWrongPassword: w });
      },
      onProgress: (y) => {
        t("progress", y);
      },
      source: x0(s, "source")
    }), c = P0(() => {
      if (!h.value || !s.annotationLayer)
        return null;
      const y = new KP();
      return y.setDocument(h.value), y.setViewer({
        scrollPageIntoView: ({ pageNumber: w }) => {
          t("internal-link-clicked", w);
        }
      }), y;
    }), d = async (y) => {
      if (!h.value)
        return;
      const w = await h.value.getData(), S = await h.value.getMetadata(), C = (
        // @ts-expect-error: contentDispositionFilename is not typed
        y ?? S.contentDispositionFilename ?? ""
      );
      NS(w, C);
    }, u = (y) => {
      let w, S;
      return s.height && !s.width ? (S = s.height, w = S / y) : (w = s.width ?? r.value.clientWidth, S = w * y), [w, S];
    }, f = async (y = 300, w = "", S = !1) => {
      var T, I, _;
      if (!h.value)
        return;
      const C = y / 72, P = 96 / 72;
      let x, R, M;
      try {
        x = window.document.createElement("div"), x.style.display = "none", window.document.body.appendChild(x), R = await FS(x);
        const k = s.page && !S ? [s.page] : [...Array(h.value.numPages + 1).keys()].slice(1);
        await Promise.all(
          k.map(async (F, V) => {
            const $ = await h.value.getPage(F), L = $.getViewport({
              scale: 1,
              rotation: 0
            });
            if (V === 0) {
              const ot = L.width * C / P, mt = L.height * C / P;
              kS(R, ot, mt);
            }
            const B = window.document.createElement("canvas");
            B.width = L.width * C, B.height = L.height * C, x.appendChild(B);
            const j = B.cloneNode();
            R.contentWindow.document.body.appendChild(j), await $.render({
              canvasContext: B.getContext("2d"),
              intent: "print",
              transform: [C, 0, 0, C, 0, 0],
              viewport: L
            }).promise, j.getContext("2d").drawImage(B, 0, 0);
          })
        ), w && (M = window.document.title, window.document.title = w), (T = R.contentWindow) == null || T.focus(), (I = R.contentWindow) == null || I.print();
      } finally {
        M && (window.document.title = M), em(x), (_ = x.parentNode) == null || _.removeChild(x);
      }
    }, m = async () => {
      if (!(!h.value || a != null && a.isAborted))
        try {
          i.value = s.page ? [s.page] : [...Array(h.value.numPages + 1).keys()].slice(1), n.value = Array(i.value.length).fill(1), await Promise.all(
            i.value.map(async (y, w) => {
              const S = await h.value.getPage(y);
              if (a != null && a.isAborted)
                return;
              const C = ((s.rotation % 90 === 0 ? s.rotation : 0) + S.rotate) % 360, [P, x, R] = Array.from(
                r.value.getElementsByClassName("vue-pdf-embed__page")[w].children
              ), M = !!(C / 90 % 2), T = S.view[2] - S.view[0], I = S.view[3] - S.view[1], [_, k] = u(
                M ? T / I : I / T
              ), F = `${Math.floor(_)}px`, V = `${Math.floor(k)}px`, L = _ / (M ? I : T), B = S.getViewport({
                scale: L,
                rotation: C
              });
              n.value[w] = L, P.style.display = "block", P.style.width = F, P.style.height = V;
              const j = [
                g(
                  S,
                  B.clone({
                    scale: B.scale * window.devicePixelRatio * s.scale
                  }),
                  P
                )
              ];
              return s.textLayer && j.push(
                E(
                  S,
                  B.clone({
                    dontFlip: !0
                  }),
                  x
                )
              ), s.annotationLayer && j.push(
                A(
                  S,
                  B.clone({
                    dontFlip: !0
                  }),
                  R || x
                )
              ), Promise.all(j);
            })
          ), a != null && a.isAborted || t("rendered");
        } catch (y) {
          i.value = [], n.value = [], a != null && a.isAborted || t("rendering-failed", y);
        }
    }, g = async (y, w, S) => {
      S.width = w.width, S.height = w.height, await y.render({
        canvasContext: S.getContext("2d"),
        viewport: w
      }).promise;
    }, A = async (y, w, S) => {
      $b(S), new _S({
        accessibilityManager: null,
        annotationCanvasMap: null,
        annotationEditorUIManager: null,
        div: S,
        page: y,
        viewport: w
      }).render({
        annotations: await y.getAnnotations(),
        div: S,
        imageResourcesPath: s.imageResourcesPath,
        linkService: c.value,
        page: y,
        renderForms: !1,
        viewport: w
      });
    }, E = async (y, w, S) => {
      $b(S), new OS({
        container: S,
        textContentSource: await y.getTextContent(),
        viewport: w
      }).render();
    };
    return cm(
      h,
      (y) => {
        y && t("loaded", y);
      },
      { immediate: !0 }
    ), cm(
      () => [
        h.value,
        s.annotationLayer,
        s.height,
        s.imageResourcesPath,
        s.page,
        s.rotation,
        s.scale,
        s.textLayer,
        s.width
      ],
      async ([y]) => {
        y && (a && (a.isAborted = !0, await a.promise), em(r.value), a = {
          isAborted: !1,
          promise: m()
        }, await a.promise, a = null);
      },
      { immediate: !0 }
    ), Cy(() => {
      em(r.value);
    }), e({
      doc: h,
      download: d,
      print: f
    }), (y, w) => (ll(), hl("div", {
      id: y.id,
      ref_key: "root",
      ref: r,
      class: "vue-pdf-embed"
    }, [
      (ll(!0), hl(T0, null, C0(i.value, (S, C) => (ll(), hl("div", { key: S }, [
        Ab(y.$slots, "before-page", { page: S }),
        Ry("div", {
          id: y.id && `${y.id}-${S}`,
          class: "vue-pdf-embed__page",
          style: R0({
            "--scale-factor": n.value[C],
            position: "relative"
          })
        }, [
          ZP,
          y.textLayer ? (ll(), hl("div", JP)) : Eb("", !0),
          y.annotationLayer ? (ll(), hl("div", qP)) : Eb("", !0)
        ], 12, QP),
        Ab(y.$slots, "after-page", { page: S })
      ]))), 128))
    ], 8, YP));
  }
}), tT = {}, pl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, default: tT }, Symbol.toStringTag, { value: "Module" }));
var gl = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
}, eT = /([astvzqmhlc])([^astvzqmhlc]*)/gi, sT = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
function iT(l) {
  const e = l.match(sT);
  return e ? e.map(Number) : [];
}
function b0(l) {
  const e = [], t = String(l).trim();
  return t[0] !== "M" && t[0] !== "m" || t.replace(eT, (s, i, n) => {
    const r = iT(n);
    let a = i.toLowerCase(), h = i;
    if (a === "m" && r.length > 2 && (e.push([h, ...r.splice(0, 2)]), a = "l", h = h === "m" ? "l" : "L"), r.length < gl[a])
      return "";
    for (e.push([h, ...r.splice(0, gl[a])]); r.length >= gl[a] && r.length && gl[a]; )
      e.push([h, ...r.splice(0, gl[a])]);
    return "";
  }), e;
}
function wy(l, e) {
  const t = l.x * Math.cos(e) - l.y * Math.sin(e), s = l.y * Math.cos(e) + l.x * Math.sin(e);
  l.x = t, l.y = s;
}
function nT(l, e, t) {
  l.x += e, l.y += t;
}
function Sy(l, e) {
  l.x *= e, l.y *= e;
}
var ef = class eb {
  constructor(e) {
    this.commands = [], e && e instanceof eb ? this.commands.push(...e.commands) : e && (this.commands = b0(e));
  }
  addPath(e) {
    e && e instanceof eb && this.commands.push(...e.commands);
  }
  moveTo(e, t) {
    this.commands.push(["M", e, t]);
  }
  lineTo(e, t) {
    this.commands.push(["L", e, t]);
  }
  arc(e, t, s, i, n, r) {
    this.commands.push(["AC", e, t, s, i, n, !!r]);
  }
  arcTo(e, t, s, i, n) {
    this.commands.push(["AT", e, t, s, i, n]);
  }
  ellipse(e, t, s, i, n, r, a, h) {
    this.commands.push(["E", e, t, s, i, n, r, a, !!h]);
  }
  closePath() {
    this.commands.push(["Z"]);
  }
  bezierCurveTo(e, t, s, i, n, r) {
    this.commands.push(["C", e, t, s, i, n, r]);
  }
  quadraticCurveTo(e, t, s, i) {
    this.commands.push(["Q", e, t, s, i]);
  }
  rect(e, t, s, i) {
    this.commands.push(["R", e, t, s, i]);
  }
  roundRect(e, t, s, i, n) {
    typeof n > "u" ? this.commands.push(["RR", e, t, s, i, 0]) : this.commands.push(["RR", e, t, s, i, n]);
  }
};
function Nl(l, e) {
  let t = 0, s = 0, i, n, r, a, h, c, d, u, f, m, g, A, E, y, w, S, C, P, x, R, M, T = null, I = null, _ = null, k = null, F = null, V = null;
  l.beginPath();
  for (let $ = 0; $ < e.length; ++$) {
    P = e[$][0], P !== "S" && P !== "s" && P !== "C" && P !== "c" && (T = null, I = null), P !== "T" && P !== "t" && P !== "Q" && P !== "q" && (_ = null, k = null);
    let L;
    switch (P) {
      case "m":
      case "M":
        L = e[$], P === "m" ? (t += L[1], s += L[2]) : (t = L[1], s = L[2]), (P === "M" || !F) && (F = { x: t, y: s }), l.moveTo(t, s);
        break;
      case "l":
        L = e[$], t += L[1], s += L[2], l.lineTo(t, s);
        break;
      case "L":
        L = e[$], t = L[1], s = L[2], l.lineTo(t, s);
        break;
      case "H":
        L = e[$], t = L[1], l.lineTo(t, s);
        break;
      case "h":
        L = e[$], t += L[1], l.lineTo(t, s);
        break;
      case "V":
        L = e[$], s = L[1], l.lineTo(t, s);
        break;
      case "v":
        L = e[$], s += L[1], l.lineTo(t, s);
        break;
      case "a":
      case "A":
        if (L = e[$], V === null)
          throw new Error("This should never happen");
        P === "a" ? (t += L[6], s += L[7]) : (t = L[6], s = L[7]), y = L[1], w = L[2], d = L[3] * Math.PI / 180, r = !!L[4], a = !!L[5], h = { x: t, y: s }, c = {
          x: (V.x - h.x) / 2,
          y: (V.y - h.y) / 2
        }, wy(c, -d), u = c.x * c.x / (y * y) + c.y * c.y / (w * w), u > 1 && (u = Math.sqrt(u), y *= u, w *= u), x = {
          x: y * c.y / w,
          y: -(w * c.x) / y
        }, f = y * y * w * w, m = y * y * c.y * c.y + w * w * c.x * c.x, a !== r ? Sy(x, Math.sqrt((f - m) / m) || 0) : Sy(x, -Math.sqrt((f - m) / m) || 0), n = Math.atan2((c.y - x.y) / w, (c.x - x.x) / y), i = Math.atan2(-(c.y + x.y) / w, -(c.x + x.x) / y), wy(x, d), nT(x, (h.x + V.x) / 2, (h.y + V.y) / 2), l.save(), l.translate(x.x, x.y), l.rotate(d), l.scale(y, w), l.arc(0, 0, 1, n, i, !a), l.restore();
        break;
      case "C":
        L = e[$], T = L[3], I = L[4], t = L[5], s = L[6], l.bezierCurveTo(L[1], L[2], T, I, t, s);
        break;
      case "c":
        L = e[$], l.bezierCurveTo(L[1] + t, L[2] + s, L[3] + t, L[4] + s, L[5] + t, L[6] + s), T = L[3] + t, I = L[4] + s, t += L[5], s += L[6];
        break;
      case "S":
        L = e[$], (T === null || I === null) && (T = t, I = s), l.bezierCurveTo(2 * t - T, 2 * s - I, L[1], L[2], L[3], L[4]), T = L[1], I = L[2], t = L[3], s = L[4];
        break;
      case "s":
        L = e[$], (T === null || I === null) && (T = t, I = s), l.bezierCurveTo(2 * t - T, 2 * s - I, L[1] + t, L[2] + s, L[3] + t, L[4] + s), T = L[1] + t, I = L[2] + s, t += L[3], s += L[4];
        break;
      case "Q":
        L = e[$], _ = L[1], k = L[2], t = L[3], s = L[4], l.quadraticCurveTo(_, k, t, s);
        break;
      case "q":
        L = e[$], _ = L[1] + t, k = L[2] + s, t += L[3], s += L[4], l.quadraticCurveTo(_, k, t, s);
        break;
      case "T":
        L = e[$], (_ === null || k === null) && (_ = t, k = s), _ = 2 * t - _, k = 2 * s - k, t = L[1], s = L[2], l.quadraticCurveTo(_, k, t, s);
        break;
      case "t":
        L = e[$], (_ === null || k === null) && (_ = t, k = s), _ = 2 * t - _, k = 2 * s - k, t += L[1], s += L[2], l.quadraticCurveTo(_, k, t, s);
        break;
      case "z":
      case "Z":
        F && (t = F.x, s = F.y), F = null, l.closePath();
        break;
      case "AC":
        L = e[$], t = L[1], s = L[2], E = L[3], n = L[4], i = L[5], R = L[6], l.arc(t, s, E, n, i, R);
        break;
      case "AT":
        L = e[$], g = L[1], A = L[2], t = L[3], s = L[4], E = L[5], l.arcTo(g, A, t, s, E);
        break;
      case "E":
        L = e[$], t = L[1], s = L[2], y = L[3], w = L[4], d = L[5], n = L[6], i = L[7], R = L[8], l.save(), l.translate(t, s), l.rotate(d), l.scale(y, w), l.arc(0, 0, 1, n, i, R), l.restore();
        break;
      case "R":
        L = e[$], t = L[1], s = L[2], S = L[3], C = L[4], F = { x: t, y: s }, l.rect(t, s, S, C);
        break;
      case "RR":
        L = e[$], t = L[1], s = L[2], S = L[3], C = L[4], M = L[5], F = { x: t, y: s }, l.roundRect(t, s, S, C, M);
        break;
      default:
        throw new Error(`Invalid path command: ${P}`);
    }
    V ? (V.x = t, V.y = s) : V = { x: t, y: s };
  }
}
function pb(l, e, t, s, i = 0) {
  if (typeof i == "number" && (i = [i]), Array.isArray(i)) {
    if (i.length === 0 || i.length > 4)
      throw new RangeError(
        `Failed to execute 'roundRect' on '${this.constructor.name}': ${i.length} radii provided. Between one and four radii are necessary.`
      );
    i.forEach((d) => {
      if (d < 0)
        throw new RangeError(
          `Failed to execute 'roundRect' on '${this.constructor.name}': Radius value ${d} is negative.`
        );
    });
  } else
    return;
  if (i.length === 1 && i[0] === 0) {
    this.rect(l, e, t, s);
    return;
  }
  const n = Math.min(t, s) / 2, r = Math.min(n, i[0]);
  let a = r, h = r, c = r;
  i.length === 2 && (a = Math.min(n, i[1]), c = a), i.length === 3 && (a = Math.min(n, i[1]), c = a, h = Math.min(n, i[2])), i.length === 4 && (a = Math.min(n, i[1]), h = Math.min(n, i[2]), c = Math.min(n, i[3])), this.moveTo(l, e + s - c), this.arcTo(l, e, l + r, e, r), this.arcTo(l + t, e, l + t, e + a, a), this.arcTo(l + t, e + s, l + t - h, e + s, h), this.arcTo(l, e + s, l, e + s - c, c), this.moveTo(l, e);
}
function rT(l) {
  if (!l)
    return;
  const e = l.prototype.clip, t = l.prototype.fill, s = l.prototype.stroke, i = l.prototype.isPointInPath;
  l.prototype.clip = function(...r) {
    if (r[0] instanceof ef) {
      const h = r[0], c = r[1] || "nonzero";
      return Nl(this, h.commands), e.apply(this, [c]);
    }
    const a = r[0] || "nonzero";
    return e.apply(this, [a]);
  }, l.prototype.fill = function(...r) {
    if (r[0] instanceof ef) {
      const h = r[0], c = r[1] || "nonzero";
      return Nl(this, h.commands), t.apply(this, [c]);
    }
    const a = r[0] || "nonzero";
    return t.apply(this, [a]);
  }, l.prototype.stroke = function(r) {
    r && Nl(this, r.commands), s.apply(this);
  }, l.prototype.isPointInPath = function(...r) {
    if (r[0] instanceof ef) {
      const a = r[0], h = r[1], c = r[2], d = r[3] || "nonzero";
      return Nl(this, a.commands), i.apply(this, [h, c, d]);
    }
    return i.apply(this, r);
  };
}
function aT(l) {
  l && !l.prototype.roundRect && (l.prototype.roundRect = pb);
}
function oT(l) {
  l && !l.prototype.roundRect && (l.prototype.roundRect = pb);
}
const lT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({ __proto__: null, Path2D: ef, applyPath2DToCanvasRenderingContext: rT, applyRoundRectToCanvasRenderingContext2D: aT, applyRoundRectToPath2D: oT, buildPath: Nl, parsePath: b0, roundRect: pb }, Symbol.toStringTag, { value: "Module" }));
export {
  xT as GlobalWorkerOptions,
  ZT as default,
  BS as useVuePdfEmbed
};
